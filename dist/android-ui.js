/*
 * AndroidUI4Web: https://github.com/linfaxin/AndroidUI4Web
 * version: 0.1.1
 * release type: Pre-release
 * release date: 2016-01-19
 */
var androidui;
(function (androidui) {
    androidui.sdk_version = '0.1.1';
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/10/28.
 */
///<reference path="List.ts"/>
var java;
(function (java) {
    var util;
    (function (util) {
        class ArrayList {
            constructor(initialCapacity = 0) {
                this.array = [];
            }
            size() {
                return this.array.length;
            }
            isEmpty() {
                return this.size() <= 0;
            }
            contains(o) {
                return this.indexOf(o) >= 0;
            }
            indexOf(o) {
                return this.array.indexOf(o);
            }
            lastIndexOf(o) {
                return this.array.lastIndexOf(o);
            }
            clone() {
                let arrayList = new ArrayList();
                arrayList.array.push(...this.array);
                return arrayList;
            }
            toArray(a = new Array(this.size())) {
                let size = this.size();
                for (let i = 0; i < size; i++) {
                    a[i] = this.array[i];
                }
                return a;
            }
            getArray() {
                return this.array;
            }
            get(index) {
                index = Math.floor(index);
                return this.array[index];
            }
            set(index, element) {
                index = Math.floor(index);
                let old = this.array[index];
                this.array[index] = element;
                return old;
            }
            add(...args) {
                let index, t;
                if (args.length === 1)
                    t = args[0];
                else if (args.length === 2) {
                    index = Math.floor(args[0]);
                    t = args[1];
                }
                if (index === undefined)
                    this.array.push(t);
                else
                    this.array.splice(index, 0, t);
            }
            remove(o) {
                let index;
                if (Number.isInteger(o)) {
                    index = o;
                }
                else {
                    index = this.array.indexOf(o);
                }
                let old = this.array[index];
                this.array.splice(index, 1);
                return old;
            }
            clear() {
                this.array = [];
            }
            addAll(...args) {
                let index, list;
                if (args.length === 1) {
                    list = args[0];
                }
                else if (args.length === 2) {
                    index = Math.floor(args[0]);
                    list = args[1];
                }
                if (index === undefined) {
                    this.array.push(...list.array);
                }
                else {
                    this.array.splice(index, 0, ...list.array);
                }
            }
            removeAll(list) {
                let oldSize = this.size();
                list.array.forEach((item) => {
                    let index = this.array.indexOf(item);
                    this.array.splice(index, 1);
                });
                return this.size() === oldSize;
            }
            [Symbol.iterator]() {
                return this.array[Symbol.iterator];
            }
            subList(fromIndex, toIndex) {
                let list = new ArrayList();
                fromIndex = Math.floor(fromIndex);
                toIndex = Math.floor(toIndex);
                for (var i = fromIndex; i < toIndex; i++) {
                    list.array.push(this.array[i]);
                }
                return list;
            }
            toString() {
                return this.array.toString();
            }
            sort(compareFn) {
                this.array.sort(compareFn);
            }
        }
        util.ArrayList = ArrayList;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
/**
 * Created by linfaxin on 16/1/4.
 * lite impl of Android Bundle
 */
var android;
(function (android) {
    var os;
    (function (os) {
        class Bundle {
            constructor(copy) {
                if (copy)
                    Object.assign(this, copy);
            }
            get(key, defaultValue) {
                if (this.containsKey(key)) {
                    return this[key];
                }
                return defaultValue;
            }
            put(key, value) {
                this[key] = value;
            }
            containsKey(key) {
                return key in this;
            }
        }
        os.Bundle = Bundle;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class StringBuilder {
            constructor(arg) {
                this.array = [];
                if (!Number.isInteger(arg) && arg) {
                    this.append(arg);
                }
            }
            length() {
                return this.array.length;
            }
            append(a) {
                let str = a + '';
                this.array.push(...str.split(''));
                return this;
            }
            deleteCharAt(index) {
                this.array.splice(index, 1);
                return this;
            }
            replace(start, end, str) {
                this.array.splice(start, end - start, ...str.split(''));
                return this;
            }
            setLength(length) {
                let arrayLength = this.array.length;
                if (length === arrayLength)
                    return;
                if (length < arrayLength) {
                    this.array = this.array.splice(length, arrayLength - length);
                }
                else {
                    for (let i = 0; i < arrayLength - length; i++) {
                        this.array.push('\0');
                    }
                }
            }
            toString() {
                return this.array.join('');
            }
        }
        lang.StringBuilder = StringBuilder;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
///<reference path="../../java/lang/StringBuilder.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var StringBuilder = java.lang.StringBuilder;
        class Rect {
            constructor(...args) {
                this.left = 0;
                this.top = 0;
                this.right = 0;
                this.bottom = 0;
                if (args.length === 1) {
                    let rect = args[0];
                    this.left = rect.left;
                    this.top = rect.top;
                    this.right = rect.right;
                    this.bottom = rect.bottom;
                }
                else if (args.length === 4 || args.length === 0) {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    this.left = left;
                    this.top = t;
                    this.right = right;
                    this.bottom = bottom;
                }
            }
            equals(r) {
                if (this === r)
                    return true;
                if (!r || !(r instanceof Rect))
                    return false;
                return this.left === r.left && this.top === r.top
                    && this.right === r.right && this.bottom === r.bottom;
            }
            toString() {
                let sb = new StringBuilder();
                sb.append("Rect(");
                sb.append(this.left);
                sb.append(", ");
                sb.append(this.top);
                sb.append(" - ");
                sb.append(this.right);
                sb.append(", ");
                sb.append(this.bottom);
                sb.append(")");
                return sb.toString();
            }
            toShortString(sb = new StringBuilder()) {
                sb.setLength(0);
                sb.append('[');
                sb.append(this.left);
                sb.append(',');
                sb.append(this.top);
                sb.append("][");
                sb.append(this.right);
                sb.append(',');
                sb.append(this.bottom);
                sb.append(']');
                return sb.toString();
            }
            flattenToString() {
                let sb = new StringBuilder(32);
                sb.append(this.left);
                sb.append(' ');
                sb.append(this.top);
                sb.append(' ');
                sb.append(this.right);
                sb.append(' ');
                sb.append(this.bottom);
                return sb.toString();
            }
            static unflattenFromString(str) {
                let parts = str.split(" ");
                return new Rect(Number.parseInt(parts[0]), Number.parseInt(parts[1]), Number.parseInt(parts[2]), Number.parseInt(parts[3]));
            }
            isEmpty() {
                return this.left >= this.right || this.top >= this.bottom;
            }
            width() {
                return this.right - this.left;
            }
            height() {
                return this.bottom - this.top;
            }
            centerX() {
                return (this.left + this.right) >> 1;
            }
            centerY() {
                return (this.top + this.bottom) >> 1;
            }
            exactCenterX() {
                return (this.left + this.right) * 0.5;
            }
            exactCenterY() {
                return (this.top + this.bottom) * 0.5;
            }
            setEmpty() {
                this.left = this.right = this.top = this.bottom = 0;
            }
            set(...args) {
                if (args.length === 1) {
                    let rect = args[0];
                    [this.left, this.top, this.right, this.bottom] = [rect.left, rect.top, rect.right, rect.bottom];
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    this.left = left;
                    this.top = t;
                    this.right = right;
                    this.bottom = bottom;
                }
            }
            offset(dx, dy) {
                this.left += dx;
                this.top += dy;
                this.right += dx;
                this.bottom += dy;
            }
            offsetTo(newLeft, newTop) {
                this.right += newLeft - this.left;
                this.bottom += newTop - this.top;
                this.left = newLeft;
                this.top = newTop;
            }
            inset(dx, dy) {
                this.left += dx;
                this.top += dy;
                this.right -= dx;
                this.bottom -= dy;
            }
            contains(...args) {
                if (args.length === 1) {
                    let r = args[0];
                    return this.left < this.right && this.top < this.bottom
                        && this.left <= r.left && this.top <= r.top && this.right >= r.right && this.bottom >= r.bottom;
                }
                else if (args.length === 2) {
                    let [x, y] = args;
                    return this.left < this.right && this.top < this.bottom
                        && x >= this.left && x < this.right && y >= this.top && y < this.bottom;
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    return this.left < this.right && this.top < this.bottom
                        && this.left <= left && this.top <= t
                        && this.right >= right && this.bottom >= bottom;
                }
            }
            intersect(...args) {
                if (args.length === 1) {
                    let rect = args[0];
                    return this.intersect(rect.left, rect.top, rect.right, rect.bottom);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    if (this.left < right && left < this.right && this.top < bottom && t < this.bottom) {
                        if (this.left < left)
                            this.left = left;
                        if (this.top < t)
                            this.top = t;
                        if (this.right > right)
                            this.right = right;
                        if (this.bottom > bottom)
                            this.bottom = bottom;
                        return true;
                    }
                    return false;
                }
            }
            intersects(...args) {
                if (args.length === 1) {
                    let rect = args[0];
                    return this.intersects(rect.left, rect.top, rect.right, rect.bottom);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    return this.left < right && left < this.right && this.top < bottom && t < this.bottom;
                }
            }
            union(...args) {
                if (arguments.length === 1) {
                    let rect = args[0];
                    this.union(rect.left, rect.top, rect.right, rect.bottom);
                }
                else if (arguments.length === 2) {
                    let [x = 0, y = 0] = args;
                    if (x < this.left) {
                        this.left = x;
                    }
                    else if (x > this.right) {
                        this.right = x;
                    }
                    if (y < this.top) {
                        this.top = y;
                    }
                    else if (y > this.bottom) {
                        this.bottom = y;
                    }
                }
                else {
                    let left = args[0];
                    let top = args[1];
                    let right = args[2];
                    let bottom = args[3];
                    if ((left < right) && (top < bottom)) {
                        if ((this.left < this.right) && (this.top < this.bottom)) {
                            if (this.left > left)
                                this.left = left;
                            if (this.top > top)
                                this.top = top;
                            if (this.right < right)
                                this.right = right;
                            if (this.bottom < bottom)
                                this.bottom = bottom;
                        }
                        else {
                            this.left = left;
                            this.top = top;
                            this.right = right;
                            this.bottom = bottom;
                        }
                    }
                }
            }
            sort() {
                if (this.left > this.right) {
                    [this.left, this.right] = [this.right, this.left];
                }
                if (this.top > this.bottom) {
                    [this.top, this.bottom] = [this.bottom, this.top];
                }
            }
            scale(scale) {
                if (scale != 1) {
                    this.left = this.left * scale;
                    this.top = this.top * scale;
                    this.right = this.right * scale;
                    this.bottom = this.bottom * scale;
                }
            }
        }
        graphics.Rect = Rect;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/9.
 */
///<reference path="../graphics/Rect.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class Gravity {
            static apply(gravity, w, h, container, outRect, layoutDirection) {
                let xAdj = 0, yAdj = 0;
                if (layoutDirection != null)
                    gravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);
                switch (gravity & ((Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_X_SHIFT)) {
                    case 0:
                        outRect.left = container.left + ((container.right - container.left - w) / 2) + xAdj;
                        outRect.right = outRect.left + w;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) == (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) {
                            if (outRect.left < container.left) {
                                outRect.left = container.left;
                            }
                            if (outRect.right > container.right) {
                                outRect.right = container.right;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_BEFORE << Gravity.AXIS_X_SHIFT:
                        outRect.left = container.left + xAdj;
                        outRect.right = outRect.left + w;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) == (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) {
                            if (outRect.right > container.right) {
                                outRect.right = container.right;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_AFTER << Gravity.AXIS_X_SHIFT:
                        outRect.right = container.right - xAdj;
                        outRect.left = outRect.right - w;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) == (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) {
                            if (outRect.left < container.left) {
                                outRect.left = container.left;
                            }
                        }
                        break;
                    default:
                        outRect.left = container.left + xAdj;
                        outRect.right = container.right + xAdj;
                        break;
                }
                switch (gravity & ((Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_Y_SHIFT)) {
                    case 0:
                        outRect.top = container.top + ((container.bottom - container.top - h) / 2) + yAdj;
                        outRect.bottom = outRect.top + h;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) == (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) {
                            if (outRect.top < container.top) {
                                outRect.top = container.top;
                            }
                            if (outRect.bottom > container.bottom) {
                                outRect.bottom = container.bottom;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_BEFORE << Gravity.AXIS_Y_SHIFT:
                        outRect.top = container.top + yAdj;
                        outRect.bottom = outRect.top + h;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) == (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) {
                            if (outRect.bottom > container.bottom) {
                                outRect.bottom = container.bottom;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_AFTER << Gravity.AXIS_Y_SHIFT:
                        outRect.bottom = container.bottom - yAdj;
                        outRect.top = outRect.bottom - h;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) == (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) {
                            if (outRect.top < container.top) {
                                outRect.top = container.top;
                            }
                        }
                        break;
                    default:
                        outRect.top = container.top + yAdj;
                        outRect.bottom = container.bottom + yAdj;
                        break;
                }
            }
            static getAbsoluteGravity(gravity, layoutDirection) {
                return gravity;
            }
        }
        Gravity.NO_GRAVITY = 0x0000;
        Gravity.AXIS_SPECIFIED = 0x0001;
        Gravity.AXIS_PULL_BEFORE = 0x0002;
        Gravity.AXIS_PULL_AFTER = 0x0004;
        Gravity.AXIS_CLIP = 0x0008;
        Gravity.AXIS_X_SHIFT = 0;
        Gravity.AXIS_Y_SHIFT = 4;
        Gravity.TOP = (Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_Y_SHIFT;
        Gravity.BOTTOM = (Gravity.AXIS_PULL_AFTER | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_Y_SHIFT;
        Gravity.LEFT = (Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_X_SHIFT;
        Gravity.RIGHT = (Gravity.AXIS_PULL_AFTER | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_X_SHIFT;
        Gravity.START = Gravity.LEFT;
        Gravity.END = Gravity.RIGHT;
        Gravity.CENTER_VERTICAL = Gravity.AXIS_SPECIFIED << Gravity.AXIS_Y_SHIFT;
        Gravity.FILL_VERTICAL = Gravity.TOP | Gravity.BOTTOM;
        Gravity.CENTER_HORIZONTAL = Gravity.AXIS_SPECIFIED << Gravity.AXIS_X_SHIFT;
        Gravity.FILL_HORIZONTAL = Gravity.LEFT | Gravity.RIGHT;
        Gravity.CENTER = Gravity.CENTER_VERTICAL | Gravity.CENTER_HORIZONTAL;
        Gravity.FILL = Gravity.FILL_VERTICAL | Gravity.FILL_HORIZONTAL;
        Gravity.CLIP_VERTICAL = Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT;
        Gravity.CLIP_HORIZONTAL = Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT;
        Gravity.HORIZONTAL_GRAVITY_MASK = (Gravity.AXIS_SPECIFIED |
            Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_X_SHIFT;
        Gravity.VERTICAL_GRAVITY_MASK = (Gravity.AXIS_SPECIFIED |
            Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_Y_SHIFT;
        Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK = Gravity.HORIZONTAL_GRAVITY_MASK;
        Gravity.DISPLAY_CLIP_VERTICAL = 0x10000000;
        Gravity.DISPLAY_CLIP_HORIZONTAL = 0x01000000;
        view.Gravity = Gravity;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class SparseMap {
            constructor(initialCapacity) {
                this.map = new Map();
            }
            clone() {
                let clone = new SparseMap();
                clone.map = new Map(this.map);
                return clone;
            }
            get(key, valueIfKeyNotFound = null) {
                let value = this.map.get(key);
                if (value === undefined)
                    return valueIfKeyNotFound;
                return value;
            }
            delete(key) {
                this.map.delete(key);
            }
            remove(key) {
                this.delete(key);
            }
            removeAt(index) {
                this.removeAtRange(index);
            }
            removeAtRange(index, size = 1) {
                let keys = [...this.map.keys()];
                let end = Math.min(this.map.size, index + size);
                for (let i = index; i < end; i++) {
                    this.map.delete(keys[i]);
                }
            }
            put(key, value) {
                this.map.set(key, value);
            }
            size() {
                return this.map.size;
            }
            keyAt(index) {
                return [...this.map.keys()][index];
            }
            valueAt(index) {
                return [...this.map.values()][index];
            }
            setValueAt(index, value) {
                let key = this.keyAt(index);
                this.map.set(key, value);
            }
            indexOfKey(key) {
                return [...this.map.keys()].indexOf(key);
            }
            indexOfValue(value) {
                return [...this.map.values()].indexOf(value);
            }
            clear() {
                this.map.clear();
            }
            append(key, value) {
                this.put(key, value);
            }
        }
        util.SparseMap = SparseMap;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="SparseMap.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        class SparseArray extends util.SparseMap {
        }
        util.SparseArray = SparseArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class Log {
            static getPriorityString(priority) {
                if (priority > Log.PriorityString.length)
                    return "";
                return Log.PriorityString[priority - 2];
            }
            static v(tag, msg, tr) {
                console.log(Log.getLogMsg(Log.VERBOSE, tag, msg));
                if (tr)
                    console.log(tr);
            }
            static d(tag, msg) {
                console.debug(Log.getLogMsg(Log.DEBUG, tag, msg));
            }
            static i(tag, msg, tr) {
                console.info(Log.getLogMsg(Log.INFO, tag, msg));
                if (tr)
                    console.info(tr);
            }
            static w(tag, msg, tr) {
                console.warn(Log.getLogMsg(Log.WARN, tag, msg));
                if (tr)
                    console.warn(tr);
            }
            static e(tag, msg, tr) {
                console.error(Log.getLogMsg(Log.ERROR, tag, msg));
                if (tr)
                    console.error(tr);
            }
            static getLogMsg(priority, tag, msg) {
                let d = new Date();
                let dateFormat = d.toLocaleTimeString() + '.' + d.getUTCMilliseconds();
                return "[" + Log.getPriorityString(priority) + "] " + dateFormat + " \t " + tag + " \t " + msg;
            }
        }
        Log.View_DBG = false;
        Log.VelocityTracker_DBG = false;
        Log.DBG_DrawableContainer = false;
        Log.DBG_StateListDrawable = false;
        Log.VERBOSE = 2;
        Log.DEBUG = 3;
        Log.INFO = 4;
        Log.WARN = 5;
        Log.ERROR = 6;
        Log.ASSERT = 7;
        Log.PriorityString = ["VERBOSE", "DEBUG", "INFO", "WARN", "ERROR", "ASSERT"];
        util.Log = Log;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class PixelFormat {
        }
        PixelFormat.UNKNOWN = 0;
        PixelFormat.TRANSLUCENT = -3;
        PixelFormat.TRANSPARENT = -2;
        PixelFormat.OPAQUE = -1;
        PixelFormat.RGBA_8888 = 1;
        PixelFormat.RGBX_8888 = 2;
        PixelFormat.RGB_888 = 3;
        PixelFormat.RGB_565 = 4;
        graphics.PixelFormat = PixelFormat;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        var ref;
        (function (ref) {
            class WeakReference {
                constructor(referent) {
                    this.weakMap = new WeakMap();
                    this.weakMap.set(this, referent);
                }
                get() {
                    return this.weakMap.get(this);
                }
                set(value) {
                    this.weakMap.set(this, value);
                }
                clear() {
                    this.weakMap.delete(this);
                }
            }
            ref.WeakReference = WeakReference;
        })(ref = lang.ref || (lang.ref = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class System {
            static currentTimeMillis() {
                return new Date().getTime();
            }
            static arraycopy(src, srcPos, dest, destPos, length) {
                let srcLength = src.length;
                let destLength = dest.length;
                for (let i = 0; i < length; i++) {
                    let srcIndex = i + srcPos;
                    if (srcIndex >= srcLength)
                        return;
                    let destIndex = i + destPos;
                    if (destIndex >= destLength)
                        return;
                    dest[destIndex] = src[srcIndex];
                }
            }
        }
        System.out = {
            println(any) {
                console.log('\n');
                console.log(any);
            },
            print(any) {
                console.log(any);
            }
        };
        lang.System = System;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="../../java/lang/System.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        var System = java.lang.System;
        class StateSet {
            static isWildCard(stateSetOrSpec) {
                return stateSetOrSpec.length == 0 || stateSetOrSpec[0] == 0;
            }
            static stateSetMatches(stateSpec, stateSetOrState) {
                if (Number.isInteger(stateSetOrState)) {
                    return StateSet._stateSetMatches_single(stateSpec, stateSetOrState);
                }
                let stateSet = stateSetOrState;
                if (stateSet == null) {
                    return (stateSpec == null || this.isWildCard(stateSpec));
                }
                let stateSpecSize = stateSpec.length;
                let stateSetSize = stateSet.length;
                for (let i = 0; i < stateSpecSize; i++) {
                    let stateSpecState = stateSpec[i];
                    if (stateSpecState == 0) {
                        return true;
                    }
                    let mustMatch;
                    if (stateSpecState > 0) {
                        mustMatch = true;
                    }
                    else {
                        mustMatch = false;
                        stateSpecState = -stateSpecState;
                    }
                    let found = false;
                    for (let j = 0; j < stateSetSize; j++) {
                        const state = stateSet[j];
                        if (state == 0) {
                            if (mustMatch) {
                                return false;
                            }
                            else {
                                break;
                            }
                        }
                        if (state == stateSpecState) {
                            if (mustMatch) {
                                found = true;
                                break;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                    if (mustMatch && !found) {
                        return false;
                    }
                }
                return true;
            }
            static _stateSetMatches_single(stateSpec, state) {
                let stateSpecSize = stateSpec.length;
                for (let i = 0; i < stateSpecSize; i++) {
                    let stateSpecState = stateSpec[i];
                    if (stateSpecState == 0) {
                        return true;
                    }
                    if (stateSpecState > 0) {
                        if (state != stateSpecState) {
                            return false;
                        }
                    }
                    else {
                        if (state == -stateSpecState) {
                            return false;
                        }
                    }
                }
                return true;
            }
            static trimStateSet(states, newSize) {
                if (states.length == newSize) {
                    return states;
                }
                let trimmedStates = new Array(newSize);
                System.arraycopy(states, 0, trimmedStates, 0, newSize);
                return trimmedStates;
            }
        }
        StateSet.WILD_CARD = [];
        StateSet.NOTHING = [0];
        util.StateSet = StateSet;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class Pools {
        }
        util.Pools = Pools;
        (function (Pools) {
            class SimplePool {
                constructor(maxPoolSize) {
                    this.mPoolSize = 0;
                    if (maxPoolSize <= 0) {
                        throw new Error("The max pool size must be > 0");
                    }
                    this.mPool = new Array(maxPoolSize);
                }
                acquire() {
                    if (this.mPoolSize > 0) {
                        const lastPooledIndex = this.mPoolSize - 1;
                        let instance = this.mPool[lastPooledIndex];
                        this.mPool[lastPooledIndex] = null;
                        this.mPoolSize--;
                        return instance;
                    }
                    return null;
                }
                release(instance) {
                    if (this.isInPool(instance)) {
                        throw new Error("Already in the pool!");
                    }
                    if (this.mPoolSize < this.mPool.length) {
                        this.mPool[this.mPoolSize] = instance;
                        this.mPoolSize++;
                        return true;
                    }
                    return false;
                }
                isInPool(instance) {
                    for (let i = 0; i < this.mPoolSize; i++) {
                        if (this.mPool[i] == instance) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            Pools.SimplePool = SimplePool;
            class SynchronizedPool extends SimplePool {
            }
            Pools.SynchronizedPool = SynchronizedPool;
        })(Pools = util.Pools || (util.Pools = {}));
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Color {
            static alpha(color) {
                return color >>> 24;
            }
            static red(color) {
                return (color >> 16) & 0xFF;
            }
            static green(color) {
                return (color >> 8) & 0xFF;
            }
            static blue(color) {
                return color & 0xFF;
            }
            static rgb(red, green, blue) {
                return (0xFF << 24) | (red << 16) | (green << 8) | blue;
            }
            static argb(alpha, red, green, blue) {
                return (alpha << 24) | (red << 16) | (green << 8) | blue;
            }
            static rgba(red, green, blue, alpha) {
                return (alpha << 24) | (red << 16) | (green << 8) | blue;
            }
            static parseColor(colorString) {
                if (colorString.charAt(0) == '#') {
                    let color = parseInt(colorString.substring(1), 16);
                    if (colorString.length == 7) {
                        color |= 0x00000000ff000000;
                    }
                    else if (colorString.length != 9) {
                        throw new Error("Unknown color");
                    }
                    return color;
                }
                else {
                    let color = Color.sColorNameMap.get(colorString.toLowerCase());
                    if (color != null) {
                        return color;
                    }
                }
                throw new Error("Unknown color");
            }
            static toARGBHex(color) {
                let r = Color.red(color);
                let g = Color.green(color);
                let b = Color.blue(color);
                let a = Color.alpha(color);
                let hR = r < 16 ? '0' + r.toString(16) : r.toString(16);
                let hG = g < 16 ? '0' + g.toString(16) : g.toString(16);
                let hB = b < 16 ? '0' + b.toString(16) : b.toString(16);
                let hA = a < 16 ? '0' + a.toString(16) : a.toString(16);
                return "#" + hA + hR + hG + hB;
            }
            static toRGBAFunc(color) {
                let r = Color.red(color);
                let g = Color.green(color);
                let b = Color.blue(color);
                let a = Color.alpha(color);
                return `rgba(${r},${g},${b},${a / 255})`;
            }
            static getHtmlColor(color) {
                let i = Color.sColorNameMap.get(color.toLowerCase());
                return i;
            }
        }
        Color.BLACK = 0xFF000000;
        Color.DKGRAY = 0xFF444444;
        Color.GRAY = 0xFF888888;
        Color.LTGRAY = 0xFFCCCCCC;
        Color.WHITE = 0xFFFFFFFF;
        Color.RED = 0xFFFF0000;
        Color.GREEN = 0xFF00FF00;
        Color.BLUE = 0xFF0000FF;
        Color.YELLOW = 0xFFFFFF00;
        Color.CYAN = 0xFF00FFFF;
        Color.MAGENTA = 0xFFFF00FF;
        Color.TRANSPARENT = 0;
        Color.sColorNameMap = new Map();
        graphics.Color = Color;
        Color.sColorNameMap = new Map();
        Color.sColorNameMap.set("black", Color.BLACK);
        Color.sColorNameMap.set("darkgray", Color.DKGRAY);
        Color.sColorNameMap.set("gray", Color.GRAY);
        Color.sColorNameMap.set("lightgray", Color.LTGRAY);
        Color.sColorNameMap.set("white", Color.WHITE);
        Color.sColorNameMap.set("red", Color.RED);
        Color.sColorNameMap.set("green", Color.GREEN);
        Color.sColorNameMap.set("blue", Color.BLUE);
        Color.sColorNameMap.set("yellow", Color.YELLOW);
        Color.sColorNameMap.set("cyan", Color.CYAN);
        Color.sColorNameMap.set("magenta", Color.MAGENTA);
        Color.sColorNameMap.set("aqua", 0xFF00FFFF);
        Color.sColorNameMap.set("fuchsia", 0xFFFF00FF);
        Color.sColorNameMap.set("darkgrey", Color.DKGRAY);
        Color.sColorNameMap.set("grey", Color.GRAY);
        Color.sColorNameMap.set("lightgrey", Color.LTGRAY);
        Color.sColorNameMap.set("lime", 0xFF00FF00);
        Color.sColorNameMap.set("maroon", 0xFF800000);
        Color.sColorNameMap.set("navy", 0xFF000080);
        Color.sColorNameMap.set("olive", 0xFF808000);
        Color.sColorNameMap.set("purple", 0xFF800080);
        Color.sColorNameMap.set("silver", 0xFFC0C0C0);
        Color.sColorNameMap.set("teal", 0xFF008080);
        Color.sColorNameMap.set("transparent", Color.TRANSPARENT);
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Paint {
            constructor(flag = 0) {
                this.textScaleX = 1;
                this.mFlag = 0;
                this.shadowDx = 0;
                this.shadowDy = 0;
                this.shadowRadius = 0;
                this.shadowColor = 0;
                this.mFlag = flag;
            }
            set(src) {
                if (this != src) {
                    this.setClassVariablesFrom(src);
                }
            }
            setClassVariablesFrom(paint) {
                this.mTextStyle = paint.mTextStyle;
                this.mColor = paint.mColor;
                this.mAlpha = paint.mAlpha;
                this.mStrokeWidth = paint.mStrokeWidth;
                this.align = paint.align;
                this.mStrokeCap = paint.mStrokeCap;
                this.mStrokeJoin = paint.mStrokeJoin;
                this.textSize = paint.textSize;
                this.textScaleX = paint.textScaleX;
                this.mFlag = paint.mFlag;
                this.hasShadow = paint.hasShadow;
                this.shadowDx = paint.shadowDx;
                this.shadowDy = paint.shadowDy;
                this.shadowRadius = paint.shadowRadius;
                this.shadowColor = paint.shadowColor;
                this.drawableState = paint.drawableState;
            }
            getStyle() {
                return this.mTextStyle;
            }
            setStyle(style) {
                this.mTextStyle = style;
            }
            getFlags() {
                return this.mFlag;
            }
            setFlags(flags) {
                this.mFlag = flags;
            }
            getTextScaleX() {
                return this.textScaleX;
            }
            setTextScaleX(scaleX) {
                this.textScaleX = scaleX;
            }
            getColor() {
                return this.mColor;
            }
            setColor(color) {
                this.mColor = color;
            }
            setARGB(a, r, g, b) {
                this.setColor((a << 24) | (r << 16) | (g << 8) | b);
            }
            getAlpha() {
                if (this.mAlpha == null)
                    return 255;
                return this.mAlpha;
            }
            setAlpha(alpha) {
                this.mAlpha = alpha;
            }
            getStrokeWidth() {
                return this.mStrokeWidth;
            }
            setStrokeWidth(width) {
                this.mStrokeWidth = width;
            }
            getStrokeCap() {
                return this.mStrokeCap;
            }
            setStrokeCap(cap) {
                this.mStrokeCap = cap;
            }
            getStrokeJoin() {
                return this.mStrokeJoin;
            }
            setStrokeJoin(join) {
                this.mStrokeJoin = join;
            }
            setAntiAlias(enable) {
            }
            isAntiAlias() {
                return true;
            }
            setShadowLayer(radius, dx, dy, color) {
                this.hasShadow = radius > 0.0;
                this.shadowRadius = radius;
                this.shadowDx = dx;
                this.shadowDy = dy;
                this.shadowColor = color;
            }
            clearShadowLayer() {
                this.hasShadow = false;
            }
            getTextAlign() {
                return this.align;
            }
            setTextAlign(align) {
                this.align = align;
            }
            getTextSize() {
                return this.textSize;
            }
            setTextSize(textSize) {
                this.textSize = textSize;
            }
            ascent() {
                return this.textSize * Paint.FontMetrics_Size_Ascent;
            }
            descent() {
                return this.textSize * Paint.FontMetrics_Size_Descent;
            }
            getFontMetricsInt(fmi) {
                if (this.textSize == null) {
                    console.warn('call Paint.getFontMetricsInt but textSize not init');
                    return 0;
                }
                if (fmi == null) {
                    return Math.floor((Paint.FontMetrics_Size_Descent - Paint.FontMetrics_Size_Ascent) * this.textSize);
                }
                fmi.ascent = Math.floor(Paint.FontMetrics_Size_Ascent * this.textSize);
                fmi.bottom = Math.floor(Paint.FontMetrics_Size_Bottom * this.textSize);
                fmi.descent = Math.floor(Paint.FontMetrics_Size_Descent * this.textSize);
                fmi.leading = Math.floor(Paint.FontMetrics_Size_Leading * this.textSize);
                fmi.top = Math.floor(Paint.FontMetrics_Size_Top * this.textSize);
                return fmi.descent - fmi.ascent;
            }
            getFontMetrics(metrics) {
                if (this.textSize == null) {
                    console.warn('call Paint.getFontMetrics but textSize not init');
                    return 0;
                }
                if (metrics == null) {
                    return (Paint.FontMetrics_Size_Descent - Paint.FontMetrics_Size_Ascent) * this.textSize;
                }
                metrics.ascent = Paint.FontMetrics_Size_Ascent * this.textSize;
                metrics.bottom = Paint.FontMetrics_Size_Bottom * this.textSize;
                metrics.descent = Paint.FontMetrics_Size_Descent * this.textSize;
                metrics.leading = Paint.FontMetrics_Size_Leading * this.textSize;
                metrics.top = Paint.FontMetrics_Size_Top * this.textSize;
                return metrics.descent - metrics.ascent;
            }
            measureText(text, index = 0, count = text.length) {
                return graphics.Canvas.measureText(text.substr(index, count), this.textSize) * this.textScaleX;
            }
            getTextWidths_count(text, index, count, widths) {
                return this.getTextWidths_end(text, index, index + count, widths);
            }
            getTextWidths_end(text, start, end, widths) {
                if (text == null) {
                    throw Error(`new IllegalArgumentException("text cannot be null")`);
                }
                if ((start | end | (end - start) | (text.length - end)) < 0) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                if (end - start > widths.length) {
                    throw Error(`new ArrayIndexOutOfBoundsException()`);
                }
                if (text.length == 0 || start == end) {
                    return 0;
                }
                for (let i = start; i < end; i++) {
                    widths[i - start] = this.measureText(text[i]);
                }
                return end - start;
            }
            getTextWidths_2(text, widths) {
                return this.getTextWidths_end(text, 0, text.length, widths);
            }
            getTextRunAdvances_count(chars, index, count, contextIndex, contextCount, flags, advances, advancesIndex) {
                return this.getTextRunAdvances_end(chars, index, index + count, contextIndex, contextCount, flags, advances, advancesIndex);
            }
            getTextRunAdvances_end(text, start, end, contextStart, contextEnd, flags, advances, advancesIndex) {
                if (text == null) {
                    throw Error(`new IllegalArgumentException("text cannot be null")`);
                }
                if (flags != Paint.DIRECTION_LTR && flags != Paint.DIRECTION_RTL) {
                    throw Error(`new IllegalArgumentException("unknown flags value: " + flags)`);
                }
                if ((start | end | contextStart | contextEnd | advancesIndex | (end - start)
                    | (start - contextStart) | (contextEnd - end) | (text.length - contextEnd)
                    | (advances == null ? 0 : (advances.length - advancesIndex - (end - start)))) < 0) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                if (text.length == 0 || start == end) {
                    return 0;
                }
                let totalAdvance = 0;
                for (let i = start; i < end; i++) {
                    let width = this.measureText(text[i]);
                    if (advances)
                        advances[i - start + advancesIndex] = width;
                    totalAdvance += width;
                }
                return totalAdvance;
            }
            getTextRunCursor_len(text, contextStart, contextLength, flags, offset, cursorOpt) {
                let contextEnd = contextStart + contextLength;
                if (((contextStart | contextEnd | offset | (contextEnd - contextStart) | (offset - contextStart) | (contextEnd - offset)
                    | (text.length - contextEnd) | cursorOpt) < 0) || cursorOpt > Paint.CURSOR_OPT_MAX_VALUE) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                const scalarArray = new Array(contextLength);
                this.getTextRunAdvances_count(text, contextStart, contextLength, contextStart, contextLength, flags, scalarArray, 0);
                let pos = offset - contextStart;
                switch (cursorOpt) {
                    case Paint.CURSOR_AFTER:
                        if (pos < contextLength) {
                            pos += 1;
                        }
                    case Paint.CURSOR_AT_OR_AFTER:
                        while (pos < contextLength && scalarArray[pos] == 0) {
                            ++pos;
                        }
                        break;
                    case Paint.CURSOR_BEFORE:
                        if (pos > 0) {
                            --pos;
                        }
                    case Paint.CURSOR_AT_OR_BEFORE:
                        while (pos > 0 && scalarArray[pos] == 0) {
                            --pos;
                        }
                        break;
                    case Paint.CURSOR_AT:
                    default:
                        if (scalarArray[pos] == 0) {
                            pos = -1;
                        }
                        break;
                }
                if (pos != -1) {
                    pos += contextStart;
                }
                return pos;
            }
            getTextRunCursor_end(text, contextStart, contextEnd, flags, offset, cursorOpt) {
                if (((contextStart | contextEnd | offset | (contextEnd - contextStart) | (offset - contextStart) | (contextEnd - offset)
                    | (text.length - contextEnd) | cursorOpt) < 0) || cursorOpt > Paint.CURSOR_OPT_MAX_VALUE) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                let contextLen = contextEnd - contextStart;
                return this.getTextRunCursor_len(text, 0, contextLen, flags, offset - contextStart, cursorOpt);
            }
            isEmpty() {
                return this.mColor == null
                    && this.mAlpha == null
                    && this.align == null
                    && this.mStrokeWidth == null
                    && this.mStrokeCap == null
                    && this.mStrokeJoin == null
                    && !this.hasShadow
                    && this.textSize == null;
            }
            applyToCanvas(canvas) {
                if (this.mColor != null) {
                    canvas.setColor(this.mColor, this.getStyle());
                }
                if (this.mAlpha != null) {
                    canvas.multiplyAlpha(this.mAlpha / 255);
                }
                if (this.align != null) {
                    canvas.setTextAlign(Paint.Align[this.align].toLowerCase());
                }
                if (this.mStrokeWidth != null) {
                    canvas.setLineWidth(this.mStrokeWidth);
                }
                if (this.mStrokeCap != null) {
                    canvas.setLineCap(Paint.Cap[this.mStrokeCap].toLowerCase());
                }
                if (this.mStrokeJoin != null) {
                    canvas.setLineJoin(Paint.Join[this.mStrokeJoin].toLowerCase());
                }
                if (this.hasShadow) {
                    canvas.setShadow(this.shadowRadius, this.shadowDx, this.shadowDy, this.shadowColor);
                }
                if (this.textSize != null) {
                    canvas.setFontSize(this.textSize);
                }
                if (this.textScaleX != 1) {
                    canvas.scale(this.textScaleX, 1);
                }
            }
        }
        Paint.FontMetrics_Size_Ascent = -0.9277344;
        Paint.FontMetrics_Size_Bottom = 0.2709961;
        Paint.FontMetrics_Size_Descent = 0.24414062;
        Paint.FontMetrics_Size_Leading = 0;
        Paint.FontMetrics_Size_Top = -1.05615234;
        Paint.DIRECTION_LTR = 0;
        Paint.DIRECTION_RTL = 1;
        Paint.CURSOR_AFTER = 0;
        Paint.CURSOR_AT_OR_AFTER = 1;
        Paint.CURSOR_BEFORE = 2;
        Paint.CURSOR_AT_OR_BEFORE = 3;
        Paint.CURSOR_AT = 4;
        Paint.CURSOR_OPT_MAX_VALUE = Paint.CURSOR_AT;
        Paint.ANTI_ALIAS_FLAG = 0x01;
        Paint.FILTER_BITMAP_FLAG = 0x02;
        Paint.DITHER_FLAG = 0x04;
        Paint.UNDERLINE_TEXT_FLAG = 0x08;
        Paint.STRIKE_THRU_TEXT_FLAG = 0x10;
        Paint.FAKE_BOLD_TEXT_FLAG = 0x20;
        Paint.LINEAR_TEXT_FLAG = 0x40;
        Paint.SUBPIXEL_TEXT_FLAG = 0x80;
        Paint.DEV_KERN_TEXT_FLAG = 0x100;
        Paint.LCD_RENDER_TEXT_FLAG = 0x200;
        Paint.EMBEDDED_BITMAP_TEXT_FLAG = 0x400;
        Paint.AUTO_HINTING_TEXT_FLAG = 0x800;
        Paint.VERTICAL_TEXT_FLAG = 0x1000;
        Paint.DEFAULT_PAINT_FLAGS = Paint.DEV_KERN_TEXT_FLAG | Paint.EMBEDDED_BITMAP_TEXT_FLAG;
        graphics.Paint = Paint;
        (function (Paint) {
            (function (Align) {
                Align[Align["LEFT"] = 0] = "LEFT";
                Align[Align["CENTER"] = 1] = "CENTER";
                Align[Align["RIGHT"] = 2] = "RIGHT";
            })(Paint.Align || (Paint.Align = {}));
            var Align = Paint.Align;
            class FontMetrics {
                constructor() {
                    this.top = 0;
                    this.ascent = 0;
                    this.descent = 0;
                    this.bottom = 0;
                    this.leading = 0;
                }
            }
            Paint.FontMetrics = FontMetrics;
            class FontMetricsInt {
                constructor() {
                    this.top = 0;
                    this.ascent = 0;
                    this.descent = 0;
                    this.bottom = 0;
                    this.leading = 0;
                }
                toString() {
                    return "FontMetricsInt: top=" + this.top + " ascent=" + this.ascent + " descent=" + this.descent + " bottom=" + this.bottom + " leading=" + this.leading;
                }
            }
            Paint.FontMetricsInt = FontMetricsInt;
            (function (Style) {
                Style[Style["FILL"] = 0] = "FILL";
                Style[Style["STROKE"] = 1] = "STROKE";
                Style[Style["FILL_AND_STROKE"] = 2] = "FILL_AND_STROKE";
            })(Paint.Style || (Paint.Style = {}));
            var Style = Paint.Style;
            (function (Cap) {
                Cap[Cap["BUTT"] = 0] = "BUTT";
                Cap[Cap["ROUND"] = 1] = "ROUND";
                Cap[Cap["SQUARE"] = 2] = "SQUARE";
            })(Paint.Cap || (Paint.Cap = {}));
            var Cap = Paint.Cap;
            (function (Join) {
                Join[Join["MITER"] = 0] = "MITER";
                Join[Join["ROUND"] = 1] = "ROUND";
                Join[Join["BEVEL"] = 2] = "BEVEL";
            })(Paint.Join || (Paint.Join = {}));
            var Join = Paint.Join;
        })(Paint = graphics.Paint || (graphics.Paint = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Path {
            reset() {
            }
        }
        graphics.Path = Path;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Point {
            constructor(...args) {
                this.x = 0;
                this.y = 0;
                if (args.length === 1) {
                    let src = args[0];
                    this.x = src.x;
                    this.y = src.y;
                }
                else {
                    let [x = 0, y = 0] = args;
                    this.x = x;
                    this.y = y;
                }
            }
            set(x, y) {
                this.x = x;
                this.y = y;
            }
            negate() {
                this.x = -this.x;
                this.y = -this.y;
            }
            offset(dx, dy) {
                this.x += dx;
                this.y += dy;
            }
            equals(...args) {
                if (args.length === 2) {
                    let [x = 0, y = 0] = args;
                    return this.x == x && this.y == y;
                }
                else {
                    let o = args[0];
                    if (this === o)
                        return true;
                    if (!o || !(o instanceof Point))
                        return false;
                    let point = o;
                    if (this.x != point.x)
                        return false;
                    if (this.y != point.y)
                        return false;
                    return true;
                }
            }
            toString() {
                return "Point(" + this.x + ", " + this.y + ")";
            }
        }
        graphics.Point = Point;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/12/6.
 */
///<reference path="Rect.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class RectF extends graphics.Rect {
        }
        graphics.RectF = RectF;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../android/graphics/Point.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/RectF.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var System = java.lang.System;
        var StringBuilder = java.lang.StringBuilder;
        class Matrix {
            constructor(values) {
                this.mValues = new Array(Matrix.MATRIX_SIZE);
                if (values instanceof Matrix)
                    this.set(values);
                else if (values instanceof Array) {
                    System.arraycopy(values, 0, this.mValues, 0, Matrix.MATRIX_SIZE);
                }
                else {
                    Matrix.reset(this.mValues);
                }
            }
            isIdentity() {
                for (let i = 0, k = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++, k++) {
                        if (this.mValues[k] != ((i == j) ? 1 : 0)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            hasPerspective() {
                return (this.mValues[6] != 0 || this.mValues[7] != 0 || this.mValues[8] != 1);
            }
            rectStaysRect() {
                return (this.computeTypeMask() & Matrix.kRectStaysRect_Mask) != 0;
            }
            set(src) {
                if (src == null) {
                    this.reset();
                }
                else {
                    System.arraycopy(src.mValues, 0, this.mValues, 0, Matrix.MATRIX_SIZE);
                }
            }
            equals(obj) {
                if (!(obj instanceof Matrix))
                    return false;
                let another = obj;
                for (let i = 0; i < Matrix.MATRIX_SIZE; i++) {
                    if (this.mValues[i] != another.mValues[i]) {
                        return false;
                    }
                }
                return true;
            }
            hashCode() {
                return 44;
            }
            reset() {
                Matrix.reset(this.mValues);
            }
            setTranslate(dx, dy) {
                Matrix.setTranslate(this.mValues, dx, dy);
            }
            setScale(sx, sy, px, py) {
                if (px == null || py == null) {
                    this.mValues[0] = sx;
                    this.mValues[1] = 0;
                    this.mValues[2] = 0;
                    this.mValues[3] = 0;
                    this.mValues[4] = sy;
                    this.mValues[5] = 0;
                    this.mValues[6] = 0;
                    this.mValues[7] = 0;
                    this.mValues[8] = 1;
                }
                else {
                    this.mValues = Matrix.getScale(sx, sy, px, py);
                }
            }
            setRotate(degrees, px, py) {
                if (px == null || py == null) {
                    Matrix.setRotate_1(this.mValues, degrees);
                }
                else {
                    this.mValues = Matrix.getRotate_3(degrees, px, py);
                }
            }
            setSinCos(sinValue, cosValue, px, py) {
                if (px == null || py == null) {
                    Matrix.setRotate_2(this.mValues, sinValue, cosValue);
                }
                else {
                    Matrix.setTranslate(this.mValues, -px, -py);
                    this.postTransform(Matrix.getRotate_2(sinValue, cosValue));
                    this.postTransform(Matrix.getTranslate(px, py));
                }
            }
            setSkew(kx, ky, px, py) {
                if (px == null || py == null) {
                    this.mValues[0] = 1;
                    this.mValues[1] = kx;
                    this.mValues[2] = -0;
                    this.mValues[3] = ky;
                    this.mValues[4] = 1;
                    this.mValues[5] = 0;
                    this.mValues[6] = 0;
                    this.mValues[7] = 0;
                    this.mValues[8] = 1;
                }
                else {
                    this.mValues = Matrix.getSkew(kx, ky, px, py);
                }
            }
            setConcat(a, b) {
                Matrix.multiply(this.mValues, a.mValues, b.mValues);
                return true;
            }
            preTranslate(dx, dy) {
                this.preTransform(Matrix.getTranslate(dx, dy));
                return true;
            }
            preScale(sx, sy, px, py) {
                this.preTransform(Matrix.getScale(sx, sy, px, py));
                return true;
            }
            preRotate(degrees, px, py) {
                if (px == null || py == null) {
                    let rad = Math_toRadians(degrees);
                    let sin = Math.sin(rad);
                    let cos = Math.cos(rad);
                    this.preTransform(Matrix.getRotate_2(sin, cos));
                    return true;
                }
                this.preTransform(Matrix.getRotate_3(degrees, px, py));
                return true;
            }
            preSkew(kx, ky, px, py) {
                this.preTransform(Matrix.getSkew(kx, ky, px, py));
                return true;
            }
            preConcat(other) {
                this.preTransform(other.mValues);
                return true;
            }
            postTranslate(dx, dy) {
                this.postTransform(Matrix.getTranslate(dx, dy));
                return true;
            }
            postScale(sx, sy, px, py) {
                this.postTransform(Matrix.getScale(sx, sy, px, py));
                return true;
            }
            postRotate(degrees, px, py) {
                this.postTransform(Matrix.getRotate_3(degrees, px, py));
                return true;
            }
            postSkew(kx, ky, px, py) {
                this.postTransform(Matrix.getSkew(kx, ky, px, py));
                return true;
            }
            postConcat(other) {
                this.postTransform(other.mValues);
                return true;
            }
            setRectToRect(src, dst, stf) {
                if (dst == null || src == null) {
                    throw Error(`new NullPointerException()`);
                }
                let d = this;
                if (src.isEmpty()) {
                    Matrix.reset(d.mValues);
                    return false;
                }
                if (dst.isEmpty()) {
                    d.mValues[0] = d.mValues[1] = d.mValues[2] = d.mValues[3] = d.mValues[4] = d.mValues[5] = d.mValues[6] = d.mValues[7] = 0;
                    d.mValues[8] = 1;
                }
                else {
                    let tx, sx = dst.width() / src.width();
                    let ty, sy = dst.height() / src.height();
                    let xLarger = false;
                    if (stf != Matrix.ScaleToFit.FILL) {
                        if (sx > sy) {
                            xLarger = true;
                            sx = sy;
                        }
                        else {
                            sy = sx;
                        }
                    }
                    tx = dst.left - src.left * sx;
                    ty = dst.top - src.top * sy;
                    if (stf == Matrix.ScaleToFit.CENTER || stf == Matrix.ScaleToFit.END) {
                        let diff;
                        if (xLarger) {
                            diff = dst.width() - src.width() * sy;
                        }
                        else {
                            diff = dst.height() - src.height() * sy;
                        }
                        if (stf == Matrix.ScaleToFit.CENTER) {
                            diff = diff / 2;
                        }
                        if (xLarger) {
                            tx += diff;
                        }
                        else {
                            ty += diff;
                        }
                    }
                    d.mValues[0] = sx;
                    d.mValues[4] = sy;
                    d.mValues[2] = tx;
                    d.mValues[5] = ty;
                    d.mValues[1] = d.mValues[3] = d.mValues[6] = d.mValues[7] = 0;
                }
                d.mValues[8] = 1;
                return true;
            }
            static checkPointArrays(src, srcIndex, dst, dstIndex, pointCount) {
                let srcStop = srcIndex + (pointCount << 1);
                let dstStop = dstIndex + (pointCount << 1);
                if ((pointCount | srcIndex | dstIndex | srcStop | dstStop) < 0 || srcStop > src.length || dstStop > dst.length) {
                    throw Error(`new ArrayIndexOutOfBoundsException()`);
                }
            }
            mapPoints(dst, dstIndex = 0, src = dst, srcIndex = 0, pointCount = dst.length >> 1) {
                Matrix.checkPointArrays(src, srcIndex, dst, dstIndex, pointCount);
                const count = pointCount * 2;
                let tmpDest = dst;
                let inPlace = dst == src;
                if (inPlace) {
                    tmpDest = new Array(dstIndex + count);
                }
                for (let i = 0; i < count; i += 2) {
                    let x = this.mValues[0] * src[i + srcIndex] + this.mValues[1] * src[i + srcIndex + 1] + this.mValues[2];
                    let y = this.mValues[3] * src[i + srcIndex] + this.mValues[4] * src[i + srcIndex + 1] + this.mValues[5];
                    tmpDest[i + dstIndex] = x;
                    tmpDest[i + dstIndex + 1] = y;
                }
                if (inPlace) {
                    System.arraycopy(tmpDest, dstIndex, dst, dstIndex, count);
                }
            }
            mapVectors(dst, dstIndex = 0, src = dst, srcIndex = 0, ptCount = dst.length >> 1) {
                Matrix.checkPointArrays(src, srcIndex, dst, dstIndex, ptCount);
                if (this.hasPerspective()) {
                    let origin = [0., 0.];
                    this.mapPoints(origin);
                    this.mapPoints(dst, dstIndex, src, srcIndex, ptCount);
                    const count = ptCount * 2;
                    for (let i = 0; i < count; i += 2) {
                        dst[dstIndex + i] = dst[dstIndex + i] - origin[0];
                        dst[dstIndex + i + 1] = dst[dstIndex + i + 1] - origin[1];
                    }
                }
                else {
                    let copy = new Matrix(this.mValues);
                    Matrix.setTranslate(copy.mValues, 0, 0);
                    copy.mapPoints(dst, dstIndex, src, srcIndex, ptCount);
                }
            }
            mapRect(dst, src = dst) {
                if (dst == null || src == null) {
                    throw Error(`new NullPointerException()`);
                }
                let corners = [src.left, src.top, src.right, src.top, src.right, src.bottom, src.left, src.bottom];
                this.mapPoints(corners);
                dst.left = Math.min(Math.min(corners[0], corners[2]), Math.min(corners[4], corners[6]));
                dst.right = Math.max(Math.max(corners[0], corners[2]), Math.max(corners[4], corners[6]));
                dst.top = Math.min(Math.min(corners[1], corners[3]), Math.min(corners[5], corners[7]));
                dst.bottom = Math.max(Math.max(corners[1], corners[3]), Math.max(corners[5], corners[7]));
                return (this.computeTypeMask() & Matrix.kRectStaysRect_Mask) != 0;
            }
            mapRadius(radius) {
                let src = [radius, 0., 0., radius];
                this.mapVectors(src, 0, src, 0, 2);
                let l1 = Matrix.getPointLength(src, 0);
                let l2 = Matrix.getPointLength(src, 2);
                return Math.sqrt(l1 * l2);
            }
            getValues(values) {
                if (values.length < 9) {
                    throw Error(`new ArrayIndexOutOfBoundsException()`);
                }
                System.arraycopy(this.mValues, 0, values, 0, Matrix.MATRIX_SIZE);
            }
            setValues(values) {
                if (values.length < 9) {
                    throw Error(`new ArrayIndexOutOfBoundsException()`);
                }
                System.arraycopy(values, 0, this.mValues, 0, Matrix.MATRIX_SIZE);
            }
            toString() {
                let sb = new StringBuilder(64);
                sb.append("Matrix{");
                this.toShortString(sb);
                sb.append('}');
                return sb.toString();
            }
            toShortString(sb) {
                let values = new Array(9);
                this.getValues(values);
                sb.append('[');
                sb.append(values[0]);
                sb.append(", ");
                sb.append(values[1]);
                sb.append(", ");
                sb.append(values[2]);
                sb.append("][");
                sb.append(values[3]);
                sb.append(", ");
                sb.append(values[4]);
                sb.append(", ");
                sb.append(values[5]);
                sb.append("][");
                sb.append(values[6]);
                sb.append(", ");
                sb.append(values[7]);
                sb.append(", ");
                sb.append(values[8]);
                sb.append(']');
            }
            postTransform(matrix) {
                let tmp = new Array(9);
                Matrix.multiply(tmp, this.mValues, matrix);
                this.mValues = tmp;
            }
            preTransform(matrix) {
                let tmp = new Array(9);
                Matrix.multiply(tmp, matrix, this.mValues);
                this.mValues = tmp;
            }
            static getPointLength(src, index) {
                return Math.sqrt(src[index] * src[index] + src[index + 1] * src[index + 1]);
            }
            static multiply(dest, a, b) {
                dest[0] = b[0] * a[0] + b[1] * a[3] + b[2] * a[6];
                dest[1] = b[0] * a[1] + b[1] * a[4] + b[2] * a[7];
                dest[2] = b[0] * a[2] + b[1] * a[5] + b[2] * a[8];
                dest[3] = b[3] * a[0] + b[4] * a[3] + b[5] * a[6];
                dest[4] = b[3] * a[1] + b[4] * a[4] + b[5] * a[7];
                dest[5] = b[3] * a[2] + b[4] * a[5] + b[5] * a[8];
                dest[6] = b[6] * a[0] + b[7] * a[3] + b[8] * a[6];
                dest[7] = b[6] * a[1] + b[7] * a[4] + b[8] * a[7];
                dest[8] = b[6] * a[2] + b[7] * a[5] + b[8] * a[8];
            }
            static getTranslate(dx, dy) {
                return this.setTranslate(new Array(9), dx, dy);
            }
            static setTranslate(dest, dx, dy) {
                dest[0] = 1;
                dest[1] = 0;
                dest[2] = dx;
                dest[3] = 0;
                dest[4] = 1;
                dest[5] = dy;
                dest[6] = 0;
                dest[7] = 0;
                dest[8] = 1;
                return dest;
            }
            static getScale(sx, sy, px, py) {
                if (px == null || py == null) {
                    return [sx, 0, 0, 0, sy, 0, 0, 0, 1];
                }
                let tmp = new Array(9);
                let tmp2 = new Array(9);
                this.setTranslate(tmp, -px, -py);
                Matrix.multiply(tmp2, tmp, Matrix.getScale(sx, sy));
                Matrix.multiply(tmp, tmp2, Matrix.getTranslate(px, py));
                return tmp;
            }
            static getRotate_1(degrees) {
                let rad = Math_toRadians(degrees);
                let sin = Math.sin(rad);
                let cos = Math.cos(rad);
                return Matrix.getRotate_2(sin, cos);
            }
            static getRotate_2(sin, cos) {
                return this.setRotate_2(new Array(9), sin, cos);
            }
            static setRotate_1(dest, degrees) {
                let rad = Math_toRadians(degrees);
                let sin = Math.sin(rad);
                let cos = Math.cos(rad);
                return Matrix.setRotate_2(dest, sin, cos);
            }
            static setRotate_2(dest, sin, cos) {
                dest[0] = cos;
                dest[1] = -sin;
                dest[2] = 0;
                dest[3] = sin;
                dest[4] = cos;
                dest[5] = 0;
                dest[6] = 0;
                dest[7] = 0;
                dest[8] = 1;
                return dest;
            }
            static getRotate_3(degrees, px, py) {
                let tmp = new Array(9);
                let tmp2 = new Array(9);
                this.setTranslate(tmp, -px, -py);
                let rad = Math_toRadians(degrees);
                let cos = Math.cos(rad);
                let sin = Math.sin(rad);
                Matrix.multiply(tmp2, tmp, Matrix.getRotate_2(sin, cos));
                Matrix.multiply(tmp, tmp2, Matrix.getTranslate(px, py));
                return tmp;
            }
            static getSkew(kx, ky, px, py) {
                if (px == null || py == null) {
                    return [1, kx, 0, ky, 1, 0, 0, 0, 1];
                }
                let tmp = new Array(9);
                let tmp2 = new Array(9);
                this.setTranslate(tmp, -px, -py);
                Matrix.multiply(tmp2, tmp, [1, kx, 0, ky, 1, 0, 0, 0, 1]);
                Matrix.multiply(tmp, tmp2, Matrix.getTranslate(px, py));
                return tmp;
            }
            static reset(mtx) {
                for (let i = 0, k = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++, k++) {
                        mtx[k] = ((i == j) ? 1 : 0);
                    }
                }
            }
            computeTypeMask() {
                let mask = 0;
                if (this.mValues[6] != 0. || this.mValues[7] != 0. || this.mValues[8] != 1.) {
                    mask |= Matrix.kPerspective_Mask;
                }
                if (this.mValues[2] != 0. || this.mValues[5] != 0.) {
                    mask |= Matrix.kTranslate_Mask;
                }
                let m00 = this.mValues[0];
                let m01 = this.mValues[1];
                let m10 = this.mValues[3];
                let m11 = this.mValues[4];
                if (m01 != 0. || m10 != 0.) {
                    mask |= Matrix.kAffine_Mask;
                }
                if (m00 != 1. || m11 != 1.) {
                    mask |= Matrix.kScale_Mask;
                }
                if ((mask & Matrix.kPerspective_Mask) == 0) {
                    let im00 = m00 != 0 ? 1 : 0;
                    let im01 = m01 != 0 ? 1 : 0;
                    let im10 = m10 != 0 ? 1 : 0;
                    let im11 = m11 != 0 ? 1 : 0;
                    let dp0 = (im00 | im11) ^ 1;
                    let dp1 = im00 & im11;
                    let ds0 = (im01 | im10) ^ 1;
                    let ds1 = im01 & im10;
                    mask |= ((dp0 & ds1) | (dp1 & ds0)) << Matrix.kRectStaysRect_Shift;
                }
                return mask;
            }
        }
        Matrix.MSCALE_X = 0;
        Matrix.MSKEW_X = 1;
        Matrix.MTRANS_X = 2;
        Matrix.MSKEW_Y = 3;
        Matrix.MSCALE_Y = 4;
        Matrix.MTRANS_Y = 5;
        Matrix.MPERSP_0 = 6;
        Matrix.MPERSP_1 = 7;
        Matrix.MPERSP_2 = 8;
        Matrix.MATRIX_SIZE = 9;
        Matrix.IDENTITY_MATRIX = (() => {
            class _Inner extends Matrix {
                oops() {
                    throw Error(`new IllegalStateException("Matrix can not be modified")`);
                }
                set(src) {
                    this.oops();
                }
                reset() {
                    this.oops();
                }
                setTranslate(dx, dy) {
                    this.oops();
                }
                setScale(sx, sy, px, py) {
                    this.oops();
                }
                setRotate(degrees, px, py) {
                    this.oops();
                }
                setSinCos(sinValue, cosValue, px, py) {
                    this.oops();
                }
                setSkew(kx, ky, px, py) {
                    this.oops();
                }
                setConcat(a, b) {
                    this.oops();
                    return false;
                }
                preTranslate(dx, dy) {
                    this.oops();
                    return false;
                }
                preScale(sx, sy, px, py) {
                    this.oops();
                    return false;
                }
                preRotate(degrees, px, py) {
                    this.oops();
                    return false;
                }
                preSkew(kx, ky, px, py) {
                    this.oops();
                    return false;
                }
                preConcat(other) {
                    this.oops();
                    return false;
                }
                postTranslate(dx, dy) {
                    this.oops();
                    return false;
                }
                postScale(sx, sy, px, py) {
                    this.oops();
                    return false;
                }
                postRotate(degrees, px, py) {
                    this.oops();
                    return false;
                }
                postSkew(kx, ky, px, py) {
                    this.oops();
                    return false;
                }
                postConcat(other) {
                    this.oops();
                    return false;
                }
                setRectToRect(src, dst, stf) {
                    this.oops();
                    return false;
                }
                setPolyToPoly(src, srcIndex, dst, dstIndex, pointCount) {
                    this.oops();
                    return false;
                }
                setValues(values) {
                    this.oops();
                }
            }
            return new _Inner();
        })();
        Matrix.kIdentity_Mask = 0;
        Matrix.kTranslate_Mask = 0x01;
        Matrix.kScale_Mask = 0x02;
        Matrix.kAffine_Mask = 0x04;
        Matrix.kPerspective_Mask = 0x08;
        Matrix.kRectStaysRect_Mask = 0x10;
        Matrix.kUnknown_Mask = 0x80;
        Matrix.kAllMasks = Matrix.kTranslate_Mask | Matrix.kScale_Mask | Matrix.kAffine_Mask | Matrix.kPerspective_Mask | Matrix.kRectStaysRect_Mask;
        Matrix.kTranslate_Shift = 0;
        Matrix.kScale_Shift = 1;
        Matrix.kAffine_Shift = 2;
        Matrix.kPerspective_Shift = 3;
        Matrix.kRectStaysRect_Shift = 4;
        graphics.Matrix = Matrix;
        (function (Matrix) {
            (function (ScaleToFit) {
                ScaleToFit[ScaleToFit["FILL"] = 0] = "FILL";
                ScaleToFit[ScaleToFit["START"] = 1] = "START";
                ScaleToFit[ScaleToFit["CENTER"] = 2] = "CENTER";
                ScaleToFit[ScaleToFit["END"] = 3] = "END";
            })(Matrix.ScaleToFit || (Matrix.ScaleToFit = {}));
            var ScaleToFit = Matrix.ScaleToFit;
        })(Matrix = graphics.Matrix || (graphics.Matrix = {}));
        function Math_toRadians(angdeg) {
            return angdeg / 180.0 * Math.PI;
        }
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/12/11.
 */
var androidui;
(function (androidui) {
    var image;
    (function (image) {
        class NetImage {
            constructor(src, overrideImageRatio) {
                this.mImageWidth = 0;
                this.mImageHeight = 0;
                this.mOnLoads = new Set();
                this.mOnErrors = new Set();
                this.init(src);
                this.mOverrideImageRatio = overrideImageRatio;
            }
            init(src) {
                this.createImage();
                this.src = src;
            }
            createImage() {
                this.platformImage = new Image();
            }
            loadImage() {
                this.platformImage.src = this.mSrc;
                this.platformImage.onload = () => {
                    this.mImageWidth = this.platformImage.width;
                    this.mImageHeight = this.platformImage.height;
                    this.fireOnLoad();
                };
                this.platformImage.onerror = () => {
                    this.mImageWidth = this.mImageHeight = 0;
                    this.fireOnError();
                };
            }
            get src() {
                return this.mSrc;
            }
            set src(value) {
                value = convertToAbsUrl(value);
                if (value !== this.mSrc) {
                    this.mSrc = value;
                    this.loadImage();
                }
            }
            get width() {
                return this.mImageWidth;
            }
            get height() {
                return this.mImageHeight;
            }
            getImageRatio() {
                if (this.mOverrideImageRatio != null)
                    return this.mOverrideImageRatio;
                let url = this.src;
                if (!url)
                    return 1;
                if (url.startsWith('data:'))
                    return 1;
                let idx = url.lastIndexOf('.');
                if (idx > 0) {
                    url = url.substring(0, idx);
                }
                if (url.endsWith('@2x'))
                    return 2;
                if (url.endsWith('@3x'))
                    return 3;
                if (url.endsWith('@4x'))
                    return 4;
                if (url.endsWith('@5x'))
                    return 5;
                return 1;
            }
            fireOnLoad() {
                for (let load of this.mOnLoads) {
                    load();
                }
            }
            fireOnError() {
                for (let error of this.mOnErrors) {
                    error();
                }
            }
            addLoadListener(onload, onerror) {
                if (onload) {
                    this.mOnLoads.add(onload);
                }
                if (onerror) {
                    this.mOnErrors.add(onerror);
                }
            }
            removeLoadListener(onload, onerror) {
                if (onload) {
                    this.mOnLoads.delete(onload);
                }
                if (onerror) {
                    this.mOnErrors.delete(onerror);
                }
            }
            recycle() {
            }
        }
        image.NetImage = NetImage;
        let convertA = document.createElement('a');
        function convertToAbsUrl(url) {
            convertA.href = url;
            return convertA.href;
        }
    })(image = androidui.image || (androidui.image = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/10/13.
 */
///<reference path="../util/Pools.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="Rect.ts"/>
///<reference path="Color.ts"/>
///<reference path="Paint.ts"/>
///<reference path="Path.ts"/>
///<reference path="Matrix.ts"/>
///<reference path="../../androidui/image/NetImage.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var Pools = android.util.Pools;
        var Rect = android.graphics.Rect;
        var Color = android.graphics.Color;
        class Canvas {
            constructor(width, height) {
                this.mWidth = 0;
                this.mHeight = 0;
                this._saveCount = 0;
                this.mClipStateMap = new Map();
                this.mWidth = width;
                this.mHeight = height;
                this.mCurrentClip = Canvas.obtainRect();
                this.mCurrentClip.set(0, 0, this.mWidth, this.mHeight);
                this.initImpl();
            }
            static obtainRect(copy) {
                let rect = Canvas.sRectPool.acquire();
                if (!rect)
                    rect = new Rect();
                if (copy)
                    rect.set(copy);
                return rect;
            }
            static recycleRect(rect) {
                rect.setEmpty();
                Canvas.sRectPool.release(rect);
            }
            initImpl() {
                this.mCanvasElement = document.createElement("canvas");
                this.mCanvasElement.width = this.mWidth;
                this.mCanvasElement.height = this.mHeight;
                this._mCanvasContent = this.mCanvasElement.getContext("2d");
                this._saveCount = this.save();
            }
            recycle() {
                Canvas.recycleRect(this.mCurrentClip);
                for (let rect of this.mClipStateMap.values()) {
                    Canvas.recycleRect(rect);
                }
                this.recycleImpl();
            }
            recycleImpl() {
                if (this.mCanvasElement)
                    this.mCanvasElement.width = this.mCanvasElement.height = 0;
            }
            getHeight() {
                return this.mHeight;
            }
            getWidth() {
                return this.mWidth;
            }
            translate(dx, dy) {
                if (dx == 0 && dy == 0)
                    return;
                if (this.mCurrentClip)
                    this.mCurrentClip.offset(-dx, -dy);
                this.translateImpl(dx, dy);
            }
            translateImpl(dx, dy) {
                this._mCanvasContent.translate(dx, dy);
            }
            scale(sx, sy, px, py) {
                if (px || py)
                    this.translate(px, py);
                this.scaleImpl(sx, sy);
                if (px || py)
                    this.translate(-px, -py);
            }
            scaleImpl(sx, sy) {
                this._mCanvasContent.scale(sx, sy);
            }
            rotate(degrees, px, py) {
                if (px || py)
                    this.translate(px, py);
                this.rotateImpl(degrees);
                if (px || py)
                    this.translate(-px, -py);
            }
            rotateImpl(degrees) {
                this._mCanvasContent.rotate(degrees * Math.PI / 180);
            }
            concat(m) {
                let v = Canvas.TempMatrixValue;
                m.getValues(v);
                this.concatImpl(v[graphics.Matrix.MSCALE_X], v[graphics.Matrix.MSKEW_X], v[graphics.Matrix.MTRANS_X], v[graphics.Matrix.MSKEW_Y], v[graphics.Matrix.MSCALE_Y], v[graphics.Matrix.MTRANS_Y], v[graphics.Matrix.MPERSP_0], v[graphics.Matrix.MPERSP_1], v[graphics.Matrix.MPERSP_2]);
            }
            concatImpl(MSCALE_X, MSKEW_X, MTRANS_X, MSKEW_Y, MSCALE_Y, MTRANS_Y, MPERSP_0, MPERSP_1, MPERSP_2) {
                this._mCanvasContent.transform(MSCALE_X, -MSKEW_X, -MSKEW_Y, MSCALE_Y, MTRANS_X, MTRANS_Y);
            }
            drawRGB(r, g, b) {
                this.drawARGB(255, r, g, b);
            }
            drawARGB(a, r, g, b) {
                this.drawARGBImpl(a, r, g, b);
            }
            drawColor(color) {
                this.drawARGB(Color.alpha(color), Color.red(color), Color.green(color), Color.blue(color));
            }
            drawARGBImpl(a, r, g, b) {
                let preStyle = this._mCanvasContent.fillStyle;
                this._mCanvasContent.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
                this._mCanvasContent.fillRect(this.mCurrentClip.left, this.mCurrentClip.top, this.mCurrentClip.width(), this.mCurrentClip.height());
                this._mCanvasContent.fillStyle = preStyle;
            }
            clearColor() {
                this.clearRectImpl(this.mCurrentClip.left, this.mCurrentClip.top, this.mCurrentClip.width(), this.mCurrentClip.height());
            }
            clearRectImpl(left, top, width, height) {
                this._mCanvasContent.clearRect(left, top, width, height);
            }
            save() {
                this.saveImpl();
                if (this.mCurrentClip)
                    this.mClipStateMap.set(this._saveCount, Canvas.obtainRect(this.mCurrentClip));
                this._saveCount++;
                return this._saveCount;
            }
            saveImpl() {
                this._mCanvasContent.save();
            }
            restore() {
                this._saveCount--;
                this.restoreImpl();
                let savedClip = this.mClipStateMap.get(this._saveCount);
                if (savedClip) {
                    this.mClipStateMap.delete(this._saveCount);
                    this.mCurrentClip.set(savedClip);
                    Canvas.recycleRect(savedClip);
                }
            }
            restoreImpl() {
                this._mCanvasContent.restore();
            }
            restoreToCount(saveCount) {
                if (saveCount <= 0)
                    throw Error('saveCount can\'t <= 0');
                while (saveCount <= this._saveCount) {
                    this.restore();
                }
            }
            getSaveCount() {
                return this._saveCount;
            }
            clipRect(...args) {
                let rect = Canvas.obtainRect();
                if (args.length === 1) {
                    rect.set(args[0]);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    rect.set(left, t, right, bottom);
                }
                if (args.length === 8) {
                    this.clipRoundRectImpl(Math.floor(rect.left), Math.floor(rect.top), Math.ceil(rect.width()), Math.ceil(rect.height()), args[4], args[5], args[6], args[7]);
                }
                else {
                    this.clipRectImpl(Math.floor(rect.left), Math.floor(rect.top), Math.ceil(rect.width()), Math.ceil(rect.height()));
                }
                this.mCurrentClip.intersect(rect);
                let r = rect.isEmpty();
                Canvas.recycleRect(rect);
                return r;
            }
            clipRectImpl(left, top, width, height) {
                this._mCanvasContent.beginPath();
                this._mCanvasContent.rect(left, top, width, height);
                this._mCanvasContent.clip();
            }
            clipRoundRect(r, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft) {
                let rect = Canvas.obtainRect(r);
                this.clipRoundRectImpl(Math.floor(rect.left), Math.floor(rect.top), Math.ceil(rect.width()), Math.ceil(rect.height()), radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft);
                this.mCurrentClip.intersect(rect);
                let empty = rect.isEmpty();
                Canvas.recycleRect(rect);
                return empty;
            }
            clipRoundRectImpl(left, top, width, height, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft) {
                this.doRoundRectPath(left, top, width, height, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft);
                this._mCanvasContent.clip();
            }
            doRoundRectPath(left, top, width, height, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft) {
                let scale1 = height / (radiusTopLeft + radiusBottomLeft);
                let scale2 = height / (radiusTopRight + radiusBottomRight);
                let scale3 = width / (radiusTopLeft + radiusTopRight);
                let scale4 = width / (radiusBottomLeft + radiusBottomRight);
                let scale = Math.min(scale1, scale2, scale3, scale4);
                if (scale < 1) {
                    radiusTopLeft *= scale;
                    radiusTopRight *= scale;
                    radiusBottomRight *= scale;
                    radiusBottomLeft *= scale;
                }
                let ctx = this._mCanvasContent;
                ctx.beginPath();
                ctx.moveTo(left + radiusTopLeft, top);
                ctx.arcTo(left + width, top, left + width, top + radiusTopRight, radiusTopRight);
                ctx.arcTo(left + width, top + height, left + width - radiusBottomRight, top + height, radiusBottomRight);
                ctx.arcTo(left, top + height, left, top + height - radiusBottomLeft, radiusBottomLeft);
                ctx.arcTo(left, top, left + radiusTopLeft, top, radiusTopLeft);
                ctx.closePath();
            }
            getClipBounds(bounds) {
                if (!this.mCurrentClip)
                    this.mCurrentClip = Canvas.obtainRect();
                let rect = bounds || Canvas.obtainRect();
                rect.set(this.mCurrentClip);
                return rect;
            }
            quickReject(...args) {
                if (!this.mCurrentClip)
                    return false;
                if (args.length == 1) {
                    return !this.mCurrentClip.intersects(args[0]);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    return !this.mCurrentClip.intersects(left, t, right, bottom);
                }
            }
            drawCanvas(canvas, offsetX, offsetY) {
                this.drawCanvasImpl(canvas, offsetX, offsetY);
            }
            drawCanvasImpl(canvas, offsetX, offsetY) {
                this._mCanvasContent.drawImage(canvas.mCanvasElement, offsetX, offsetY);
            }
            drawImage(image, srcRect, dstRect, paint) {
                let paintEmpty = !paint || paint.isEmpty();
                if (!paintEmpty) {
                    this.saveImpl();
                    paint.applyToCanvas(this);
                }
                this.drawImageImpl(image, srcRect, dstRect);
                if (!paintEmpty)
                    this.restoreImpl();
            }
            drawImageImpl(image, srcRect, dstRect) {
                if (!dstRect) {
                    if (!srcRect) {
                        this._mCanvasContent.drawImage(image.platformImage, 0, 0);
                    }
                    else {
                        this._mCanvasContent.drawImage(image.platformImage, srcRect.left, srcRect.top, srcRect.width(), srcRect.height(), 0, 0, image.platformImage.width, image.platformImage.height);
                    }
                }
                else {
                    if (dstRect.isEmpty())
                        return;
                    if (!srcRect) {
                        this._mCanvasContent.drawImage(image.platformImage, dstRect.left, dstRect.top, dstRect.width(), dstRect.height());
                    }
                    else {
                        this._mCanvasContent.drawImage(image.platformImage, srcRect.left, srcRect.top, srcRect.width(), srcRect.height(), dstRect.left, dstRect.top, dstRect.width(), dstRect.height());
                    }
                }
            }
            drawRect(...args) {
                if (args.length == 2) {
                    let rect = args[0];
                    this.drawRect(rect.left, rect.top, rect.right, rect.bottom, args[1]);
                }
                else {
                    let [left, top, right, bottom, paint] = args;
                    let paintEmpty = !paint || paint.isEmpty();
                    if (!paintEmpty) {
                        this.saveImpl();
                        paint.applyToCanvas(this);
                    }
                    this.drawRectImpl(left, top, right - left, bottom - top, paint);
                    if (!paintEmpty)
                        this.restoreImpl();
                }
            }
            drawRectImpl(left, top, width, height, paint) {
                switch (paint.getStyle()) {
                    case graphics.Paint.Style.STROKE:
                        this._mCanvasContent.strokeRect(left, top, width, height);
                        break;
                    case graphics.Paint.Style.FILL_AND_STROKE:
                        this._mCanvasContent.fillRect(left, top, width, height);
                        this._mCanvasContent.strokeRect(left, top, width, height);
                        break;
                    case graphics.Paint.Style.FILL:
                    default:
                        this._mCanvasContent.fillRect(left, top, width, height);
                        break;
                }
            }
            applyFillOrStrokeToContent(style) {
                switch (style) {
                    case graphics.Paint.Style.STROKE:
                        this._mCanvasContent.stroke();
                        break;
                    case graphics.Paint.Style.FILL_AND_STROKE:
                        this._mCanvasContent.fill();
                        this._mCanvasContent.stroke();
                        break;
                    case graphics.Paint.Style.FILL:
                    default:
                        this._mCanvasContent.fill();
                        break;
                }
            }
            drawOval(oval, paint) {
                if (oval == null) {
                    throw Error(`new NullPointerException()`);
                }
                this.drawOvalImpl(oval, paint);
            }
            drawOvalImpl(oval, paint) {
                let paintEmpty = !paint || paint.isEmpty();
                if (!paintEmpty) {
                    this.saveImpl();
                    paint.applyToCanvas(this);
                }
                let ctx = this._mCanvasContent;
                ctx.beginPath();
                let cx = oval.centerX();
                let cy = oval.centerY();
                let rx = oval.width() / 2;
                let ry = oval.height() / 2;
                ctx.save();
                ctx.translate(cx - rx, cy - ry);
                ctx.scale(rx, ry);
                ctx.arc(1, 1, 1, 0, 2 * Math.PI, false);
                ctx.restore();
                this.applyFillOrStrokeToContent(paint.getStyle());
                if (!paintEmpty)
                    this.restoreImpl();
            }
            drawCircle(cx, cy, radius, paint) {
                this.drawCircleImpl(cx, cy, radius, paint);
            }
            drawCircleImpl(cx, cy, radius, paint) {
                let paintEmpty = !paint || paint.isEmpty();
                if (!paintEmpty) {
                    this.saveImpl();
                    paint.applyToCanvas(this);
                }
                let ctx = this._mCanvasContent;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, 2 * Math.PI, false);
                this.applyFillOrStrokeToContent(paint.getStyle());
                if (!paintEmpty)
                    this.restoreImpl();
            }
            drawArc(oval, startAngle, sweepAngle, useCenter, paint) {
                if (oval == null) {
                    throw Error(`new NullPointerException()`);
                }
                this.drawArcImpl(oval, startAngle, sweepAngle, useCenter, paint);
            }
            drawArcImpl(oval, startAngle, sweepAngle, useCenter, paint) {
                let paintEmpty = !paint || paint.isEmpty();
                if (!paintEmpty) {
                    this.saveImpl();
                    paint.applyToCanvas(this);
                }
                let ctx = this._mCanvasContent;
                ctx.save();
                ctx.beginPath();
                let cx = oval.centerX();
                let cy = oval.centerY();
                let rx = oval.width() / 2;
                let ry = oval.height() / 2;
                ctx.translate(cx - rx, cy - ry);
                ctx.scale(rx, ry);
                ctx.arc(1, 1, 1, startAngle / 180 * Math.PI, (sweepAngle + startAngle) / 180 * Math.PI, false);
                if (useCenter) {
                    ctx.lineTo(1, 1);
                    ctx.closePath();
                }
                ctx.restore();
                this.applyFillOrStrokeToContent(paint.getStyle());
                if (!paintEmpty)
                    this.restoreImpl();
            }
            drawRoundRect(rect, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft, paint) {
                if (rect == null) {
                    throw Error(`new NullPointerException()`);
                }
                this.drawRoundRectImpl(rect, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft, paint);
            }
            drawRoundRectImpl(rect, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft, paint) {
                let paintEmpty = !paint || paint.isEmpty();
                if (!paintEmpty) {
                    this.saveImpl();
                    paint.applyToCanvas(this);
                }
                this.doRoundRectPath(rect.left, rect.top, rect.width(), rect.height(), radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft);
                this.applyFillOrStrokeToContent(paint.getStyle());
                if (!paintEmpty)
                    this.restoreImpl();
            }
            drawPath(path, paint) {
            }
            drawText_count(text, index, count, x, y, paint) {
                if ((index | count | (index + count) | (text.length - index - count)) < 0) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                this.drawText(text.substr(index, count), x, y, paint);
            }
            drawText_end(text, start, end, x, y, paint) {
                if ((start | end | (end - start) | (text.length - end)) < 0) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                this.drawText(text.substring(start, end), x, y, paint);
            }
            drawText(text, x, y, paint) {
                let paintEmpty = !paint || paint.isEmpty();
                if (!paintEmpty) {
                    this.saveImpl();
                    paint.applyToCanvas(this);
                }
                this.drawTextImpl(text, x, y, paint ? paint.getStyle() : null);
                if (!paintEmpty)
                    this.restoreImpl();
            }
            drawTextImpl(text, x, y, style) {
                switch (style) {
                    case graphics.Paint.Style.STROKE:
                        this._mCanvasContent.strokeText(text, x, y);
                        break;
                    case graphics.Paint.Style.FILL_AND_STROKE:
                        this._mCanvasContent.strokeText(text, x, y);
                        this._mCanvasContent.fillText(text, x, y);
                        break;
                    case graphics.Paint.Style.FILL:
                    default:
                        this._mCanvasContent.fillText(text, x, y);
                        break;
                }
            }
            drawTextRun_count(text, index, count, contextIndex, contextCount, x, y, dir, paint) {
                this.drawText_count(text, index, count, x, y, paint);
            }
            drawTextRun_end(text, start, end, contextStart, contextEnd, x, y, dir, paint) {
                this.drawText_end(text, start, end, x, y, paint);
            }
            static measureText(text, textSize) {
                if (textSize == null || textSize === 0)
                    return 0;
                return Canvas.measureTextImpl(text, textSize);
            }
            static measureTextImpl(text, textSize) {
                let width = 0;
                for (let i = 0, length = text.length; i < length; i++) {
                    let c = text.charCodeAt(i);
                    let cWidth = Canvas._measureCacheMap.get(c);
                    if (cWidth == null) {
                        cWidth = Canvas._measureTextContext.measureText(text[i]).width;
                        Canvas._measureCacheMap.set(c, cWidth);
                    }
                    width += (cWidth * textSize / Canvas._measureCacheTextSize);
                }
                return width;
            }
            static getMeasureTextFontFamily() {
                let fontParts = Canvas._measureTextContext.font.split(' ');
                return fontParts[fontParts.length - 1];
            }
            setColor(color, style) {
                if (typeof color === 'number') {
                    this.setColorImpl(color, style);
                }
            }
            setColorImpl(color, style) {
                let colorS = Color.toRGBAFunc(color);
                switch (style) {
                    case graphics.Paint.Style.STROKE:
                        this._mCanvasContent.strokeStyle = colorS;
                        break;
                    case graphics.Paint.Style.FILL:
                        this._mCanvasContent.fillStyle = colorS;
                        break;
                    default:
                    case graphics.Paint.Style.FILL_AND_STROKE:
                        this._mCanvasContent.fillStyle = colorS;
                        this._mCanvasContent.strokeStyle = colorS;
                        break;
                }
            }
            multiplyAlpha(alpha) {
                if (typeof alpha === 'number') {
                    this.multiplyAlphaImpl(alpha);
                }
            }
            multiplyAlphaImpl(alpha) {
                this._mCanvasContent.globalAlpha *= alpha;
            }
            setAlpha(alpha) {
                if (typeof alpha === 'number') {
                    this.setAlphaImpl(alpha);
                }
            }
            setAlphaImpl(alpha) {
                this._mCanvasContent.globalAlpha = alpha;
            }
            setTextAlign(align) {
                if (align != null)
                    this.setTextAlignImpl(align);
            }
            setTextAlignImpl(align) {
                this._mCanvasContent.textAlign = align;
            }
            setLineWidth(width) {
                if (width != null)
                    this.setLineWidthImpl(width);
            }
            setLineWidthImpl(width) {
                this._mCanvasContent.lineWidth = width;
            }
            setLineCap(lineCap) {
                if (lineCap != null)
                    this.setLineCapImpl(lineCap);
            }
            setLineCapImpl(lineCap) {
                this._mCanvasContent.lineCap = lineCap;
            }
            setLineJoin(lineJoin) {
                if (lineJoin != null)
                    this.setLineJoinImpl(lineJoin);
            }
            setLineJoinImpl(lineJoin) {
                this._mCanvasContent.lineJoin = lineJoin;
            }
            setShadow(radius, dx, dy, color) {
                if (radius > 0) {
                    this.setShadowImpl(radius, dx, dy, color);
                }
            }
            setShadowImpl(radius, dx, dy, color) {
                this._mCanvasContent.shadowBlur = radius;
                this._mCanvasContent.shadowOffsetX = dx;
                this._mCanvasContent.shadowOffsetY = dy;
                this._mCanvasContent.shadowColor = Color.toRGBAFunc(color);
            }
            setFontSize(size) {
                if (typeof size === 'number') {
                    this.setFontSizeImpl(size);
                }
            }
            setFontSizeImpl(size) {
                const fontStyles = [];
                if (size != null) {
                    fontStyles.push(size + 'px');
                }
                if (fontStyles.length > 0) {
                    let cFont = this._mCanvasContent.font;
                    let fontParts = cFont.split(' ');
                    fontStyles.push(fontParts[fontParts.length - 1]);
                    let font = fontStyles.join(' ');
                    if (font != cFont)
                        this._mCanvasContent.font = font;
                }
            }
            setFont(fontName) {
                if (fontName != null) {
                    this.setFontImpl(fontName);
                }
            }
            setFontImpl(fontName) {
                let cFont = this._mCanvasContent.font;
                let fontParts = cFont.split(' ');
                fontParts[fontParts.length - 1] = fontName;
                let font = fontParts.join(' ');
                if (font != cFont)
                    this._mCanvasContent.font = font;
            }
        }
        Canvas.TempMatrixValue = new Array(9);
        Canvas.DIRECTION_LTR = 0;
        Canvas.DIRECTION_RTL = 1;
        Canvas.sRectPool = new Pools.SynchronizedPool(20);
        Canvas._measureTextContext = document.createElement('canvas').getContext('2d');
        Canvas._measureCacheTextSize = 1000;
        Canvas._static = (() => {
            Canvas._measureTextContext.font = Canvas._measureCacheTextSize + 'px ' + Canvas.getMeasureTextFontFamily();
        })();
        Canvas._measureCacheMap = new Map();
        graphics.Canvas = Canvas;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="../Rect.ts"/>
///<reference path="../PixelFormat.ts"/>
///<reference path="../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../util/StateSet.ts"/>
///<reference path="../Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Rect = android.graphics.Rect;
            var PixelFormat = android.graphics.PixelFormat;
            var WeakReference = java.lang.ref.WeakReference;
            var StateSet = android.util.StateSet;
            class Drawable {
                constructor() {
                    this.mBounds = Drawable.ZERO_BOUNDS_RECT;
                    this.mStateSet = StateSet.WILD_CARD;
                    this.mLevel = 0;
                    this.mVisible = true;
                }
                setBounds(...args) {
                    if (args.length === 1) {
                        let rect = args[0];
                        return this.setBounds(rect.left, rect.top, rect.right, rect.bottom);
                    }
                    else {
                        let [left = 0, top = 0, right = 0, bottom = 0] = args;
                        let oldBounds = this.mBounds;
                        if (oldBounds == Drawable.ZERO_BOUNDS_RECT) {
                            oldBounds = this.mBounds = new Rect();
                        }
                        if (oldBounds.left != left || oldBounds.top != top ||
                            oldBounds.right != right || oldBounds.bottom != bottom) {
                            if (!oldBounds.isEmpty()) {
                                this.invalidateSelf();
                            }
                            this.mBounds.set(left, top, right, bottom);
                            this.onBoundsChange(this.mBounds);
                        }
                    }
                }
                copyBounds(bounds = new Rect()) {
                    bounds.set(this.mBounds);
                    return bounds;
                }
                getBounds() {
                    if (this.mBounds == Drawable.ZERO_BOUNDS_RECT) {
                        this.mBounds = new Rect();
                    }
                    return this.mBounds;
                }
                setDither(dither) { }
                setCallback(cb) {
                    this.mCallback = new WeakReference(cb);
                }
                getCallback() {
                    if (this.mCallback != null) {
                        return this.mCallback.get();
                    }
                    return null;
                }
                notifySizeChangeSelf() {
                    let callback = this.getCallback();
                    if (callback != null && callback.drawableSizeChange) {
                        callback.drawableSizeChange(this);
                    }
                }
                invalidateSelf() {
                    let callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleSelf(what, when) {
                    let callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleSelf(what) {
                    let callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                getAlpha() {
                    return 0xFF;
                }
                isStateful() {
                    return false;
                }
                setState(stateSet) {
                    if (this.mStateSet + '' !== stateSet + '') {
                        this.mStateSet = stateSet;
                        return this.onStateChange(stateSet);
                    }
                    return false;
                }
                getState() {
                    return this.mStateSet;
                }
                jumpToCurrentState() {
                }
                getCurrent() {
                    return this;
                }
                setLevel(level) {
                    if (this.mLevel != level) {
                        this.mLevel = level;
                        return this.onLevelChange(level);
                    }
                    return false;
                }
                getLevel() {
                    return this.mLevel;
                }
                setVisible(visible, restart) {
                    let changed = this.mVisible != visible;
                    if (changed) {
                        this.mVisible = visible;
                        this.invalidateSelf();
                    }
                    return changed;
                }
                isVisible() {
                    return this.mVisible;
                }
                setAutoMirrored(mirrored) {
                }
                isAutoMirrored() {
                    return false;
                }
                getOpacity() {
                    return PixelFormat.TRANSLUCENT;
                }
                static resolveOpacity(op1, op2) {
                    if (op1 == op2) {
                        return op1;
                    }
                    if (op1 == PixelFormat.UNKNOWN || op2 == PixelFormat.UNKNOWN) {
                        return PixelFormat.UNKNOWN;
                    }
                    if (op1 == PixelFormat.TRANSLUCENT || op2 == PixelFormat.TRANSLUCENT) {
                        return PixelFormat.TRANSLUCENT;
                    }
                    if (op1 == PixelFormat.TRANSPARENT || op2 == PixelFormat.TRANSPARENT) {
                        return PixelFormat.TRANSPARENT;
                    }
                    return PixelFormat.OPAQUE;
                }
                onStateChange(state) {
                    return false;
                }
                onLevelChange(level) {
                    return false;
                }
                onBoundsChange(bounds) {
                }
                getIntrinsicWidth() {
                    return -1;
                }
                getIntrinsicHeight() {
                    return -1;
                }
                getMinimumWidth() {
                    let intrinsicWidth = this.getIntrinsicWidth();
                    return intrinsicWidth > 0 ? intrinsicWidth : 0;
                }
                getMinimumHeight() {
                    let intrinsicHeight = this.getIntrinsicHeight();
                    return intrinsicHeight > 0 ? intrinsicHeight : 0;
                }
                getPadding(padding) {
                    padding.set(0, 0, 0, 0);
                    return false;
                }
                mutate() {
                    return this;
                }
                getConstantState() {
                    return null;
                }
            }
            Drawable.ZERO_BOUNDS_RECT = new Rect();
            drawable.Drawable = Drawable;
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
///<reference path="../Paint.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            class ColorDrawable extends drawable.Drawable {
                constructor(color) {
                    super();
                    this.mMutated = false;
                    this.mPaint = new graphics.Paint();
                    this.mState = new ColorState();
                    if (color !== undefined) {
                        this.setColor(color);
                    }
                }
                _setStateCopyFrom(state) {
                    this.mState = new ColorState(state);
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mState = new ColorState(this.mState);
                        this.mMutated = true;
                    }
                    return this;
                }
                draw(canvas) {
                    if ((this.mState.mUseColor >>> 24) != 0) {
                        this.mPaint.setColor(this.mState.mUseColor);
                        canvas.drawRect(this.getBounds(), this.mPaint);
                    }
                }
                getColor() {
                    return this.mState.mUseColor;
                }
                setColor(color) {
                    if (this.mState.mBaseColor != color || this.mState.mUseColor != color) {
                        this.invalidateSelf();
                        this.mState.mBaseColor = this.mState.mUseColor = color;
                    }
                }
                getAlpha() {
                    return this.mState.mUseColor >>> 24;
                }
                setAlpha(alpha) {
                    alpha += alpha >> 7;
                    let baseAlpha = this.mState.mBaseColor >>> 24;
                    let useAlpha = baseAlpha * alpha >> 8;
                    let oldUseColor = this.mState.mUseColor;
                    this.mState.mUseColor = (this.mState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
                    if (oldUseColor != this.mState.mUseColor) {
                        this.invalidateSelf();
                    }
                }
                getOpacity() {
                    switch (this.mState.mUseColor >>> 24) {
                        case 255:
                            return graphics.PixelFormat.OPAQUE;
                        case 0:
                            return graphics.PixelFormat.TRANSPARENT;
                    }
                    return graphics.PixelFormat.TRANSLUCENT;
                }
                getConstantState() {
                    return this.mState;
                }
            }
            drawable.ColorDrawable = ColorDrawable;
            class ColorState {
                constructor(state) {
                    this.mBaseColor = 0;
                    this.mUseColor = 0;
                    if (state != null) {
                        this.mBaseColor = state.mBaseColor;
                        this.mUseColor = state.mUseColor;
                    }
                }
                newDrawable() {
                    let c = new ColorDrawable();
                    c._setStateCopyFrom(this);
                    return c;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/30.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Drawable = android.graphics.drawable.Drawable;
            class ScrollBarDrawable extends Drawable {
                constructor(...args) {
                    super(...args);
                    this.mRange = 0;
                    this.mOffset = 0;
                    this.mExtent = 0;
                    this.mVertical = false;
                    this.mChanged = false;
                    this.mRangeChanged = false;
                    this.mTempBounds = new graphics.Rect();
                    this.mAlwaysDrawHorizontalTrack = false;
                    this.mAlwaysDrawVerticalTrack = false;
                }
                setAlwaysDrawHorizontalTrack(alwaysDrawTrack) {
                    this.mAlwaysDrawHorizontalTrack = alwaysDrawTrack;
                }
                setAlwaysDrawVerticalTrack(alwaysDrawTrack) {
                    this.mAlwaysDrawVerticalTrack = alwaysDrawTrack;
                }
                getAlwaysDrawVerticalTrack() {
                    return this.mAlwaysDrawVerticalTrack;
                }
                getAlwaysDrawHorizontalTrack() {
                    return this.mAlwaysDrawHorizontalTrack;
                }
                setParameters(range, offset, extent, vertical) {
                    if (this.mVertical != vertical) {
                        this.mChanged = true;
                    }
                    if (this.mRange != range || this.mOffset != offset || this.mExtent != extent) {
                        this.mRangeChanged = true;
                    }
                    this.mRange = range;
                    this.mOffset = offset;
                    this.mExtent = extent;
                    this.mVertical = vertical;
                }
                draw(canvas) {
                    const vertical = this.mVertical;
                    const extent = this.mExtent;
                    const range = this.mRange;
                    let drawTrack = true;
                    let drawThumb = true;
                    if (extent <= 0 || range <= extent) {
                        drawTrack = vertical ? this.mAlwaysDrawVerticalTrack : this.mAlwaysDrawHorizontalTrack;
                        drawThumb = false;
                    }
                    let r = this.getBounds();
                    if (drawTrack) {
                        this.drawTrack(canvas, r, vertical);
                    }
                    if (drawThumb) {
                        let size = vertical ? r.height() : r.width();
                        let thickness = vertical ? r.width() : r.height();
                        let length = Math.round(size * extent / range);
                        let offset = Math.round((size - length) * this.mOffset / (range - extent));
                        let minLength = thickness * 2;
                        if (length < minLength) {
                            length = minLength;
                        }
                        if (offset + length > size) {
                            offset = size - length;
                        }
                        this.drawThumb(canvas, r, offset, length, vertical);
                    }
                }
                onBoundsChange(bounds) {
                    super.onBoundsChange(bounds);
                    this.mChanged = true;
                }
                drawTrack(canvas, bounds, vertical) {
                    let track;
                    if (vertical) {
                        track = this.mVerticalTrack;
                    }
                    else {
                        track = this.mHorizontalTrack;
                    }
                    if (track != null) {
                        if (this.mChanged) {
                            track.setBounds(bounds);
                        }
                        track.draw(canvas);
                    }
                }
                drawThumb(canvas, bounds, offset, length, vertical) {
                    const thumbRect = this.mTempBounds;
                    const changed = this.mRangeChanged || this.mChanged;
                    if (changed) {
                        if (vertical) {
                            thumbRect.set(bounds.left, bounds.top + offset, bounds.right, bounds.top + offset + length);
                        }
                        else {
                            thumbRect.set(bounds.left + offset, bounds.top, bounds.left + offset + length, bounds.bottom);
                        }
                    }
                    if (vertical) {
                        const thumb = this.mVerticalThumb;
                        if (changed)
                            thumb.setBounds(thumbRect);
                        thumb.draw(canvas);
                    }
                    else {
                        const thumb = this.mHorizontalThumb;
                        if (changed)
                            thumb.setBounds(thumbRect);
                        thumb.draw(canvas);
                    }
                }
                setVerticalThumbDrawable(thumb) {
                    if (thumb != null) {
                        this.mVerticalThumb = thumb;
                    }
                }
                setVerticalTrackDrawable(track) {
                    this.mVerticalTrack = track;
                }
                setHorizontalThumbDrawable(thumb) {
                    if (thumb != null) {
                        this.mHorizontalThumb = thumb;
                    }
                }
                setHorizontalTrackDrawable(track) {
                    this.mHorizontalTrack = track;
                }
                getSize(vertical) {
                    if (vertical) {
                        return (this.mVerticalTrack != null ?
                            this.mVerticalTrack : this.mVerticalThumb).getIntrinsicWidth();
                    }
                    else {
                        return (this.mHorizontalTrack != null ?
                            this.mHorizontalTrack : this.mHorizontalThumb).getIntrinsicHeight();
                    }
                }
                setAlpha(alpha) {
                    if (this.mVerticalTrack != null) {
                        this.mVerticalTrack.setAlpha(alpha);
                    }
                    this.mVerticalThumb.setAlpha(alpha);
                    if (this.mHorizontalTrack != null) {
                        this.mHorizontalTrack.setAlpha(alpha);
                    }
                    this.mHorizontalThumb.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mVerticalThumb.getAlpha();
                }
                getOpacity() {
                    return graphics.PixelFormat.TRANSLUCENT;
                }
                toString() {
                    return "ScrollBarDrawable: range=" + this.mRange + " offset=" + this.mOffset +
                        " extent=" + this.mExtent + (this.mVertical ? " V" : " H");
                }
            }
            drawable.ScrollBarDrawable = ScrollBarDrawable;
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_1) {
            class InsetDrawable extends drawable_1.Drawable {
                constructor(drawable, insetLeft, insetTop = insetLeft, insetRight = insetTop, insetBottom = insetRight) {
                    super();
                    this.mTmpRect = new graphics.Rect();
                    this.mMutated = false;
                    this.mInsetState = new InsetState(null, this);
                    this.mInsetState.mDrawable = drawable;
                    this.mInsetState.mInsetLeft = insetLeft;
                    this.mInsetState.mInsetTop = insetTop;
                    this.mInsetState.mInsetRight = insetRight;
                    this.mInsetState.mInsetBottom = insetBottom;
                    if (drawable != null) {
                        drawable.setCallback(this);
                    }
                }
                drawableSizeChange(who) {
                    const callback = this.getCallback();
                    if (callback != null && callback.drawableSizeChange) {
                        callback.drawableSizeChange(this);
                    }
                }
                invalidateDrawable(who) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                draw(canvas) {
                    this.mInsetState.mDrawable.draw(canvas);
                }
                getPadding(padding) {
                    let pad = this.mInsetState.mDrawable.getPadding(padding);
                    padding.left += this.mInsetState.mInsetLeft;
                    padding.right += this.mInsetState.mInsetRight;
                    padding.top += this.mInsetState.mInsetTop;
                    padding.bottom += this.mInsetState.mInsetBottom;
                    if (pad || (this.mInsetState.mInsetLeft | this.mInsetState.mInsetRight |
                        this.mInsetState.mInsetTop | this.mInsetState.mInsetBottom) != 0) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                setVisible(visible, restart) {
                    this.mInsetState.mDrawable.setVisible(visible, restart);
                    return super.setVisible(visible, restart);
                }
                setAlpha(alpha) {
                    this.mInsetState.mDrawable.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mInsetState.mDrawable.getAlpha();
                }
                getOpacity() {
                    return this.mInsetState.mDrawable.getOpacity();
                }
                isStateful() {
                    return this.mInsetState.mDrawable.isStateful();
                }
                onStateChange(state) {
                    let changed = this.mInsetState.mDrawable.setState(state);
                    this.onBoundsChange(this.getBounds());
                    return changed;
                }
                onBoundsChange(bounds) {
                    const r = this.mTmpRect;
                    r.set(bounds);
                    r.left += this.mInsetState.mInsetLeft;
                    r.top += this.mInsetState.mInsetTop;
                    r.right -= this.mInsetState.mInsetRight;
                    r.bottom -= this.mInsetState.mInsetBottom;
                    this.mInsetState.mDrawable.setBounds(r.left, r.top, r.right, r.bottom);
                }
                getIntrinsicWidth() {
                    return this.mInsetState.mDrawable.getIntrinsicWidth();
                }
                getIntrinsicHeight() {
                    return this.mInsetState.mDrawable.getIntrinsicHeight();
                }
                getConstantState() {
                    if (this.mInsetState.canConstantState()) {
                        return this.mInsetState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mInsetState.mDrawable.mutate();
                        this.mMutated = true;
                    }
                    return this;
                }
                getDrawable() {
                    return this.mInsetState.mDrawable;
                }
            }
            drawable_1.InsetDrawable = InsetDrawable;
            class InsetState {
                constructor(orig, owner) {
                    this.mInsetLeft = 0;
                    this.mInsetTop = 0;
                    this.mInsetRight = 0;
                    this.mInsetBottom = 0;
                    if (orig != null) {
                        this.mDrawable = orig.mDrawable.getConstantState().newDrawable();
                        this.mDrawable.setCallback(owner);
                        this.mInsetLeft = orig.mInsetLeft;
                        this.mInsetTop = orig.mInsetTop;
                        this.mInsetRight = orig.mInsetRight;
                        this.mInsetBottom = orig.mInsetBottom;
                        this.mCheckedConstantState = this.mCanConstantState = true;
                    }
                }
                newDrawable() {
                    let drawable = new InsetDrawable(null, 0);
                    drawable.mInsetState = new InsetState(this, drawable);
                    return drawable;
                }
                canConstantState() {
                    if (!this.mCheckedConstantState) {
                        this.mCanConstantState = this.mDrawable.getConstantState() != null;
                        this.mCheckedConstantState = true;
                    }
                    return this.mCanConstantState;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 16/1/13.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
///<reference path="../Paint.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_2) {
            class ShadowDrawable extends drawable_2.Drawable {
                constructor(drawable, radius, dx, dy, color) {
                    super();
                    this.mMutated = false;
                    this.mState = new DrawableState(null, this);
                    this.mState.mDrawable = drawable;
                    this.mState.shadowDx = dx;
                    this.mState.shadowDy = dy;
                    this.mState.shadowRadius = radius;
                    this.mState.shadowColor = color;
                    if (drawable != null) {
                        drawable.setCallback(this);
                    }
                }
                setShadow(radius, dx, dy, color) {
                    this.mState.shadowDx = dx;
                    this.mState.shadowDy = dy;
                    this.mState.shadowRadius = radius;
                    this.mState.shadowColor = color;
                }
                drawableSizeChange(who) {
                    const callback = this.getCallback();
                    if (callback != null && callback.drawableSizeChange) {
                        callback.drawableSizeChange(this);
                    }
                }
                invalidateDrawable(who) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                draw(canvas) {
                    if (!this.mState.shadowRadius || graphics.Color.alpha(this.mState.shadowColor) === 0) {
                        this.mState.mDrawable.draw(canvas);
                        return;
                    }
                    let saveCount = canvas.save();
                    canvas.setShadow(this.mState.shadowRadius, this.mState.shadowDx, this.mState.shadowDy, this.mState.shadowColor);
                    this.mState.mDrawable.draw(canvas);
                    canvas.restoreToCount(saveCount);
                }
                getPadding(padding) {
                    return this.mState.mDrawable.getPadding(padding);
                }
                setVisible(visible, restart) {
                    this.mState.mDrawable.setVisible(visible, restart);
                    return super.setVisible(visible, restart);
                }
                setAlpha(alpha) {
                    this.mState.mDrawable.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mState.mDrawable.getAlpha();
                }
                getOpacity() {
                    return graphics.PixelFormat.TRANSPARENT;
                }
                isStateful() {
                    return this.mState.mDrawable.isStateful();
                }
                onStateChange(state) {
                    let changed = this.mState.mDrawable.setState(state);
                    this.onBoundsChange(this.getBounds());
                    return changed;
                }
                onBoundsChange(bounds) {
                    this.mState.mDrawable.setBounds(bounds.left, bounds.top, bounds.right, bounds.bottom);
                }
                getIntrinsicWidth() {
                    return this.mState.mDrawable.getIntrinsicWidth();
                }
                getIntrinsicHeight() {
                    return this.mState.mDrawable.getIntrinsicHeight();
                }
                getConstantState() {
                    if (this.mState.canConstantState()) {
                        return this.mState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mState.mDrawable.mutate();
                        this.mMutated = true;
                    }
                    return this;
                }
                getDrawable() {
                    return this.mState.mDrawable;
                }
            }
            drawable_2.ShadowDrawable = ShadowDrawable;
            class DrawableState {
                constructor(orig, owner) {
                    this.shadowDx = 0;
                    this.shadowDy = 0;
                    this.shadowRadius = 0;
                    this.shadowColor = 0;
                    if (orig != null) {
                        this.mDrawable = orig.mDrawable.getConstantState().newDrawable();
                        this.mDrawable.setCallback(owner);
                        this.shadowDx = orig.shadowDx;
                        this.shadowDy = orig.shadowDy;
                        this.shadowRadius = orig.shadowRadius;
                        this.shadowColor = orig.shadowColor;
                    }
                }
                newDrawable() {
                    let drawable = new ShadowDrawable(null, 0, 0, 0, 0);
                    drawable.mState = new DrawableState(this, drawable);
                    return drawable;
                }
                canConstantState() {
                    if (!this.mCheckedConstantState) {
                        this.mCanConstantState = this.mDrawable.getConstantState() != null;
                        this.mCheckedConstantState = true;
                    }
                    return this.mCanConstantState;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
///<reference path="../Paint.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            class RoundRectDrawable extends drawable.Drawable {
                constructor(color, radiusTopLeft, radiusTopRight = radiusTopLeft, radiusBottomRight = radiusTopRight, radiusBottomLeft = radiusBottomRight) {
                    super();
                    this.mMutated = false;
                    this.mPaint = new graphics.Paint();
                    this.mState = new State();
                    this.setColor(color);
                    this.mState.mRadiusTopLeft = radiusTopLeft;
                    this.mState.mRadiusTopRight = radiusTopRight;
                    this.mState.mRadiusBottomRight = radiusBottomRight;
                    this.mState.mRadiusBottomLeft = radiusBottomLeft;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mState = new State(this.mState);
                        this.mMutated = true;
                    }
                    return this;
                }
                draw(canvas) {
                    if ((this.mState.mUseColor >>> 24) != 0) {
                        this.mPaint.setColor(this.mState.mUseColor);
                        canvas.drawRoundRect(this.getBounds(), this.mState.mRadiusTopLeft, this.mState.mRadiusTopRight, this.mState.mRadiusBottomRight, this.mState.mRadiusBottomLeft, this.mPaint);
                    }
                }
                getColor() {
                    return this.mState.mUseColor;
                }
                setColor(color) {
                    if (this.mState.mBaseColor != color || this.mState.mUseColor != color) {
                        this.invalidateSelf();
                        this.mState.mBaseColor = this.mState.mUseColor = color;
                    }
                }
                getAlpha() {
                    return this.mState.mUseColor >>> 24;
                }
                setAlpha(alpha) {
                    alpha += alpha >> 7;
                    let baseAlpha = this.mState.mBaseColor >>> 24;
                    let useAlpha = baseAlpha * alpha >> 8;
                    let oldUseColor = this.mState.mUseColor;
                    this.mState.mUseColor = (this.mState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
                    if (oldUseColor != this.mState.mUseColor) {
                        this.invalidateSelf();
                    }
                }
                getOpacity() {
                    switch (this.mState.mUseColor >>> 24) {
                        case 255:
                            return graphics.PixelFormat.OPAQUE;
                        case 0:
                            return graphics.PixelFormat.TRANSPARENT;
                    }
                    return graphics.PixelFormat.TRANSLUCENT;
                }
                getConstantState() {
                    return this.mState;
                }
            }
            drawable.RoundRectDrawable = RoundRectDrawable;
            class State {
                constructor(state) {
                    this.mBaseColor = 0;
                    this.mUseColor = 0;
                    this.mRadiusTopLeft = 0;
                    this.mRadiusTopRight = 0;
                    this.mRadiusBottomRight = 0;
                    this.mRadiusBottomLeft = 0;
                    if (state != null) {
                        this.mBaseColor = state.mBaseColor;
                        this.mUseColor = state.mUseColor;
                        this.mRadiusTopLeft = state.mRadiusTopLeft;
                        this.mRadiusTopRight = state.mRadiusTopRight;
                        this.mRadiusBottomRight = state.mRadiusBottomRight;
                        this.mRadiusBottomLeft = state.mRadiusBottomLeft;
                    }
                }
                newDrawable() {
                    let c = new RoundRectDrawable(0, 0, 0, 0, 0);
                    c.mState = new State(this);
                    return c;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        let hashCodeGenerator = 0;
        class JavaObject {
            constructor() {
                this.hash = hashCodeGenerator++;
                this._class = new Class(this.constructor.name);
            }
            static get class() {
                return new Class(this.name);
            }
            hashCode() {
                return this.hash;
            }
            getClass() {
                return this._class;
            }
            equals(o) {
                return this === o;
            }
        }
        lang.JavaObject = JavaObject;
        class Class {
            constructor(name) {
                this.name = name;
            }
            getName() {
                return this.name;
            }
            getSimpleName() {
                return this.name;
            }
        }
        lang.Class = Class;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        var util;
        (function (util) {
            var concurrent;
            (function (concurrent) {
                class CopyOnWriteArrayList {
                    constructor() {
                        this.mData = [];
                        this.isDataNew = true;
                    }
                    iterator() {
                        this.isDataNew = false;
                        return this.mData;
                    }
                    [Symbol.iterator]() {
                        this.isDataNew = false;
                        return this.mData[Symbol.iterator]();
                    }
                    checkNewData() {
                        if (!this.isDataNew) {
                            this.isDataNew = true;
                            this.mData = [...this.mData];
                        }
                    }
                    size() {
                        return this.mData.length;
                    }
                    add(...items) {
                        this.checkNewData();
                        this.mData.push(...items);
                    }
                    addAll(array) {
                        this.checkNewData();
                        this.mData.push(...array.mData);
                    }
                    remove(item) {
                        this.checkNewData();
                        this.mData.splice(this.mData.indexOf(item), 1);
                    }
                }
                concurrent.CopyOnWriteArrayList = CopyOnWriteArrayList;
            })(concurrent = util.concurrent || (util.concurrent = {}));
        })(util = lang.util || (lang.util = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class Access {
            get(index) {
                return this.mData[index];
            }
            size() {
                return this.mSize;
            }
        }
        class CopyOnWriteArray {
            constructor() {
                this.mData = [];
                this.mAccess = new Access();
            }
            getArray() {
                if (this.mStart) {
                    if (this.mDataCopy == null)
                        this.mDataCopy = [...this.mData];
                    return this.mDataCopy;
                }
                return this.mData;
            }
            start() {
                if (this.mStart)
                    throw new Error("Iteration already started");
                this.mStart = true;
                this.mDataCopy = null;
                this.mAccess.mData = this.mData;
                this.mAccess.mSize = this.mData.length;
                return this.mAccess.mData;
            }
            end() {
                if (!this.mStart)
                    throw new Error("Iteration not started");
                this.mStart = false;
                if (this.mDataCopy != null) {
                    this.mData = this.mDataCopy;
                    this.mAccess.mData = [];
                    this.mAccess.mSize = 0;
                }
                this.mDataCopy = null;
            }
            size() {
                return this.getArray().length;
            }
            add(...items) {
                this.getArray().push(...items);
            }
            addAll(array) {
                this.getArray().push(...array.mData);
            }
            remove(item) {
                this.getArray().splice(this.getArray().indexOf(item), 1);
            }
        }
        util.CopyOnWriteArray = CopyOnWriteArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/8.
 */
///<reference path="../../java/lang/util/concurrent/CopyOnWriteArrayList.ts"/>
///<reference path="../util/CopyOnWriteArray.ts"/>
///<reference path="../view/View.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var CopyOnWriteArrayList = java.lang.util.concurrent.CopyOnWriteArrayList;
        var CopyOnWriteArray = android.util.CopyOnWriteArray;
        class ViewTreeObserver {
            constructor() {
                this.mAlive = true;
            }
            addOnGlobalLayoutListener(listener) {
                this.checkIsAlive();
                if (this.mOnGlobalLayoutListeners == null) {
                    this.mOnGlobalLayoutListeners = new CopyOnWriteArray();
                }
                this.mOnGlobalLayoutListeners.add(listener);
            }
            removeGlobalOnLayoutListener(victim) {
                this.removeOnGlobalLayoutListener(victim);
            }
            removeOnGlobalLayoutListener(victim) {
                this.checkIsAlive();
                if (this.mOnGlobalLayoutListeners == null) {
                    return;
                }
                this.mOnGlobalLayoutListeners.remove(victim);
            }
            dispatchOnGlobalLayout() {
                let listeners = this.mOnGlobalLayoutListeners;
                if (listeners != null && listeners.size() > 0) {
                    let access = listeners.start();
                    try {
                        let count = access.length;
                        for (let i = 0; i < count; i++) {
                            access[i].onGlobalLayout();
                        }
                    }
                    finally {
                        listeners.end();
                    }
                }
            }
            addOnPreDrawListener(listener) {
                this.checkIsAlive();
                if (this.mOnPreDrawListeners == null) {
                    this.mOnPreDrawListeners = new CopyOnWriteArray();
                }
                this.mOnPreDrawListeners.add(listener);
            }
            removeOnPreDrawListener(victim) {
                this.checkIsAlive();
                if (this.mOnPreDrawListeners == null) {
                    return;
                }
                this.mOnPreDrawListeners.remove(victim);
            }
            dispatchOnPreDraw() {
                let cancelDraw = false;
                const listeners = this.mOnPreDrawListeners;
                if (listeners != null && listeners.size() > 0) {
                    let access = listeners.start();
                    try {
                        let count = access.length;
                        for (let i = 0; i < count; i++) {
                            cancelDraw = cancelDraw || !(access[i].onPreDraw());
                        }
                    }
                    finally {
                        listeners.end();
                    }
                }
                return cancelDraw;
            }
            addOnTouchModeChangeListener(listener) {
                this.checkIsAlive();
                if (this.mOnTouchModeChangeListeners == null) {
                    this.mOnTouchModeChangeListeners = new CopyOnWriteArrayList();
                }
                this.mOnTouchModeChangeListeners.add(listener);
            }
            removeOnTouchModeChangeListener(victim) {
                this.checkIsAlive();
                if (this.mOnTouchModeChangeListeners == null) {
                    return;
                }
                this.mOnTouchModeChangeListeners.remove(victim);
            }
            dispatchOnTouchModeChanged(inTouchMode) {
                const listeners = this.mOnTouchModeChangeListeners;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onTouchModeChanged(inTouchMode);
                    }
                }
            }
            addOnScrollChangedListener(listener) {
                this.checkIsAlive();
                if (this.mOnScrollChangedListeners == null) {
                    this.mOnScrollChangedListeners = new CopyOnWriteArray();
                }
                this.mOnScrollChangedListeners.add(listener);
            }
            removeOnScrollChangedListener(victim) {
                this.checkIsAlive();
                if (this.mOnScrollChangedListeners == null) {
                    return;
                }
                this.mOnScrollChangedListeners.remove(victim);
            }
            dispatchOnScrollChanged() {
                let listeners = this.mOnScrollChangedListeners;
                if (listeners != null && listeners.size() > 0) {
                    let access = listeners.start();
                    try {
                        let count = access.length;
                        for (let i = 0; i < count; i++) {
                            access[i].onScrollChanged();
                        }
                    }
                    finally {
                        listeners.end();
                    }
                }
            }
            addOnDrawListener(listener) {
                this.checkIsAlive();
                if (this.mOnDrawListeners == null) {
                    this.mOnDrawListeners = new CopyOnWriteArrayList();
                }
                this.mOnDrawListeners.add(listener);
            }
            removeOnDrawListener(victim) {
                this.checkIsAlive();
                if (this.mOnDrawListeners == null) {
                    return;
                }
                this.mOnDrawListeners.remove(victim);
            }
            dispatchOnDraw() {
                if (this.mOnDrawListeners != null) {
                    for (let listener of this.mOnDrawListeners) {
                        listener.onDraw();
                    }
                }
            }
            merge(observer) {
                //if (observer.mOnWindowAttachListeners != null) {
                //    if (this.mOnWindowAttachListeners != null) {
                //        this.mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
                //    } else {
                //        this.mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
                //    }
                //}
                if (observer.mOnGlobalLayoutListeners != null) {
                    if (this.mOnGlobalLayoutListeners != null) {
                        this.mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
                    }
                    else {
                        this.mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
                    }
                }
                if (observer.mOnPreDrawListeners != null) {
                    if (this.mOnPreDrawListeners != null) {
                        this.mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
                    }
                    else {
                        this.mOnPreDrawListeners = observer.mOnPreDrawListeners;
                    }
                }
                if (observer.mOnScrollChangedListeners != null) {
                    if (this.mOnScrollChangedListeners != null) {
                        this.mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
                    }
                    else {
                        this.mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
                    }
                }
                observer.kill();
            }
            checkIsAlive() {
                if (!this.mAlive) {
                    throw new Error("This ViewTreeObserver is not alive, call "
                        + "getViewTreeObserver() again");
                }
            }
            isAlive() {
                return this.mAlive;
            }
            kill() {
                this.mAlive = false;
            }
        }
        view.ViewTreeObserver = ViewTreeObserver;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class DisplayMetrics {
        }
        DisplayMetrics.DENSITY_LOW = 120;
        DisplayMetrics.DENSITY_MEDIUM = 160;
        DisplayMetrics.DENSITY_HIGH = 240;
        DisplayMetrics.DENSITY_XHIGH = 320;
        DisplayMetrics.DENSITY_XXHIGH = 480;
        DisplayMetrics.DENSITY_XXXHIGH = 640;
        DisplayMetrics.DENSITY_DEFAULT = DisplayMetrics.DENSITY_MEDIUM;
        util.DisplayMetrics = DisplayMetrics;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 16/1/4.
 * lite impl of Android Intent. Only use for startActivity
 */
///<reference path="../os/Bundle.ts"/>
var android;
(function (android) {
    var content;
    (function (content) {
        var Bundle = android.os.Bundle;
        class Intent {
            constructor(activityClassOrName) {
                this.mRequestCode = -1;
                this.activityName = activityClassOrName;
            }
            getBooleanExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getIntExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getLongExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getFloatExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getDoubleExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getStringExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getStringArrayExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getIntegerArrayExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getLongArrayExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getFloatArrayExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getDoubleArrayExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            getBooleanArrayExtra(name, defaultValue) {
                return this.mExtras == null ? defaultValue : this.mExtras.get(name, defaultValue);
            }
            hasExtra(name) {
                return this.mExtras != null && this.mExtras.containsKey(name);
            }
            putExtra(name, value) {
                if (this.mExtras == null) {
                    this.mExtras = new Bundle();
                }
                this.mExtras.put(name, value);
                return this;
            }
            getExtras() {
                return (this.mExtras != null) ? new Bundle(this.mExtras) : null;
            }
        }
        content.Intent = Intent;
    })(content = android.content || (android.content = {}));
})(android || (android = {}));
var androidui;
(function (androidui) {
    var util;
    (function (util) {
        class ClassFinder {
            static findClass(classFullName, findInRoot = window) {
                let nameParts = classFullName.split('.');
                let finding = findInRoot;
                for (let part of nameParts) {
                    let quickFind = finding[part.toLowerCase()];
                    if (quickFind) {
                        finding = quickFind;
                        continue;
                    }
                    let found = false;
                    for (let key in finding) {
                        if (key.toUpperCase() === part.toUpperCase()) {
                            finding = finding[key];
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                        return null;
                }
                if (finding === findInRoot) {
                    return null;
                }
                return finding;
            }
        }
        util.ClassFinder = ClassFinder;
    })(util = androidui.util || (androidui.util = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/content/Context.ts"/>
/**
 * Created by linfaxin on 16/1/3.
 *
 */
///<reference path="../content/Context.ts"/>
///<reference path="../../androidui/util/ClassFinder.ts"/>
///<reference path="../../androidui/widget/HtmlDataAdapter.ts"/>
var android;
(function (android) {
    var view;
    (function (view_1) {
        var ClassFinder = androidui.util.ClassFinder;
        class LayoutInflater {
            constructor(context) {
                this.mContext = context;
            }
            static from(context) {
                return context.getLayoutInflater();
            }
            getContext() {
                return this.mContext;
            }
            inflate(layout, viewParent, attachToRoot = (viewParent != null)) {
                let domtree = layout instanceof HTMLElement ? layout : this.mContext.getResources().getLayout(layout);
                if (!domtree) {
                    console.error('not find layout: ' + layout);
                    return null;
                }
                let className = domtree.tagName;
                if (className.startsWith('ANDROID-')) {
                    className = className.substring('ANDROID-'.length);
                }
                if (className === 'LAYOUT') {
                    domtree = domtree.firstElementChild;
                }
                if (className === 'INCLUDE') {
                    let refLayoutId = domtree.getAttribute('layout');
                    if (!refLayoutId)
                        return null;
                    let refEle = this.mContext.getResources().getLayout(refLayoutId);
                    let view = this.inflate(refEle, viewParent, false);
                    if (view) {
                        for (let attr of Array.from(domtree.attributes)) {
                            let name = attr.name;
                            if (name === 'layout')
                                continue;
                            view.bindElement.setAttribute(name, attr.value);
                        }
                    }
                    return view;
                }
                else if (className === 'MERGE') {
                    if (!viewParent)
                        throw Error('merge tag need ViewParent');
                    Array.from(domtree.children).forEach((item) => {
                        if (item instanceof HTMLElement) {
                            this.inflate(item, viewParent);
                        }
                    });
                    return viewParent;
                }
                else if (className === 'VIEW') {
                    let overrideClass = domtree.className || domtree.getAttribute('android:class');
                    if (overrideClass)
                        className = overrideClass;
                }
                let rootViewClass = ClassFinder.findClass(className, android.view);
                if (!rootViewClass)
                    rootViewClass = ClassFinder.findClass(className, android['widget']);
                if (!rootViewClass)
                    rootViewClass = ClassFinder.findClass(className, androidui['widget']);
                if (!rootViewClass)
                    rootViewClass = ClassFinder.findClass(className);
                if (!rootViewClass) {
                    if (document.createElement(className) instanceof HTMLUnknownElement) {
                        console.warn('inflate: not find class ' + className);
                    }
                    return null;
                }
                let children = Array.from(domtree.children);
                let defStyle;
                let styleAttrValue = domtree.getAttribute('style');
                if (styleAttrValue) {
                    defStyle = this.mContext.getResources().getAttr(styleAttrValue);
                }
                let rootView;
                if (styleAttrValue)
                    rootView = new rootViewClass(this.mContext, domtree, defStyle);
                else
                    rootView = new rootViewClass(this.mContext, domtree);
                if (rootView['onInflateAdapter']) {
                    rootView.onInflateAdapter(domtree, this.mContext, viewParent);
                    domtree.parentNode.removeChild(domtree);
                }
                if (!(rootView instanceof view_1.View)) {
                    return rootView;
                }
                let params;
                if (viewParent) {
                    params = viewParent.generateDefaultLayoutParams();
                    params.parseAttributeFrom(domtree, this.mContext);
                    rootView.setLayoutParams(params);
                }
                rootView._fireInitedAttributeChange();
                if (rootView instanceof view_1.ViewGroup) {
                    let parent = rootView;
                    children.forEach((item) => {
                        if (item instanceof HTMLElement) {
                            this.inflate(item, parent);
                        }
                    });
                }
                rootView.onFinishInflate();
                if (attachToRoot && viewParent)
                    viewParent.addView(rootView);
                return rootView;
            }
        }
        view_1.LayoutInflater = LayoutInflater;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 16/1/4.
 * lite impl of Android Content
 */
///<reference path="../view/WindowManager.ts"/>
///<reference path="res/Resources.ts"/>
///<reference path="../app/Application.ts"/>
///<reference path="../content/Intent.ts"/>
///<reference path="../os/Bundle.ts"/>
///<reference path="../view/LayoutInflater.ts"/>
var android;
(function (android) {
    var content;
    (function (content) {
        var LayoutInflater = android.view.LayoutInflater;
        class Context {
            constructor(androidUI) {
                this.androidUI = androidUI;
                this.mLayoutInflater = new LayoutInflater(this);
                this.mResources = new android.content.res.Resources(this);
            }
            getApplicationContext() {
                return this.androidUI.mApplication;
            }
            getResources() {
                return this.mResources;
            }
            getLayoutInflater() {
                return this.mLayoutInflater;
            }
        }
        content.Context = Context;
    })(content = android.content || (android.content = {}));
})(android || (android = {}));
var android;
(function (android) {
    var R;
    (function (R) {
        const _layout_data = {
            "alert_dialog": "\n<!--\n/*\n** Copyright 2010, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\");\n** you may not use this file except in compliance with the License.\n** You may obtain a copy of the License at\n**\n**     http://www.apache.org/licenses/LICENSE-2.0\n**\n** Unless required by applicable law or agreed to in writing, software\n** distributed under the License is distributed on an \"AS IS\" BASIS,\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n** See the License for the specific language governing permissions and\n** limitations under the License.\n*/\n-->\n\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"parentPanel\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:viewShadowColor=\"black\"\n    android:viewShadowDy=\"3dp\"\n    android:viewShadowRadius=\"10dp\"\n    android:cornerRadius=\"4dp\"\n    android:layout_marginStart=\"8dip\"\n    android:layout_marginEnd=\"8dip\"\n    android:orientation=\"vertical\">\n\n    <LinearLayout android:id=\"topPanel\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\">\n        <View android:id=\"titleDividerTop\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"1dip\"\n            android:visibility=\"gone\"\n            android:background=\"#aaa\" ></View>\n        <LinearLayout android:id=\"title_template\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"horizontal\"\n            android:gravity=\"center_vertical|start\"\n            android:minHeight=\"64dp\"\n            android:layout_marginStart=\"16dip\"\n            android:layout_marginEnd=\"16dip\">\n            <ImageView android:id=\"icon\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:paddingEnd=\"8dip\"></ImageView>\n            <TextView android:id=\"alertTitle\"\n                android:maxLines=\"1\"\n                android:scrollHorizontally=\"true\"\n                android:textSize=\"22sp\"\n                android:textColor=\"#333\"\n                android:singleLine=\"true\"\n                android:ellipsize=\"end\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:textAlignment=\"viewStart\"></TextView>\n        </LinearLayout>\n        <View android:id=\"titleDivider\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"1dip\"\n            android:visibility=\"gone\"\n            android:background=\"#aaa\" ></View>\n        <!-- If the client uses a customTitle, it will be added here. -->\n    </LinearLayout>\n\n    <LinearLayout android:id=\"contentPanel\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:orientation=\"vertical\"\n        android:minHeight=\"64dp\">\n        <ScrollView android:id=\"scrollView\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:clipToPadding=\"false\">\n            <TextView android:id=\"message\"\n                android:textSize=\"18sp\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:paddingStart=\"16dip\"\n                android:paddingEnd=\"16dip\"\n                android:paddingTop=\"8dip\"\n                android:paddingBottom=\"8dip\"></TextView>\n        </ScrollView>\n    </LinearLayout>\n\n    <FrameLayout android:id=\"customPanel\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:minHeight=\"64dp\">\n        <FrameLayout android:id=\"custom\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\" ></FrameLayout>\n    </FrameLayout>\n\n    <LinearLayout android:id=\"buttonPanel\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:minHeight=\"48dip\"\n        android:orientation=\"vertical\"\n        android:divider=\"@android:drawable/divider_horizontal\"\n        android:showDividers=\"beginning\"\n        android:dividerPadding=\"0dip\">\n        <LinearLayout\n            android:divider=\"@android:drawable/divider_vertical\"\n            android:showDividers=\"middle\"\n            android:dividerPadding=\"0dp\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"horizontal\"\n            android:layoutDirection=\"locale\"\n            android:measureWithLargestChild=\"true\">\n            <Button android:id=\"button2\"\n                android:layout_width=\"wrap_content\"\n                android:layout_gravity=\"start\"\n                android:layout_weight=\"1\"\n                android:maxLines=\"2\"\n                android:paddingStart=\"4dp\"\n                android:paddingEnd=\"4dp\"\n                android:background=\"@android:drawable/item_background\"\n                android:textSize=\"14sp\"\n                android:minHeight=\"48dp\"\n                android:layout_height=\"wrap_content\" ></Button>\n            <Button android:id=\"button3\"\n                android:layout_width=\"wrap_content\"\n                android:layout_gravity=\"center_horizontal\"\n                android:layout_weight=\"1\"\n                android:maxLines=\"2\"\n                android:paddingStart=\"4dp\"\n                android:paddingEnd=\"4dp\"\n                android:background=\"@android:drawable/item_background\"\n                android:textSize=\"14sp\"\n                android:minHeight=\"48dp\"\n                android:layout_height=\"wrap_content\" ></Button>\n            <Button android:id=\"button1\"\n                android:layout_width=\"wrap_content\"\n                android:layout_gravity=\"end\"\n                android:layout_weight=\"1\"\n                android:maxLines=\"2\"\n                android:paddingStart=\"4dp\"\n                android:paddingEnd=\"4dp\"\n                android:background=\"@android:drawable/item_background\"\n                android:textSize=\"14sp\"\n                android:minHeight=\"48dp\"\n                android:layout_height=\"wrap_content\" ></Button>\n        </LinearLayout>\n     </LinearLayout>\n</LinearLayout>\n",
            "alert_dialog_progress": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Copyright (C) 2011 The Android Open Source Project\n\n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n          http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n-->\n\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\">\n        <ProgressBar android:id=\"progress\"\n            style=\"@android:attr/progressBarStyleHorizontal\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginTop=\"16dip\"\n            android:layout_marginBottom=\"1dip\"\n            android:layout_marginStart=\"16dip\"\n            android:layout_marginEnd=\"16dip\"\n            android:layout_centerHorizontal=\"true\"></ProgressBar>\n        <TextView\n            android:id=\"progress_percent\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:paddingBottom=\"16dip\"\n            android:layout_marginStart=\"16dip\"\n            android:layout_marginEnd=\"16dip\"\n            android:layout_alignParentStart=\"true\"\n            android:layout_below=\"progress\"\n        ></TextView>\n        <TextView\n            android:id=\"progress_number\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:paddingBottom=\"16dip\"\n            android:layout_marginStart=\"16dip\"\n            android:layout_marginEnd=\"16dip\"\n            android:layout_alignParentEnd=\"true\"\n            android:layout_below=\"progress\"\n        ></TextView>\n</RelativeLayout>\n",
            "select_dialog": "<!--\n/*\n** Copyright 2010, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\");\n** you may not use this file except in compliance with the License.\n** You may obtain a copy of the License at\n**\n**     http://www.apache.org/licenses/LICENSE-2.0\n**\n** Unless required by applicable law or agreed to in writing, software\n** distributed under the License is distributed on an \"AS IS\" BASIS,\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n** See the License for the specific language governing permissions and\n** limitations under the License.\n*/\n-->\n\n<!--\n    This layout file is used by the AlertDialog when displaying a list of items.\n    This layout file is inflated and used as the ListView to display the items.\n    Assign an ID so its state will be saved/restored.\n-->\n<view class=\"android.app.AlertController.RecycleListView\"\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"select_dialog_listview\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:cacheColorHint=\"@null\"\n    android:divider=\"@android:drawable/list_divider\"\n    android:scrollbars=\"vertical\"\n    android:overScrollMode=\"ifContentScrolls\"\n    android:textAlignment=\"viewStart\" />\n",
            "select_dialog_item": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!--\n/*\n** Copyright 2010, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\");\n** you may not use this file except in compliance with the License.\n** You may obtain a copy of the License at\n**\n**     http://www.apache.org/licenses/LICENSE-2.0\n**\n** Unless required by applicable law or agreed to in writing, software\n** distributed under the License is distributed on an \"AS IS\" BASIS,\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n** See the License for the specific language governing permissions and\n** limitations under the License.\n*/\n-->\n\n<!--\n    This layout file is used by the AlertDialog when displaying a list of items.\n    This layout file is inflated and used as the TextView to display individual\n    items.\n-->\n<TextView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"text1\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:minHeight=\"48dp\"\n    android:textSize=\"18sp\"\n    android:gravity=\"center_vertical\"\n    android:paddingStart=\"16dip\"\n    android:paddingEnd=\"16dip\"\n    android:ellipsize=\"end\"\n></TextView>\n",
            "select_dialog_multichoice": "\n<!-- Copyright (C) 2010 The Android Open Source Project\n\n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n          http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n-->\n\n<CheckedTextView\n    android:id=\"text1\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:minHeight=\"48dp\"\n    android:textSize=\"18sp\"\n    android:gravity=\"center_vertical\"\n    android:paddingStart=\"16dip\"\n    android:paddingEnd=\"16dip\"\n    android:checkMark=\"@android:drawable/btn_check\"\n    android:ellipsize=\"end\"\n></CheckedTextView>\n",
            "select_dialog_singlechoice": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Copyright (C) 2010 The Android Open Source Project\n\n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n          http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n-->\n\n<CheckedTextView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"text1\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:minHeight=\"48dp\"\n    android:textSize=\"18sp\"\n    android:gravity=\"center_vertical\"\n    android:paddingStart=\"16dip\"\n    android:paddingEnd=\"16dip\"\n    android:checkMark=\"@android:drawable/btn_radio\"\n    android:ellipsize=\"end\"\n></CheckedTextView>\n",
            "simple_spinner_dropdown_item": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!--\n/* //device/apps/common/assets/res/any/layout/simple_spinner_item.xml\n**\n** Copyright 2008, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\"); \n** you may not use this file except in compliance with the License. \n** You may obtain a copy of the License at \n**\n**     http://www.apache.org/licenses/LICENSE-2.0 \n**\n** Unless required by applicable law or agreed to in writing, software \n** distributed under the License is distributed on an \"AS IS\" BASIS, \n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n** See the License for the specific language governing permissions and \n** limitations under the License.\n*/\n-->\n<CheckedTextView xmlns:android=\"http://schemas.android.com/apk/res/android\" \n    android:id=\"text1\"\n\n    android:paddingStart=\"8dp\"\n    android:paddingEnd=\"8dp\"\n    android:textColor=\"@android:color/primary_text_light_disable_only\"\n\n    android:gravity=\"center_vertical\"\n    android:singleLine=\"true\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"48dp\"\n    android:ellipsize=\"end\"\n    android:textAlignment=\"inherit\"></CheckedTextView>\n",
            "simple_spinner_item": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!--\n/* //device/apps/common/assets/res/any/layout/simple_spinner_item.xml\n**\n** Copyright 2006, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\"); \n** you may not use this file except in compliance with the License. \n** You may obtain a copy of the License at \n**\n**     http://www.apache.org/licenses/LICENSE-2.0 \n**\n** Unless required by applicable law or agreed to in writing, software \n** distributed under the License is distributed on an \"AS IS\" BASIS, \n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n** See the License for the specific language governing permissions and \n** limitations under the License.\n*/\n-->\n<TextView xmlns:android=\"http://schemas.android.com/apk/res/android\" \n    android:id=\"text1\"\n\n    android:paddingStart=\"8dp\"\n    android:paddingEnd=\"8dp\"\n    android:textColor=\"@android:color/primary_text_light_disable_only\"\n\n    android:gravity=\"center_vertical\"\n    android:singleLine=\"true\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:ellipsize=\"end\"\n    android:textAlignment=\"inherit\"></TextView>\n",
            "transient_notification": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!--\n/* //device/apps/common/res/layout/transient_notification.xml\n**\n** Copyright 2006, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\");\n** you may not use this file except in compliance with the License.\n** You may obtain a copy of the License at\n**\n**     http://www.apache.org/licenses/LICENSE-2.0\n**\n** Unless required by applicable law or agreed to in writing, software\n** distributed under the License is distributed on an \"AS IS\" BASIS,\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n** See the License for the specific language governing permissions and\n** limitations under the License.\n*/\n-->\n\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    android:background=\"@android:drawable/toast_frame\">\n\n    <TextView\n        android:id=\"message\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:layout_gravity=\"center_horizontal\"\n        android:textColor=\"white\"\n        android:shadowColor=\"#BB000000\"\n        android:shadowRadius=\"2.75\"\n        ></TextView>\n\n</LinearLayout>\n\n\n"
        };
        const _tempDiv = document.createElement('div');
        class layout {
            static getLayoutData(layoutRef) {
                if (!layoutRef)
                    return null;
                layoutRef = layoutRef.replace('/', '.').split('.').pop();
                if (!_layout_data[layoutRef])
                    return null;
                _tempDiv.innerHTML = _layout_data[layoutRef];
                let data = _tempDiv.firstElementChild;
                _tempDiv.removeChild(data);
                return data;
            }
        }
        layout.alert_dialog = '@android:layout/alert_dialog';
        layout.alert_dialog_progress = '@android:layout/alert_dialog_progress';
        layout.select_dialog = '@android:layout/select_dialog';
        layout.select_dialog_item = '@android:layout/select_dialog_item';
        layout.select_dialog_multichoice = '@android:layout/select_dialog_multichoice';
        layout.select_dialog_singlechoice = '@android:layout/select_dialog_singlechoice';
        layout.simple_spinner_dropdown_item = '@android:layout/simple_spinner_dropdown_item';
        layout.simple_spinner_item = '@android:layout/simple_spinner_item';
        layout.transient_notification = '@android:layout/transient_notification';
        R.layout = layout;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="../../util/DisplayMetrics.ts"/>
///<reference path="../../content/Context.ts"/>
///<reference path="../../graphics/drawable/Drawable.ts"/>
///<reference path="../../R/layout.ts"/>
var android;
(function (android) {
    var content;
    (function (content) {
        var res;
        (function (res) {
            var DisplayMetrics = android.util.DisplayMetrics;
            class Resources {
                constructor(context) {
                    this.context = context;
                }
                static getSystem() {
                    return Resources.instance;
                }
                static from(context) {
                    return context.getResources();
                }
                static getDisplayMetrics() {
                    return Resources.instance.getDisplayMetrics();
                }
                getDisplayMetrics() {
                    if (this.displayMetrics)
                        return this.displayMetrics;
                    this.displayMetrics = new DisplayMetrics();
                    let displayMetrics = this.displayMetrics;
                    let density = window.devicePixelRatio;
                    displayMetrics.xdpi = window.screen.deviceXDPI || DisplayMetrics.DENSITY_DEFAULT;
                    displayMetrics.ydpi = window.screen.deviceYDPI || DisplayMetrics.DENSITY_DEFAULT;
                    displayMetrics.density = density;
                    displayMetrics.densityDpi = density * DisplayMetrics.DENSITY_DEFAULT;
                    displayMetrics.scaledDensity = density;
                    displayMetrics.widthPixels = window.innerWidth * density;
                    displayMetrics.heightPixels = window.innerHeight * density;
                    return displayMetrics;
                }
                getObjectRef(refString) {
                    if (refString.startsWith('@'))
                        refString = refString.substring(1);
                    if (refString == 'null')
                        return null;
                    try {
                        return window.eval(refString);
                    }
                    catch (e) {
                        console.log(e);
                    }
                }
                getAttr(refString) {
                    if (refString.startsWith('@android:attr/')) {
                        refString = refString.substring('@android:attr/'.length);
                        return android.R.attr[refString];
                    }
                    else if (Resources.buildAttrFinder && refString.startsWith('@attr/')) {
                        return Resources.buildAttrFinder(refString);
                    }
                    else if (refString.startsWith('@')) {
                        return this.getObjectRef(refString);
                    }
                    return null;
                }
                getDrawable(refString) {
                    if (refString.startsWith('@android:drawable/')) {
                        refString = refString.substring('@android:drawable/'.length);
                        return android.R.drawable[refString] || android.R.image[refString];
                    }
                    else if (Resources.buildDrawableFinder && refString.startsWith('@drawable/')) {
                        return Resources.buildDrawableFinder(refString);
                    }
                    else if (refString.startsWith('@')) {
                        return this.getObjectRef(refString);
                    }
                }
                getColor(refString) {
                    let s = this.getString(refString);
                    return android.graphics.Color.parseColor(s);
                }
                getColorStateList(refString) {
                    if (refString.startsWith('@android:color/')) {
                        refString = refString.substring('@android:color/'.length);
                        return android.R.color[refString];
                    }
                    else if (refString.startsWith('@')) {
                        return this.getObjectRef(refString);
                    }
                }
                getString(refString, notFindValue = refString) {
                    if (!refString || !refString.startsWith('@'))
                        return notFindValue;
                    let referenceArray = [];
                    let attrValue = refString;
                    while (attrValue && attrValue.startsWith('@')) {
                        let reference = this.getReference(attrValue, false);
                        if (!reference)
                            return notFindValue;
                        if (referenceArray.indexOf(reference) >= 0)
                            throw Error('findReference Error: circle reference');
                        referenceArray.push(reference);
                        attrValue = reference.innerText;
                    }
                    return attrValue;
                }
                getTextArray(refString) {
                    if (!refString || !refString.startsWith('@'))
                        return null;
                    let reference = this.getReference(refString, false);
                    if (reference instanceof HTMLElement) {
                        let array = [];
                        for (let ele of Array.from(reference.children)) {
                            if (ele instanceof HTMLElement)
                                array.push(ele.innerText);
                        }
                        return array;
                    }
                    return null;
                }
                getLayout(refString) {
                    if (!refString || !refString.trim().startsWith('@'))
                        return null;
                    let reference = this.getReference(refString, true);
                    if (reference)
                        return reference.firstElementChild;
                    if (refString.startsWith('@android:layout/')) {
                        return android.R.layout.getLayoutData(refString);
                    }
                    else if (Resources.buildLayoutFinder && refString.startsWith('@layout/')) {
                        return Resources.buildLayoutFinder(refString);
                    }
                    else if (refString.startsWith('@')) {
                        return this.getObjectRef(refString);
                    }
                }
                getReference(refString, cloneNode = true) {
                    if (refString)
                        refString = refString.trim();
                    if (refString && refString.startsWith('@')) {
                        refString = refString.substring(1);
                        let [tagName, ...refIds] = refString.split('/');
                        if (!refIds || refIds.length === 0)
                            return null;
                        let resourcesElement = Resources.buildResourcesElement;
                        if (tagName.startsWith('android:')) {
                            tagName = tagName.substring('android:'.length);
                            resourcesElement = Resources.SDKResourcesElement;
                        }
                        if (!tagName.startsWith('android-'))
                            tagName = 'android-' + tagName;
                        let q = 'resources ' + tagName + '#' + refIds.join(' #');
                        let rootElement = this.context ? this.context.androidUI.rootResourceElement : Resources.emptySelectorNode;
                        let el = rootElement.querySelector(q) || resourcesElement.querySelector(q);
                        if (!el)
                            return null;
                        return cloneNode ? el.cloneNode(true) : el;
                    }
                    return null;
                }
            }
            Resources.instance = new Resources();
            Resources.emptySelectorNode = document.createElement('resources');
            Resources.buildResourcesElement = document.createElement('resources');
            Resources.SDKResourcesElement = document.createElement('resources');
            res.Resources = Resources;
        })(res = content.res || (content.res = {}));
    })(content = android.content || (android.content = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="../util/SparseArray.ts"/>
///<reference path="../content/res/Resources.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class ViewConfiguration {
            constructor() {
                this.density = android.content.res.Resources.getDisplayMetrics().density;
                this.sizeAndDensity = this.density;
                this.mEdgeSlop = this.sizeAndDensity * ViewConfiguration.EDGE_SLOP;
                this.mFadingEdgeLength = this.sizeAndDensity * ViewConfiguration.FADING_EDGE_LENGTH;
                this.mMinimumFlingVelocity = this.density * ViewConfiguration.MINIMUM_FLING_VELOCITY;
                this.mMaximumFlingVelocity = this.density * ViewConfiguration.MAXIMUM_FLING_VELOCITY;
                this.mScrollbarSize = this.density * ViewConfiguration.SCROLL_BAR_SIZE;
                this.mTouchSlop = this.density * ViewConfiguration.TOUCH_SLOP;
                this.mDoubleTapTouchSlop = this.sizeAndDensity * ViewConfiguration.DOUBLE_TAP_TOUCH_SLOP;
                this.mPagingTouchSlop = this.density * ViewConfiguration.PAGING_TOUCH_SLOP;
                this.mDoubleTapSlop = this.density * ViewConfiguration.DOUBLE_TAP_SLOP;
                this.mWindowTouchSlop = this.sizeAndDensity * ViewConfiguration.WINDOW_TOUCH_SLOP;
                this.mOverscrollDistance = this.sizeAndDensity * ViewConfiguration.OVERSCROLL_DISTANCE;
                this.mOverflingDistance = this.sizeAndDensity * ViewConfiguration.OVERFLING_DISTANCE;
                this.mMaximumDrawingCacheSize = android.content.res.Resources.getDisplayMetrics().widthPixels
                    * android.content.res.Resources.getDisplayMetrics().heightPixels * 4 * 2;
            }
            static get(arg) {
                if (!ViewConfiguration.instance) {
                    ViewConfiguration.instance = new ViewConfiguration();
                }
                return ViewConfiguration.instance;
            }
            getScaledScrollBarSize() {
                return this.mScrollbarSize;
            }
            static getScrollBarFadeDuration() {
                return ViewConfiguration.SCROLL_BAR_FADE_DURATION;
            }
            static getScrollDefaultDelay() {
                return ViewConfiguration.SCROLL_BAR_DEFAULT_DELAY;
            }
            getScaledFadingEdgeLength() {
                return this.mFadingEdgeLength;
            }
            static getPressedStateDuration() {
                return ViewConfiguration.PRESSED_STATE_DURATION;
            }
            static getLongPressTimeout() {
                return ViewConfiguration.DEFAULT_LONG_PRESS_TIMEOUT;
            }
            static getKeyRepeatDelay() {
                return ViewConfiguration.KEY_REPEAT_DELAY;
            }
            static getTapTimeout() {
                return ViewConfiguration.TAP_TIMEOUT;
            }
            static getJumpTapTimeout() {
                return ViewConfiguration.JUMP_TAP_TIMEOUT;
            }
            static getDoubleTapTimeout() {
                return ViewConfiguration.DOUBLE_TAP_TIMEOUT;
            }
            static getDoubleTapMinTime() {
                return ViewConfiguration.DOUBLE_TAP_MIN_TIME;
            }
            getScaledEdgeSlop() {
                return this.mEdgeSlop;
            }
            getScaledTouchSlop() {
                return this.mTouchSlop;
            }
            getScaledDoubleTapTouchSlop() {
                return this.mDoubleTapTouchSlop;
            }
            getScaledPagingTouchSlop() {
                return this.mPagingTouchSlop;
            }
            getScaledDoubleTapSlop() {
                return this.mDoubleTapSlop;
            }
            getScaledWindowTouchSlop() {
                return this.mWindowTouchSlop;
            }
            getScaledMinimumFlingVelocity() {
                return this.mMinimumFlingVelocity;
            }
            getScaledMaximumFlingVelocity() {
                return this.mMaximumFlingVelocity;
            }
            getScaledMaximumDrawingCacheSize() {
                return this.mMaximumDrawingCacheSize;
            }
            getScaledOverscrollDistance() {
                return this.mOverscrollDistance;
            }
            getScaledOverflingDistance() {
                return this.mOverflingDistance;
            }
            static getScrollFriction() {
                return ViewConfiguration.SCROLL_FRICTION;
            }
        }
        ViewConfiguration.SCROLL_BAR_SIZE = 8;
        ViewConfiguration.SCROLL_BAR_FADE_DURATION = 250;
        ViewConfiguration.SCROLL_BAR_DEFAULT_DELAY = 300;
        ViewConfiguration.FADING_EDGE_LENGTH = 12;
        ViewConfiguration.PRESSED_STATE_DURATION = 64;
        ViewConfiguration.DEFAULT_LONG_PRESS_TIMEOUT = 500;
        ViewConfiguration.KEY_REPEAT_DELAY = 50;
        ViewConfiguration.GLOBAL_ACTIONS_KEY_TIMEOUT = 500;
        ViewConfiguration.TAP_TIMEOUT = 180;
        ViewConfiguration.JUMP_TAP_TIMEOUT = 500;
        ViewConfiguration.DOUBLE_TAP_TIMEOUT = 300;
        ViewConfiguration.DOUBLE_TAP_MIN_TIME = 40;
        ViewConfiguration.HOVER_TAP_TIMEOUT = 150;
        ViewConfiguration.HOVER_TAP_SLOP = 20;
        ViewConfiguration.ZOOM_CONTROLS_TIMEOUT = 3000;
        ViewConfiguration.EDGE_SLOP = 12;
        ViewConfiguration.TOUCH_SLOP = 8;
        ViewConfiguration.DOUBLE_TAP_TOUCH_SLOP = ViewConfiguration.TOUCH_SLOP;
        ViewConfiguration.PAGING_TOUCH_SLOP = ViewConfiguration.TOUCH_SLOP * 2;
        ViewConfiguration.DOUBLE_TAP_SLOP = 100;
        ViewConfiguration.WINDOW_TOUCH_SLOP = 16;
        ViewConfiguration.MINIMUM_FLING_VELOCITY = 50;
        ViewConfiguration.MAXIMUM_FLING_VELOCITY = 8000;
        ViewConfiguration.SCROLL_FRICTION = 0.015;
        ViewConfiguration.OVERSCROLL_DISTANCE = 800;
        ViewConfiguration.OVERFLING_DISTANCE = 100;
        view.ViewConfiguration = ViewConfiguration;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var android;
(function (android) {
    var os;
    (function (os) {
        class SystemClock {
            static uptimeMillis() {
                return new Date().getTime();
            }
        }
        os.SystemClock = SystemClock;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/6.
 */
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../os/SystemClock.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Rect = android.graphics.Rect;
        var ViewConfiguration = android.view.ViewConfiguration;
        class MotionEvent {
            constructor() {
                this.mAction = 0;
                this.mEdgeFlags = 0;
                this.mDownTime = 0;
                this.mEventTime = 0;
                this.mActivePointerId = 0;
                this.mXOffset = 0;
                this.mYOffset = 0;
                this._axisValues = new Map();
            }
            static obtainWithTouchEvent(e, action) {
                let event = new MotionEvent();
                event.initWithTouch(e, action);
                return event;
            }
            static obtain(event) {
                let newEv = new MotionEvent();
                Object.assign(newEv, event);
                return newEv;
            }
            static obtainWithAction(downTime, eventTime, action, x, y, metaState = 0) {
                let newEv = new MotionEvent();
                newEv.mAction = action;
                newEv.mDownTime = downTime;
                newEv.mEventTime = eventTime;
                let touch = {
                    identifier: 0,
                    target: null,
                    screenX: x,
                    screenY: y,
                    clientX: x,
                    clientY: y,
                    pageX: x,
                    pageY: y
                };
                newEv.mTouchingPointers = [touch];
                return newEv;
            }
            initWithTouch(event, baseAction, windowBound = new Rect()) {
                let e = event;
                let now = android.os.SystemClock.uptimeMillis();
                let action = baseAction;
                let actionIndex = -1;
                let activeTouch = e.changedTouches[0];
                this._activeTouch = activeTouch;
                let activePointerId = activeTouch.identifier;
                for (let i = 0, length = e.touches.length; i < length; i++) {
                    if (e.touches[i].identifier === activePointerId) {
                        actionIndex = i;
                        MotionEvent.IdIndexCache.set(activePointerId, i);
                        break;
                    }
                }
                if (actionIndex < 0 && (baseAction === MotionEvent.ACTION_UP || baseAction === MotionEvent.ACTION_CANCEL)) {
                    actionIndex = MotionEvent.IdIndexCache.get(activePointerId);
                }
                if (actionIndex < 0)
                    throw Error('not find action index');
                switch (baseAction) {
                    case MotionEvent.ACTION_DOWN:
                    case MotionEvent.ACTION_UP:
                        MotionEvent.TouchMoveRecord.set(activePointerId, []);
                        break;
                    case MotionEvent.ACTION_MOVE:
                        let moveHistory = MotionEvent.TouchMoveRecord.get(activePointerId);
                        if (moveHistory) {
                            activeTouch.mEventTime = now;
                            moveHistory.push(activeTouch);
                            if (moveHistory.length > MotionEvent.HistoryMaxSize)
                                moveHistory.shift();
                        }
                        break;
                }
                this.mTouchingPointers = Array.from(e.touches);
                if (baseAction === MotionEvent.ACTION_UP) {
                    this.mTouchingPointers.splice(actionIndex, 0, activeTouch);
                }
                if (this.mTouchingPointers.length > 1) {
                    switch (action) {
                        case MotionEvent.ACTION_DOWN:
                            action = MotionEvent.ACTION_POINTER_DOWN;
                            action = actionIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT | action;
                            break;
                        case MotionEvent.ACTION_UP:
                            action = MotionEvent.ACTION_POINTER_UP;
                            action = actionIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT | action;
                            break;
                    }
                }
                this.mAction = action;
                this.mActivePointerId = activePointerId;
                if (action == MotionEvent.ACTION_DOWN) {
                    this.mDownTime = now;
                }
                this.mEventTime = now;
                this.mXOffset = this.mYOffset = 0;
                let edgeFlag = 0;
                let unScaledX = activeTouch.clientX;
                let unScaledY = activeTouch.clientY;
                let edgeSlop = ViewConfiguration.EDGE_SLOP;
                let tempBound = new Rect();
                tempBound.set(windowBound);
                tempBound.right = tempBound.left + edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_LEFT;
                }
                tempBound.set(windowBound);
                tempBound.bottom = tempBound.top + edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_TOP;
                }
                tempBound.set(windowBound);
                tempBound.left = tempBound.right - edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_RIGHT;
                }
                tempBound.set(windowBound);
                tempBound.top = tempBound.bottom - edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_BOTTOM;
                }
                this.mEdgeFlags = edgeFlag;
            }
            initWithMouseWheel(e) {
                this.mAction = MotionEvent.ACTION_SCROLL;
                this.mActivePointerId = 0;
                let touch = {
                    identifier: 0,
                    target: null,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY
                };
                this.mTouchingPointers = [touch];
                this.mDownTime = this.mEventTime = android.os.SystemClock.uptimeMillis();
                this.mXOffset = this.mYOffset = 0;
                this._axisValues.clear();
                this._axisValues.set(MotionEvent.AXIS_VSCROLL, -e.deltaY);
                this._axisValues.set(MotionEvent.AXIS_HSCROLL, -e.deltaX);
            }
            recycle() {
            }
            getAction() {
                return this.mAction;
            }
            getActionMasked() {
                return this.mAction & MotionEvent.ACTION_MASK;
            }
            getActionIndex() {
                return (this.mAction & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
            }
            getDownTime() {
                return this.mDownTime;
            }
            getEventTime() {
                return this.mEventTime;
            }
            getX(pointerIndex = 0) {
                let density = android.content.res.Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[pointerIndex].clientX) * density + this.mXOffset;
            }
            getY(pointerIndex = 0) {
                let density = android.content.res.Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[pointerIndex].clientY) * density + this.mYOffset;
            }
            getPointerCount() {
                return this.mTouchingPointers.length;
            }
            getPointerId(pointerIndex) {
                return this.mTouchingPointers[pointerIndex].identifier;
            }
            findPointerIndex(pointerId) {
                for (let i = 0, length = this.mTouchingPointers.length; i < length; i++) {
                    if (this.mTouchingPointers[i].identifier === pointerId) {
                        return i;
                    }
                }
                return -1;
            }
            getRawX() {
                let density = android.content.res.Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[0].clientX) * density;
            }
            getRawY() {
                let density = android.content.res.Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[0].clientY) * density;
            }
            getHistorySize(id = this.mActivePointerId) {
                let moveHistory = MotionEvent.TouchMoveRecord.get(id);
                return moveHistory ? moveHistory.length : 0;
            }
            getHistoricalX(pointerIndex, pos) {
                let density = android.content.res.Resources.getDisplayMetrics().density;
                let moveHistory = MotionEvent.TouchMoveRecord.get(this.mTouchingPointers[pointerIndex].identifier);
                return (moveHistory[pos].clientX) * density + this.mXOffset;
            }
            getHistoricalY(pointerIndex, pos) {
                let density = android.content.res.Resources.getDisplayMetrics().density;
                let moveHistory = MotionEvent.TouchMoveRecord.get(this.mTouchingPointers[pointerIndex].identifier);
                return (moveHistory[pos].clientY) * density + this.mYOffset;
            }
            getHistoricalEventTime(...args) {
                let pos, activePointerId;
                if (args.length === 1) {
                    pos = args[0];
                    activePointerId = this.mActivePointerId;
                }
                else {
                    pos = args[1];
                    activePointerId = this.getPointerId(args[0]);
                }
                let moveHistory = MotionEvent.TouchMoveRecord.get(activePointerId);
                return moveHistory[pos].mEventTime;
            }
            getTouchMajor(pointerIndex) {
                return Math.floor(android.content.res.Resources.getDisplayMetrics().density);
            }
            getHistoricalTouchMajor(pointerIndex, pos) {
                return Math.floor(android.content.res.Resources.getDisplayMetrics().density);
            }
            getEdgeFlags() {
                return this.mEdgeFlags;
            }
            setEdgeFlags(flags) {
                this.mEdgeFlags = flags;
            }
            setAction(action) {
                this.mAction = action;
            }
            isTouchEvent() {
                let action = this.getActionMasked();
                switch (action) {
                    case MotionEvent.ACTION_DOWN:
                    case MotionEvent.ACTION_UP:
                    case MotionEvent.ACTION_MOVE:
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_OUTSIDE:
                    case MotionEvent.ACTION_POINTER_DOWN:
                    case MotionEvent.ACTION_POINTER_UP:
                        return true;
                }
                return false;
            }
            isPointerEvent() {
                return true;
            }
            offsetLocation(deltaX, deltaY) {
                this.mXOffset += deltaX;
                this.mYOffset += deltaY;
            }
            setLocation(x, y) {
                this.mXOffset = x - this.getRawX();
                this.mYOffset = y - this.getRawY();
            }
            getPointerIdBits() {
                let idBits = 0;
                let pointerCount = this.getPointerCount();
                for (let i = 0; i < pointerCount; i++) {
                    idBits |= 1 << this.getPointerId(i);
                }
                return idBits;
            }
            split(idBits) {
                let ev = MotionEvent.obtain(this);
                let oldPointerCount = this.getPointerCount();
                const oldAction = this.getAction();
                const oldActionMasked = oldAction & MotionEvent.ACTION_MASK;
                let newPointerIds = [];
                for (let i = 0; i < oldPointerCount; i++) {
                    let pointerId = this.getPointerId(i);
                    let idBit = 1 << pointerId;
                    if ((idBit & idBits) != 0) {
                        newPointerIds.push(pointerId);
                    }
                }
                let newActionPointerIndex = newPointerIds.indexOf(this.mActivePointerId);
                let newPointerCount = newPointerIds.length;
                let newAction;
                if (oldActionMasked == MotionEvent.ACTION_POINTER_DOWN || oldActionMasked == MotionEvent.ACTION_POINTER_UP) {
                    if (newActionPointerIndex < 0) {
                        newAction = MotionEvent.ACTION_MOVE;
                    }
                    else if (newPointerCount == 1) {
                        newAction = oldActionMasked == MotionEvent.ACTION_POINTER_DOWN
                            ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_UP;
                    }
                    else {
                        newAction = oldActionMasked | (newActionPointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);
                    }
                }
                else {
                    newAction = oldAction;
                }
                ev.mAction = newAction;
                ev.mTouchingPointers = this.mTouchingPointers.filter((item) => {
                    return newPointerIds.indexOf(item.identifier) >= 0;
                });
                return ev;
            }
            getAxisValue(axis) {
                let value = this._axisValues.get(axis);
                return value ? value : 0;
            }
            toString() {
                return "MotionEvent{action=" + this.getAction() + " x=" + this.getX()
                    + " y=" + this.getY() + "}";
            }
        }
        MotionEvent.INVALID_POINTER_ID = -1;
        MotionEvent.ACTION_MASK = 0xff;
        MotionEvent.ACTION_DOWN = 0;
        MotionEvent.ACTION_UP = 1;
        MotionEvent.ACTION_MOVE = 2;
        MotionEvent.ACTION_CANCEL = 3;
        MotionEvent.ACTION_OUTSIDE = 4;
        MotionEvent.ACTION_POINTER_DOWN = 5;
        MotionEvent.ACTION_POINTER_UP = 6;
        MotionEvent.ACTION_HOVER_MOVE = 7;
        MotionEvent.ACTION_SCROLL = 8;
        MotionEvent.ACTION_HOVER_ENTER = 9;
        MotionEvent.ACTION_HOVER_EXIT = 10;
        MotionEvent.EDGE_TOP = 0x00000001;
        MotionEvent.EDGE_BOTTOM = 0x00000002;
        MotionEvent.EDGE_LEFT = 0x00000004;
        MotionEvent.EDGE_RIGHT = 0x00000008;
        MotionEvent.ACTION_POINTER_INDEX_MASK = 0xff00;
        MotionEvent.ACTION_POINTER_INDEX_SHIFT = 8;
        MotionEvent.AXIS_VSCROLL = 9;
        MotionEvent.AXIS_HSCROLL = 10;
        MotionEvent.HistoryMaxSize = 10;
        MotionEvent.TouchMoveRecord = new Map();
        MotionEvent.IdIndexCache = new Map();
        view.MotionEvent = MotionEvent;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/16.
 */
///<reference path="View.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="ViewConfiguration.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Rect = android.graphics.Rect;
        class TouchDelegate {
            constructor(bounds, delegateView) {
                this.mDelegateTargeted = false;
                this.mSlop = 0;
                this.mBounds = bounds;
                this.mSlop = view.ViewConfiguration.get().getScaledTouchSlop();
                this.mSlopBounds = new Rect(bounds);
                this.mSlopBounds.inset(-this.mSlop, -this.mSlop);
                this.mDelegateView = delegateView;
            }
            onTouchEvent(event) {
                let x = event.getX();
                let y = event.getY();
                let sendToDelegate = false;
                let hit = true;
                let handled = false;
                switch (event.getAction()) {
                    case view.MotionEvent.ACTION_DOWN:
                        let bounds = this.mBounds;
                        if (bounds.contains(x, y)) {
                            this.mDelegateTargeted = true;
                            sendToDelegate = true;
                        }
                        break;
                    case view.MotionEvent.ACTION_UP:
                    case view.MotionEvent.ACTION_MOVE:
                        sendToDelegate = this.mDelegateTargeted;
                        if (sendToDelegate) {
                            let slopBounds = this.mSlopBounds;
                            if (!slopBounds.contains(x, y)) {
                                hit = false;
                            }
                        }
                        break;
                    case view.MotionEvent.ACTION_CANCEL:
                        sendToDelegate = this.mDelegateTargeted;
                        this.mDelegateTargeted = false;
                        break;
                }
                if (sendToDelegate) {
                    let delegateView = this.mDelegateView;
                    if (hit) {
                        event.setLocation(delegateView.getWidth() / 2, delegateView.getHeight() / 2);
                    }
                    else {
                        let slop = this.mSlop;
                        event.setLocation(-(slop * 2), -(slop * 2));
                    }
                    handled = delegateView.dispatchTouchEvent(event);
                }
                return handled;
            }
        }
        view.TouchDelegate = TouchDelegate;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="Handler.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../util/Pools.ts"/>
///<reference path="SystemClock.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        var StringBuilder = java.lang.StringBuilder;
        var Pools = android.util.Pools;
        class Message {
            constructor() {
                this.mType = Message.Type_Normal;
                this.what = 0;
                this.arg1 = 0;
                this.arg2 = 0;
                this.when = 0;
            }
            recycle() {
                this.clearForRecycle();
                Message.sPool.release(this);
            }
            copyFrom(o) {
                this.mType = o.mType;
                this.what = o.what;
                this.arg1 = o.arg1;
                this.arg2 = o.arg2;
                this.obj = o.obj;
            }
            sendToTarget() {
                this.target.sendMessage(this);
            }
            clearForRecycle() {
                this.mType = Message.Type_Normal;
                this.what = 0;
                this.arg1 = 0;
                this.arg2 = 0;
                this.obj = null;
                this.when = 0;
                this.target = null;
                this.callback = null;
            }
            toString(now = os.SystemClock.uptimeMillis()) {
                let b = new StringBuilder();
                b.append("{ what=");
                b.append(this.what);
                b.append(" when=");
                b.append(this.when - now).append("ms");
                if (this.arg1 != 0) {
                    b.append(" arg1=");
                    b.append(this.arg1);
                }
                if (this.arg2 != 0) {
                    b.append(" arg2=");
                    b.append(this.arg2);
                }
                if (this.obj != null) {
                    b.append(" obj=");
                    b.append(this.obj);
                }
                b.append(" }");
                return b.toString();
            }
            static obtain(...args) {
                let m = Message.sPool.acquire();
                m = m || new Message();
                if (args.length === 1) {
                    if (args[0] instanceof Message) {
                        let orig = args[0];
                        [m.target, m.what, m.arg1, m.arg2, m.obj, m.callback] =
                            [orig.target, orig.what, orig.arg1, orig.arg2, orig.obj, orig.callback];
                    }
                    else {
                        m.target = args[0];
                    }
                }
                else if (args.length === 2) {
                    m.target = args[0];
                    if (typeof args[1] === 'number')
                        m.what = args[1];
                    else
                        m.callback = args[1];
                }
                else if (args.length === 3) {
                    [m.target, m.what, m.obj] = args;
                }
                else if (args.length === 4) {
                    [m.target, m.what, m.arg1, m.arg2] = args;
                }
                else {
                    [m.target, m.what, m.arg1 = 0, m.arg2, m.obj, m.callback] = args;
                }
                return m;
            }
        }
        Message.Type_Normal = 0;
        Message.Type_Traversal = 1;
        Message.sPool = new Pools.SynchronizedPool(10);
        os.Message = Message;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="Message.ts"/>
///<reference path="Handler.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        var requestAnimationFrame = window["requestAnimationFrame"] ||
            window["webkitRequestAnimationFrame"] ||
            window["mozRequestAnimationFrame"] ||
            window["oRequestAnimationFrame"] ||
            window["msRequestAnimationFrame"];
        if (!requestAnimationFrame) {
            requestAnimationFrame = function (callback) {
                return window.setTimeout(callback, 1000 / 60);
            };
        }
        class MessageQueue {
            static getMessages(h, args, object) {
                let msgs = [];
                if (h == null) {
                    return msgs;
                }
                if (typeof args === "number") {
                    let what = args;
                    for (let p of MessageQueue.messages) {
                        if (p.target == h && p.what == what && (object == null || p.obj == object)) {
                            msgs.push(p);
                        }
                    }
                }
                else {
                    let r = args;
                    for (let p of MessageQueue.messages) {
                        if (p.target == h && p.callback == r && (object == null || p.obj == object)) {
                            msgs.push(p);
                        }
                    }
                }
                return msgs;
            }
            static hasMessages(h, args, object) {
                return MessageQueue.getMessages(h, args, object).length > 0;
            }
            static enqueueMessage(msg, when) {
                if (msg.target == null) {
                    throw new Error("Message must have a target.");
                }
                msg.when = when;
                MessageQueue.messages.add(msg);
                MessageQueue.checkLoop();
                return true;
            }
            static recycleMessage(handler, message) {
                message.recycle();
                MessageQueue.messages.delete(message);
            }
            static removeMessages(h, args, object) {
                let p = MessageQueue.getMessages(h, args, object);
                if (p && p.length > 0) {
                    for (let item of p) {
                        MessageQueue.recycleMessage(h, item);
                    }
                }
            }
            static removeCallbacksAndMessages(h, object) {
                if (h == null) {
                    return;
                }
                for (let p of MessageQueue.messages) {
                    if (p != null && p.target == h && (object == null || p.obj == object)) {
                        MessageQueue.recycleMessage(h, p);
                    }
                }
            }
            static checkLoop() {
                if (!MessageQueue._loopActive) {
                    MessageQueue._loopActive = true;
                    requestAnimationFrame(MessageQueue.loop);
                }
            }
            static loop() {
                let normalMessages = [];
                let traversalMessages = [];
                const now = os.SystemClock.uptimeMillis();
                for (let msg of MessageQueue.messages) {
                    if (msg.when <= now) {
                        if (msg.mType === os.Message.Type_Traversal)
                            traversalMessages.push(msg);
                        else
                            normalMessages.push(msg);
                    }
                }
                for (let msg of normalMessages) {
                    MessageQueue.dispatchMessage(msg);
                }
                for (let msg of traversalMessages) {
                    MessageQueue.dispatchMessage(msg);
                }
                if (MessageQueue.messages.size > 0)
                    requestAnimationFrame(MessageQueue.loop);
                else
                    MessageQueue._loopActive = false;
            }
            static dispatchMessage(msg) {
                if (MessageQueue.messages.has(msg)) {
                    MessageQueue.messages.delete(msg);
                    msg.target.dispatchMessage(msg);
                    MessageQueue.recycleMessage(msg.target, msg);
                }
            }
        }
        MessageQueue.messages = new Set();
        MessageQueue._loopActive = false;
        os.MessageQueue = MessageQueue;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="Message.ts"/>
///<reference path="MessageQueue.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="SystemClock.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        class Handler {
            constructor(mCallback) {
                this.mCallback = mCallback;
            }
            handleMessage(msg) {
            }
            dispatchMessage(msg) {
                if (msg.callback != null) {
                    msg.callback.run.call(msg.callback);
                }
                else {
                    if (this.mCallback != null) {
                        if (this.mCallback.handleMessage(msg)) {
                            return;
                        }
                    }
                    this.handleMessage(msg);
                }
            }
            obtainMessage(...args) {
                if (args.length === 2) {
                    let [what, obj] = args;
                    return os.Message.obtain(this, what, obj);
                }
                else {
                    let [what, arg1, arg2, obj] = args;
                    return os.Message.obtain(this, what, arg1, arg2, obj);
                }
            }
            post(r) {
                return this.sendMessageDelayed(Handler.getPostMessage(r), 0);
            }
            postAsTraversal(r) {
                let msg = Handler.getPostMessage(r);
                msg.mType = os.Message.Type_Traversal;
                return this.sendMessageDelayed(msg, 0);
            }
            postAtTime(...args) {
                if (args.length === 2) {
                    let [r, uptimeMillis] = args;
                    return this.sendMessageAtTime(Handler.getPostMessage(r), uptimeMillis);
                }
                else {
                    let [r, token, uptimeMillis] = args;
                    return this.sendMessageAtTime(Handler.getPostMessage(r, token), uptimeMillis);
                }
            }
            postDelayed(r, delayMillis) {
                return this.sendMessageDelayed(Handler.getPostMessage(r), delayMillis);
            }
            postAtFrontOfQueue(r) {
                return this.post(r);
            }
            removeCallbacks(r, token) {
                os.MessageQueue.removeMessages(this, r, token);
            }
            sendMessage(msg) {
                return this.sendMessageDelayed(msg, 0);
            }
            sendEmptyMessage(what) {
                return this.sendEmptyMessageDelayed(what, 0);
            }
            sendEmptyMessageDelayed(what, delayMillis) {
                let msg = os.Message.obtain();
                msg.what = what;
                return this.sendMessageDelayed(msg, delayMillis);
            }
            sendEmptyMessageAtTime(what, uptimeMillis) {
                let msg = os.Message.obtain();
                msg.what = what;
                return this.sendMessageAtTime(msg, uptimeMillis);
            }
            sendMessageDelayed(msg, delayMillis) {
                if (delayMillis < 0) {
                    delayMillis = 0;
                }
                return this.sendMessageAtTime(msg, os.SystemClock.uptimeMillis() + delayMillis);
            }
            sendMessageAtTime(msg, uptimeMillis) {
                msg.target = this;
                return os.MessageQueue.enqueueMessage(msg, uptimeMillis);
            }
            sendMessageAtFrontOfQueue(msg) {
                return this.sendMessage(msg);
            }
            removeMessages(what, object) {
                os.MessageQueue.removeMessages(this, what, object);
            }
            removeCallbacksAndMessages(token) {
                os.MessageQueue.removeCallbacksAndMessages(this, token);
            }
            hasMessages(what, object) {
                return os.MessageQueue.hasMessages(this, what, object);
            }
            static getPostMessage(r, token) {
                let m = os.Message.obtain();
                m.obj = token;
                m.callback = r;
                return m;
            }
        }
        os.Handler = Handler;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="../../util/SparseArray.ts"/>
///<reference path="../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../util/StateSet.ts"/>
var android;
(function (android) {
    var content;
    (function (content) {
        var res;
        (function (res) {
            var SparseArray = android.util.SparseArray;
            var StateSet = android.util.StateSet;
            var WeakReference = java.lang.ref.WeakReference;
            class ColorStateList {
                constructor(states, colors) {
                    this.mDefaultColor = 0xffff0000;
                    this.mStateSpecs = states;
                    this.mColors = colors;
                    if (states.length > 0) {
                        this.mDefaultColor = colors[0];
                        for (let i = 0; i < states.length; i++) {
                            if (states[i].length == 0) {
                                this.mDefaultColor = colors[i];
                            }
                        }
                    }
                }
                static valueOf(color) {
                    let ref = ColorStateList.sCache.get(color);
                    let csl = ref != null ? ref.get() : null;
                    if (csl != null) {
                        return csl;
                    }
                    csl = new ColorStateList(ColorStateList.EMPTY, [color]);
                    ColorStateList.sCache.put(color, new WeakReference(csl));
                    return csl;
                }
                withAlpha(alpha) {
                    let colors = new Array(this.mColors.length);
                    let len = colors.length;
                    for (let i = 0; i < len; i++) {
                        colors[i] = (this.mColors[i] & 0xFFFFFF) | (alpha << 24);
                    }
                    return new ColorStateList(this.mStateSpecs, colors);
                }
                isStateful() {
                    return this.mStateSpecs.length > 1;
                }
                getColorForState(stateSet, defaultColor) {
                    const setLength = this.mStateSpecs.length;
                    for (let i = 0; i < setLength; i++) {
                        let stateSpec = this.mStateSpecs[i];
                        if (StateSet.stateSetMatches(stateSpec, stateSet)) {
                            return this.mColors[i];
                        }
                    }
                    return defaultColor;
                }
                getDefaultColor() {
                    return this.mDefaultColor;
                }
                toString() {
                    return "ColorStateList{" +
                        "mStateSpecs=" + JSON.stringify(this.mStateSpecs) +
                        "mColors=" + JSON.stringify(this.mColors) +
                        "mDefaultColor=" + this.mDefaultColor + '}';
                }
            }
            ColorStateList.EMPTY = [[]];
            ColorStateList.sCache = new SparseArray();
            res.ColorStateList = ColorStateList;
        })(res = content.res || (content.res = {}));
    })(content = android.content || (android.content = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/27.
 */
///<reference path="DisplayMetrics.ts"/>
///<reference path="../content/res/Resources.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        class TypedValue {
            static initUnit() {
                this.initUnit = null;
                let temp = document.createElement('div');
                document.body.appendChild(temp);
                temp.style.height = 100 + TypedValue.COMPLEX_UNIT_PT;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_PT, temp.offsetHeight / 100);
                temp.style.height = 1 + TypedValue.COMPLEX_UNIT_IN;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_IN, temp.offsetHeight);
                temp.style.height = 100 + TypedValue.COMPLEX_UNIT_MM;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_MM, temp.offsetHeight / 100);
                temp.style.height = 10 + TypedValue.COMPLEX_UNIT_EM;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_EM, temp.offsetHeight / 10);
                temp.style.height = 10 + TypedValue.COMPLEX_UNIT_REM;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_REM, temp.offsetHeight / 10);
                document.body.removeChild(temp);
            }
            static applyDimension(unit, size, dm) {
                let scale = 1;
                if (unit === TypedValue.COMPLEX_UNIT_DP || unit === TypedValue.COMPLEX_UNIT_DIP || unit === TypedValue.COMPLEX_UNIT_SP) {
                    scale = dm.density;
                }
                else {
                    scale = TypedValue.UNIT_SCALE_MAP.get(unit) || 1;
                }
                return size * scale;
            }
            static complexToDimensionPixelSize(valueWithUnit, baseValue = 0, metrics = android.content.res.Resources.getDisplayMetrics()) {
                if (this.initUnit)
                    this.initUnit();
                if (valueWithUnit === undefined || valueWithUnit === null) {
                    throw Error('complexToDimensionPixelSize error: valueWithUnit is ' + valueWithUnit);
                }
                if (valueWithUnit === '' + (Number.parseInt(valueWithUnit)))
                    return Number.parseInt(valueWithUnit);
                if (typeof valueWithUnit !== 'string')
                    valueWithUnit = valueWithUnit + "";
                let scale = 1;
                if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_PX)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_PX, "");
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_DP)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_DP, "");
                    scale = metrics.density;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_DIP)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_DIP, "");
                    scale = metrics.density;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_SP)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_SP, "");
                    scale = metrics.density * (TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_SP) || 1);
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_PT)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_PT, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_PT) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_IN)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_IN, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_IN) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_MM)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_MM, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_MM) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_EM)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_EM, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_EM) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_REM)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_REM, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_REM) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_VH)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_VH, "");
                    scale = metrics.heightPixels / 100;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_VW)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_VW, "");
                    scale = metrics.widthPixels / 100;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_FRACTION)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_FRACTION, "");
                    scale = Number.parseInt(valueWithUnit) / 100;
                    if (Number.isNaN(scale))
                        return 0;
                    valueWithUnit = baseValue;
                }
                let value = Number.parseFloat(valueWithUnit);
                if (Number.isNaN(value))
                    throw Error('complexToDimensionPixelSize error: ' + valueWithUnit);
                return value * scale;
            }
        }
        TypedValue.COMPLEX_UNIT_PX = 'px';
        TypedValue.COMPLEX_UNIT_DP = 'dp';
        TypedValue.COMPLEX_UNIT_DIP = 'dip';
        TypedValue.COMPLEX_UNIT_SP = 'sp';
        TypedValue.COMPLEX_UNIT_PT = 'pt';
        TypedValue.COMPLEX_UNIT_IN = 'in';
        TypedValue.COMPLEX_UNIT_MM = 'mm';
        TypedValue.COMPLEX_UNIT_EM = 'em';
        TypedValue.COMPLEX_UNIT_REM = 'rem';
        TypedValue.COMPLEX_UNIT_VH = 'vh';
        TypedValue.COMPLEX_UNIT_VW = 'vw';
        TypedValue.COMPLEX_UNIT_FRACTION = '%';
        TypedValue.UNIT_SCALE_MAP = new Map();
        util.TypedValue = TypedValue;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class LinearInterpolator {
                getInterpolation(input) {
                    return input;
                }
            }
            animation.LinearInterpolator = LinearInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="../../os/SystemClock.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            var SystemClock = android.os.SystemClock;
            class AnimationUtils {
                static currentAnimationTimeMillis() {
                    return SystemClock.uptimeMillis();
                }
            }
            animation.AnimationUtils = AnimationUtils;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var util;
    (function (util) {
        class LayoutDirection {
        }
        LayoutDirection.LTR = 0;
        LayoutDirection.RTL = 1;
        LayoutDirection.INHERIT = 2;
        LayoutDirection.LOCALE = 3;
        util.LayoutDirection = LayoutDirection;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/3.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/util/StateSet.ts"/>
var androidui;
(function (androidui) {
    var attr;
    (function (attr) {
        class StateAttr {
            constructor(state) {
                this.attributes = new Map();
                this.stateSpec = state.sort();
            }
            setAttr(name, value) {
                this.attributes.set(name, value);
            }
            hasAttr(name) {
                return this.attributes.has(name);
            }
            getAttrMap() {
                return this.attributes;
            }
            putAll(stateAttr) {
                for (let [key, value] of stateAttr.attributes.entries()) {
                    this.attributes.set(key, value);
                }
            }
            isStateEquals(state) {
                if (!state)
                    return false;
                return this.stateSpec + '' === state.sort() + '';
            }
            isStateMatch(state) {
                return android.util.StateSet.stateSetMatches(this.stateSpec, state);
            }
            mergeRemovedFrom(another) {
                if (!another)
                    return this.attributes;
                let removed = new Map(another.attributes);
                for (let key of this.attributes.keys())
                    removed.delete(key);
                let merge = new Map(this.attributes);
                for (let key of removed.keys())
                    merge.set(key, null);
                return merge;
            }
            static parseStateAttrName(stateDesc) {
                if (stateDesc.startsWith('android:'))
                    stateDesc = stateDesc.substring('android:'.length);
                if (stateDesc.startsWith('state_'))
                    stateDesc = stateDesc.substring('state_'.length);
                let stateSet = new Set();
                let stateParts = stateDesc.split('&');
                for (let part of stateParts) {
                    let sign = 1;
                    while (part.startsWith('!')) {
                        sign *= -1;
                        part = part.substring(1);
                    }
                    let stateValue = android.view.View['VIEW_STATE_' + part.toUpperCase()];
                    if (stateValue !== undefined) {
                        stateSet.add(stateValue * sign);
                    }
                }
                return stateSet;
            }
        }
        attr.StateAttr = StateAttr;
    })(attr = androidui.attr || (androidui.attr = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/3.
 */
///<reference path="StateAttr.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/util/StateSet.ts"/>
var androidui;
(function (androidui) {
    var attr;
    (function (attr_1) {
        class StateAttrList {
            constructor(view) {
                this.list = new Array(0);
                this.match_list = new Array(0);
                this.mView = view;
                this.list.push(new attr_1.StateAttr([]));
                this._initStyleAttributes(view.bindElement, []);
            }
            _initStyleAttributes(ele, inParseState) {
                let attributes = Array.from(ele.attributes);
                attributes.forEach((attr) => {
                    if (attr.name === 'style' || attr.name === 'android:style') {
                        this._initStyleAttr(attr, ele, inParseState);
                    }
                });
                attributes.forEach((attr) => {
                    if (attr.name === 'style' || attr.name === 'android:style') {
                        return;
                    }
                    if (attr.name.startsWith('android:state_') || attr.name.startsWith('state_')) {
                        return;
                    }
                    this._initStyleAttr(attr, ele, inParseState);
                });
                attributes.forEach((attr) => {
                    if (attr.name.startsWith('android:state_') || attr.name.startsWith('state_')) {
                        this._initStyleAttr(attr, ele, inParseState);
                    }
                });
                this.list_reverse = this.list.concat().reverse();
            }
            _initStyleAttr(attr, ele, inParseState) {
                let attrName = attr.name;
                if (!attrName.startsWith('android:'))
                    return;
                attrName = attrName.substring('android:'.length);
                if (attrName === 'id')
                    return;
                let attrValue = attr.value;
                if (attrName.startsWith('state_')) {
                    let newStateSet = attr_1.StateAttr.parseStateAttrName(attrName);
                    inParseState = inParseState.concat(Array.from(newStateSet));
                    inParseState = Array.from(new Set(inParseState)).sort();
                }
                let _stateAttr = this.optStateAttr(inParseState);
                if (attrName.startsWith('state_') || attrName === 'style') {
                    if (attrValue.startsWith('@')) {
                        let reference = this.mView.getResources().getReference(attrValue, false);
                        if (reference)
                            this._initStyleAttributes(reference, inParseState);
                    }
                    else {
                        for (let part of attrValue.split(';')) {
                            let [name, value] = part.split(':');
                            value = value ? this.mView.getResources().getString(value) : '';
                            if (name)
                                _stateAttr.setAttr(name.trim().toLowerCase(), value);
                        }
                    }
                }
                else {
                    attrValue = this.mView.getResources().getString(attrValue);
                    _stateAttr.setAttr(attrName, attrValue);
                }
            }
            getDefaultStateAttr() {
                return this.getStateAttr(StateAttrList.EmptyArray);
            }
            getStateAttr(state) {
                for (let stateAttr of this.list) {
                    if (stateAttr.isStateEquals(state))
                        return stateAttr;
                }
            }
            optStateAttr(state) {
                let stateAttr = this.getStateAttr(state);
                if (!stateAttr) {
                    stateAttr = new attr_1.StateAttr(state);
                    this.list.splice(0, 0, stateAttr);
                }
                return stateAttr;
            }
            getMatchedAttr(state) {
                for (let stateAttr of this.match_list) {
                    if (stateAttr.isStateEquals(state))
                        return stateAttr;
                }
                let matchedAttr = new attr_1.StateAttr(state);
                for (let stateAttr of this.list_reverse) {
                    if (stateAttr.isStateMatch(state))
                        matchedAttr.putAll(stateAttr);
                }
                this.match_list.push(matchedAttr);
                return matchedAttr;
            }
        }
        StateAttrList.EmptyArray = [];
        attr_1.StateAttrList = StateAttrList;
    })(attr = androidui.attr || (androidui.attr = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/26.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/graphics/drawable/ColorDrawable.ts"/>
///<reference path="../../android/content/res/ColorStateList.ts"/>
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/content/Context.ts"/>
var androidui;
(function (androidui) {
    var attr;
    (function (attr) {
        var Gravity = android.view.Gravity;
        var Drawable = android.graphics.drawable.Drawable;
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var Color = android.graphics.Color;
        var ColorStateList = android.content.res.ColorStateList;
        var Resources = android.content.res.Resources;
        var TypedValue = android.util.TypedValue;
        class AttrBinder {
            constructor(host) {
                this.attrChangeMap = new Map();
                this.attrStashMap = new Map();
                this.objectRefs = [];
                this.host = host;
            }
            addAttr(attrName, onAttrChange, stashAttrValueWhenStateChange) {
                if (!attrName)
                    return;
                attrName = attrName.toLowerCase();
                if (onAttrChange)
                    this.attrChangeMap.set(attrName, onAttrChange);
                if (stashAttrValueWhenStateChange)
                    this.attrStashMap.set(attrName, stashAttrValueWhenStateChange);
            }
            onAttrChange(attrName, attrValue, context) {
                this.mContext = context;
                if (!attrName)
                    return;
                attrName = attrName.toLowerCase();
                let onAttrChangeCall = this.attrChangeMap.get(attrName);
                if (onAttrChangeCall)
                    onAttrChangeCall.call(this.host, attrValue);
            }
            getAttrValue(attrName) {
                if (!attrName)
                    return null;
                attrName = attrName.toLowerCase();
                let getAttrCall = this.attrStashMap.get(attrName);
                if (getAttrCall) {
                    let value = getAttrCall.call(this.host);
                    if (value == null)
                        return null;
                    if (typeof value === "number")
                        return value + '';
                    if (typeof value === "boolean")
                        return value + '';
                    if (typeof value === "string")
                        return value;
                    return this.setRefObject(value);
                }
                return null;
            }
            getRefObject(ref, recycel = true) {
                if (ref && ref.startsWith('@ref/')) {
                    ref = ref.substring(5);
                    let index = Number.parseInt(ref);
                    if (Number.isInteger(index)) {
                        let obj = this.objectRefs[index];
                        if (recycel)
                            this.objectRefs[index] = null;
                        return obj;
                    }
                }
            }
            setRefObject(obj) {
                let length = this.objectRefs.length;
                for (let i = 0; i < length; i++) {
                    if (this.objectRefs[i] == null) {
                        this.objectRefs[i] = obj;
                        return '@ref/' + i;
                    }
                }
                this.objectRefs.push(obj);
                return '@ref/' + length;
            }
            parsePaddingMarginLTRB(value) {
                value = (value + '');
                let parts = [];
                for (let part of value.split(' ')) {
                    if (part)
                        parts.push(part);
                }
                switch (parts.length) {
                    case 1: return [parts[0], parts[0], parts[0], parts[0]];
                    case 2: return [parts[1], parts[0], parts[1], parts[0]];
                    case 3: return [parts[1], parts[0], parts[1], parts[2]];
                    case 4: return [parts[3], parts[0], parts[1], parts[2]];
                }
                throw Error('not a padding or margin value : ' + value);
            }
            parseBoolean(value, defaultValue = true) {
                if (value === false || value === 'false' || value === '0')
                    return false;
                else if (value === true || value === 'true' || value === '1' || value === '')
                    return true;
                return defaultValue;
            }
            parseGravity(s, defaultValue = Gravity.NO_GRAVITY) {
                let gravity = Number.parseInt(s);
                if (Number.isInteger(gravity))
                    return gravity;
                gravity = Gravity.NO_GRAVITY;
                try {
                    let parts = s.split("|");
                    parts.forEach((part) => {
                        let g = Gravity[part.toUpperCase()];
                        if (Number.isInteger(g))
                            gravity |= g;
                    });
                }
                catch (e) {
                    console.error(e);
                }
                if (Number.isNaN(gravity) || gravity === Gravity.NO_GRAVITY)
                    gravity = defaultValue;
                return gravity;
            }
            parseDrawable(s) {
                if (!s)
                    return null;
                if (s instanceof Drawable)
                    return s;
                if (s.startsWith('@')) {
                    let refObj = this.getRefObject(s);
                    if (refObj)
                        return refObj;
                    return Resources.getSystem().getDrawable(s);
                }
                else {
                    try {
                        let color = this.parseColor(s);
                        return new ColorDrawable(color);
                    }
                    catch (e) {
                        console.log(e);
                    }
                }
                return null;
            }
            parseColor(value, defaultValue) {
                let color = Number.parseInt(value);
                if (Number.isInteger(color))
                    return color;
                try {
                    if (value.startsWith('rgb(')) {
                        value = value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));
                        let parts = value.split(',');
                        return Color.rgb(Number.parseInt(parts[0]), Number.parseInt(parts[1]), Number.parseInt(parts[2]));
                    }
                    else if (value.startsWith('rgba(')) {
                        value = value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));
                        let parts = value.split(',');
                        return Color.rgba(Number.parseInt(parts[0]), Number.parseInt(parts[1]), Number.parseInt(parts[2]), Number.parseFloat(parts[3]) * 255);
                    }
                    else if (value.startsWith('@')) {
                        return Resources.getSystem().getColor(value);
                    }
                    else {
                        if (value.startsWith('#') && value.length === 4) {
                            value = '#' + value[1] + value[1] + value[2] + value[2] + value[2] + value[2];
                        }
                        return Color.parseColor(value);
                    }
                }
                catch (e) {
                    if (defaultValue == null)
                        throw e;
                }
                return defaultValue;
            }
            parseColorList(value) {
                if (!value)
                    return null;
                if (value instanceof ColorStateList)
                    return value;
                if (value.startsWith('@')) {
                    let refObj = this.getRefObject(value);
                    if (refObj)
                        return refObj;
                    return Resources.getSystem().getColorStateList(value);
                }
                else {
                    try {
                        let color = this.parseColor(value);
                        return ColorStateList.valueOf(color);
                    }
                    catch (e) {
                        console.log(e);
                    }
                }
                return null;
            }
            parseNumber(value, defaultValue = 0, baseValue = 0) {
                if (typeof value === 'string' && value.startsWith('@')) {
                    value = Resources.getSystem().getString(value);
                }
                try {
                    return TypedValue.complexToDimensionPixelSize(value, baseValue);
                }
                catch (e) {
                    return defaultValue;
                }
            }
            parseString(value, defaultValue) {
                if (typeof value === 'string') {
                    if (value.startsWith('@')) {
                        return Resources.getSystem().getString(value);
                    }
                    return value;
                }
                return defaultValue;
            }
            parseTextArray(value) {
                value += '';
                if (value.startsWith('@')) {
                    return Resources.getSystem().getTextArray(value);
                }
                else {
                    try {
                        let json = JSON.parse(value);
                        if (json instanceof Array)
                            return json;
                    }
                    catch (e) {
                    }
                }
                return null;
            }
        }
        attr.AttrBinder = AttrBinder;
    })(attr = androidui.attr || (androidui.attr = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/12/1.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/graphics/Canvas.ts"/>
var androidui;
(function (androidui) {
    var util;
    (function (util) {
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var Color = android.graphics.Color;
        class PerformanceAdjuster {
            static noCanvasMode() {
                android.graphics.Canvas.prototype = HackCanvas.prototype;
                android.view.View.prototype.onDrawVerticalScrollBar =
                    function (canvas, scrollBar, l, t, r, b) {
                        let scrollBarEl = this.bindElement['VerticalScrollBar'];
                        if (!scrollBarEl) {
                            scrollBarEl = document.createElement('div');
                            this.bindElement['VerticalScrollBar'] = scrollBarEl;
                            scrollBarEl.style.zIndex = '9';
                            scrollBarEl.style.position = 'absolute';
                            scrollBarEl.style.background = 'black';
                            scrollBarEl.style.left = '0px';
                            scrollBarEl.style.top = '0px';
                            this.bindElement.appendChild(scrollBarEl);
                        }
                        let height = b - t;
                        let width = r - l;
                        let size = height;
                        let thickness = width;
                        let extent = this.mScrollCache.scrollBar.mExtent;
                        let range = this.mScrollCache.scrollBar.mRange;
                        let length = Math.round(size * extent / range);
                        let offset = Math.round((size - length) * this.mScrollCache.scrollBar.mOffset / (range - extent));
                        if (t < 0)
                            t = 0;
                        if (offset < 0)
                            offset = 0;
                        scrollBarEl.style.transform = scrollBarEl.style.webkitTransform = `translate(${l}px, ${t + offset}px)`;
                        scrollBarEl.style.width = (r - l) / 2 + 'px';
                        scrollBarEl.style.height = length + 'px';
                        scrollBarEl.style.opacity = this.mScrollCache.scrollBar.mVerticalThumb.getAlpha() / 255 + '';
                    };
                const oldSetBackground = android.view.View.prototype.setBackground;
                android.view.View.prototype.setBackground = function (drawable) {
                    oldSetBackground.call(this, drawable);
                    if (drawable instanceof ColorDrawable) {
                        this.bindElement.style.background = Color.toRGBAFunc(this.mBackground.getColor());
                    }
                };
            }
        }
        util.PerformanceAdjuster = PerformanceAdjuster;
        class HackCanvas extends android.graphics.Canvas {
            init() {
            }
            recycle() {
            }
            translate(dx, dy) {
            }
            scale(sx, sy, px, py) {
            }
            rotate(degrees, px, py) {
            }
            drawRGB(r, g, b) {
            }
            drawARGB(a, r, g, b) {
            }
            drawColor(color) {
            }
            clearColor() {
            }
            save() {
                return 1;
            }
            restore() {
            }
            restoreToCount(saveCount) {
            }
            getSaveCount() {
                return 1;
            }
            clipRect(...args) {
                return false;
            }
            getClipBounds(bounds) {
                return null;
            }
            quickReject(...args) {
                return false;
            }
            drawCanvas(canvas, offsetX, offsetY) {
            }
            drawRect(...args) {
            }
            drawText(text, x, y, paint) {
            }
        }
    })(util = androidui.util || (androidui.util = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/12/11.
 */
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="NetImage.ts"/>
var androidui;
(function (androidui) {
    var image;
    (function (image_1) {
        var Paint = android.graphics.Paint;
        var Rect = android.graphics.Rect;
        var Drawable = android.graphics.drawable.Drawable;
        class NetDrawable extends Drawable {
            constructor(src, paint, overrideImageRatio) {
                super();
                this.mImageWidth = -1;
                this.mImageHeight = -1;
                this.mTmpTileBound = new Rect();
                let image;
                if (src instanceof image_1.NetImage) {
                    image = src;
                    if (overrideImageRatio)
                        image.mOverrideImageRatio = overrideImageRatio;
                }
                else {
                    image = new image_1.NetImage(src, overrideImageRatio);
                }
                image.addLoadListener(() => this.onLoad(), () => this.onError());
                let imageRatio = image.getImageRatio();
                this.mImageWidth = Math.floor(image.width / imageRatio * android.content.res.Resources.getDisplayMetrics().density);
                this.mImageHeight = Math.floor(image.height / imageRatio * android.content.res.Resources.getDisplayMetrics().density);
                this.mState = new State(image, paint);
            }
            draw(canvas) {
                if (!this.isImageSizeEmpty()) {
                    let emptyTileX = this.mTileModeX == null || this.mTileModeX == NetDrawable.TileMode.DEFAULT;
                    let emptyTileY = this.mTileModeY == null || this.mTileModeY == NetDrawable.TileMode.DEFAULT;
                    if (emptyTileX && emptyTileY) {
                        canvas.drawImage(this.mState.mImage, null, this.getBounds(), this.mState.paint);
                    }
                    else {
                        this.drawTile(canvas);
                    }
                }
            }
            drawTile(canvas) {
                let imageWidth = this.mImageWidth;
                let imageHeight = this.mImageHeight;
                if (imageHeight <= 0 || imageWidth <= 0)
                    return;
                let tileX = this.mTileModeX;
                let tileY = this.mTileModeY;
                let bound = this.getBounds();
                let tmpBound = this.mTmpTileBound;
                tmpBound.setEmpty();
                function drawColumn() {
                    if (tileY === NetDrawable.TileMode.REPEAT) {
                        tmpBound.bottom = imageHeight;
                        while (tmpBound.isEmpty() || tmpBound.intersects(bound)) {
                            canvas.drawImage(this.mState.mImage, null, tmpBound, this.mState.paint);
                            tmpBound.offset(0, imageHeight);
                        }
                    }
                    else {
                        tmpBound.bottom = bound.height();
                        canvas.drawImage(this.mState.mImage, null, tmpBound, this.mState.paint);
                    }
                }
                if (tileX === NetDrawable.TileMode.REPEAT) {
                    tmpBound.right = imageWidth;
                    while (tmpBound.isEmpty() || tmpBound.intersects(bound)) {
                        drawColumn.call(this);
                        tmpBound.offset(imageWidth, -tmpBound.top);
                    }
                }
                else {
                    tmpBound.right = bound.width();
                    drawColumn.call(this);
                }
            }
            setAlpha(alpha) {
                this.mState.paint.setAlpha(alpha);
            }
            getAlpha() {
                return this.mState.paint.getAlpha();
            }
            getIntrinsicWidth() {
                return this.mImageWidth;
            }
            getIntrinsicHeight() {
                return this.mImageHeight;
            }
            onLoad() {
                let imageRatio = this.mState.mImage.getImageRatio();
                this.mImageWidth = Math.floor(this.mState.mImage.width / imageRatio * android.content.res.Resources.getDisplayMetrics().density);
                this.mImageHeight = Math.floor(this.mState.mImage.height / imageRatio * android.content.res.Resources.getDisplayMetrics().density);
                if (this.mLoadListener)
                    this.mLoadListener.onLoad(this);
                this.invalidateSelf();
                this.notifySizeChangeSelf();
            }
            onError() {
                this.mImageWidth = this.mImageHeight = 0;
                if (this.mLoadListener)
                    this.mLoadListener.onError(this);
                this.invalidateSelf();
                this.notifySizeChangeSelf();
            }
            isImageSizeEmpty() {
                return this.mImageWidth <= 0 || this.mImageHeight <= 0;
            }
            getImage() {
                return this.mState.mImage;
            }
            setLoadListener(loadListener) {
                this.mLoadListener = loadListener;
            }
            setTileMode(tileX, tileY) {
                this.mTileModeX = tileX;
                this.mTileModeY = tileY;
                this.invalidateSelf();
            }
            getConstantState() {
                return this.mState;
            }
        }
        image_1.NetDrawable = NetDrawable;
        (function (NetDrawable) {
            (function (TileMode) {
                TileMode[TileMode["DEFAULT"] = 0] = "DEFAULT";
                TileMode[TileMode["REPEAT"] = 1] = "REPEAT";
            })(NetDrawable.TileMode || (NetDrawable.TileMode = {}));
            var TileMode = NetDrawable.TileMode;
        })(NetDrawable = image_1.NetDrawable || (image_1.NetDrawable = {}));
        class State {
            constructor(image, paint = new Paint()) {
                this.mImage = image;
                this.paint = new Paint();
                if (paint != null)
                    this.paint.set(paint);
            }
            newDrawable() {
                return new NetDrawable(this.mImage, this.paint);
            }
        }
    })(image = androidui.image || (androidui.image = {}));
})(androidui || (androidui = {}));
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../util/Log.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var SystemClock = android.os.SystemClock;
        var Log = android.util.Log;
        const DEBUG = false;
        const TAG = "KeyEvent";
        class KeyEvent {
            constructor() {
                this._downingKeyEventMap = new Map();
            }
            static obtain(action, code) {
                let ev = new KeyEvent();
                ev.mDownTime = SystemClock.uptimeMillis();
                ev.mEventTime = SystemClock.uptimeMillis();
                ev.mAction = action;
                ev.mKeyCode = code;
                return ev;
            }
            initKeyEvent(keyEvent, action) {
                this.mEventTime = SystemClock.uptimeMillis();
                this.mKeyCode = keyEvent.keyCode;
                this.mAltKey = keyEvent.altKey;
                this.mShiftKey = keyEvent.shiftKey;
                this.mCtrlKey = keyEvent.ctrlKey;
                this.mMetaKey = keyEvent.metaKey;
                this.mIsTypingKey = (keyEvent['keyIdentifier'] + '').startsWith('U+');
                if (action === KeyEvent.ACTION_DOWN) {
                    this.mDownTime = SystemClock.uptimeMillis();
                    let keyEvents = this._downingKeyEventMap.get(keyEvent.keyCode);
                    if (keyEvents == null) {
                        keyEvents = [];
                        this._downingKeyEventMap.set(keyEvent.keyCode, keyEvents);
                    }
                    keyEvents.push(keyEvent);
                }
                else if (action === KeyEvent.ACTION_UP) {
                    this._downingKeyEventMap.delete(keyEvent.keyCode);
                }
                this.mAction = action;
            }
            static isConfirmKey(keyCode) {
                switch (keyCode) {
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_ENTER:
                        return true;
                    default:
                        return false;
                }
            }
            isAltPressed() {
                return this.mAltKey;
            }
            isShiftPressed() {
                return this.mShiftKey;
            }
            isCtrlPressed() {
                return this.mCtrlKey;
            }
            isMetaPressed() {
                return this.mMetaKey;
            }
            getAction() {
                return this.mAction;
            }
            startTracking() {
                this.mFlags |= KeyEvent.FLAG_START_TRACKING;
            }
            isTracking() {
                return (this.mFlags & KeyEvent.FLAG_TRACKING) != 0;
            }
            isLongPress() {
                return this.getRepeatCount() === 1;
            }
            getKeyCode() {
                return this.mKeyCode;
            }
            getRepeatCount() {
                let downArray = this._downingKeyEventMap.get(this.mKeyCode);
                return downArray ? downArray.length - 1 : 0;
            }
            getDownTime() {
                return this.mDownTime;
            }
            getEventTime() {
                return this.mEventTime;
            }
            dispatch(receiver, state, target) {
                switch (this.mAction) {
                    case KeyEvent.ACTION_DOWN: {
                        this.mFlags &= ~KeyEvent.FLAG_START_TRACKING;
                        if (DEBUG)
                            Log.v(TAG, "Key down to " + target + " in " + state
                                + ": " + this);
                        let res = receiver.onKeyDown(this.getKeyCode(), this);
                        if (state != null) {
                            if (res && this.getRepeatCount() == 0 && (this.mFlags & KeyEvent.FLAG_START_TRACKING) != 0) {
                                if (DEBUG)
                                    Log.v(TAG, "  Start tracking!");
                                state.startTracking(this, target);
                            }
                            else if (this.isLongPress() && state.isTracking(this)) {
                                if (receiver.onKeyLongPress(this.getKeyCode(), this)) {
                                    if (DEBUG)
                                        Log.v(TAG, "  Clear from long press!");
                                    state.performedLongPress(this);
                                    res = true;
                                }
                            }
                        }
                        return res;
                    }
                    case KeyEvent.ACTION_UP:
                        if (DEBUG)
                            Log.v(TAG, "Key up to " + target + " in " + state
                                + ": " + this);
                        if (state != null) {
                            state.handleUpEvent(this);
                        }
                        return receiver.onKeyUp(this.getKeyCode(), this);
                }
                return false;
            }
            hasNoModifiers() {
                if (this.isAltPressed())
                    return false;
                if (this.isShiftPressed())
                    return false;
                if (this.isCtrlPressed())
                    return false;
                if (this.isMetaPressed())
                    return false;
                return true;
            }
            hasModifiers(modifiers) {
                if ((modifiers & KeyEvent.META_ALT_ON) === KeyEvent.META_ALT_ON && this.isAltPressed())
                    return true;
                if ((modifiers & KeyEvent.META_SHIFT_ON) === KeyEvent.META_SHIFT_ON && this.isShiftPressed())
                    return true;
                if ((modifiers & KeyEvent.META_META_ON) === KeyEvent.META_META_ON && this.isMetaPressed())
                    return true;
                if ((modifiers & KeyEvent.META_CTRL_ON) === KeyEvent.META_CTRL_ON && this.isCtrlPressed())
                    return true;
            }
            getMetaState() {
                let meta = 0;
                if (this.isAltPressed())
                    meta |= KeyEvent.META_ALT_ON;
                if (this.isShiftPressed())
                    meta |= KeyEvent.META_SHIFT_ON;
                if (this.isCtrlPressed())
                    meta |= KeyEvent.META_CTRL_ON;
                if (this.isMetaPressed())
                    meta |= KeyEvent.META_META_ON;
                return meta;
            }
            toString() {
                return JSON.stringify(this);
            }
            isCanceled() {
                return false;
            }
            static actionToString(action) {
                switch (action) {
                    case KeyEvent.ACTION_DOWN:
                        return "ACTION_DOWN";
                    case KeyEvent.ACTION_UP:
                        return "ACTION_UP";
                    default:
                        return '' + (action);
                }
            }
            static keyCodeToString(keyCode) {
                return String.fromCharCode(keyCode);
            }
        }
        KeyEvent.KEYCODE_DPAD_UP = 38;
        KeyEvent.KEYCODE_DPAD_DOWN = 40;
        KeyEvent.KEYCODE_DPAD_LEFT = 37;
        KeyEvent.KEYCODE_DPAD_RIGHT = 39;
        KeyEvent.KEYCODE_DPAD_CENTER = 13;
        KeyEvent.KEYCODE_ENTER = 13;
        KeyEvent.KEYCODE_TAB = 9;
        KeyEvent.KEYCODE_SPACE = 32;
        KeyEvent.KEYCODE_ESCAPE = 27;
        KeyEvent.KEYCODE_PAGE_UP = 33;
        KeyEvent.KEYCODE_PAGE_DOWN = 34;
        KeyEvent.KEYCODE_MOVE_HOME = 36;
        KeyEvent.KEYCODE_MOVE_END = 35;
        KeyEvent.KEYCODE_BACK = -1;
        KeyEvent.ACTION_DOWN = 0;
        KeyEvent.ACTION_UP = 1;
        KeyEvent.META_ALT_ON = 0x02;
        KeyEvent.META_SHIFT_ON = 0x1;
        KeyEvent.META_CTRL_ON = 0x1000;
        KeyEvent.META_META_ON = 0x10000;
        KeyEvent.FLAG_CANCELED = 0x20;
        KeyEvent.FLAG_CANCELED_LONG_PRESS = 0x100;
        KeyEvent.FLAG_LONG_PRESS = 0x80;
        KeyEvent.FLAG_TRACKING = 0x200;
        KeyEvent.FLAG_START_TRACKING = 0x40000000;
        view.KeyEvent = KeyEvent;
        (function (KeyEvent) {
            class DispatcherState {
                constructor() {
                    this.mActiveLongPresses = new android.util.SparseArray();
                }
                reset(target) {
                    if (target == null) {
                        if (DEBUG)
                            Log.v(TAG, "Reset: " + this);
                        this.mDownKeyCode = 0;
                        this.mDownTarget = null;
                        this.mActiveLongPresses.clear();
                    }
                    else {
                        if (this.mDownTarget == target) {
                            if (DEBUG)
                                Log.v(TAG, "Reset in " + target + ": " + this);
                            this.mDownKeyCode = 0;
                            this.mDownTarget = null;
                        }
                    }
                }
                startTracking(event, target) {
                    if (event.getAction() != KeyEvent.ACTION_DOWN) {
                        throw new Error("Can only start tracking on a down event");
                    }
                    if (DEBUG)
                        Log.v(TAG, "Start trackingt in " + target + ": " + this);
                    this.mDownKeyCode = event.getKeyCode();
                    this.mDownTarget = target;
                }
                isTracking(event) {
                    return this.mDownKeyCode == event.getKeyCode();
                }
                performedLongPress(event) {
                    this.mActiveLongPresses.put(event.getKeyCode(), 1);
                }
                handleUpEvent(event) {
                    const keyCode = event.getKeyCode();
                    if (DEBUG)
                        Log.v(TAG, "Handle key up " + event + ": " + this);
                    let index = this.mActiveLongPresses.indexOfKey(keyCode);
                    if (index >= 0) {
                        if (DEBUG)
                            Log.v(TAG, "  Index: " + index);
                        event.mFlags |= KeyEvent.FLAG_CANCELED | KeyEvent.FLAG_CANCELED_LONG_PRESS;
                        this.mActiveLongPresses.removeAt(index);
                    }
                    if (this.mDownKeyCode == keyCode) {
                        if (DEBUG)
                            Log.v(TAG, "  Tracking!");
                        event.mFlags |= KeyEvent.FLAG_TRACKING;
                        this.mDownKeyCode = 0;
                        this.mDownTarget = null;
                    }
                }
            }
            KeyEvent.DispatcherState = DispatcherState;
        })(KeyEvent = view.KeyEvent || (view.KeyEvent = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/content/res/Resources.ts"/>
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/graphics/PixelFormat.ts"/>
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/view/View.ts"/>
///<reference path="../../../java/lang/System.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../../android/graphics/drawable/Drawable.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_3) {
            var PixelFormat = android.graphics.PixelFormat;
            var Rect = android.graphics.Rect;
            var System = java.lang.System;
            var Drawable = android.graphics.drawable.Drawable;
            class LayerDrawable extends Drawable {
                constructor(layers, state = null) {
                    super();
                    this.mOpacityOverride = PixelFormat.UNKNOWN;
                    this.mTmpRect = new Rect();
                    let _as = this.createConstantState(state);
                    this.mLayerState = _as;
                    if (_as.mNum > 0) {
                        this.ensurePadding();
                    }
                    if (layers != null) {
                        let length = layers.length;
                        let r = new Array(length);
                        for (let i = 0; i < length; i++) {
                            r[i] = new LayerDrawable.ChildDrawable();
                            r[i].mDrawable = layers[i];
                            layers[i].setCallback(this);
                        }
                        this.mLayerState.mNum = length;
                        this.mLayerState.mChildren = r;
                        this.ensurePadding();
                    }
                }
                createConstantState(state) {
                    return new LayerDrawable.LayerState(state, this);
                }
                addLayer(layer, id, left = 0, top = 0, right = 0, bottom = 0) {
                    const st = this.mLayerState;
                    let N = st.mChildren != null ? st.mChildren.length : 0;
                    let i = st.mNum;
                    if (i >= N) {
                        let nu = new Array(N + 10);
                        if (i > 0) {
                            System.arraycopy(st.mChildren, 0, nu, 0, i);
                        }
                        st.mChildren = nu;
                    }
                    let childDrawable = new LayerDrawable.ChildDrawable();
                    st.mChildren[i] = childDrawable;
                    childDrawable.mId = id;
                    childDrawable.mDrawable = layer;
                    childDrawable.mDrawable.setAutoMirrored(this.isAutoMirrored());
                    childDrawable.mInsetL = left;
                    childDrawable.mInsetT = top;
                    childDrawable.mInsetR = right;
                    childDrawable.mInsetB = bottom;
                    st.mNum++;
                    layer.setCallback(this);
                }
                findDrawableByLayerId(id) {
                    const layers = this.mLayerState.mChildren;
                    for (let i = this.mLayerState.mNum - 1; i >= 0; i--) {
                        if (layers[i].mId == id) {
                            return layers[i].mDrawable;
                        }
                    }
                    return null;
                }
                setId(index, id) {
                    this.mLayerState.mChildren[index].mId = id;
                }
                getNumberOfLayers() {
                    return this.mLayerState.mNum;
                }
                getDrawable(index) {
                    return this.mLayerState.mChildren[index].mDrawable;
                }
                getId(index) {
                    return this.mLayerState.mChildren[index].mId;
                }
                setDrawableByLayerId(id, drawable) {
                    const layers = this.mLayerState.mChildren;
                    for (let i = this.mLayerState.mNum - 1; i >= 0; i--) {
                        if (layers[i].mId == id) {
                            if (layers[i].mDrawable != null) {
                                if (drawable != null) {
                                    let bounds = layers[i].mDrawable.getBounds();
                                    drawable.setBounds(bounds);
                                }
                                layers[i].mDrawable.setCallback(null);
                            }
                            if (drawable != null) {
                                drawable.setCallback(this);
                            }
                            layers[i].mDrawable = drawable;
                            return true;
                        }
                    }
                    return false;
                }
                setLayerInset(index, l, t, r, b) {
                    let childDrawable = this.mLayerState.mChildren[index];
                    childDrawable.mInsetL = l;
                    childDrawable.mInsetT = t;
                    childDrawable.mInsetR = r;
                    childDrawable.mInsetB = b;
                }
                drawableSizeChange(who) {
                    let callback = this.getCallback();
                    if (callback != null && callback.drawableSizeChange) {
                        callback.drawableSizeChange(this);
                    }
                }
                invalidateDrawable(who) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                draw(canvas) {
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    for (let i = 0; i < N; i++) {
                        array[i].mDrawable.draw(canvas);
                    }
                }
                getPadding(padding) {
                    padding.left = 0;
                    padding.top = 0;
                    padding.right = 0;
                    padding.bottom = 0;
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    for (let i = 0; i < N; i++) {
                        this.reapplyPadding(i, array[i]);
                        padding.left += this.mPaddingL[i];
                        padding.top += this.mPaddingT[i];
                        padding.right += this.mPaddingR[i];
                        padding.bottom += this.mPaddingB[i];
                    }
                    return true;
                }
                setVisible(visible, restart) {
                    let changed = super.setVisible(visible, restart);
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    for (let i = 0; i < N; i++) {
                        array[i].mDrawable.setVisible(visible, restart);
                    }
                    return changed;
                }
                setDither(dither) {
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    for (let i = 0; i < N; i++) {
                        array[i].mDrawable.setDither(dither);
                    }
                }
                setAlpha(alpha) {
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    for (let i = 0; i < N; i++) {
                        array[i].mDrawable.setAlpha(alpha);
                    }
                }
                getAlpha() {
                    const array = this.mLayerState.mChildren;
                    if (this.mLayerState.mNum > 0) {
                        return array[0].mDrawable.getAlpha();
                    }
                    else {
                        return super.getAlpha();
                    }
                }
                setOpacity(opacity) {
                    this.mOpacityOverride = opacity;
                }
                getOpacity() {
                    if (this.mOpacityOverride != PixelFormat.UNKNOWN) {
                        return this.mOpacityOverride;
                    }
                    return this.mLayerState.getOpacity();
                }
                setAutoMirrored(mirrored) {
                    this.mLayerState.mAutoMirrored = mirrored;
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    for (let i = 0; i < N; i++) {
                        array[i].mDrawable.setAutoMirrored(mirrored);
                    }
                }
                isAutoMirrored() {
                    return this.mLayerState.mAutoMirrored;
                }
                isStateful() {
                    return this.mLayerState.isStateful();
                }
                onStateChange(state) {
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    let paddingChanged = false;
                    let changed = false;
                    for (let i = 0; i < N; i++) {
                        const r = array[i];
                        if (r.mDrawable.setState(state)) {
                            changed = true;
                        }
                        if (this.reapplyPadding(i, r)) {
                            paddingChanged = true;
                        }
                    }
                    if (paddingChanged) {
                        this.onBoundsChange(this.getBounds());
                    }
                    return changed;
                }
                onLevelChange(level) {
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    let paddingChanged = false;
                    let changed = false;
                    for (let i = 0; i < N; i++) {
                        const r = array[i];
                        if (r.mDrawable.setLevel(level)) {
                            changed = true;
                        }
                        if (this.reapplyPadding(i, r)) {
                            paddingChanged = true;
                        }
                    }
                    if (paddingChanged) {
                        this.onBoundsChange(this.getBounds());
                    }
                    return changed;
                }
                onBoundsChange(bounds) {
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    let padL = 0, padT = 0, padR = 0, padB = 0;
                    for (let i = 0; i < N; i++) {
                        const r = array[i];
                        r.mDrawable.setBounds(bounds.left + r.mInsetL + padL, bounds.top + r.mInsetT + padT, bounds.right - r.mInsetR - padR, bounds.bottom - r.mInsetB - padB);
                        padL += this.mPaddingL[i];
                        padR += this.mPaddingR[i];
                        padT += this.mPaddingT[i];
                        padB += this.mPaddingB[i];
                    }
                }
                getIntrinsicWidth() {
                    let width = -1;
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    let padL = 0, padR = 0;
                    for (let i = 0; i < N; i++) {
                        const r = array[i];
                        let w = r.mDrawable.getIntrinsicWidth() + r.mInsetL + r.mInsetR + padL + padR;
                        if (w > width) {
                            width = w;
                        }
                        padL += this.mPaddingL[i];
                        padR += this.mPaddingR[i];
                    }
                    return width;
                }
                getIntrinsicHeight() {
                    let height = -1;
                    const array = this.mLayerState.mChildren;
                    const N = this.mLayerState.mNum;
                    let padT = 0, padB = 0;
                    for (let i = 0; i < N; i++) {
                        const r = array[i];
                        let h = r.mDrawable.getIntrinsicHeight() + r.mInsetT + r.mInsetB + padT + padB;
                        if (h > height) {
                            height = h;
                        }
                        padT += this.mPaddingT[i];
                        padB += this.mPaddingB[i];
                    }
                    return height;
                }
                reapplyPadding(i, r) {
                    const rect = this.mTmpRect;
                    r.mDrawable.getPadding(rect);
                    if (rect.left != this.mPaddingL[i] || rect.top != this.mPaddingT[i] || rect.right != this.mPaddingR[i] || rect.bottom != this.mPaddingB[i]) {
                        this.mPaddingL[i] = rect.left;
                        this.mPaddingT[i] = rect.top;
                        this.mPaddingR[i] = rect.right;
                        this.mPaddingB[i] = rect.bottom;
                        return true;
                    }
                    return false;
                }
                ensurePadding() {
                    const N = this.mLayerState.mNum;
                    if (this.mPaddingL != null && this.mPaddingL.length >= N) {
                        return;
                    }
                    this.mPaddingL = new Array(N);
                    this.mPaddingT = new Array(N);
                    this.mPaddingR = new Array(N);
                    this.mPaddingB = new Array(N);
                }
                getConstantState() {
                    if (this.mLayerState.canConstantState()) {
                        return this.mLayerState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mLayerState = this.createConstantState(this.mLayerState);
                        const array = this.mLayerState.mChildren;
                        const N = this.mLayerState.mNum;
                        for (let i = 0; i < N; i++) {
                            array[i].mDrawable.mutate();
                        }
                        this.mMutated = true;
                    }
                    return this;
                }
            }
            drawable_3.LayerDrawable = LayerDrawable;
            (function (LayerDrawable) {
                class ChildDrawable {
                    constructor() {
                        this.mInsetL = 0;
                        this.mInsetT = 0;
                        this.mInsetR = 0;
                        this.mInsetB = 0;
                    }
                }
                LayerDrawable.ChildDrawable = ChildDrawable;
                class LayerState {
                    constructor(orig, owner) {
                        this.mNum = 0;
                        this.mHaveOpacity = false;
                        this.mOpacity = 0;
                        this.mHaveStateful = false;
                        if (orig != null) {
                            const origChildDrawable = orig.mChildren;
                            const N = orig.mNum;
                            this.mNum = N;
                            this.mChildren = new Array(N);
                            for (let i = 0; i < N; i++) {
                                const r = this.mChildren[i] = new LayerDrawable.ChildDrawable();
                                const or = origChildDrawable[i];
                                r.mDrawable = or.mDrawable.getConstantState().newDrawable();
                                r.mDrawable.setCallback(owner);
                                r.mInsetL = or.mInsetL;
                                r.mInsetT = or.mInsetT;
                                r.mInsetR = or.mInsetR;
                                r.mInsetB = or.mInsetB;
                                r.mId = or.mId;
                            }
                            this.mHaveOpacity = orig.mHaveOpacity;
                            this.mOpacity = orig.mOpacity;
                            this.mHaveStateful = orig.mHaveStateful;
                            this.mStateful = orig.mStateful;
                            this.mCheckedConstantState = this.mCanConstantState = true;
                            this.mAutoMirrored = orig.mAutoMirrored;
                        }
                        else {
                            this.mNum = 0;
                            this.mChildren = null;
                        }
                    }
                    newDrawable() {
                        return new LayerDrawable(null, this);
                    }
                    getOpacity() {
                        if (this.mHaveOpacity) {
                            return this.mOpacity;
                        }
                        const N = this.mNum;
                        let op = N > 0 ? this.mChildren[0].mDrawable.getOpacity() : PixelFormat.TRANSPARENT;
                        for (let i = 1; i < N; i++) {
                            op = Drawable.resolveOpacity(op, this.mChildren[i].mDrawable.getOpacity());
                        }
                        this.mOpacity = op;
                        this.mHaveOpacity = true;
                        return op;
                    }
                    isStateful() {
                        if (this.mHaveStateful) {
                            return this.mStateful;
                        }
                        let stateful = false;
                        const N = this.mNum;
                        for (let i = 0; i < N; i++) {
                            if (this.mChildren[i].mDrawable.isStateful()) {
                                stateful = true;
                                break;
                            }
                        }
                        this.mStateful = stateful;
                        this.mHaveStateful = true;
                        return stateful;
                    }
                    canConstantState() {
                        if (!this.mCheckedConstantState && this.mChildren != null) {
                            this.mCanConstantState = true;
                            const N = this.mNum;
                            for (let i = 0; i < N; i++) {
                                if (this.mChildren[i].mDrawable.getConstantState() == null) {
                                    this.mCanConstantState = false;
                                    break;
                                }
                            }
                            this.mCheckedConstantState = true;
                        }
                        return this.mCanConstantState;
                    }
                }
                LayerDrawable.LayerState = LayerState;
            })(LayerDrawable = drawable_3.LayerDrawable || (drawable_3.LayerDrawable = {}));
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/content/res/Resources.ts"/>
///<reference path="../../../android/util/TypedValue.ts"/>
///<reference path="../../../android/util/Log.ts"/>
///<reference path="../../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Drawable = android.graphics.drawable.Drawable;
            class RotateDrawable extends Drawable {
                constructor(rotateState) {
                    super();
                    this.mState = new RotateDrawable.RotateState(rotateState, this);
                }
                draw(canvas) {
                    let saveCount = canvas.save();
                    let bounds = this.mState.mDrawable.getBounds();
                    let w = bounds.right - bounds.left;
                    let h = bounds.bottom - bounds.top;
                    const st = this.mState;
                    let px = st.mPivotXRel ? (w * st.mPivotX) : st.mPivotX;
                    let py = st.mPivotYRel ? (h * st.mPivotY) : st.mPivotY;
                    canvas.rotate(st.mCurrentDegrees, px + bounds.left, py + bounds.top);
                    st.mDrawable.draw(canvas);
                    canvas.restoreToCount(saveCount);
                }
                getDrawable() {
                    return this.mState.mDrawable;
                }
                setAlpha(alpha) {
                    this.mState.mDrawable.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mState.mDrawable.getAlpha();
                }
                getOpacity() {
                    return this.mState.mDrawable.getOpacity();
                }
                drawableSizeChange(who) {
                    const callback = this.getCallback();
                    if (callback != null && callback.drawableSizeChange) {
                        callback.drawableSizeChange(this);
                    }
                }
                invalidateDrawable(who) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                getPadding(padding) {
                    return this.mState.mDrawable.getPadding(padding);
                }
                setVisible(visible, restart) {
                    this.mState.mDrawable.setVisible(visible, restart);
                    return super.setVisible(visible, restart);
                }
                isStateful() {
                    return this.mState.mDrawable.isStateful();
                }
                onStateChange(state) {
                    let changed = this.mState.mDrawable.setState(state);
                    this.onBoundsChange(this.getBounds());
                    return changed;
                }
                onLevelChange(level) {
                    this.mState.mDrawable.setLevel(level);
                    this.onBoundsChange(this.getBounds());
                    this.mState.mCurrentDegrees = this.mState.mFromDegrees + (this.mState.mToDegrees - this.mState.mFromDegrees) * (level / RotateDrawable.MAX_LEVEL);
                    this.invalidateSelf();
                    return true;
                }
                onBoundsChange(bounds) {
                    this.mState.mDrawable.setBounds(bounds.left, bounds.top, bounds.right, bounds.bottom);
                }
                getIntrinsicWidth() {
                    return this.mState.mDrawable.getIntrinsicWidth();
                }
                getIntrinsicHeight() {
                    return this.mState.mDrawable.getIntrinsicHeight();
                }
                getConstantState() {
                    if (this.mState.canConstantState()) {
                        return this.mState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mState.mDrawable.mutate();
                        this.mMutated = true;
                    }
                    return this;
                }
            }
            RotateDrawable.MAX_LEVEL = 10000.0;
            drawable.RotateDrawable = RotateDrawable;
            (function (RotateDrawable) {
                class RotateState {
                    constructor(source, owner) {
                        this.mPivotX = 0;
                        this.mPivotY = 0;
                        this.mFromDegrees = 0;
                        this.mToDegrees = 0;
                        this.mCurrentDegrees = 0;
                        if (source != null) {
                            this.mDrawable = source.mDrawable.getConstantState().newDrawable();
                            this.mDrawable.setCallback(owner);
                            this.mPivotXRel = source.mPivotXRel;
                            this.mPivotX = source.mPivotX;
                            this.mPivotYRel = source.mPivotYRel;
                            this.mPivotY = source.mPivotY;
                            this.mFromDegrees = this.mCurrentDegrees = source.mFromDegrees;
                            this.mToDegrees = source.mToDegrees;
                            this.mCanConstantState = this.mCheckedConstantState = true;
                        }
                    }
                    newDrawable() {
                        return new RotateDrawable(this);
                    }
                    canConstantState() {
                        if (!this.mCheckedConstantState) {
                            this.mCanConstantState = this.mDrawable.getConstantState() != null;
                            this.mCheckedConstantState = true;
                        }
                        return this.mCanConstantState;
                    }
                }
                RotateDrawable.RotateState = RotateState;
            })(RotateDrawable = drawable.RotateDrawable || (drawable.RotateDrawable = {}));
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class Float {
            static parseFloat(value) {
                return Number.parseFloat(value);
            }
        }
        Float.MIN_VALUE = Number.MIN_VALUE;
        Float.MAX_VALUE = Number.MAX_VALUE;
        lang.Float = Float;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/content/res/Resources.ts"/>
///<reference path="../../../android/util/TypedValue.ts"/>
///<reference path="../../../android/util/Log.ts"/>
///<reference path="../../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../../android/view/Gravity.ts"/>
///<reference path="../../../java/lang/Float.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_4) {
            var Rect = android.graphics.Rect;
            var Gravity = android.view.Gravity;
            var Drawable = android.graphics.drawable.Drawable;
            class ScaleDrawable extends Drawable {
                constructor(...args) {
                    super();
                    this.mTmpRect = new Rect();
                    if (args.length <= 1) {
                        this.mScaleState = new ScaleDrawable.ScaleState(args[0], this);
                        return;
                    }
                    let drawable = args[0];
                    let gravity = args[1];
                    let scaleWidth = args[2];
                    let scaleHeight = args[3];
                    this.mScaleState = new ScaleDrawable.ScaleState(null, this);
                    this.mScaleState.mDrawable = drawable;
                    this.mScaleState.mGravity = gravity;
                    this.mScaleState.mScaleWidth = scaleWidth;
                    this.mScaleState.mScaleHeight = scaleHeight;
                    if (drawable != null) {
                        drawable.setCallback(this);
                    }
                }
                getDrawable() {
                    return this.mScaleState.mDrawable;
                }
                drawableSizeChange(who) {
                    const callback = this.getCallback();
                    if (callback != null && callback.drawableSizeChange) {
                        callback.drawableSizeChange(this);
                    }
                }
                invalidateDrawable(who) {
                    if (this.getCallback() != null) {
                        this.getCallback().invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    if (this.getCallback() != null) {
                        this.getCallback().scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    if (this.getCallback() != null) {
                        this.getCallback().unscheduleDrawable(this, what);
                    }
                }
                draw(canvas) {
                    if (this.mScaleState.mDrawable.getLevel() != 0)
                        this.mScaleState.mDrawable.draw(canvas);
                }
                getPadding(padding) {
                    return this.mScaleState.mDrawable.getPadding(padding);
                }
                setVisible(visible, restart) {
                    this.mScaleState.mDrawable.setVisible(visible, restart);
                    return super.setVisible(visible, restart);
                }
                setAlpha(alpha) {
                    this.mScaleState.mDrawable.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mScaleState.mDrawable.getAlpha();
                }
                getOpacity() {
                    return this.mScaleState.mDrawable.getOpacity();
                }
                isStateful() {
                    return this.mScaleState.mDrawable.isStateful();
                }
                onStateChange(state) {
                    let changed = this.mScaleState.mDrawable.setState(state);
                    this.onBoundsChange(this.getBounds());
                    return changed;
                }
                onLevelChange(level) {
                    this.mScaleState.mDrawable.setLevel(level);
                    this.onBoundsChange(this.getBounds());
                    this.invalidateSelf();
                    return true;
                }
                onBoundsChange(bounds) {
                    const r = this.mTmpRect;
                    const min = this.mScaleState.mUseIntrinsicSizeAsMin;
                    let level = this.getLevel();
                    let w = bounds.width();
                    if (this.mScaleState.mScaleWidth > 0) {
                        const iw = min ? this.mScaleState.mDrawable.getIntrinsicWidth() : 0;
                        w -= Math.floor(((w - iw) * (10000 - level) * this.mScaleState.mScaleWidth / 10000));
                    }
                    let h = bounds.height();
                    if (this.mScaleState.mScaleHeight > 0) {
                        const ih = min ? this.mScaleState.mDrawable.getIntrinsicHeight() : 0;
                        h -= Math.floor(((h - ih) * (10000 - level) * this.mScaleState.mScaleHeight / 10000));
                    }
                    Gravity.apply(this.mScaleState.mGravity, w, h, bounds, r);
                    if (w > 0 && h > 0) {
                        this.mScaleState.mDrawable.setBounds(r.left, r.top, r.right, r.bottom);
                    }
                }
                getIntrinsicWidth() {
                    return this.mScaleState.mDrawable.getIntrinsicWidth();
                }
                getIntrinsicHeight() {
                    return this.mScaleState.mDrawable.getIntrinsicHeight();
                }
                getConstantState() {
                    if (this.mScaleState.canConstantState()) {
                        return this.mScaleState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mScaleState.mDrawable.mutate();
                        this.mMutated = true;
                    }
                    return this;
                }
            }
            drawable_4.ScaleDrawable = ScaleDrawable;
            (function (ScaleDrawable) {
                class ScaleState {
                    constructor(orig, owner) {
                        this.mScaleWidth = 0;
                        this.mScaleHeight = 0;
                        this.mGravity = 0;
                        if (orig != null) {
                            this.mDrawable = orig.mDrawable.getConstantState().newDrawable();
                            this.mDrawable.setCallback(owner);
                            this.mScaleWidth = orig.mScaleWidth;
                            this.mScaleHeight = orig.mScaleHeight;
                            this.mGravity = orig.mGravity;
                            this.mUseIntrinsicSizeAsMin = orig.mUseIntrinsicSizeAsMin;
                            this.mCheckedConstantState = this.mCanConstantState = true;
                        }
                    }
                    newDrawable() {
                        return new ScaleDrawable(this);
                    }
                    canConstantState() {
                        if (!this.mCheckedConstantState) {
                            this.mCanConstantState = this.mDrawable.getConstantState() != null;
                            this.mCheckedConstantState = true;
                        }
                        return this.mCanConstantState;
                    }
                }
                ScaleDrawable.ScaleState = ScaleState;
            })(ScaleDrawable = drawable_4.ScaleDrawable || (drawable_4.ScaleDrawable = {}));
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Animatable;
            (function (Animatable) {
                function isImpl(obj) {
                    return obj && obj['start'] && obj['stop'] && obj['isRunning'];
                }
                Animatable.isImpl = isImpl;
            })(Animatable = drawable.Animatable || (drawable.Animatable = {}));
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
///<reference path="../Rect.ts"/>
///<reference path="../PixelFormat.ts"/>
///<reference path="../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../util/StateSet.ts"/>
///<reference path="../../util/Log.ts"/>
///<reference path="../../util/SparseArray.ts"/>
///<reference path="../../os/SystemClock.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Rect = android.graphics.Rect;
            var PixelFormat = android.graphics.PixelFormat;
            var Log = android.util.Log;
            var SparseArray = android.util.SparseArray;
            var SystemClock = android.os.SystemClock;
            class DrawableContainer extends drawable.Drawable {
                constructor(...args) {
                    super(...args);
                    this.mAlpha = 0xFF;
                    this.mCurIndex = -1;
                    this.mMutated = false;
                    this.mEnterAnimationEnd = 0;
                    this.mExitAnimationEnd = 0;
                }
                draw(canvas) {
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.draw(canvas);
                    }
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.draw(canvas);
                    }
                }
                needsMirroring() {
                    return false && this.isAutoMirrored();
                }
                getPadding(padding) {
                    const r = this.mDrawableContainerState.getConstantPadding();
                    let result;
                    if (r != null) {
                        padding.set(r);
                        result = (r.left | r.top | r.bottom | r.right) != 0;
                    }
                    else {
                        if (this.mCurrDrawable != null) {
                            result = this.mCurrDrawable.getPadding(padding);
                        }
                        else {
                            result = super.getPadding(padding);
                        }
                    }
                    if (this.needsMirroring()) {
                        const left = padding.left;
                        const right = padding.right;
                        padding.left = right;
                        padding.right = left;
                    }
                    return result;
                }
                setAlpha(alpha) {
                    if (this.mAlpha != alpha) {
                        this.mAlpha = alpha;
                        if (this.mCurrDrawable != null) {
                            if (this.mEnterAnimationEnd == 0) {
                                this.mCurrDrawable.mutate().setAlpha(alpha);
                            }
                            else {
                                this.animate(false);
                            }
                        }
                    }
                }
                getAlpha() {
                    return this.mAlpha;
                }
                setDither(dither) {
                    if (this.mDrawableContainerState.mDither != dither) {
                        this.mDrawableContainerState.mDither = dither;
                        if (this.mCurrDrawable != null) {
                            this.mCurrDrawable.mutate().setDither(this.mDrawableContainerState.mDither);
                        }
                    }
                }
                setEnterFadeDuration(ms) {
                    this.mDrawableContainerState.mEnterFadeDuration = ms;
                }
                setExitFadeDuration(ms) {
                    this.mDrawableContainerState.mExitFadeDuration = ms;
                }
                onBoundsChange(bounds) {
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.setBounds(bounds);
                    }
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.setBounds(bounds);
                    }
                }
                isStateful() {
                    return this.mDrawableContainerState.isStateful();
                }
                setAutoMirrored(mirrored) {
                    this.mDrawableContainerState.mAutoMirrored = mirrored;
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.mutate().setAutoMirrored(this.mDrawableContainerState.mAutoMirrored);
                    }
                }
                isAutoMirrored() {
                    return this.mDrawableContainerState.mAutoMirrored;
                }
                jumpToCurrentState() {
                    let changed = false;
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.jumpToCurrentState();
                        this.mLastDrawable = null;
                        changed = true;
                    }
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.jumpToCurrentState();
                        this.mCurrDrawable.mutate().setAlpha(this.mAlpha);
                    }
                    if (this.mExitAnimationEnd != 0) {
                        this.mExitAnimationEnd = 0;
                        changed = true;
                    }
                    if (this.mEnterAnimationEnd != 0) {
                        this.mEnterAnimationEnd = 0;
                        changed = true;
                    }
                    if (changed) {
                        this.invalidateSelf();
                    }
                }
                onStateChange(state) {
                    if (this.mLastDrawable != null) {
                        return this.mLastDrawable.setState(state);
                    }
                    if (this.mCurrDrawable != null) {
                        return this.mCurrDrawable.setState(state);
                    }
                    return false;
                }
                onLevelChange(level) {
                    if (this.mLastDrawable != null) {
                        return this.mLastDrawable.setLevel(level);
                    }
                    if (this.mCurrDrawable != null) {
                        return this.mCurrDrawable.setLevel(level);
                    }
                    return false;
                }
                getIntrinsicWidth() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantWidth();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getIntrinsicWidth() : -1;
                }
                getIntrinsicHeight() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantHeight();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getIntrinsicHeight() : -1;
                }
                getMinimumWidth() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantMinimumWidth();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getMinimumWidth() : 0;
                }
                getMinimumHeight() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantMinimumHeight();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getMinimumHeight() : 0;
                }
                drawableSizeChange(who) {
                    let callback = this.getCallback();
                    if (who == this.mCurrDrawable && callback != null && callback.drawableSizeChange) {
                        callback.drawableSizeChange(this);
                    }
                }
                invalidateDrawable(who) {
                    if (who == this.mCurrDrawable && this.getCallback() != null) {
                        this.getCallback().invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    if (who == this.mCurrDrawable && this.getCallback() != null) {
                        this.getCallback().scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    if (who == this.mCurrDrawable && this.getCallback() != null) {
                        this.getCallback().unscheduleDrawable(this, what);
                    }
                }
                setVisible(visible, restart) {
                    let changed = super.setVisible(visible, restart);
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.setVisible(visible, restart);
                    }
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.setVisible(visible, restart);
                    }
                    return changed;
                }
                getOpacity() {
                    return this.mCurrDrawable == null || !this.mCurrDrawable.isVisible() ? PixelFormat.TRANSPARENT :
                        this.mDrawableContainerState.getOpacity();
                }
                selectDrawable(idx) {
                    if (idx == this.mCurIndex) {
                        return false;
                    }
                    const now = SystemClock.uptimeMillis();
                    if (DrawableContainer.DEBUG)
                        android.util.Log.i(DrawableContainer.TAG, toString() + " from " + this.mCurIndex + " to " + idx
                            + ": exit=" + this.mDrawableContainerState.mExitFadeDuration
                            + " enter=" + this.mDrawableContainerState.mEnterFadeDuration);
                    if (this.mDrawableContainerState.mExitFadeDuration > 0) {
                        if (this.mLastDrawable != null) {
                            this.mLastDrawable.setVisible(false, false);
                        }
                        if (this.mCurrDrawable != null) {
                            this.mLastDrawable = this.mCurrDrawable;
                            this.mExitAnimationEnd = now + this.mDrawableContainerState.mExitFadeDuration;
                        }
                        else {
                            this.mLastDrawable = null;
                            this.mExitAnimationEnd = 0;
                        }
                    }
                    else if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.setVisible(false, false);
                    }
                    if (idx >= 0 && idx < this.mDrawableContainerState.mNumChildren) {
                        const d = this.mDrawableContainerState.getChild(idx);
                        this.mCurrDrawable = d;
                        this.mCurIndex = idx;
                        if (d != null) {
                            d.mutate();
                            if (this.mDrawableContainerState.mEnterFadeDuration > 0) {
                                this.mEnterAnimationEnd = now + this.mDrawableContainerState.mEnterFadeDuration;
                            }
                            else {
                                d.setAlpha(this.mAlpha);
                            }
                            d.setVisible(this.isVisible(), true);
                            d.setDither(this.mDrawableContainerState.mDither);
                            d.setState(this.getState());
                            d.setLevel(this.getLevel());
                            d.setBounds(this.getBounds());
                            d.setAutoMirrored(this.mDrawableContainerState.mAutoMirrored);
                        }
                        else {
                        }
                    }
                    else {
                        this.mCurrDrawable = null;
                        this.mCurIndex = -1;
                    }
                    if (this.mEnterAnimationEnd != 0 || this.mExitAnimationEnd != 0) {
                        if (this.mAnimationRunnable == null) {
                            let t = this;
                            this.mAnimationRunnable = {
                                run() {
                                    t.animate(true);
                                    t.invalidateSelf();
                                }
                            };
                        }
                        else {
                            this.unscheduleSelf(this.mAnimationRunnable);
                        }
                        this.animate(true);
                    }
                    this.invalidateSelf();
                    return true;
                }
                animate(schedule) {
                    const now = SystemClock.uptimeMillis();
                    let animating = false;
                    if (this.mCurrDrawable != null) {
                        if (this.mEnterAnimationEnd != 0) {
                            if (this.mEnterAnimationEnd <= now) {
                                this.mCurrDrawable.mutate().setAlpha(this.mAlpha);
                                this.mEnterAnimationEnd = 0;
                            }
                            else {
                                let animAlpha = ((this.mEnterAnimationEnd - now) * 255)
                                    / this.mDrawableContainerState.mEnterFadeDuration;
                                if (DrawableContainer.DEBUG)
                                    android.util.Log.i(DrawableContainer.TAG, toString() + " cur alpha " + animAlpha);
                                this.mCurrDrawable.mutate().setAlpha(((255 - animAlpha) * this.mAlpha) / 255);
                                animating = true;
                            }
                        }
                    }
                    else {
                        this.mEnterAnimationEnd = 0;
                    }
                    if (this.mLastDrawable != null) {
                        if (this.mExitAnimationEnd != 0) {
                            if (this.mExitAnimationEnd <= now) {
                                this.mLastDrawable.setVisible(false, false);
                                this.mLastDrawable = null;
                                this.mExitAnimationEnd = 0;
                            }
                            else {
                                let animAlpha = ((this.mExitAnimationEnd - now) * 255)
                                    / this.mDrawableContainerState.mExitFadeDuration;
                                if (DrawableContainer.DEBUG)
                                    android.util.Log.i(DrawableContainer.TAG, toString() + " last alpha " + animAlpha);
                                this.mLastDrawable.mutate().setAlpha((animAlpha * this.mAlpha) / 255);
                                animating = true;
                            }
                        }
                    }
                    else {
                        this.mExitAnimationEnd = 0;
                    }
                    if (schedule && animating) {
                        this.scheduleSelf(this.mAnimationRunnable, now + 1000 / 60);
                    }
                }
                getCurrent() {
                    return this.mCurrDrawable;
                }
                getConstantState() {
                    if (this.mDrawableContainerState.canConstantState()) {
                        return this.mDrawableContainerState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mDrawableContainerState.mutate();
                        this.mMutated = true;
                    }
                    return this;
                }
                setConstantState(state) {
                    this.mDrawableContainerState = state;
                }
            }
            DrawableContainer.DEBUG = Log.DBG_DrawableContainer;
            DrawableContainer.TAG = "DrawableContainer";
            DrawableContainer.DEFAULT_DITHER = true;
            drawable.DrawableContainer = DrawableContainer;
            (function (DrawableContainer) {
                class DrawableContainerState {
                    constructor(orig, owner) {
                        this.mVariablePadding = false;
                        this.mPaddingChecked = false;
                        this.mConstantSize = false;
                        this.mComputedConstantSize = false;
                        this.mConstantWidth = 0;
                        this.mConstantHeight = 0;
                        this.mConstantMinimumWidth = 0;
                        this.mConstantMinimumHeight = 0;
                        this.mCheckedOpacity = false;
                        this.mOpacity = 0;
                        this.mCheckedStateful = false;
                        this.mStateful = false;
                        this.mCheckedConstantState = false;
                        this.mCanConstantState = false;
                        this.mDither = DrawableContainer.DEFAULT_DITHER;
                        this.mMutated = false;
                        this.mEnterFadeDuration = 0;
                        this.mExitFadeDuration = 0;
                        this.mAutoMirrored = false;
                        this.mOwner = owner;
                        if (orig != null) {
                            this.mCheckedConstantState = true;
                            this.mCanConstantState = true;
                            this.mVariablePadding = orig.mVariablePadding;
                            this.mConstantSize = orig.mConstantSize;
                            this.mDither = orig.mDither;
                            this.mMutated = orig.mMutated;
                            this.mEnterFadeDuration = orig.mEnterFadeDuration;
                            this.mExitFadeDuration = orig.mExitFadeDuration;
                            this.mAutoMirrored = orig.mAutoMirrored;
                            this.mConstantPadding = orig.getConstantPadding();
                            this.mPaddingChecked = true;
                            this.mConstantWidth = orig.getConstantWidth();
                            this.mConstantHeight = orig.getConstantHeight();
                            this.mConstantMinimumWidth = orig.getConstantMinimumWidth();
                            this.mConstantMinimumHeight = orig.getConstantMinimumHeight();
                            this.mComputedConstantSize = true;
                            this.mOpacity = orig.getOpacity();
                            this.mCheckedOpacity = true;
                            this.mStateful = orig.isStateful();
                            this.mCheckedStateful = true;
                            const origDr = orig.mDrawables;
                            this.mDrawables = new Array(0);
                            const origDf = orig.mDrawableFutures;
                            if (origDf != null) {
                                this.mDrawableFutures = origDf.clone();
                            }
                            else {
                                this.mDrawableFutures = new SparseArray(this.mNumChildren);
                            }
                            const N = this.mNumChildren;
                            for (let i = 0; i < N; i++) {
                                if (origDr[i] != null) {
                                    this.mDrawableFutures.put(i, new ConstantStateFuture(origDr[i]));
                                }
                            }
                        }
                        else {
                            this.mDrawables = new Array(0);
                        }
                    }
                    get mNumChildren() {
                        return this.mDrawables.length;
                    }
                    addChild(dr) {
                        const pos = this.mNumChildren;
                        dr.setVisible(false, true);
                        dr.setCallback(this.mOwner);
                        this.mDrawables.push(dr);
                        this.mCheckedStateful = false;
                        this.mCheckedOpacity = false;
                        this.mConstantPadding = null;
                        this.mPaddingChecked = false;
                        this.mComputedConstantSize = false;
                        return pos;
                    }
                    getCapacity() {
                        return this.mDrawables.length;
                    }
                    createAllFutures() {
                        if (this.mDrawableFutures != null) {
                            const futureCount = this.mDrawableFutures.size();
                            for (let keyIndex = 0; keyIndex < futureCount; keyIndex++) {
                                const index = this.mDrawableFutures.keyAt(keyIndex);
                                this.mDrawables[index] = this.mDrawableFutures.valueAt(keyIndex).get(this);
                            }
                            this.mDrawableFutures = null;
                        }
                    }
                    getChildCount() {
                        return this.mNumChildren;
                    }
                    getChildren() {
                        this.createAllFutures();
                        return this.mDrawables;
                    }
                    getChild(index) {
                        const result = this.mDrawables[index];
                        if (result != null) {
                            return result;
                        }
                        if (this.mDrawableFutures != null) {
                            const keyIndex = this.mDrawableFutures.indexOfKey(index);
                            if (keyIndex >= 0) {
                                const prepared = this.mDrawableFutures.valueAt(keyIndex).get(this);
                                this.mDrawables[index] = prepared;
                                this.mDrawableFutures.removeAt(keyIndex);
                                return prepared;
                            }
                        }
                        return null;
                    }
                    mutate() {
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i] != null) {
                                drawables[i].mutate();
                            }
                        }
                        this.mMutated = true;
                    }
                    setVariablePadding(variable) {
                        this.mVariablePadding = variable;
                    }
                    getConstantPadding() {
                        if (this.mVariablePadding) {
                            return null;
                        }
                        if ((this.mConstantPadding != null) || this.mPaddingChecked) {
                            return this.mConstantPadding;
                        }
                        this.createAllFutures();
                        let r = null;
                        const t = new Rect();
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i].getPadding(t)) {
                                if (r == null)
                                    r = new Rect(0, 0, 0, 0);
                                if (t.left > r.left)
                                    r.left = t.left;
                                if (t.top > r.top)
                                    r.top = t.top;
                                if (t.right > r.right)
                                    r.right = t.right;
                                if (t.bottom > r.bottom)
                                    r.bottom = t.bottom;
                            }
                        }
                        this.mPaddingChecked = true;
                        return (this.mConstantPadding = r);
                    }
                    setConstantSize(constant) {
                        this.mConstantSize = constant;
                    }
                    isConstantSize() {
                        return this.mConstantSize;
                    }
                    getConstantWidth() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantWidth;
                    }
                    getConstantHeight() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantHeight;
                    }
                    getConstantMinimumWidth() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantMinimumWidth;
                    }
                    getConstantMinimumHeight() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantMinimumHeight;
                    }
                    computeConstantSize() {
                        this.mComputedConstantSize = true;
                        this.createAllFutures();
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        this.mConstantWidth = this.mConstantHeight = -1;
                        this.mConstantMinimumWidth = this.mConstantMinimumHeight = 0;
                        for (let i = 0; i < N; i++) {
                            const dr = drawables[i];
                            let s = dr.getIntrinsicWidth();
                            if (s > this.mConstantWidth)
                                this.mConstantWidth = s;
                            s = dr.getIntrinsicHeight();
                            if (s > this.mConstantHeight)
                                this.mConstantHeight = s;
                            s = dr.getMinimumWidth();
                            if (s > this.mConstantMinimumWidth)
                                this.mConstantMinimumWidth = s;
                            s = dr.getMinimumHeight();
                            if (s > this.mConstantMinimumHeight)
                                this.mConstantMinimumHeight = s;
                        }
                    }
                    setEnterFadeDuration(duration) {
                        this.mEnterFadeDuration = duration;
                    }
                    getEnterFadeDuration() {
                        return this.mEnterFadeDuration;
                    }
                    setExitFadeDuration(duration) {
                        this.mExitFadeDuration = duration;
                    }
                    getExitFadeDuration() {
                        return this.mExitFadeDuration;
                    }
                    getOpacity() {
                        if (this.mCheckedOpacity) {
                            return this.mOpacity;
                        }
                        this.createAllFutures();
                        this.mCheckedOpacity = true;
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        let op = (N > 0) ? drawables[0].getOpacity() : PixelFormat.TRANSPARENT;
                        for (let i = 1; i < N; i++) {
                            op = drawable.Drawable.resolveOpacity(op, drawables[i].getOpacity());
                        }
                        this.mOpacity = op;
                        return op;
                    }
                    isStateful() {
                        if (this.mCheckedStateful) {
                            return this.mStateful;
                        }
                        this.createAllFutures();
                        this.mCheckedStateful = true;
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i].isStateful()) {
                                this.mStateful = true;
                                return true;
                            }
                        }
                        this.mStateful = false;
                        return false;
                    }
                    canConstantState() {
                        if (this.mCheckedConstantState) {
                            return this.mCanConstantState;
                        }
                        this.createAllFutures();
                        this.mCheckedConstantState = true;
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i].getConstantState() == null) {
                                this.mCanConstantState = false;
                                return false;
                            }
                        }
                        this.mCanConstantState = true;
                        return true;
                    }
                    newDrawable() {
                        return undefined;
                    }
                }
                DrawableContainer.DrawableContainerState = DrawableContainerState;
                class ConstantStateFuture {
                    constructor(source) {
                        this.mConstantState = source.getConstantState();
                    }
                    get(state) {
                        const result = this.mConstantState.newDrawable();
                        result.setCallback(state.mOwner);
                        if (state.mMutated) {
                            result.mutate();
                        }
                        return result;
                    }
                }
            })(DrawableContainer = drawable.DrawableContainer || (drawable.DrawableContainer = {}));
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/content/res/Resources.ts"/>
///<reference path="../../../android/os/SystemClock.ts"/>
///<reference path="../../../java/lang/System.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../../android/graphics/drawable/Animatable.ts"/>
///<reference path="../../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../../android/graphics/drawable/DrawableContainer.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var SystemClock = android.os.SystemClock;
            var DrawableContainer = android.graphics.drawable.DrawableContainer;
            class AnimationDrawable extends DrawableContainer {
                constructor(state) {
                    super();
                    this.mCurFrame = -1;
                    let _as = new AnimationDrawable.AnimationState(state, this);
                    this.mAnimationState = _as;
                    this.setConstantState(_as);
                    if (state != null) {
                        this.setFrame(0, true, false);
                    }
                }
                setVisible(visible, restart) {
                    let changed = super.setVisible(visible, restart);
                    if (visible) {
                        if (changed || restart) {
                            this.setFrame(0, true, true);
                        }
                    }
                    else {
                        this.unscheduleSelf(this);
                    }
                    return changed;
                }
                start() {
                    if (!this.isRunning()) {
                        this.run();
                    }
                }
                stop() {
                    if (this.isRunning()) {
                        this.unscheduleSelf(this);
                    }
                }
                isRunning() {
                    return this.mCurFrame > -1;
                }
                run() {
                    this.nextFrame(false);
                }
                unscheduleSelf(what) {
                    this.mCurFrame = -1;
                    super.unscheduleSelf(what);
                }
                getNumberOfFrames() {
                    return this.mAnimationState.getChildCount();
                }
                getFrame(index) {
                    return this.mAnimationState.getChild(index);
                }
                getDuration(i) {
                    return this.mAnimationState.mDurations[i];
                }
                isOneShot() {
                    return this.mAnimationState.mOneShot;
                }
                setOneShot(oneShot) {
                    this.mAnimationState.mOneShot = oneShot;
                }
                addFrame(frame, duration) {
                    this.mAnimationState.addFrame(frame, duration);
                    if (this.mCurFrame < 0) {
                        this.setFrame(0, true, false);
                    }
                }
                nextFrame(unschedule) {
                    let next = this.mCurFrame + 1;
                    const N = this.mAnimationState.getChildCount();
                    if (next >= N) {
                        next = 0;
                    }
                    this.setFrame(next, unschedule, !this.mAnimationState.mOneShot || next < (N - 1));
                }
                setFrame(frame, unschedule, animate) {
                    if (frame >= this.mAnimationState.getChildCount()) {
                        return;
                    }
                    this.mCurFrame = frame;
                    this.selectDrawable(frame);
                    if (unschedule) {
                        this.unscheduleSelf(this);
                    }
                    if (animate) {
                        this.mCurFrame = frame;
                        this.scheduleSelf(this, SystemClock.uptimeMillis() + this.mAnimationState.mDurations[frame]);
                    }
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mAnimationState.mDurations = [...this.mAnimationState.mDurations];
                        this.mMutated = true;
                    }
                    return this;
                }
            }
            drawable.AnimationDrawable = AnimationDrawable;
            (function (AnimationDrawable) {
                class AnimationState extends DrawableContainer.DrawableContainerState {
                    constructor(orig, owner) {
                        super(orig, owner);
                        if (orig != null) {
                            this.mDurations = orig.mDurations;
                            this.mOneShot = orig.mOneShot;
                        }
                        else {
                            this.mDurations = new Array(this.getCapacity());
                            this.mOneShot = true;
                        }
                    }
                    newDrawable() {
                        return new AnimationDrawable(this);
                    }
                    addFrame(dr, dur) {
                        let pos = super.addChild(dr);
                        this.mDurations[pos] = dur;
                    }
                }
                AnimationDrawable.AnimationState = AnimationState;
            })(AnimationDrawable = drawable.AnimationDrawable || (drawable.AnimationDrawable = {}));
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="DrawableContainer.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_5) {
            const DEBUG = android.util.Log.DBG_StateListDrawable;
            const TAG = "StateListDrawable";
            const DEFAULT_DITHER = true;
            class StateListDrawable extends drawable_5.DrawableContainer {
                constructor() {
                    super();
                    this.initWithState(null);
                }
                initWithState(state) {
                    let _as = new StateListState(state, this);
                    this.mStateListState = _as;
                    this.setConstantState(_as);
                    this.onStateChange(this.getState());
                }
                addState(stateSet, drawable) {
                    if (drawable != null) {
                        this.mStateListState.addStateSet(stateSet, drawable);
                        this.onStateChange(this.getState());
                    }
                }
                isStateful() {
                    return true;
                }
                onStateChange(stateSet) {
                    let idx = this.mStateListState.indexOfStateSet(stateSet);
                    if (DEBUG)
                        android.util.Log.i(TAG, "onStateChange " + this + " states "
                            + stateSet + " found " + idx);
                    if (idx < 0) {
                        idx = this.mStateListState.indexOfStateSet(android.util.StateSet.WILD_CARD);
                    }
                    if (this.selectDrawable(idx)) {
                        return true;
                    }
                    return super.onStateChange(stateSet);
                }
                getStateCount() {
                    return this.mStateListState.getChildCount();
                }
                getStateSet(index) {
                    return this.mStateListState.mStateSets[index];
                }
                getStateDrawable(index) {
                    return this.mStateListState.getChild(index);
                }
                getStateDrawableIndex(stateSet) {
                    return this.mStateListState.indexOfStateSet(stateSet);
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        const sets = this.mStateListState.mStateSets;
                        const count = sets.length;
                        this.mStateListState.mStateSets = new Array(count);
                        for (let i = 0; i < count; i++) {
                            const _set = sets[i];
                            if (_set != null) {
                                this.mStateListState.mStateSets[i] = _set.concat();
                            }
                        }
                        this.mMutated = true;
                    }
                    return this;
                }
            }
            drawable_5.StateListDrawable = StateListDrawable;
            class StateListState extends drawable_5.DrawableContainer.DrawableContainerState {
                constructor(orig, owner) {
                    super(orig, owner);
                    if (orig != null) {
                        this.mStateSets = orig.mStateSets.concat();
                    }
                    else {
                        this.mStateSets = new Array(this.getCapacity());
                    }
                }
                addStateSet(stateSet, drawable) {
                    let pos = this.addChild(drawable);
                    this.mStateSets[pos] = stateSet;
                    return pos;
                }
                indexOfStateSet(stateSet) {
                    const stateSets = this.mStateSets;
                    const N = this.getChildCount();
                    for (let i = 0; i < N; i++) {
                        if (android.util.StateSet.stateSetMatches(stateSets[i], stateSet)) {
                            return i;
                        }
                    }
                    return -1;
                }
                newDrawable() {
                    let drawable = new StateListDrawable();
                    drawable.initWithState(this);
                    return drawable;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var android;
(function (android) {
    var R;
    (function (R) {
        class id {
        }
        id.content = 'content';
        id.background = 'background';
        id.secondaryProgress = 'secondaryProgress';
        id.progress = 'progress';
        id.contentPanel = 'contentPanel';
        id.topPanel = 'topPanel';
        id.buttonPanel = 'buttonPanel';
        id.customPanel = 'customPanel';
        id.custom = 'custom';
        id.titleDivider = 'titleDivider';
        id.titleDividerTop = 'titleDividerTop';
        id.title_template = 'title_template';
        id.icon = 'icon';
        id.alertTitle = 'alertTitle';
        id.scrollView = 'scrollView';
        id.message = 'message';
        id.button1 = 'button1';
        id.button2 = 'button2';
        id.button3 = 'button3';
        id.leftSpacer = 'leftSpacer';
        id.rightSpacer = 'rightSpacer';
        id.text1 = 'text1';
        R.id = id;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/15.
 */
///<reference path="../view/View.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/LayerDrawable.ts"/>
///<reference path="../graphics/drawable/RotateDrawable.ts"/>
///<reference path="../graphics/drawable/ScaleDrawable.ts"/>
///<reference path="../graphics/drawable/AnimationDrawable.ts"/>
///<reference path="../graphics/drawable/StateListDrawable.ts"/>
///<reference path="../graphics/drawable/RoundRectDrawable.ts"/>
///<reference path="../graphics/drawable/ShadowDrawable.ts"/>
///<reference path="id.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var View = android.view.View;
        var Resources = android.content.res.Resources;
        var Color = android.graphics.Color;
        var InsetDrawable = android.graphics.drawable.InsetDrawable;
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var LayerDrawable = android.graphics.drawable.LayerDrawable;
        var RotateDrawable = android.graphics.drawable.RotateDrawable;
        var ScaleDrawable = android.graphics.drawable.ScaleDrawable;
        var AnimationDrawable = android.graphics.drawable.AnimationDrawable;
        var StateListDrawable = android.graphics.drawable.StateListDrawable;
        var RoundRectDrawable = android.graphics.drawable.RoundRectDrawable;
        var ShadowDrawable = android.graphics.drawable.ShadowDrawable;
        var Gravity = android.view.Gravity;
        window.addEventListener('AndroidUILoadFinish', () => {
            eval('View = android.view.View;');
        });
        const density = Resources.getDisplayMetrics().density;
        class drawable {
            static get button_background() {
                class DefaultButtonBackgroundDrawable extends InsetDrawable {
                    constructor() {
                        super(DefaultButtonBackgroundDrawable.createStateList(), 6 * density);
                    }
                    static createStateList() {
                        let stateList = new StateListDrawable();
                        stateList.addState([View.VIEW_STATE_PRESSED], new ColorDrawable(Color.GRAY));
                        stateList.addState([View.VIEW_STATE_ACTIVATED], new ColorDrawable(Color.GRAY));
                        stateList.addState([View.VIEW_STATE_FOCUSED], new ColorDrawable(0xffaaaaaa));
                        stateList.addState([-View.VIEW_STATE_ENABLED], new ColorDrawable(0xffebebeb));
                        stateList.addState([], new ColorDrawable(Color.LTGRAY));
                        return stateList;
                    }
                    getPadding(padding) {
                        let result = super.getPadding(padding);
                        padding.left += 12 * density;
                        padding.right += 12 * density;
                        padding.top += 6 * density;
                        padding.bottom += 6 * density;
                        return result;
                    }
                    getIntrinsicWidth() {
                        return 64 * density;
                    }
                    getIntrinsicHeight() {
                        return 48 * density;
                    }
                }
                return new DefaultButtonBackgroundDrawable();
            }
            static get btn_check() {
                let stateList = new StateListDrawable();
                stateList.addState([View.VIEW_STATE_CHECKED, -View.VIEW_STATE_WINDOW_FOCUSED, View.VIEW_STATE_ENABLED], R.image.btn_check_on_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, -View.VIEW_STATE_WINDOW_FOCUSED, View.VIEW_STATE_ENABLED], R.image.btn_check_off_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, View.VIEW_STATE_PRESSED, View.VIEW_STATE_ENABLED], R.image.btn_check_on_pressed_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, View.VIEW_STATE_PRESSED, View.VIEW_STATE_ENABLED], R.image.btn_check_off_pressed_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, View.VIEW_STATE_FOCUSED, View.VIEW_STATE_ENABLED], R.image.btn_check_on_focused_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, View.VIEW_STATE_FOCUSED, View.VIEW_STATE_ENABLED], R.image.btn_check_off_focused_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, View.VIEW_STATE_ENABLED], R.image.btn_check_on_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, View.VIEW_STATE_ENABLED], R.image.btn_check_off_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, -View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_check_on_disabled_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, -View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_check_off_disabled_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, View.VIEW_STATE_FOCUSED], R.image.btn_check_on_disabled_focused_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, View.VIEW_STATE_FOCUSED], R.image.btn_check_off_disabled_focused_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED], R.image.btn_check_off_disabled_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED], R.image.btn_check_on_disabled_holo_light);
                return stateList;
            }
            static get btn_radio() {
                let stateList = new StateListDrawable();
                stateList.addState([View.VIEW_STATE_CHECKED, -View.VIEW_STATE_WINDOW_FOCUSED, View.VIEW_STATE_ENABLED], R.image.btn_radio_on_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, -View.VIEW_STATE_WINDOW_FOCUSED, View.VIEW_STATE_ENABLED], R.image.btn_radio_off_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, View.VIEW_STATE_PRESSED, View.VIEW_STATE_ENABLED], R.image.btn_radio_on_pressed_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, View.VIEW_STATE_PRESSED, View.VIEW_STATE_ENABLED], R.image.btn_radio_off_pressed_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, View.VIEW_STATE_FOCUSED, View.VIEW_STATE_ENABLED], R.image.btn_radio_on_focused_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, View.VIEW_STATE_FOCUSED, View.VIEW_STATE_ENABLED], R.image.btn_radio_off_focused_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, View.VIEW_STATE_ENABLED], R.image.btn_radio_on_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, View.VIEW_STATE_ENABLED], R.image.btn_radio_off_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, -View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_radio_on_disabled_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, -View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_radio_off_disabled_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED, View.VIEW_STATE_FOCUSED], R.image.btn_radio_on_disabled_focused_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED, View.VIEW_STATE_FOCUSED], R.image.btn_radio_off_disabled_focused_holo_light);
                stateList.addState([-View.VIEW_STATE_CHECKED], R.image.btn_radio_off_disabled_holo_light);
                stateList.addState([View.VIEW_STATE_CHECKED], R.image.btn_radio_on_disabled_holo_light);
                return stateList;
            }
            static get progress_small_holo() {
                let rotate1 = new RotateDrawable(null);
                rotate1.mState.mDrawable = R.image.spinner_16_outer_holo;
                rotate1.mState.mPivotXRel = true;
                rotate1.mState.mPivotX = 0.5;
                rotate1.mState.mPivotYRel = true;
                rotate1.mState.mPivotY = 0.5;
                rotate1.mState.mFromDegrees = 0;
                rotate1.mState.mToDegrees = 1080;
                let rotate2 = new RotateDrawable(null);
                rotate2.mState.mDrawable = R.image.spinner_16_inner_holo;
                rotate2.mState.mPivotXRel = true;
                rotate2.mState.mPivotX = 0.5;
                rotate2.mState.mPivotYRel = true;
                rotate2.mState.mPivotY = 0.5;
                rotate2.mState.mFromDegrees = 720;
                rotate2.mState.mToDegrees = 0;
                return new LayerDrawable([rotate1, rotate2]);
            }
            static get progress_medium_holo() {
                let rotate1 = new RotateDrawable(null);
                rotate1.mState.mDrawable = R.image.spinner_48_outer_holo;
                rotate1.mState.mPivotXRel = true;
                rotate1.mState.mPivotX = 0.5;
                rotate1.mState.mPivotYRel = true;
                rotate1.mState.mPivotY = 0.5;
                rotate1.mState.mFromDegrees = 0;
                rotate1.mState.mToDegrees = 1080;
                let rotate2 = new RotateDrawable(null);
                rotate2.mState.mDrawable = R.image.spinner_48_inner_holo;
                rotate2.mState.mPivotXRel = true;
                rotate2.mState.mPivotX = 0.5;
                rotate2.mState.mPivotYRel = true;
                rotate2.mState.mPivotY = 0.5;
                rotate2.mState.mFromDegrees = 720;
                rotate2.mState.mToDegrees = 0;
                return new LayerDrawable([rotate1, rotate2]);
            }
            static get progress_large_holo() {
                let rotate1 = new RotateDrawable(null);
                rotate1.mState.mDrawable = R.image.spinner_76_outer_holo;
                rotate1.mState.mPivotXRel = true;
                rotate1.mState.mPivotX = 0.5;
                rotate1.mState.mPivotYRel = true;
                rotate1.mState.mPivotY = 0.5;
                rotate1.mState.mFromDegrees = 0;
                rotate1.mState.mToDegrees = 1080;
                let rotate2 = new RotateDrawable(null);
                rotate2.mState.mDrawable = R.image.spinner_76_inner_holo;
                rotate2.mState.mPivotXRel = true;
                rotate2.mState.mPivotX = 0.5;
                rotate2.mState.mPivotYRel = true;
                rotate2.mState.mPivotY = 0.5;
                rotate2.mState.mFromDegrees = 720;
                rotate2.mState.mToDegrees = 0;
                return new LayerDrawable([rotate1, rotate2]);
            }
            static get progress_horizontal_holo() {
                let layerDrawable = new LayerDrawable(null);
                let returnHeight = () => 3 * density;
                let insetTopBottom = Math.floor(8 * density);
                let bg = new ColorDrawable(0x4c000000);
                bg.getIntrinsicHeight = returnHeight;
                layerDrawable.addLayer(bg, R.id.background, 0, insetTopBottom, 0, insetTopBottom);
                let secondary = new ScaleDrawable(new ColorDrawable(0x4c33b5e5), Gravity.LEFT, 1, -1);
                secondary.getIntrinsicHeight = returnHeight;
                layerDrawable.addLayer(secondary, R.id.secondaryProgress, 0, insetTopBottom, 0, insetTopBottom);
                let progress = new ScaleDrawable(new ColorDrawable(0xcc33b5e5), Gravity.LEFT, 1, -1);
                progress.getIntrinsicHeight = returnHeight;
                layerDrawable.addLayer(progress, R.id.progress, 0, insetTopBottom, 0, insetTopBottom);
                layerDrawable.ensurePadding();
                layerDrawable.onStateChange(layerDrawable.getState());
                return layerDrawable;
            }
            static get progress_indeterminate_horizontal_holo() {
                let animDrawable = new AnimationDrawable();
                animDrawable.setOneShot(false);
                let frame = R.image.progressbar_indeterminate_holo1;
                frame.setCallback(animDrawable);
                animDrawable.addFrame(frame, 50);
                frame = R.image.progressbar_indeterminate_holo2;
                frame.setCallback(animDrawable);
                animDrawable.addFrame(frame, 50);
                frame = R.image.progressbar_indeterminate_holo3;
                frame.setCallback(animDrawable);
                animDrawable.addFrame(frame, 50);
                frame = R.image.progressbar_indeterminate_holo4;
                frame.setCallback(animDrawable);
                animDrawable.addFrame(frame, 50);
                frame = R.image.progressbar_indeterminate_holo5;
                frame.setCallback(animDrawable);
                animDrawable.addFrame(frame, 50);
                frame = R.image.progressbar_indeterminate_holo6;
                frame.setCallback(animDrawable);
                animDrawable.addFrame(frame, 50);
                frame = R.image.progressbar_indeterminate_holo7;
                frame.setCallback(animDrawable);
                animDrawable.addFrame(frame, 50);
                frame = R.image.progressbar_indeterminate_holo8;
                frame.setCallback(animDrawable);
                animDrawable.addFrame(frame, 50);
                return animDrawable;
            }
            static get ratingbar_full_empty_holo_light() {
                let stateList = new StateListDrawable();
                stateList.addState([View.VIEW_STATE_PRESSED, View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_rating_star_off_pressed_holo_light);
                stateList.addState([View.VIEW_STATE_FOCUSED, View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_rating_star_off_pressed_holo_light);
                stateList.addState([View.VIEW_STATE_SELECTED, View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_rating_star_off_pressed_holo_light);
                stateList.addState([], R.image.btn_rating_star_off_normal_holo_light);
                return stateList;
            }
            static get ratingbar_full_filled_holo_light() {
                let stateList = new StateListDrawable();
                stateList.addState([View.VIEW_STATE_PRESSED, View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_rating_star_on_pressed_holo_light);
                stateList.addState([View.VIEW_STATE_FOCUSED, View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_rating_star_on_pressed_holo_light);
                stateList.addState([View.VIEW_STATE_SELECTED, View.VIEW_STATE_WINDOW_FOCUSED], R.image.btn_rating_star_on_pressed_holo_light);
                stateList.addState([], R.image.btn_rating_star_on_normal_holo_light);
                return stateList;
            }
            static get ratingbar_full_holo_light() {
                let layerDrawable = new LayerDrawable(null);
                layerDrawable.addLayer(R.drawable.ratingbar_full_empty_holo_light, R.id.background);
                layerDrawable.addLayer(R.drawable.ratingbar_full_empty_holo_light, R.id.secondaryProgress);
                layerDrawable.addLayer(R.drawable.ratingbar_full_filled_holo_light, R.id.progress);
                layerDrawable.ensurePadding();
                layerDrawable.onStateChange(layerDrawable.getState());
                return layerDrawable;
            }
            static get ratingbar_holo_light() {
                let layerDrawable = new LayerDrawable(null);
                layerDrawable.addLayer(R.image.rate_star_big_off_holo_light, R.id.background);
                layerDrawable.addLayer(R.image.rate_star_big_half_holo_light, R.id.secondaryProgress);
                layerDrawable.addLayer(R.image.rate_star_big_on_holo_light, R.id.progress);
                layerDrawable.ensurePadding();
                layerDrawable.onStateChange(layerDrawable.getState());
                return layerDrawable;
            }
            static get ratingbar_small_holo_light() {
                let layerDrawable = new LayerDrawable(null);
                layerDrawable.addLayer(R.image.rate_star_small_off_holo_light, R.id.background);
                layerDrawable.addLayer(R.image.rate_star_small_half_holo_light, R.id.secondaryProgress);
                layerDrawable.addLayer(R.image.rate_star_small_on_holo_light, R.id.progress);
                layerDrawable.ensurePadding();
                layerDrawable.onStateChange(layerDrawable.getState());
                return layerDrawable;
            }
            static get scrubber_control_selector_holo() {
                let stateList = new StateListDrawable();
                stateList.addState([-View.VIEW_STATE_ENABLED], R.image.scrubber_control_disabled_holo);
                stateList.addState([View.VIEW_STATE_PRESSED], R.image.scrubber_control_pressed_holo);
                stateList.addState([View.VIEW_STATE_SELECTED], R.image.scrubber_control_focused_holo);
                stateList.addState([], R.image.scrubber_control_normal_holo);
                return stateList;
            }
            static get scrubber_progress_horizontal_holo_light() {
                let layerDrawable = new LayerDrawable(null);
                layerDrawable.addLayer(R.drawable.scrubber_track_holo_light, R.id.background);
                let secondary = new ScaleDrawable(R.drawable.scrubber_secondary_holo, Gravity.LEFT, 1, -1);
                layerDrawable.addLayer(secondary, R.id.secondaryProgress);
                let progress = new ScaleDrawable(R.drawable.scrubber_primary_holo, Gravity.LEFT, 1, -1);
                layerDrawable.addLayer(progress, R.id.progress);
                layerDrawable.ensurePadding();
                layerDrawable.onStateChange(layerDrawable.getState());
                return layerDrawable;
            }
            static get scrubber_primary_holo() {
                let line = new ColorDrawable(0xff33b5e5);
                line.getIntrinsicHeight = () => 3 * density;
                return new InsetDrawable(line, 0, 5 * density, 0, 5 * density);
            }
            static get scrubber_secondary_holo() {
                let line = new ColorDrawable(0x4c33b5e5);
                line.getIntrinsicHeight = () => 3 * density;
                return new InsetDrawable(line, 0, 5 * density, 0, 5 * density);
            }
            static get scrubber_track_holo_light() {
                let line = new ColorDrawable(0x66666666);
                line.getIntrinsicHeight = () => 1 * density;
                return new InsetDrawable(line, 0, 6 * density, 0, 6 * density);
            }
            static get list_selector_background() {
                return this.item_background;
            }
            static get list_divider() {
                let divider = new ColorDrawable(0xffcccccc);
                return divider;
            }
            static get divider_vertical() {
                return this.divider_horizontal;
            }
            static get divider_horizontal() {
                let divider = new ColorDrawable(0xffdddddd);
                divider.getIntrinsicWidth = () => 1;
                divider.getIntrinsicHeight = () => 1;
                return divider;
            }
            static get item_background() {
                let stateList = new StateListDrawable();
                stateList.addState([View.VIEW_STATE_FOCUSED, -View.VIEW_STATE_ENABLED], new ColorDrawable(0xffebebeb));
                stateList.addState([View.VIEW_STATE_FOCUSED, View.VIEW_STATE_PRESSED], new ColorDrawable(Color.LTGRAY));
                stateList.addState([-View.VIEW_STATE_FOCUSED, View.VIEW_STATE_PRESSED], new ColorDrawable(Color.LTGRAY));
                stateList.addState([View.VIEW_STATE_FOCUSED], new ColorDrawable(0xffaaaaaa));
                stateList.addState([], new ColorDrawable(Color.TRANSPARENT));
                return stateList;
            }
            static get toast_frame() {
                let bg = new RoundRectDrawable(0xff333333, 2 * density, 2 * density, 2 * density, 2 * density);
                bg.getIntrinsicHeight = () => 32 * density;
                bg.getPadding = (rect) => {
                    rect.set(12 * density, 6 * density, 12 * density, 6 * density);
                    return true;
                };
                let shadow = new ShadowDrawable(bg, 5 * density, 0, 2 * density, 0x44000000);
                return new InsetDrawable(shadow, 7 * density);
            }
            static get dropdown_background_dark() {
                let bg = new RoundRectDrawable(0xff333333, 2 * density, 2 * density, 2 * density, 2 * density);
                bg.getIntrinsicWidth = () => 36 * density;
                bg.getIntrinsicHeight = () => 36 * density;
                bg.getPadding = (rect) => {
                    rect.set(12 * density, 6 * density, 12 * density, 6 * density);
                    return true;
                };
                let shadow = new ShadowDrawable(bg, 3 * density, 0, 2 * density, 0x44000000);
                return new InsetDrawable(shadow, 5 * density);
            }
            static get menu_panel_holo_light() {
                let bg = new RoundRectDrawable(0xffefefef, 2 * density, 2 * density, 2 * density, 2 * density);
                bg.getIntrinsicWidth = () => 48 * density;
                bg.getIntrinsicHeight = () => 16 * density;
                let shadow = new ShadowDrawable(bg, 6 * density, 0, 2 * density, 0xaa000000);
                return new InsetDrawable(shadow, 8 * density);
            }
        }
        R.drawable = drawable;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="NetImage.ts"/>
var androidui;
(function (androidui) {
    var image;
    (function (image) {
        var Drawable = android.graphics.drawable.Drawable;
        var Rect = android.graphics.Rect;
        class ChangeImageSizeDrawable extends Drawable {
            constructor(drawable, overrideWidth, overrideHeight = overrideWidth) {
                super();
                this.mTmpRect = new Rect();
                this.mMutated = false;
                this.mState = new State(null, this);
                this.mState.mDrawable = drawable;
                this.mState.mOverrideWidth = overrideWidth;
                this.mState.mOverrideHeight = overrideHeight;
                if (drawable != null) {
                    drawable.setCallback(this);
                }
            }
            drawableSizeChange(who) {
                const callback = this.getCallback();
                if (callback != null && callback.drawableSizeChange) {
                    callback.drawableSizeChange(this);
                }
            }
            invalidateDrawable(who) {
                const callback = this.getCallback();
                if (callback != null) {
                    callback.invalidateDrawable(this);
                }
            }
            scheduleDrawable(who, what, when) {
                const callback = this.getCallback();
                if (callback != null) {
                    callback.scheduleDrawable(this, what, when);
                }
            }
            unscheduleDrawable(who, what) {
                const callback = this.getCallback();
                if (callback != null) {
                    callback.unscheduleDrawable(this, what);
                }
            }
            draw(canvas) {
                this.mState.mDrawable.draw(canvas);
            }
            getPadding(padding) {
                return this.mState.mDrawable.getPadding(padding);
            }
            setVisible(visible, restart) {
                this.mState.mDrawable.setVisible(visible, restart);
                return super.setVisible(visible, restart);
            }
            setAlpha(alpha) {
                this.mState.mDrawable.setAlpha(alpha);
            }
            getAlpha() {
                return this.mState.mDrawable.getAlpha();
            }
            getOpacity() {
                return this.mState.mDrawable.getOpacity();
            }
            isStateful() {
                return this.mState.mDrawable.isStateful();
            }
            onStateChange(state) {
                let changed = this.mState.mDrawable.setState(state);
                this.onBoundsChange(this.getBounds());
                return changed;
            }
            onBoundsChange(r) {
                this.mState.mDrawable.setBounds(r.left, r.top, r.right, r.bottom);
            }
            getIntrinsicWidth() {
                return this.mState.mOverrideWidth;
            }
            getIntrinsicHeight() {
                return this.mState.mOverrideHeight;
            }
            getConstantState() {
                if (this.mState.canConstantState()) {
                    return this.mState;
                }
                return null;
            }
            mutate() {
                if (!this.mMutated && super.mutate() == this) {
                    this.mState.mDrawable.mutate();
                    this.mMutated = true;
                }
                return this;
            }
            getDrawable() {
                return this.mState.mDrawable;
            }
        }
        image.ChangeImageSizeDrawable = ChangeImageSizeDrawable;
        class State {
            constructor(orig, owner) {
                this.mOverrideWidth = 0;
                this.mOverrideHeight = 0;
                if (orig != null) {
                    this.mDrawable = orig.mDrawable.getConstantState().newDrawable();
                    this.mDrawable.setCallback(owner);
                    this.mOverrideWidth = orig.mOverrideWidth;
                    this.mOverrideHeight = orig.mOverrideHeight;
                    this.mCheckedConstantState = this.mCanConstantState = true;
                }
            }
            newDrawable() {
                let drawable = new ChangeImageSizeDrawable(null, 0);
                drawable.mState = new State(this, drawable);
                return drawable;
            }
            canConstantState() {
                if (!this.mCheckedConstantState) {
                    this.mCanConstantState = this.mDrawable.getConstantState() != null;
                    this.mCheckedConstantState = true;
                }
                return this.mCanConstantState;
            }
        }
    })(image = androidui.image || (androidui.image = {}));
})(androidui || (androidui = {}));
///<reference path="../../androidui/image/NetImage.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var NetImage = androidui.image.NetImage;
        var data = {
            "btn_check_off_disabled_focused_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgBAMAAAAQtmoLAAAAFVBMVEUAAAAAmcwzMzMAmcwAmcwAmcwAmcySYuXAAAAAB3RSTlMAZk1gRhAMJ+/C7AAAAGhJREFUWMPt1rEJgFAMBuE02gedwA0EtRcXEFxAcP8dXCDvb14gzV3/9WdEVNJwebPtDsDnoiMApwJzAFYFpgC4WzP3JLA0SgQWBgAAAAAAANAJ8m+m5Mj0JGZs6KPAHoBRrfRrRFTRD3MwONmn2VynAAAAAElFTkSuQmCC"
            ],
            "btn_check_off_disabled_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgAQMAAADYVuV7AAAABlBMVEUAAAAzMzPI8eYgAAAAAnRSTlMATX7+8BUAAAAhSURBVDjLYxgFZIP/YICNcwBEMI9yRjkkcPCkqlFALgAAVYo5bSUJskUAAAAASUVORK5CYII="
            ],
            "btn_check_off_focused_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgBAMAAAAQtmoLAAAAMFBMVEUAAAAAmcwAmcwAmcwxNTcAmcwAmcwAmcwAmcwAmcwAmcwvOT0AmcwAmcwAmcwAmczmhCwqAAAAEHRSTlMAmRIfzgUJGg4WJtCScyQtx2HoRgAAAORJREFUWMNjGAWjYEgC1lAcIACr8tDQNJwgNBSL8WEdSjhBR2oApgVN04uNcQDzSo1QDAsi9O8I4gRnP7ViaEj6I4gHnFcLQNfQeRGfBtkZ6BpC2w/i0yBTga6BTV1QcNVj7H62WyUoWJSApiFMWVBwcSX2QJ1uJSholIpFw/PdLljB7jocGiy3YNfgPRmHBiMX7GnMRXlUw6iGUQ2jGkY1jGoY1TCqgRINhBsnlDd/CDewKG3CsRJqJJLeDKW0ocsQpoWvKb0oFbOxnoSvsa4WSn53AKEDX4cjgNQuzSgYBUMRAABvBwmfTLNSCwAAAABJRU5ErkJggg=="
            ],
            "btn_check_off_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgAQMAAADYVuV7AAAABlBMVEUAAAAzMzPI8eYgAAAAAnRSTlMAzORBQ6MAAAAhSURBVDjLYxgFZIP/YICNcwBEMI9yRjkkcPCkqlFALgAAVYo5bSUJskUAAAAASUVORK5CYII="
            ],
            "btn_check_off_pressed_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgBAMAAAAQtmoLAAAAGFBMVEVPT080NDQ0NDRHR0cAAABPT09PT09PT0+86ZyxAAAACHRSTlMm1MgyABYeBtShLDEAAAB4SURBVFjD7dixDYAwEATBSzAxLdACLbxzAkukLoGE/qEAXmIlZ9ym1uTvU8TV9bFyRCiqQO0BnYASqkI1nQzM2hmY1Bkocs4Nak1KwZKUg+21HCQvBgYGBgYGBv8A+HRI4uePc25M+IuPRwQ8U+AhhE4tfMzBc9ENzCYkZWqWtP8AAAAASUVORK5CYII="
            ],
            "btn_check_on_disabled_focused_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgBAMAAAAQtmoLAAAAMFBMVEUAAAAAmcw9PT09PT09PT09PT09PT0AmcwAmcwAmcw9PT09PT09PT09PT0Amcw9PT1vR1UqAAAAEHRSTlMAZoBNQTg7Xj8IR0pEMVYjBJa89wAAASlJREFUWMPt1rFJBEEYhuENVsE7DSbS+GfPyEC4BhYrGKxA7OBCQxsQM/MrQazgSrAKQ7ECXZnzRdmd7x84OIT50uWZN5mFaerq6vayo4cwuknwFArBfSlYlYLMp1lfCNbdBFiO7PIrYNYXgY1ZNwGasR2bkfCAzQAu/KC17727wZUNO/cVCNwIIAIAFdDgloALHBIQQAQAIqDANQEXOEgBBV5cAcDc+r+BEHLg2brfAQHm6fYTEGCdTiWQB7PtsSc/gWUWfGzPfbVhiyYLuJ4xBWIe8AMsCGQBiRRQgAQBCVpAlIAEAQlIRA1IEFCARHQAEgQEIBE9gEQKSEAiugAJAj7QRidgFfwjML4dgqntCKxCZqe+Zyg78z102Z3rKc3eHpu6urp97BNIunQiihmctwAAAABJRU5ErkJggg=="
            ],
            "btn_check_on_disabled_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgBAMAAAAQtmoLAAAAG1BMVEUAAAA9PT09PT09PT09PT09PT09PT09PT09PT1gyl+KAAAACXRSTlMAgE05QT1HMyNi/YIlAAAA6ElEQVRYw+3TwQ2CQBRFUaOo6x/AtRILGDvADrQESrAD7VwxQ+4G/I/EhSb/bcmZGzKwiMVise9v084EXTXxoBnZ/hUwa2eBzqyaAONvYEZCAV0Pdjoo7L27DM7Wr9YKBC4yuBKQwJqAAghIgECSAIFyoYIVAQ2cCLjADwCOUgCwtFYJAA5WCwHAcrjYbQ54oBtu9pYDDtgM3w6B5iN45HMJOKDIBxNwQP7DSgIeyIkc8AAJAi4oAMkFJAi4gETyAQkCLuAuBECCgANIJAWQyAEXkEgSIEFAA0USAQvwR2Bi80EsFov98J52GzL3vLeyTQAAAABJRU5ErkJggg=="
            ],
            "btn_check_on_focused_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAABfVBMVEUAAAAAmcwfqdodqNotsuIBms0AmcwyteU8Pj8yteUyteUyteU7QUMEm84yteU7QUQzteUyteUFnM8yteUyteUyteUyteUzteUyteUyteUyteUEm84yteUBms0zteUyteUyteUJntEAUWsMn9IFnM8NLjsIndAMLDczteUCms0tseIyteUAV3QwtOQEm848QkUto84yteUsqtgwtOQrcokEm84IHSYcqdoDms0KJjEXo9Qiq9s6Q0cJIiszteUVotI7REgPN0UzteUnqdcdaoYeqNkDm84mi7AIGyIys+Mql74niq8jfZ8wfJYFnM8pkrgpbIMmZnsATmgwqtc7Rkksan8sdo8kXnEAmcwAmcwAmcwAmcwAmcwysuElnstChJodcY48eY4lYXUKIy0vp9QwYHAAPlMAOEoMKjUOMkASQVIUR1oAmcwAl8oAksMCms0Al8k/stkAjbwPn88RoNAAjLsqqtUtq9U+stgoqdRavd5Ftdo3r9cAkcEmqNRtLj6xAAAAbHRSTlMAmQMIBR8SDM4VDhzOFBLPIRAhGRclHik9NCMlMZ04LkMZyBcLeg93LKA7Ns0rHNRLSEdBzaZsJKFzMC7Rb1Ur1IFOQTo1o0NpXEs5MtOqSMrGxUzWyNDCko6HbmdiPdPRzsNhVL+3s2RdRkIKm20RAAAGAUlEQVRo3u2Y+VsSQRjHTS6BOASWBXYTNkxQAxJKFCQ88ii7s/u+T8vSsvtv731nZnc22Jhln/qh5+H7PPqDwucz78zszOwMDTLIIP9Lho38SzbPX6e7TfmbDkbvyt8ycLrLFFuKYTsxgX1GzIoeeLdLlHGSCZIAkgMY3dHTgHj4prdnQph8Pq9pWj4fDo/qoQ5q+KMA8CGtXPb0TAyjYOoxLeFnQVWAGP5cwrB73KvcuXXATg5BJicn68lgPJGIw08CHFCFYbAuYEK52Q9+bq4NBhqQgGGUGFBgXUDotm0+4ufWmvVMlAZKwSJ6CLAA7UY//LW1E82SLEnSqY3HZ1EBhh4lgMBbxu/D6InGt91uNBqrkGapJMunZu8/3DibQQOOg1jg0UKW0xOD07PsidXr7SZEzUJOtc59/Xp8VjdACX8WeIhAW4gctE6EZAGyCNlaVNV0er117v337++JIRiHEoQCTygy0ivoqNCk09PrrWufv+ztfSIGLIH0UW+B9+CI/rfuFcjnGw3748GoJBfV9PTY+jzwd9+92yUGUgIdBLGgc3mjeM7Pqumx1AXKf/Pm3e6X/Qcb0SQR+ASC0MERjuVxIT/A+dNTqQuF44SP2d7eef4aBaN2BZzM4kO+PxFPIh+aXzsD/E+Uv73z9sPRDRwEmwKO5mt+AJufCJr57038w7PtTJKOgVjA+0SHAx3x0D0ZqaRa8VsNmQiEsygG05TjkYwJh/2IT0YzchH5uS7+ZlGKMoHbhoDhgYxoP9IJng1v7ljh4m/8+XtqSYric+CzIwA+wyM6EQd4MIl4bD7hH+nkp7NyBgRhG4J8ZAT5OKZAZ+wo0AGfJd3fxS+sjKlFWe8hGwLgUzzSgY1wuVRUAQ/Nn7ly5GoHf2pa0EMdAugfwkc8g2eBPg34GvIv/cY/cqxGBKQAmwJ8pPxkVGE32czq9FQuN0P4+3tmfq6WmkqXcJKy7UAsMJ4p3E1am9OEXgP6zPKTLv5MrrqystqUggmjALHA4ONuMr+eqtWw8cvLyyc7+IVjuVz1/PnzJ5r1II4AK0AgYGtaBvhkNymcmaH0kyeXuvi1WhX4JxogYB0kEGgowAKQD6sl7iaFY0CHnF561Nn/qdRKFfhrjXqcTiEsQCggBSCf7SYXjzwB+mkr/tTU1MoJIkgEKN+mIBndeLD/E2cjMSwB/u7SdRP/I+GPbW2hYG2uEfNzvkgwGoYeevVsZ3sbWNRwdemuJT9d2Vq9B/zJtsfLZ5AtQWbj6Ie3oDAMnfwq8rOVxcYq8CfbZe8454u7CARnZ7lhb//b1affLPhyZbG5CvxDijbh4nw7Y5CRN1smw6dvlnypsthuAJ8IkC8W5PVBlopmw+7e3q4FP1pZrDeAf0jJj/MJKhTgcwACdX2eGVi6+cHKQr19CBJDwZBNAaylIMjA5s4MnfwrBj8eWYihADaqcfeQbQEbhGJ67EKBG6z4/siCRwE+CobtC1gflWD/5QbePyZ+OBIpK8DvU2CUoI6lzjCDNT8wEtGUA/0KXHoJMArcQPmFas3M94EgRs9TLpuCEAhYCVF6yGK9hPzLhWoK9kfOB0GeCrz9CMBAlwupaBh2CH8Fmq8WOd/lSOB20U5CQymr4nvA0Y8/fny8PA/nB+RnDD4IQv0JPPRk52PbJnvVQAPwKV7CYzTju/sT8MMvN2RkPHDBqnG5tapmizI038R3jxwMefoWDIOAGWBni0oSHIw2X7xsFkvQevLSzd+InQl0w2hYP32BRIZfDB82+A4EXhBwAzu2J9mNAcEjn+3vKPD2LxhCA46DoYjzOw+KN/ZfZwJm0E/Z5BQP8QOd4XW+Q4HZQBwgwbCbLRfnOxUwA3+VYum4mnMuYAaM4HLRkUBwO4p45DsT4FLRVyKC50B8nRPpSMd/FzTFWiC+kAr1ivEhzUME5R4C8ZVazIinK4oiFvBLQce5oU0IBPRa03FuhwTnLn4x6yg3FVEB/GrZQW7dUbyiAsyX432mXNZCE+PCAvj1ft+ZADw/WYsUTsLxYoXDDA0yyCCDDPKP8guHrOe8HDBTsAAAAABJRU5ErkJggg=="
            ],
            "btn_check_on_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAABPlBMVEUAAAAzteUzteU9PT0zteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteU9Pj4zteUzteUzteUzteUzteUzteUzteUMLTkzteUzteUzteUzteUzteUvp9QzteU9P0AIHCQ9QUMAT2kLKTQAV3QKIy0zteUAUWwzteUzteUzteUdaIQOM0Ays+MytOQpkrkzteUnjLErdIwpb4YmX3IPOEcjfZ8AU28oaH4zteUql74updIscokKIy0upNAnjLEnjbMufJYveZI9fJApa4ImZXoysuEsn8kdcY4uptETRFYiepormcIkgKJEh500gZsAWXc2bYAAPlMAOEoOMkAAmcwAmMoAksMAjbwOn88/stkQoNAqqtUsq9VBs9k+stgoqdRavd43r9cAj79HttoyrdYAibcmqNRAenSqAAAAV3RSTlMAAwbNDAgOEgohFBkXGx0fL84lNCMQOCoReDInQiw9Sj/Ra9THdc1wO8gpSFY5fVFNSEVEz8vCgzTJyFxLP81jRj401NHPycViTtFbREA6L9XVzce3s134HTq+AAAE2UlEQVRo3u2ZaXfSUBCGS1EhQoCEBAIxCIlIxbYuWDfUarXu+1qlVFqty///A85MhiZw0ZsCnqPn5P3c8zzcmZu5ye1CnDhx/pckDvI32GLmTxczX/xiKHM0hOFHOWHHXPgMT6ePYNJpdsxDEOAJfgxDElCwYXY+4RFumhbGRAcpyDAzn/GmlUodp6RS4JiLgfmEB3o2m6FkwWHBKoaGmfmMz6hqjqKCghaRZsHsfMLn8nmFkvcVUCVYAgpm5Vs+XjEMXV9ZX38BCjRYwRJm48PPV3OKYuh2u7zibm66LwwypKBILJiRn1Hh1wPdKTxr3fvy5ZZ7lQxYpLS0Rsk/RYM0MJ7nOYVqFfiDr18Hl9CQU2EJ0AWZICrfqxaLnda93b1+f2cbDbgEi2okE4gzefj4HjliprKZnKK3nUKxWOo0L+3u9T586JFByUGNogmILeLTB/xyoVos1YZ8MOx9f+xCF7LYBLlgFMw56m//rOrzS0v1C8zHbG1tvXuKAjOygNkMRzxtfzXv82v1G5Vbuzs9xn/cv+Ya0QQJX8BgJENoLFu4PYlf9PnbAf/TNXeDBNQDucCnE5hnvmn5T5dhE//EjcraCL+1YUcTJFDg45mMI98fnDgbbAf4dZH/3LGVPO+ihEzAeBr4OPER7o8e2j5L9ROPBH6hrOM2NWVPcgIFwXnCbBXoiG870F7i3w/zzzRvFgtlQ4EKRRMgn3pKPxzZNNgQj+29eFLgl6pYIW6BXBAa+FAXnMk4NhGPPx/410f5t5eKBxWS9Bj3Z1KD+iCfy27bZYAD3cefHedXbtdgAbyHqEJyAZ8ogF9x168CnOg1xJ89v3p9+3M/zK/zAnjURRBggYivr7gvN1t3iiWiE/7c6oNR/kngUwcywwXIBJqGRwrzX8Fp0urUmX7+nMg/ERSIOiB7ChZBwDMN6nN3G06TteYNpi8vT+QX2ka4QHIBdACeWuTDtITTZK3yiOjAvzyBzw1IBSe+VEBDH/l8mqytPlle7na7Vy4PBH5R4EcSQAfcx99/Ap8M91efdLsPJ/E9T+RLBSYKnr6FQwRhZLh+5eEY/5T/+z1P4EcUGO7r/Y+kYMNEfsHzRH60EhlX3dOfhob+529vLn+bwC97nsCPKrA3WiHDzmAwia97DYEvF+Bzllds507I0Ov3exP4SqMh4YtPMj8Hiu5U7zTZwBH5uUZDzhdHBXZZMeDw7bBB4NeZn2k05Hxx2HETnGrpwohB5B9vaCJfLuAawRKWLlTYMJmf0jSBLzPgeRAsocaGgD86HzRNzhePzNASSnU2MH98vmmayJcLeAm+ocZ9ID6eXyPzU0syP2pQQK/pXKTAgPzmTShP1WkH8yeZFPlywaJfJDTQizrt1n3kw/FYgPMrmD8kWDhMSBB8ien0utJpnf7x41TrJuLLupE/4JNg4bCCsW89VMDUONUivB3+3FvEv144ZJLJsa9VeuvaWH8P9Dbic2rwRQyChWkEbLBSw7cv3YboOuLxe3jIn1Lw+xsDvjIwmT+tIHynYqGCLz1UoPv4YP5MJxgacBGwCnyLp+DF0Oi90LQCNtAi0GGlIHTrxHjmTytgQ+hTiiNczU0vEO8WxcvFqQWS21HAE39qwaHyLwoi37H/J/8liBMnTpw4ceLEkeQXuf5HL4dNIhQAAAAASUVORK5CYII="
            ],
            "btn_check_on_pressed_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAANlBMVEVPT08+Pj4+Pj5KSkpAQEAAAAA/Pz9PT08/Pz9PT09PT08/Pz9AQEBAQEBPT09PT09CQkI9PT36oQq5AAAAEXRSTlMm1MgyiACTFp4eAZeNggYHXQY8LIYAAAExSURBVGje7drBbsJAFENRtx0YJlAg//+zTaRWruQNU+NFxfMa3SOxSBZ5OGy79oGnb/Tb3t6ApSO0vuzAMhDbWDagI7h+wBXR3dARXcdAdAO1Wq1We6mdjojutK6Twtuj++lTCABbn8LDwNT/I4IPaH/bOQGc11+7PxXQfoMBGH0DOErfBPw+gVCfgNv3gYv2fcDvE7D6PtCk7wCns99XQN8mfl8Bvk3svgLsU3D7CvBpf8H3Pu0+AfYpaJ+/ngfuUpO+AejzRvomoIL0PUAF6dsABe3bgAra9wEK2vcBCtr3ARG07wMUpO8DIrCfACg0JAAKDQmAQkMCoNCQACg0ZACugAJeC/iY2F+Auc0D75NDrVar1Wqz+0/fxEf8aCB+9pA+3IifnuSPZ5LnP9e9/QXc5ydUPu9cjgAAAABJRU5ErkJggg=="
            ],
            "btn_radio_off_disabled_focused_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAaVBMVEUAAAAzteU9PT0zteU9PT09PT0zteUzteUzteU9PT0zteUzteU9PT09PT0zteU9PT0zteUzteU9PT0zteU9PT0zteUzteU9PT09PT09PT09PT0zteUzteUzteU9PT0zteUzteUzteU9PT3dmb2uAAAAI3RSTlMAZkxgRwQ4EkgOBiARPFMuWyYXTTYyLEAgCioMFkMyGxg/J0SE03YAAAMlSURBVGje7VnXltsgEEUDqlbv1Wv7/z8yoS2J4zVgmc0+6D75mIEpd4YyQgcOHDhw4DuxVMGW557n4TzfumpBb8VpK707lNcTehPCK/YeAgch2o9L5D1BtO61Xi3fBH0Ysv/WPmiUij1sJIEMRlQld0NVJMe6183P+RL5KXmo/iTGmxedqDi3ZfVEpOROvJRQHZ/bI4FpLNoMAEjWFuMkvei4FT2yRsApFMGJZwJ/gcyxUMG56F5YXxlWU8uhHevYR8iP67GF38hqPtoLDfbxwR/c+gyAnGv/z3G/PhOAjHvxga2jdGLrh2ypAgBuanWlYwaAmQ2sTIMF0yH+XD8eAAr/sdhUAGTTpwa8GNcXy28Wn5TAEH8tmQ5A0k+XGyuCe8YuQOs/E/VboaG3IHqhshszEKDQCPtnAKYhMg9SQ8s3ofEndH0dzkAmGldKQ4QM8EEdqKhxA7SIQxOljIaxovNCEwckXQUMPjLRQODGJpq5cKGGrJyAFOnBJWPput6Fq3RggBkZooBMuhBoawCLEqiBqADpg5SKYsAaUUZVSX9kMCJj3Hg6YIMNYxNupswBCxdiUaFXjSgWFM+cAXMWbiJBSs02J8NIo2qBFAZJ4PNq7kUux0CQFQjQco60JARiyxrhjKzQwqimP4E0oaDyNrjBLBJ1eyqXi2LMoEZWqFmirtpTgd5zEhFSK8QwiJ0+12Yp58xHVphYViTaPPWEAgBkBx+ImI//rwJMOXATIkXyspNk52nqptBGVWgut4qOTne+2Zlu17GL7VodOIWjAwdFzo5M94e++2uLunhFOy5eDq+OF7Oro7rDFkAmwwDNaqLd9T3zLa/vq+0D5Gz+ACmFA3qETp9Q9o9A0D0C9z9jJXH5j3mIi3d1ucpWAtG0Ei68lWDfLKoQd0LTDKlkZ8a+nRPctXPYgnftHCnqrCHVqHbR7pZaNjDLM9VSQ71oqf3EpuCfbc0vck2OL7sbs2Vw+WdPDLAY7NAOhI0ngKOgEq3lsA8iLP+Pwr3N8cZRc1xh/bK9fw3Re5A8+kCxndBbEcpPLF6eb0G1oAMHDhw48I34BUmSKxG/3YRpAAAAAElFTkSuQmCC"
            ],
            "btn_radio_off_disabled_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgBAMAAAAQtmoLAAAAMFBMVEUAAAA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1STLyxAAAAEHRSTlMATAUMRyoWMBA7P0MhNh49I5b3UAAAAXZJREFUWMNjGAWjYBSMAsoB8/NZgiJr6wyIVW/qKAgGIsHEqc8UFLyTwcDUdlZQcBox6u0F3ZMgLLUSwcmE1asKiirA2EyBggEE/btQXAHBYyqUIuTzFmkUFRwbPfCrZxO8hCqgK5iAV0OjOLpIoQReHzgWoAuxi+DzBZcsptjFBXg0BG7CFNMWxeMiwQZMQQ5B3G7iFMVq7QScGhKdsImqiOHUMPEANlEeSZxeEFHAJszkiMsTrKI4wg5XCuSWwBH9G3BoMHTALs4ijEPDwwLs4uxyuOL5AHZxHlFcoZqAI83L4tCw0QBHcEvj0OCogF2cSQSHBkEGXBKUaiDsJAo9TThYJSmNOMJJg9LERzh5U5qBCGdRcgsByosZfuwF2QfKi0qEYU5YXCSKr7iXUsAIo4ULSKtQeEUMyKqyKK8UEdVuA1q1S1nFTrjpEMRAEHQhN05WENv8SWZgMIM3fyhvYGH6/PgsQcGVNQYMo2AUjIJRQDEAAKdsRGG19ZMWAAAAAElFTkSuQmCC"
            ],
            "btn_radio_off_focused_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAwFBMVEUAAAAzteU9PT0zteUzteUzteU9PT0zteUzteUzteUzteUzteUzteU9PT0zteUzteUzteUzteU9PT09PT09PT0zteUzteU9PT09PT09PT0zteU9PT0zteU9PT09PT0zteU9PT09PT0zteUzteU9PT09PT09PT09PT09PT09PT0zteUzteU9PT09PT09PT09PT09PT0zteU9PT09PT09PT0zteUzteU9PT0zteUzteU9PT09PT0zteU9PT09PT09PT2npJ6rAAAAQHRSTlMAmcwElCDAN48ValInxnBLPVclpJCHMQy1nnorizK6dGo6CYB9VhkKhHBkQz8eBwV5X6yYdR0PXSwaKRR3TCKGCl/ORQAAA8lJREFUaN7tWNl6qjAQxmErIIq74r4r7kvtqT3tef+3OkwCtLYWEii94r9Rv0xmnCWTyS9kyJAhQ4bfhKYajm1LuZxk205R1X5UuVh3arlPqB3q4g+plw8Pubt4KD0LyZEv5EKgy0kj/66+YFiyLLrxkmWr1H83oSWJvSFRLZKuXm6XLpburxVj50KzqQr7fjpH6piu/43phCrRclG/F7FqNNv1OPpXdO/K//eb6f5UMQGUymn/OvODuKIVZvHrL9EUjuiv8rIJN2gOyl4ydCJYjKVfWtEfwxYAmNXp8LoThO11OK2aANAaeq5KMSwUif48+X6tACiL9fbj+ny9UFwT1Is/EneUVNzRIYdoewYwB42vMo2lCbDckbNOEvGHoz4lTO8jSW0FYPJyX2w2AajMiAWygblaxXEQn64Cx/L3ku0m9NpBlPqsJ84IQjo0oToPE21UQekGRV3kCJBD/r8Jkwjh3QJM4oOOXl+YDGAjq40w/grqj8ICepiHESZaZ+rP6KyK9VOBKoP87gStnV95LN27gK0Zv5yh2RAY0GjCwPdcZ3RAxgoBaAtM6IJZ9ndG33EH34EKLAVG7OHku1CKPAOSdybX0JuzGmgogLVax+MvMjSJmkgceBKYMSAuiB13c9TV4LgyBsmAgg6wu7DBFhwdI/HBS/EZzgIHJjDw0lwLF3zEpoUR6vklxFpIRz+B4S3P8mq5DIrABQVm3hlSI/ocbVlT+MdnoAqvwfYw6F4d7LGGePAES68GD6FyeBPgRdOCIZ+BNelbMk5JoXJYyReS4w2fgTLJ8sXdPg6VwzIQSc7mfAZeoIk9O7JOcy7wE0DgQwMUb/9DmgZENBAZolHCEKWT5DeSZA2TnHqZMh20CUxjHzTGVrGI0yqKuD31Zsfarq987boZtGvWC2eZyoUj6EmvzEMql/5T+KWffGzp3YwtzIPXgH3wagWDF/vo2GUeHdsAHKOj0P8w/L5wD79c4/sRWluG8b3KOb6/P0DeFFiwP0A6xAEWPMd/QmlpPAJNrkcg/zNWaZPEode2yPcQJxW3OQLsOR/i/FSCMpjfic4goBLylErgJ0PUgAzpTW7JkO1HMsSiZEgcusigUV37dA5RWL6lc0RPNB4hVYgkpEYFfkKKoviVUmtVwIVLqU1DKDVuUnCshojEJQUptLFPa37DaPu0pxafmM1RdEr5z0v5UicZMUvxGHDIElLLhASTZcsoSAHjnJQgz/dzISjI6dL7VH1yiKrT+ay95tRF4SehWYZuk7KybcdQNSFDhgwZMvwi/gPvHkn+qOIQ7AAAAABJRU5ErkJggg=="
            ],
            "btn_radio_off_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAaVBMVEUAAAA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1Pag0XAAAAI3RSTlMAzL8LJcV8OyqQpLpwhGsbtp0zFwcFsZd3VFovqkEfoWEPTH3CfAwAAAGvSURBVGje7ZjpboMwEIR3bHxwhisQyJ33f8hKVSo1akS8hkRU8veXEWgZH7tDgUAgEAgEAh9mM+g+UYBIen3b0MJEWYkHyiKi5TAVABUPxm6JWmvGWAGoDC2DTQCRm5Z+IY+5AKolqmh3gCok/UFmCsi2NJNTAuiGntJoIJlp916giyYed0jtLHcVYjklkDFETd7UCvqFZJtDeddwEtCvVTlSTx/aA2IH2bbH2W8t7dBJF921ROG1gADrqlQR8UmQudfaE5sjUumqvQrUHgWM7uILvwQLId3VUuBEPDJkHLlmL6QUlrXn0RGLCIJYCDQs/YCcWMS4sfQaI7G4IGPpKxhiYRAzPd5wTTswPZPEokHJ0gPEQ0Ks6wM+v2hdJvss03VttNHjqFjXYff245p27AtnbVcm+9J/b9uSovZpvAp3wyq/1nHv6hciv+a3bHjNL799P7cO7Xvs275TJJC7DSBrHaHchkBV0wzq6THWdhB25iB+4A/i/ChBPI0SiokogR2GpNq0D591CEMYHM/3OOf7hZEZ7nHO/wmkfiK1KgGApNfDhgKBQCAQCAQ+yxdkJhHOkHWlWgAAAABJRU5ErkJggg=="
            ],
            "btn_radio_off_pressed_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAb1BMVEVPT08AAAA+Pj5PT09PT09PT09PT09PT09PT09KSkpPT09PT08+Pj5EREQ+Pj5GRkY+Pj5PT08+Pj5AQEBAQEBBQUE+Pj4+Pj4/Pz9FRUVMTExAQEBAQEA/Pz9DQ0M/Pz9HR0dDQ0NEREQ+Pj5DQ0Mt5iyXAAAAJXRSTlMmANQNAyQiHxswCRfIS8NBvhHMhYxtsayTRiuJdp9XpDxaULhc1kjPGwAAAu5JREFUaN7M1cmS4jAQRdFHavY8gDHGjF3//41NrWiilLJU9qLPmuDaSmUYuygya3NrtFaA0trYvM3kLkpEQIrcwMPkQq4PyNYiwAq5KiCswgJlxa8DrUYUE0og4e95WiQHhEYSkyUFpEUyK+MDQoGRfk7gHz9dHhWQBr9m5HIg01hBZ0sBobCKEuGAwFpKhAICGxB8QGALKuMCmcJGBX9AKmxES2/AYDPWF8ixofZnQGBT4h1gBrDNGN4BiyX1YX9rOqKuue0PNZbkn4EMYae+og9Nf0JY9hEwCHkciai4zNfaAa5+zON37nhFiPk30CKgHIiKvsSH8ly8EqfwnN8BDdZ0Jqpmhx/cXBH1E1j6HWjBqgei3sHLvdrDfeEVEH6BZ0FNCVbZUFGGp4Dgjl07ujgEuBt11+BFQmgHnh2NCJtG6srQLiCwxHVBeywaqeLmoOQrwI94GuiCCBcaJn7M4JdsT41DBNdQDz/7HZDwKz2Hy/2STuwZgb1DA/WItKcje0bgPjRfVDlEcgU9uHsEbssGOiDaTEdu1yC5cy0mRHMFN4UdMu5Yz0gwcgPL0MKrohIJntTASyCHT00VkhRUw6eFhc+BRiS5MHfCwjAjOCDJTGcmoOFzpCuSfNENPgYKPg3dkaSmP/DR7MwcktyZW6HgR4Q0jrr/K/C3WTNKQRgGgmg1oQlN8KPgRxUEzf3vqCD+yXR182gv0EDa7s7Mm35XhL9k/DPFfzR8VODDDh/X+MKhVya+9HHZ0kd4XYXwktJx8UtHWvxq+d46yfc4cAbEb6EGZaHyqgm8O03guo291WNbtI19CBtrMeLNYcTtUcL54ogS4DDEHuecPHEOH0gdii1Sq/Nc/4jU+FCQjzXFwHDClkGgFQdq+R6Oj0Q4zsf7AuA4ns8iFhoS0ZiLBnXbo8bXCQWFpZpWa9zLAusSf0PuqSty997TGPZYe7AWN8rkq56ErGshce/lmc8hUyg5pXf9J+VcgrX+8wRytCpX/RrehwAAAABJRU5ErkJggg=="
            ],
            "btn_radio_on_disabled_focused_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAA8FBMVEUAAAAzteUzMzP///////89PT3////9/f3///8zteVAQEA+Pj5JSUkzteUzteU9PT0zteU7Ozs1NTU9PT1ZWVkzteUzteUaGho9PT09PT06Ojo9PT09PT0zteUzteUuLi4zteUzteU9PT09PT08PDw9PT0zteU+Pj5NTU1CQkJXV1cfHx8zteUXFxczteUzteUzteUzteU9PT1gYGAzteUzteU9PT1nZ2czteUzteUzteUtLS0UFBQhISEgICAjIyMlJSUsLCx3d3fBwcEzteUzteUnJycbGxs9PT2UlJSrq6tpaWk+Pj4kJCQfHx9HR0fv4rWhAAAAUHRSTlMAZoABBE0JDAZgKi4FFxMNNjWAPyQeXFJJF4BIIQRHeCkkEzsxDw0JgIB+ZDtWTjBSSUZ7VUNDIEwjCGVZSUdFQj0cEUAtbl9FFhOAeWBKbUEUQ9MAAAT3SURBVGje7VnneqJAFI1hZxMBC2Kj2HUtaOwlmr6mJ7vv/zY7FdAFFDT77Q/On0SBc+aWuXO5noQIESJEiH+JH5XkdDCIRCLRwWCarPw4KjmXmWYjW8iuM9yR6OPdaMQR0W78CPSxYcQDxdihq7foF8lyPM5Bf8Vj5eTCkjgkGoUkc0axsty8tCwX2bU+F3j5A0IxyBQc5S8n5PpFQCMqJLbZivst5SwxIhOEv0+efWQOSOhCTc4DkJclQW8yK/pkFWX//F0SwgJl51/ABmZ8ggaDxCIZjP+RfFBqkDIv6UoDfhAbii4hjZpCrj4GUehj95Akb8gAaHVFhBlKAVWUugYliBWZqG8vXWJ+vE9FAS6eF7m/IPIwIDzZjFjBR6TjUZM/AZcvNE3WbxAcQxNqy01TIbp3thZwfmP/VDUwSzBuBkulOgOjBvYS3g/77rik6VIlDyTRoj+nsCRECeSrZqT7e1Z+dO8Urz8PBMxD2L+bgBpMog7y2Ibi/k66QNu3gPyvWfyI/cwE0rAURigOSxSG4l71GRlQQfkjA4nRnyP6tzkvSJLAz9+QxDmTqAEZVxb03D4HxAKVZvSPAGYi4cf0c+H+Jpe7usrlbu6FOZKgCuIM8Mzy4p4GxFAAAGhQfkj/wN/2Pn+Px+/v4/Hvz94t/wAlqAK8M8Ge3G3CmhkgA56DwPw/03e51fh93Om0Wp0O/GeVu0v/xAochABqzITuzj0QpXtSASOR8b+lrz87406rraqplKq2W/DD53X6jSmIGqjSzRD12gssVFkOG6Bb6/+1gmtXU6cUKRXasfpl2cBjEziyOG9MaWFsAM00IH2zgqsn9EwCWrG6SZsm5HEUurt9xEVpiHnAM/6Hu+cW47crtJ7vHpiCAHga5uyOMsfcOKIpBBOUz30Q/m2FjxwPk5Um0owF0Hs3l2kuJ4B2Qg2Y367ahH9bob26nVMTTjSAtjNqci696xwtWTqoMwGh99FWTx2gtj96AhOQgGI+7oUizQOB5tD3s9d7AyankwBMWOP+9Yz4SAc8PajWngITuhlrQEECKIWun1T11BGq+nSNEgkJKECiUb7wFEB9zhLHOEE9xOdKyABnE0o5nvooAWRa6SeeAigNUBLlgUgF6r3TlLMA+r5XpwJN8ILSaGeeRiDQXwBYjKWrUw9cSVRABBp9PvqVAhwV8HZRYdtF7th20RK5yH+Q3fkdg+w/Td0FHNPU/0ZzF3DcaP5LRcnVQ/ZSobPH/Rc7w9UAx2IXoFyXXAzwX66tA0fYOHCcBXwdOAxFxyPTcHSQ7cjUzCNzHezQN/4+0Qzboa/bDv2Abctzacv/z/a2ZbRn28Iar6FT42WUbPSGa+Plq3WsbraOxlOpBMlLT8Zm69jw0TpCLJgJAnhpHr35pZ5k7bss2tv31zRp39OvG+27ZGvfY35fQOr7v4BkqQG7ET/gFer/eAn08RrbmAHN/hr7v7yI01FCNvZlowQ2LKqYw5CR1zCkHGRk1CUzGuJVRSbjnComTCi6lLfGOVz3kIHR0G0g9WIOpBaE/0gjNcQt16yRGvfIRmrBh4KTisctwYaCDPEJG2s6H6+XAzbWPHgwm03GttljbKLNMiGgEQtzEj5Eo2X8XbycHDL2yDB+6HAcSrhjGDvG/H39heN9NqV2+IFimuFOjgno+OkApxX9iSVEiBAhQvxD/AFA6Z2m0icYqQAAAABJRU5ErkJggg=="
            ],
            "btn_radio_on_disabled_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAsVBMVEUAAAAzMzP///////89PT3///////89PT09PT09PT0+Pj49PT09PT1aWlo6OjoaGhogICA9PT09PT09PT04ODhFRUU9PT09PT1NTU09PT0uLi4dHR09PT1jY2NYWFg9PT08PDy6urpDQ0MxMTEmJiZoaGgUFBQYGBgjIyMlJSV3d3eYmJjr6+tfX19CQkJpaWlhYWEoKCgvLy8hISEWFhYrKysuLi5WVlZBQUEnJydHR0eJLZnuAAAAO3RSTlMAgAIFTQkMSSoDLw4WJDVSSCALPoAsOxGAf3hiQwV/RjIRgH1iH1lURUIcFQ54CICAbWdnVz48eHdubc5A5usAAAMCSURBVGje7VjZcuIwEIRkEskHMsY2+MQO933m/v8PWxGfIng3ltlUUqV+g3J1qzUjaWYaAgICAgICAgLfjI4udw0EgAwi651rsys4BAYhVq5Ir3YBABFdVaRGQ1JUnQBFV73W6g3KHqmU+yYBVVEjRCWu4ULClB4HN58QYCqBpdqhNQDkzc1FbGQAo2a4ewh8JWO8TZD9ofiAerWii4AELDurERBAaq31ywX2uwwFDbmGh07GH7PfZ6A/MoUIQs44SAaQnJ/SL8eWRYhljZcnicwEAYMvlzD4QU6/GsvPbU2bTDSt/SyPV/eZicAHzHW+AHoJP139wppNR+/r9Xa7Xr+PpjNrQV0kCj0AnhPXBRzvD+V/aM21w3q76/dtu9/fbdcHbd56yBQwdDkyFEIp52+PXnZ9e+CYzabpDOz+7mXUPinEAlIIKocBvchP1+40MzjUR1FBr25BASSlATjx2wOzWYA5sE8K6SZJqHIUMODUwGI+svPl5ybs0XyRWsCVE8mHXsx/t7K015SfVXjVrNVdrNADv+IhBtRIDIxnh0G6P+wuDQ6zcWKhgaDacdYhSgXkqZPzswrOVE4FItCrhSDOIcq/fPIcp3kRjuM9LalCnEe4YpKqiYFWe2+alwVMc99uJRZUIBVj3EkELM0tF3A1KxHoVIwyAikRiB6HDD+jMHyMEgEJUCUBgDTGZNL8CyYkjTLA/xWQAPi3qJw/36IAEH+QywWYIHOn6Vu5wFshTbv8B61cID5ot/FB478q3NIdYq4K/svuWCZwzC+7EDo1rmu3xEB+XSvg13lwvOHFHPWYB6fWk+ldjDD7ZNZ79D97GHrso1+3bPHO4uB6dcuWhnFWeB0LJobHs8LLuErp6O1d6sN19x5/6cgmUrj5SvG7CQHzlu9GwJTvLUsmRLZaTPke0M8k7gYk+ncDQgB1fmoLxTSBt2coNIE/uY39SiP+00cJ6TBEPh+GyJTeUK4+zvkQVHWCPsY5v2cglY/UgMLonkZqAgICAgICAgLfiz+OHkqDTzvSAwAAAABJRU5ErkJggg=="
            ],
            "btn_radio_on_focused_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAB11BMVEUAAAAzteUzteU9Pj4zteUzteUzteUztOQzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUMLDgPN0YzteUzteUzteU2kLAbY30zteUgcZAzteU9Pj83gZ0KJS89P0AzteUzteU9Pj89QUM8Q0Y8S1ACgq09P0AzteUzteU9Pj88Q0Y8REY8QkQzteU8QkQzteU7TVQ8SU48S08zteUIRlw9P0AMKjU9Pj8RPk4UR1kXU2kaXnczteUhdpYjfqAmhqovptIxseA7T1Y4dIk9P0A9P0A9QEIzteU9QkQzteU7TlU6WmU5bH48TVQzteUAl8kBkcIBibcFaIkRPEw9Pj8plb08SE0snsg8SU08Q0U6X2w9P0AzteU8RkozteUGUGkZPUoINkc9Pj8ZWG8oUmI7VmKy4O57w9sBksNYtdOOw9QlmL+VwM93ssU9m7qQu8ljipdAZnQbWG4IQFMrSlYRO0saXHU7VmA4dYwzteUmVGQ8Q0YAmcwHnM4Nn88Zo9I5sNhavd9LuNwnqdQjp9MSoNBCs9qi2u2T1Ol/zOZvxuJsw+Ca1+uQ0+mM0ehVu90wrdY0q10GAAAAiHRSTlMAmQTOIRYcEz4uGTUoOCpJHlQmV05RM5VDj0BGO8O2i1oxGYxLgWrDHc2mkm+9lXQp9cF2ZbiLhX96enJFODAM3MnIx6ylmJB8fHdzYFweC7ShmYZvX0s3KCQJ/vv46bGoamdkYFUznoBAJODW1qyU2zv+/Pz7+Pj29fX06N/f2diykT8kENuNq6nwywAABu5JREFUaN7tWWVD21AUHXlpkzaVpKmtRgUodPiKdMBguAwZG7rhtg2Yu/twl9mP3bsJhZZ6y/ap52PSnPOuvXff7bk00kgjjTT+JyQWrdfnM2RkGHw+r1ZJnSk54fBmZpzC9T4ZcUb0rP18Rlic56VnQK/Jz4iCHDJVz5/QV3E0yxLYXyxJc1UnElQqvtcZRBZDjqU2+FWtJcf/LotIevmtIkWrPizFMHP0/mKSRjAXxHRRCsaEAJ5arovRliXDbxa/NRJH7EMzlb2eBoTcnt7Kma4jDcIsZJiBTpyfF0M4LNIXF5WhIJTdKBYlasU00CbFbzCK9HeuYcorhdPVA06Kcg5UTxdewQ+u3RElzIYkFNTwzQWVQH/Zg1Bpeb+TkkjkAiQSytlf7sYSohUyQYFOKL7wRSYJ/N2X8OKLcimJXCplWRKDZaVSuYTKLcJmFHWDAgmBMCQQackFCC8L/EPjCFV8AXqS1CgUKgyFQkOSIDFYgZCnS1AwwAdU3PXVCgsS/FNTinpmKYmUxewqmUOvZxi93iFTYQ1WKqEe9qCCy8deuhhvxenAQSbgv9OACp2weo1KpmeUFlqARcnoZSoNWJHbi9w1oCAktTpOB8FqvML6G1AFLB/TM0raZDSrszDUZqOJVjJYAhvhLEcNgg05kBVf4xK4CAEexgJDboGfVMj0Stqo1uo4nrfbeZ7TadVGWqmXKUjspnJU0IUFaiHQOfHwK8BYJebvHkeFIj9jwfScfarN5WpudrnapuwclrAwgoJzDnm6sYISvmPjEKiCrRkK7BLqyQV+h5I2a7nO9pYmm9Wal2e12ppa2js5rZlWOkAhtwzdgIK7GJ8Jd2EhdzH/ZYQGRH6TWsd3uMbqP7x5/eLRoxev33yoH3N18Dq1SVR4iK4UYwUVfBn7jOvzGzCOLlFyViED/qvZjda3z3Z3f+z9/Ln3Y3f32VtrY/ZVUJApWDlVieb8JvAxawBqTIb5q1GBUyLVyBharZvKti283Pu1f7i+sbOzsX64/2vv5YIte0qnphmZBjupFNVgBT1kR6xaUIo/IggPmqSkpEpvMeP12x483j/4vba1vbK8vLK9tfb7YP/xAxu2wUzrVdhJN1AvFiAyhcVFhxf/hsOGXEZup4TVyJRGLY/5Dw/W11aXl46wvLq2fnD4zZbNa41KmYaV57rRECFuwfYYHoJsJiGFIAKkCjuI62hceLq+sbkC/H6Flc2N9acLjR0cdpKKlFMVkEhCglyPLiCFTQs8VAApJBjQ6bK+2tjZWlkKwsrWzsYrq6sTmwBR+Ix6wEewB0Tf8mgxl4liVIoNUOixAe1j73bWNoE/WGFzbe3dWDs2Qa/AJpSiLuwjON2YqAIc/kUWFphB3yHEjElrb6l//mdzeykE25t/nte32LUmBoeZKkT9WEAbc8fLEfOAqESTood0E011q1s4viFYxo/rmiZ0oo8mUREhHlR9UQVui8VIXEPVElbhsJi5Ntvo9io4KAQrq9ujtjbObHEoWEk/KsQCJJwKUQUgk2uxQAEalLMQAt5lLVmGBAoFflxidfEQBFY+i+5hga/489tRBaCOod1xI6eQpFn8/bxbS8vhBODprbz7fJaQqIOoDH83DGUaVQDOStiIEBKqwJRlb867uRQRN/Oa7VkmEMhFbtiOIMujC2CkIECAQEwXDYe4KBJCXFQLLko8yJEFTgeZgiAnnqaRBSKnaexCmz4ptMgCiRcaJ9Y6MY3KT7aKkUj8I4FbxYx/q0h8s5uPJDAfdrNLYrsuiRDi8Nt1EgfO4q2wObqY+IEDUfYfmaUBR2bdzTBFVhf2yOxL9NCnhUO/7slp/id1AYf+ZMChn2Tbslhyyv+LgW1LgdC2OITFxdN45YuNV1FQ4zU/EpCf80k3XhAoMcw1CD0MbB0/1r8fLRnB5CWj7+s/BraOAwhB66iIo3UEVPlNuITKBgOb308nze+nZJtfgOq4fb+HPM7A9n2izdXS3NziapsQ2nf6qH3vDWjfyYQuIMVuVB7/BSQzLgMA0uSvUFQCl0A6/CXQZDp9CWyoAX5jvJdAAHH75BrrDr7GMhgB19iBHlQqrF8FVvuIxC7iUlAYuodQZYoX8dijBHeRM+ooQSGOEhIehhgs4jBkHKGCipBhSOnxMMQiDkOSGRdxhCBR7Tka58xSGLPB4xzCnuzACJAfeyBVlQw/QB06UpsbB27PXPBIDUD/o6Gg0j8UTG2s6XOELxe9/z2V9GCWM4gUmZzm9CsFfzQvN2hTGZJLj2fIF/J1FlbY7VmW5vJBWUC+PNXhOEhERD55LnWQfZHG+3b2rP6gYEL/oMj0Oogz/ouF8/qEtGn1eXUW6lwaaaSRRhr/EX8B2K81Wi5jkwYAAAAASUVORK5CYII="
            ],
            "btn_radio_on_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAABv1BMVEUAAAA9Pj4zteUzsN4zteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUMLDg9Pj8PN0YgcZAzteUzteUzteU9P0A9Pj89QUM3gp06XGgKJS89P0AbYnw9Pj89P0A8Q0Y8S1ACgq09P0A8Q0Y3haI1l7s8REY8QkQ8SU0BkcMIRlwMKjURPk4XU2kaXXYhdpYjfqAmhqovptIzteU8S1AzteU7UFczsuA4dIk9QkQ8Q0U8SU08TVMAl8kFaIkRPEw9Pj8cY30yseA7UFc7UVk9Pj89P0E9QUI8Rko7VmE5boIBi7mSwtIGUGknU2IINkcPNUMTRVcZWG88REYpk7orm8Qtn8k8SE08REc8SU2y4O57w9slmL8Ch7N3ssWQu8ljipcbWG4IQFMrSlYZPEgRO0sUSFsVSVwcYnwxr946ZnY4dYxYtdNYtNM+m7o9mrlBZ3U/ZXMXPUwdP0sAmcwNn88FnM0Zo9Javd9LuNwnqdQjp9MSoNAInM6i2u2T1OmO0ul/zOZsw+BDtNo8sdg3sNea1+twxuJuxeJVu90wrdau6X5DAAAAfnRSTlMAzgMFIRZIGzMeJz8ZE1gqOS8lQ1VRPTbDyLWBT0sxt8OVHDXNpo29oHQp9cGLHBeFemL83MismJF8d3NgTTAtHhILb1Q5I/7psaiKXE1HrZp+QD0m+ffg29a4p5SBa2djakU0/vz49/X06N/Z2NWypKOLXSwk+/v19N/f1tVUbkKTAAAEvklEQVRo3uyTWVPaYBRAe4UkBJIQIEAAlR3Egqite92trWvVdhyne+syLqMzznRfSNjd9x/c+1HHqdU+BH3oA+dNH87Jvd/lToUKFSpUqFChwp9UIboLyF+3a0f58ND0VNgF4AtPTQ/1YeTWGsReH/PCJbyD9aRxS/qZOlS6/M2TwWR/fzI42ezHSaBuhiRuQd8TBognJpI8RXElKIpvmEj4MHHjKdA/0ATgigV4imMYltUjLMswHMUHYjhGbAALN/IPjwI0fuQpBt1Wo9GMGI1WrDAU/6wRINx3gwKuZz4O3iDRo91sqTWUqLWYsUEST70Q7cE1lf39My7wN1Ac6s0Wg1MUHSbEIYpOg8WMCY4K+MH3EGco0//QBY3k84ke5TaarkFo2oYRksAhkglw9ZRXwP37Sn69sdcgor3bLgklJHs3NkRDr1GPa0pAFN+hHP/AKPhLfovTYaOrJeFNx1ikrS0y1vFGkKppm8NpIYXkFITxlsoINIE3QPy1ThPqxzvbN92yHArJsnuzvXMcEyZnLSkEvDCIAc3+eYBgyS+aaLvQFRlpWV9dmV1YmF1ZXW8ZiXQJdtoklgpPwVWPBa2BUWjiORb3g/4Hnlb5++zW1tH2zs720dbW7De51fMAC7glluNfQR0GNPrfQ7SBYq29xP/W495Y3t7Z3ctk9/ezmb3dne3ln27PW1LotbJUIA54qxoDYWjmGb3Z4CDf/3xucff49DBfUFRVKeQPT493F+eekxkcBjMuaRCmtAZ6wEcGsIi2asHjnts7yRymi6lziunDzMnenNsjVNtEi5XlAj4YrtJ6Qk2lAUy01NW68TmTzSlq6gJVyWUzn360dkm0iYzAN2o7JAxEIXg+wHhE/prdzyupSyj5/ewXOTL+ewQ8pCfaAvUQ5zm9EV9A6hxZOzjIof+vQu7gYG2kU8JXMOo5Pg59mgJDkCAbctq6hfaWpbNcIXWFQu5sqaVd6LY5yY78MKQloJuGZoohG7K/fnE/nU+rVwMq/vv+i9d2siOGegcxnZZAHUxSLP6IaanD/biQVlLXoKQLj90dEo0/Z5aaAL+mQBQ+cCx5AmFMvqsqxesCRUW9K48J5BFYLghPNAV80MCRI60RXobupYrqdQG1mLoXeinUkEPlnoFXp+VKAfrPA22hR6l/8ijUdh4IgE9X9f8EfrVj9ioIA0EQZvURrKyMSPAn8QeNIHYWoghioSGksNDGJpCQ9Hl2c0XIXpITMpWBmxfY425v95spX5FK8hXhj6wuID0y3qbqAnibPvlHUxeAP1pnzUeFmyrkSqMCH3aeqoAnDzt8XFuKJ+bjetDt4AvH39T2qA8sHLYybbYynVPNJ3OqKxNf+s6mcn6HLf0XW/ogtvhW6f59ji1jgS3NwWsqgZfnsv70cPDi6Hjn6Bhug7P1SdOPdQ62IUfHEZFARwR+HwX8JvtdlMNvtNsnKPxyfL+RuZTxPRb4HpfwfQjhu6gwM2gOGBDYQvUKC9UDLBRsAvvCBMI29mj8tLGjAdnMxkJG/Eb0bGDEsSjBmC4aRAnNw5AL0XglhyHL69yuhCF4ibeZxzmHTHKc8/+BFI/UJhfKZE7ySK09oaCWlpaWlpZW+/UFi9DSrrMntOUAAAAASUVORK5CYII="
            ],
            "btn_radio_on_pressed_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAkFBMVEVPT08AAAA+Pj5OTk5PT09PT09PT09PT09PT09PT09PT09GRkY+Pj5PT09KSkpPT08+Pj5FRUVAQEBAQEBDQ0M+Pj4+Pj5EREREREQ9PT0+Pj5PT08+Pj4+Pj4/Pz8+Pj4/Pz8/Pz9AQEBBQUFMTEw9PT1DQ0NBQUE9PT0/Pz9KSko+Pj5AQEBCQkJCQkI9PT27eu1wAAAAL3RSTlMmANQnDQMiHwkPGT/RATAVykWLhlrHvkpO9sMcsayQzp+ZeGor7Fdx4aQyuHxeYgwIBCAAAANrSURBVGjezJTJkuIwEESTkiUveGOxjcHsO9M9/v+/G0dMRMt0q4QBH/rdOKCnUmYZg05Iz08CVyk0KOUGie/JQSc6CKSTuDDgJo58XyD9BSwsfPmWwAnwkMB5VRD5Cp1w/cgq4I/vjOIUvMBReArXe0ogAzxNILsLHLyCchjBu9fXJFEXgXTxMq58LPAU3kB5jwQO3sSxC3ygZwOY+/dmQO/nAx4n8NATnlkg0RdKmgSRi95YRAZBgh5JtIAJuLcqgQmgpxi0IMAjhvvxNU+J0vw63g87PxK6NXQ0mdMd+WTUravo0CAxXRJRtj2fhjchbsPpeZsR0fIEG25b4MNCURFlk0LcOWfjtFFYp3C0IFJgOYxDmu9i/CDeZRRODmBR0ZfAt0RbNafEMBI37mr4YATYB5hllBdgmeWUFfYUYN2x05o2MSzcrrQ+WYsE2w7M1rQSsCJWtGZnCP4LJPv+qT7fZsjYHGQj4CM+VLQReIjYUHXgY24E3JKNKY/RgVtOE5hZNAL2hYowLL4t9DY9luUx3U7FfVRhOGLfCFyHRHV/L7G71F9cPsT9rEv2jcB1aErzGJpRWN9BI2jijKbcNxUDBSMV7aH5W9bfOH5Cs6Mlt2uQzApQdmiNU9Y/KPetEVJiUojgcRUatxbiWBsoWx1YcUXy4JsjnlOhf4S1ERKtgXMY8ZHAxIjmrReuGT70HVIamlPGAibOtNV/vnCCix5hQ3uYCODCxIrOOuGa5VNPyYSwgIKJJemP8JYXbFprc4UJF2by1pOmvGDdCu0PTCiYSUmv8ZEXHHWTaY5noFYFy5pHrxqlv0vwr1lzWUEYhoKoSmoUKihYtO1CwdciiP//dwpdBCEhtzecNtl1VUib3JkzA2wR9ZHx3xQ/aPhVgV929HVtRAPn0OoHjmxkvkNvkI1M9dBvb6Khr5ctJ6ls4YVX5R/jgtBLx8/jch0lHXnxG5fvLlu+b6cxIMses1BJE3jMNIFpG/vcr1zCxp7jNlZkxF2GEZejhNc9hBK6FEqgYYgK5ywGnNMJcA4OpFRIranrRoHUWCjIY02/SQyYjUcr+mV3QTi+BuA4hPfpgIKOWOiQiI656KBu/qgRDUt9Wq2Le8sJrH/LWEXkDpYGTIG1B3lxY4NWT0xVennmr/5jh/qP7UfUf77mb6LnjEYeBwAAAABJRU5ErkJggg=="
            ],
            "btn_rating_star_off_normal_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACRCAMAAAAbxMEvAAAAw1BMVEUAAAAAAAAAAAAAAAAAAACioqI9PT0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPj49paWkAAAAAAAAAAAAAAACfn5+Kioo5OTkAAAAAAACysrKsrKyhoaGbm5sjIyMAAAAAAAAAAAClpaWTk5OGhoZDQ0MAAAAAAAAAAAC2traYmJhycnIAAAB/f397e3tjY2MyMjKDg4Nubm4YGBgAAACwsLBTU1MsLCwPDw+WlpZ2dnYUFBSmpqZaWlpHR0e3t7fVgxBxAAAAQHRSTlMAgGUJTuaZe2oVcFUlBHoQ0rNfQzYr4s2YdRv58eTejjMgBunWy5xbSj3927pHxMGvlMe3iTD2ppGF2LyH66qfatopVQAABLFJREFUeNrt22dz2kAQgOF7gUiI3jHFNGO6jY17bCf7/39VpNgEGEoQ0VmaiZ7vaG72Vrurk1ChUCgUCoVCodB/KXplqUApUMuqACkBSRUc0Rq2ugqMItxCQQVFNANTIKUCoghncg0RFQzpGrSkEZws6sCtiMwCc6PFISciTSAQtSgF9+IYQFEFwBDm4qhAJqp8lwUe5bczKCnfFeFGPuQgrvzm3PMV+fQSgDu/7NzzSzOIKZ8VYCFL72D6nNZZYCJ/GL6n9VpKO3K+N7TEMqVXaW0pH6XgWdbdwZXyUcyp0uvOoab80zOhKRuefZ3THsCQTXNfh5ACVGVT069StF2EVqWoo3wyhoH8FpBSlICWbPFvcKxDW7bd+DY4xmAm21qQUH5wJqF32aENXeWD5SS05dWnqSgJC9nl3Zf2sWob2259aR9lMGS3a1/axxAuZbcmZNLqi3WBhmxZPaBpaWj1erfTGcdisULkk8nKQPbpsyYe+WRf56rTSdXrbtca7ZacFZgc9nYhez2xz2qVsXHqmBZjxWoc4+drUw7oP71xBHOYOuJsZcUwfubz82q12vr2aSKuvS9/a19nkc8/GcbGWqN/P33iZ95ZQUM0uvhWqc6cjU0e0zK5k6+QA+I9ddSK8qJf1VlP9MixgqdH0WwORI4sACOgfS46TX4cvR7HGNt30ef8Fkj21NFSGeBadJmC2znXSgA3osclkCm77R9DwNCSSHkgYSnXroCXqXjtmwEUouoEDyZQFW+17oFRWp2knvC8aucAs6ROFY14nEh3QK2rTpeOYet7VX3OgHhWrZyaSK+ebRextPpHVtyjbbvbqj4n6iWx9T3ZLkt98n3b+pvb5fu2zTa2y/dtW26XpzomcNfQe3e537bnirj1eANkHpS3VkXy0m3vai+3S4NyBmiJK89AMa00yUbgh9v8qaWUPlFouy3PJaVR6YQIDZVGQ8iJGw29rz6igMtSZEBZaVOGgfsnjKTSJum+Dj2CmVaapE14FJcMjWfEKTDErWsYKU1GpzxeX2h8F5OAC3GtreMLldX7Mfdm2t6fFWEm7lW0fVUUh4qc4E3TO88svMkpbjQ12NLagVEgGmzkUGPN5XOHGiwaGmwPmOybU2+Bl71LGmhpsKn9jXXOh8GeKrVYL9b6y3TlDKh14k6Q+i6Kta4yfYktGVXpIrZ8c0+xtpTHLGjvCc/yqavuBOn+++5jzrHy2Bjye8JTWJa99NWeIE01fKAyhOnu8JTUSjexM0gTDVOaCY294VnpjZZB0jyldcE4GJ7DQZpD0fMUej0YnpXejkyqeJ5Ekc0Uam2FZztI/fUk8rp7pDdS6HG+Hp69QTLON7pHSlsK9dtr4TkUJBaTtVG/6HEKzdZfnpDM/i2mYxN4XiZ3y+N/6iSXB4yTBbbEMeHPFtYabgMyHjeyptimz4B57AFUOYGtuvymyPL8WOhigK2wfeHDyX02/ZhjH5SXs9CTNK6x1crKDSuCLX/h1K2Rtzm9eME2cl1NOhls+SkMPR3O7rFFrFP2O8aHhJc3mSN+ammzkjgy3i4oXlans4aAqTzTSST/tfBbV/GA/PssFAqFQqFQKBQKfa1fDsPNndmUkFoAAAAASUVORK5CYII="
            ],
            "btn_rating_star_off_pressed_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACRCAMAAAAbxMEvAAABAlBMVEUAAAAzteUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUebIgzteUpkbgJIis7OzszteUzteUzteUzteVoaGgzteUEDhIzteUto84USFwzteUzteUgdJMGFhwzteUzteUmJiYFCgsrm8QzteUzteWXl5eJiYkysuEkgaMzteUzteWlpaUWT2QRPU4MKjYzteUzteUxrtwaX3kOMj+goKCGhoYnjbOtra2cnJyBgYEXFxeysrIyMjIvqdaioqJsbGyPj497e3tjY2M/Pz+SkpJDQ0MiepsYVGt0dHReXl4ZWG8TQ1WoqKhPT0+3t7doGm77AAAAVXRSTlMAgIAFCg4SGCY2MmYVQxwfIz+AToCAmFZ1XSqzboBKgIBHO4CAYlKPgYAuctrNgIB7aemAgIB5WoCAgOPKgPPfxYj5lIDmttLBr5vVnICAu6yAgO2jRlOc3AAACadJREFUeNrtnNd62kAQhbOzqiB6qMb0Djbghnu3k7jFKXr/VwmLnSy7KyFLMiIX/i9yh7/JnGkaDXz64IMPPnAPlhRVVRUJf/ofwLKqhRKlVCkR0lR59TZJaqjUzCFCrlnSYys2CStatY8ouVZIlT6tDmyEJohlnIiuziJs6GHEsxdZnUVyKIxE9hLqiuJI0rLIinFI/rQKcLSKrJnEVyEaVvQcsqG6CtEkLY/sKK5ANGxEkD2tWOAukgphZE9OD9hFooPKiCEbtIskjXVQHSqrdZGSQPN0OwB1NoqigboIx9kUOwSAxj6aox9soim1EZpjCIQDNE8pyFqEY2zTSAN8BVi/ZhpIIcByLYdynIM6pxmAbTRPxPgUFFgt8RH01RwAdBgX5ePBaCYWxc8AcGmaGS6KRgFlvpjzPwFuTZO4qLGJ5kgFlfk4PmFqNABsmVPaXC0q9gIKa5mdO34A3JmEY4DdwMNaDOnNdYAzcwYAnAQd1mJIPwJcmS98B6isIKyVBJ/zx+YLv0jmBxvWYpXuAoD5lwxAMvBqLfWKaI4ngG/mX74ApNE8CeXT0jEifEgfmf+4ADgJbk6jg4cY0jZh3Q8tXTNZ37MMaRrW+8GVIrEIlV/aGCUDUA+0FGF2lj4AeDDn2QA4ZB70l12KlBo/mQ1MBgAoL3twxC9IkiTL8Sw3eFyYLA/cEDIOKfL0k/gFHzZIsqwYhqpGo7G4Rij0QqGQnmJm6W0yeLAM+FI0qU0/1ysUtCnxWDSqqoahKPLUxDebohjRuNbTa4lItZRqZSf5ZnjKuNjP5UaIL0I3JoWWIoZcLlcch6c085NsK1WqRhI1PVSIR1VFxnixMbIR1UKJaisf7o+QI0NahJhStI0cGfXH+WwpoRdixtRZdvvdqKZHWuEceis7AOcmzxbA+iZ6I3vhbLVWiFmtuLEc01PhEXLBdQfg1BS4AnhEbhhnE5rBWyQZvVQOuSMJkDFFzgF2kEuatSjrJCmaGCO37AJ8MUVOAeAauWSvFJfxvD0Rl+6hk5DIHZmKXNPS5LllTyKHXHNAJyGWezLsuydFV6Vyb4zckybDPYVvH+6J/O0yOJpCrqFtQ+SZtA/3jHsyHUrd88S0DbF9eKCq0scI9zSY2VVoH13kFjo8OSl2/XnGMPnKQWXKDkDbtGMNYLcy5Sn5yuPnGYuspAMv1pqIp/y5ntyu7KTTabCHFiGxfdgz/ZuHlUoyeUKt4x5SpFCfsSVZ2V2HN/DdtOcY3kK6cnDCrQFfxnY0RwUELjIzfq+98nVjyv2puZCzjSnna688Z2a0QWD3mlndzgyqsR2c0M58Wzve+HJzc2O+N1s3N4ONjdu1uysgMCullPoiWW5esXWAzpkZBFt3ADBk8t6weJD4TAIoAIuIPXzTqyl0e8BZNDCXzU0G6DMcu3IzIki0aMNcLmcXgj1oEsfi1pnQbQBZ9C6TAVB7uBCimlHKpB4+m8vjHADWTyybK0HR+4hln2R/5sZcEmsk37vW4wcBq1WrZg6d5YT2DUmvQ2HKbc29y5biWcRT7wBZtbw/A/KHtzeFOb9ABKMzo9hgTxogDqn+OQawmrmLuoLZl/BhseUfAsDV0RLC50ScPGoqdr4r2dyGKffm+3F0RfppWbSH3osIFomB9N18L74ADR/RP+ItUBMJdNMk/99HtksiV6eOBIqsPTSOehMksP+TDof+OGqTmayLBMK6im3WH1oK2ci2Zvplg8rFkg8Z2PbgLl7ds5LNf7ZdfiPNYohEsgWFs4dbOhQtZNsGn/3/rE2yy0KuUUmT8eI9tN5EIo/rpEhe+pLryUKufiQmOd4p9bLIRra2t0Hy9NlOrqa+6MiQhnZphGyK5IZnucpW4dNT8JsuW2MkkASGRLbnS0+964eFXKMUDR8HJFXPI5HyLpHNpUVrdnIVEzEJv/3grZBCIps/XI+2W2T0sZIr7+5GFcuxiKVsAL/dCWaztU5pNHz8yHYC8OB2eH6ykCvCXBX7kG3bbe8/AmgslMunbA0Al5N/G+Czd7lE2cL8XrFtuuOW1ywXYbLLrWy1PXGv6FazNOufmOTrJX2f2wS7bvoX3I444vlVvrg7KtNNsCPijpjugHygMol24OX5esDt9Zua1wgS96G7nh5B6LsY9j21/6uBawAw3fMAUOd2HJ4xqsxwTcq0e46592eTmPesj024feixl/kMYH1f3JP5v8zZp2803XEFMHyfGx4lwXX6jNftVIW9u3qfpK8AnC8QZuFM1BAT33/SN8i5og33bWifXy5usP4TX9ZzDo2VrsQIVwP7BnvwHkdFRoQr07cLdhoN8s/3S/ti7f8QDEezXJkeWEbIA0w52Jw9S16d2RZr/8d7WAtzSX9p5540CZHrHbB7BnjgEr8mewuh0YKkp+6hT10zJ2XOnBO/angLIcekv++8uueVMnWSkPhc9/AdQmkx6U+/iQ+ldeokLvG7noOIhtDi2ez+grjnxGJ1KzpzjdsE67Lf0aMO8Gzhnm3aNTknHfGhv+M3iBQmhH5ynX5wwe6bRScd8x3fbyWKtri+8WvuoHONcY9AssNH0hXbPcIa9tfIukzf+NJh3SPSPeQK9y1A0ns7E18N1+feehxlRPeIJEkktQdzJzw7/h6GlARXhTZokaPJJcLVpIetf0HU8DcTqSXLKjRoA0DnYBO9gWGDBjepRGX27sTPOL0PADO1ZnPGYRc5QtfJr7r9Bhiyg7WfsngCcDd1+1eY0qi7uXrahSl306I0/eyBn9IohfpcTF+ed2adwjqYJ9VWDllRn+l2u+U3quUa9+WWrxcL1CpG4mpMz1vr9gSEW24LUjL8JNlPmJEeIkuyIVXCWNFK1k7qvn58nd05+DHocGbOI7Jzj4xn++2o3rQJpVkJ6PgxSK5xZWi3juzdQ9eSpZy9SQ32dslPoe4mu2ixewgzJ9WadoXyceg9qMXDNGf3UCf10QJoM3Pf7B0ZU/fMO0mfIGt8tXsl4vifbPUMyeaXLoqOro26NUgOOXg+X7PdxktqKDtCC0kovr61JVKsLtp+YzmeaC5UzMOUT294REYtUgodXkyUig6Hwf5/I8JZLQqe6taijwniZY57pHjL2t0RqpbDuxKbfMsXZG/rGM3ConG1YDBqLdQtXstbvbtz+g8tuCvoc96pFhYHj1gCEvkR96q14MEemr/0ux6jcCvBm+OMpMT1VDP3LzuzNP5cQ78Nkw/nWxG9EFUk7PUXk1L5cHNSqvViHtwjfl8orsWjhoyxn9+UimtazPfPSlGr8Hv8jdX/ntQHH6yCPxAVpRFrKWRlAAAAAElFTkSuQmCC"
            ],
            "btn_rating_star_on_normal_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACPCAMAAAAiGKLEAAAAz1BMVEUAAAAAAAAAAAAAAAAQO0sdaIMAAAAAAAAAAAAAAAAAAAAAAAAqlb0miK0LJjEAAAAAAAAuo88AAAAAAAAoj7UAAAAAAAAAAAAAAAAtoMsAAAAAAAAsnMYAAAAea4gaX3gONUMHGyIEEBQAAAAAAAAAAAAAAAAAAAAAAAAkgKIcZH8TQlQAAAAysuIwqtglg6YjfZ4heJgSP1ANLjsAAAAAAAAsnsgrmcEmhakfcI4xrdsAAAAAAAAxr94uptIpkrkxr90lhagYVGsVTWEzteVy6FwbAAAARHRSTlMAgDMambN+cUl6EgLZzY92TehiQ9NmUiwF5moW4Qi2rZaKhlgiC149JsaxnCn88snDwJuTLw7j3cu59ToP+OzX9sqno0H7ekIAAATzSURBVHja7dqJWtpAEMDx/XMkGLlvEMsNUsAbW7WtPfb9n6lZJBVNYwluTL5++T3BfjOzM8MGEYvFYrFYLBaLvYuxiJaGURRRYh1AQ0TIEDCbIjJGKFMRGTW4gINjEREqQHc9yIiImMC5zEYnREfAdylTcC8ioQ4fpFQhMg9FBIwNKElbPiK9qAKXUjmDsgjfYQE+yTUgKUK3gCv56BYiMNEmcCYffYvCzbeApdxIQUKErAIfpaMKNREuVdI38o9B6GXtlHRkytop6a2ybooQrQynpJ/K+lqE6B7mclsOJiJEbcjKbUswvojQJKEvn5uHuspm1OLxXBbaIiyqCbXkC/0QW9GJakIv3Ya4Ww9hJl8qQSGkxfH4AE6lSw8WIhQJSEm3GQxFKMpQlW53YISyFVmA/JvLkLai6eMm5FYNadlvO8u9CxDC+DhyxoZbN5TxUdkaG5EYHyZ0pIcBHIngHCfXRomNadFWh7z0koZy0VZJbCySa5bY1zh5ncgU67VazcBTVXop4a1dqw2LxURi59OtEplygR1cSG8/2IFRK94nd1hxXPqptV/pjYucrXoqX9XJ2WbpjZ+ptTwu5X819frmDN30Wa7aarWkbqVWK5vLfUhfXqH880lpVYBBR76HUgqMkfiX5AEeLVj/eXYbeklV0lkZtFYPjOvdhoI6UU4Gq9Pf8TzKkbm+1UF6AIzG7n2xBnRlcGZAYSR21xwCqZYMSBowLd/DnEEwpd26BCa+t9xrdf3PpH7ZAZA5FL4lTdSSqpsac0Ziv5E/AXo3UquPgJkU+znMOFuGLjc9oDwWe2uoQrqVuuRwymdvR219afuqbvtBQ7xNs64rbZ0roGYJx9vSll5GIF0OqwZcdd6Wrq5K14nQo5nhjfO/k1e3yxLaLFTaPn6Ve/qMrfKULl1py++XtjuVroKOdLmb5Gfp36e+StdKaHdSALrfpU9nTrr0W5VV2nyeKO2sYkE4rADn0o8SMBmLwIzgl9+EZUSAkjD3uzxXRIAyfmf/DZgiQCa0pC/5QN+ukpCX/nwILmfOu6I/nUDfG9vge3oMAnwj/gID6Vc3wP853e/z+zob4Lt+GR6kb8F9izk2QPo3D+yPVw2Y77ed1UUg6vvtQ6dQaIoANNdfNPfQgxMRgBNIyX2cBzTxM6/uQq/ErhTQgDWhJD1U8+Rny/cdsEeQ934SU66y3gN2KrSbeg7WKjYT2+3yHZt12eM1vTQHjOnhoqCC9OndmrW69Euv8LRViRzXPT9azQO4+OrSe4XH+dW1DlKvE/jF9770D4PH8DjGQ2zn73Lx2+5Lf/rxMTyuxyR3kPJgCa2+uL/SP/RVeJLiudUQ28z99poQWjWg6w4PmabHi1vq5mXpD4US2KTPqvCYI/E3qwkvPwLcQUFoZcI3+cc3JzweEutK2u5JPc3Tw3o2N6oDJzxerAm2i69P00NzEV1vlVAr5QqPV5Dy2aci0rs2Fp/ePGc4l+t14zq2eWlzBzR3oprThbJ54GB6uFNzN7deAfsw1jjIDHjaMybWzs/Jxp+8/dQ6zpJwad/dC2xmw88SVcZ22ZLyAqZ6a3o5G6wnRdNnRzWxfSjpreoKnA+wDS3/6a4Y6yNBTWufVmojsQ+rjqKzVw+xtRf77+NDbAda21C58bZrUTd0NiIrYYm3Gi9GIhaLxWKxWCwW+w/9BhJXDgaJOiFiAAAAAElFTkSuQmCC"
            ],
            "btn_rating_star_on_pressed_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACPCAMAAAAiGKLEAAABF1BMVEUAAAAzteUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUFExkCCgwebIgzteUzteUokLYzteURPU0zteUdZ4ILKDIzteUzteUzteUto84zteUWTmITR1ozteUzteUzteUzteUzteUzteUzteUzteUzteUmiK0sm8UgdJIRPE0IHygGFBouo88KJC4YVm0NMT0oj7UPNkUxrtwtoMslhKcqlLwzteUrm8Qjf6EieZkzteUMLDgvqdYxrt0snscplLsea4gqlr4bYn0ysuEbYXsysuIkgKITQlQwqtgjfZ4heJgyseAlhKgaXXcfcY8aXHUvp9MWT2QZV24zteUFHZYuAAAAXHRSTlMAgIACBQgNGCZTMgs2EGYVHB8SI4CAgF1OgEOaKrOAcks6gEeAgHZuYlhAPS55as2AgICAiOmOgIDTloDmyoB834CAf5KA9+PYttuvgID8xpzyw8CAgK26gO2jqAdlyAAAAAokSURBVHja7NrXetNAEAVg71n1Ysm9xiV2lLiGNEiCUyihhIQAobPv/xxYJmCt1oYIsMwF/7Uv5hvNzoxWTvz337+BUpr4Z1DJTKuqmjalfyEoKimqZnQbxUbX0FRl6TFRUzUaGx7xeRsNK7XckKhka606mfJ0Q5WXFxGVHaNDeMOuu7yIJMdKkrBBeWkRUdtIEtGgq0qJZaCm1iGzDA17KSmS3BaZrZNZxkOjaatO5mgt4aFRWSuQedYNJfYUUadM5tNTsafIrCbJfJ4Vc12LCVpdcopkjU/QFtZCKYq3imi6S4Lu5IAtPkVurCmSMvwR2weQvU8C6rEeNGo3T0jAO/guSVBDjTEgKaWToBpwDeTOuAFSlROxUQyuST8A8OQQaJOgrhNbiqjaCFfQG3YeTlEhE1tZy3xTPPYTxNhhqIpOYmuONN0jQWvAc8bYMyB7QQKKcZ18KdPhejSAPTZ2F3jIlXXfTMRCsTwScA+oMN8RUCNB5RjKWizpt1nglE0AKMVd1mJJPwQes28+gJ9oJ7EMNGr3wmf+iH3zKXzyi+6iAxK79B0AL9mNCpCPvVub/fVQSb9g3x0AOySol154iqhTDpf0U/bDLlCKYU8TFg+xpOeUdd1YeCtSrMGskg6U9f34WpHYhFaDJe07BLbia0XiLn0JvGJBm8A+CRhYSmKRqN0kQTvAMxb0EsDqghdHSiWfLJumomS4JlQCdhnvFfCRv3lIK6Ypy5Lvt69GxyGYim07jqq6biqj+ap9wzCsIrdLt/3Fg3cebkWFnmEY/WpVG8ukXFdVHSdtK6Ys0Vumw7QdN6P1rWa33GoUdb1T2EiODdfrnjcgQRdZYMQ4Yisijzyvvj5Mjm0UOrpebLTK3Z5lVDOumlZkSn8WjKw4rmb0WnohWR+QX3owbUJcK2qTXzqpDwt6o2tVU449J1dUUlzNKutJj9zWNnDFwvaA3FtyS4Nkp9WsptIypWI4KauYPCERnOWA10xw6C+OUQw7Pc2Rafg+tV/0SDR5oMJEV8A2iWij6ZqUi8ftDUlUNeCAiZ4AOCMRDRoZhQbjKXskqjsAGIfbiqLStWlEktPzSGQfp5sQ7wCokeiKP65KqdIfkuh2/OV+psn4iOxRWZW+3+8WSXTH3NjgvAcuSXTDvsItpRHd48eGOD6ia90MYv82LDpudxXHxzGJgF+e6K+e2Flp4l3+xse1sW3gLptnBdj3f3Qvf+NhaeIOEYkLr6RtkLDV0la+vbZdq9Uw3wGbZw/z7dRq42Dz+VnR9exJCRl1LpZ8u5bDLVyz+Y5wG7W1y1LoGnCytjcfcSuOYLcy8XnlxvXm2MFr9lOn/o+uVm58qUw8hqB2xl3d+lVtN/kJ7rtbebFytHkwGo3Y37Y3Gp1vbj5fmUQXulIqqnTyyLzgE8sCuVMWh70KgAfcuXdmvEiUcgBiiMiPJzz0mpOipimdCBGds0UbHSJ8+7/el2d+RznOAthki3W6y8XDvVUqhjcjomu2SM8gxOOXEJ3e+HBWawDes8W5ApB7N2+4Ulv4enrfP/2VEVuQFQBZoVP768c3ktqaNcyxu5jSHlUA7Atbrj79lk3ljE7CtnIAjtjfd+6Xc/tC2POrwaVa6YsDtpSFv6T+bUcQ2o9v3UpLiSkpbSXFkb8P4PDpAsqnJG4ePZV7f6Uz/1dy0ea3jD/3tZ2rbWoaCMJzl0JTSitpCgm11qat9g0wgrZaR0tLLSpQCii+jP//d+hl1PWydxkv23H84PPBT8Is+zx7u7e7udORkE9DZY8QELIIYSqE9HFl9jziSD7YHrBoo6Mo5Y9WR9tC0LU9ZQjtANsjLCrtdRnCiwerou10JsqfkCEUwR4ZmYLtM6aO/3uL1dCl6It4G3d0vStr3W3uM4RQ0Daj0TY/E3RNGEauWlDYA5f8XltBW4sT8//xQEPXuA5XerVF2c0O00Tb2ZxE11BB1/2Kk8f2YGljhCL/D47T0XWro6uzieSMkVm362OG8B5oS0VXg2F090pYPhhW3lEJiU0EbbfzVLlreK6Qj28X0NxBKySPYTQi2uYpctcHhnHQQ/JJ2iit+icM4VwUSddmVwvIXTI8sx1Va92pKGnj/IspYS2GceLbcPpQaNvlfGlaPA8VyavnwOlDoq1lmvtPOS9T6QLacLRFww0jDDh/RaAL0VaMMzYwjPq3cc4eosPZhLZSsI/7iqacyf1G31mzKEP6+7FOsHHSfxLrEfdIo/yC1MxqoE4whr5HDD0gygzaj418b9Pc4mtSQrXTzqlxP7QGI18DwCwGzamJWwOvYdpigiW0OaDHkXbPoynvu/JluqvqoVR0OJn0mzldqR+a7q5/BesX0CdLhzVpCPICJppmGHE+Qe3xVCj0Y5l+9DUNrjlv4b0retC3Emuhq8SaqIwDnx70ZbGuqMHzGZ9dLpISLDnwYV8RBnYDfUtMYPZOn2AvqEtFuF18oU2sz6MRgfjn40I30KvJgZ/OoK1cbJfqnVIhS2HKp/OpMGl2rD2sqct7MHKAoF/o3HMkJPL6UDu0WsqBfxKsp5PQWA76u2r3wCU5ctLoWB345OwBEtIH/ZsnkXugPomcdK0PfBARWUJHOOivzsA90EwCJ8mBHxJEBBJCtRlyzy4DgJMu8f11hyQiKD0g098q3NOCrBlz0mlc+odUEZUqsTX3l8g9cGfH/W35v88535ZXUi2ihMqcf/5tofMeuEeFHaSkkZw9ivYaLZGFUt54Du7RIIycdDP/PXvsENIZTPNBQmeQuZB7dE4avNGJqFKi1UIPoHl2ySG4EFC4LZ/+KhvLpJoIlnDlU+jNQPQLL87ZH2BSBnGLk6hBWdq1pHL6Becc2HoWMj1wO3kW8faF8wmlsM5Ix+JulMjmN1GdMTXZeqrxH7PSG84/oaORpOnF5XaUKdRi7jZz6jW2xxFvb5/GVd0zUDXeUBlyfv0kga2Dipt1Nj01b0MemRTrgtTvEINMoKY5erqiI5Yp2HW1k8Lox+NhljU0qIdWZo404mlX3OgZAiu/FXQ0Uop+wTbJoCDmodpjluCen/2tqsZJbPcw5qF6liLqcCdkWvdAwzDJSawx/UAQNaSyZMSfaLDWvjvpPtOAkMwg2SfhoOfCIxbgJAg3BEK6h3JIh/3cHmxBx166aDMdYNuM9uUohhfAGx+onbyRGzMEQusT7fAgtJs2zLoU2/Ruv5PIWDVvYAve4cFsbWR13W8QN+INbeYQ34jAbOlhiTdccvsMgDZzTGHlXTVpxQpiS8ObE3RPlH8QbOaYDV9shUUHzSqKLf1Aye17qtldyZQw2CuI6ajYrGbRM0OJUrL73ljWnw+bA2ne8oFvPcbFXF9vjt4kN/A7vzJcuxuYz+7w1zBe0ctVNqtb8IWKiUkF8WKS7xU73Xp/zymZ6xl/L+Ta7tYd8WER4U0p17adbAEcTIElPg1bwe/4lx7e+o//+Hv4BrTtIsYUPbP9AAAAAElFTkSuQmCC"
            ],
            "progressbar_indeterminate_holo1": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAl4AAAAwBAMAAAAybmm2AAAAKlBMVEUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteWZdn3rAAAADXRSTlMABRAKFywhOfYnMR3v8BlJngAAAUFJREFUaN7s0D1qAlEUxfE7hBRJNc9ZgZk0IU3GZAXGzsZG0A1o4QIEewsFQURBtLHyoxURXIS9he7F8jRPEN6c7vzaPxwu10RERERERESe4R5ACYExmtgi+oXolvx6ZXGEEgBjLM4c+0L0zEofXmkcoQTAGEtmCftC9NQ+K17lnxeUABhjSa3EvhC9bNWW1yFLUAJgjKTz7/6O5AvR93aqey2LBZQAGCNp7t33jHwh+tTaXa9dsbDo5gBjJL2J+9qQL0Rf2/nmdRm/jW45wBjLwObsC9GvD/9Ve8VAAIyx9K1BvBBd/8r1X6t3DATAGMvQtsQL0fUv/evenh3bAACDMBDcf2tW4CUapLsRKBKwzevNvLz3/seDedlX277qHmr3kHu73dvynJbnyAtbXiiPbnm0vqP1Hfq02KcBAADAwgBwBEHj/3RdFwAAAABJRU5ErkJggg=="
            ],
            "progressbar_indeterminate_holo2": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAl4AAAAwBAMAAAAybmm2AAAALVBMVEUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUW/iK7AAAADnRSTlMABQoQITkYLCcz9hTw7fhFXIgAAAF4SURBVGje7dmxSgNBEAbgOUE03e5aWm0C9l7ExtJDlDRpUtgmcgg+QCS1KGqTQkHyAmIjKEF8Ct8iRQrvGcRrdCN7e4ObsBf+rzpuYJYZuGN3lgAAAAAAAADKkAUERdKnmdUCyy0ockdJ1e0kybpHWkTGaoHlliSdUU2Npp0m1fQoFpGxWmC5NSlnNKbd1C4WjbfUn55W5mpec6/spQzcas9i+o72aJzYvcqtxKOWVifJL4HlLq62m0dbdNq3Ot+XO1d9fy62Nw6NF0Hlzqt1RS/pqGN1fCvf7zv+PLxsXhsvgsqdV+uK3tFHZjelm8ynYS2bm+H6c8bArvYxj34W9mtCg8r0q73G6Re/2icaLLxf7dWf56r1a4p+saqdlOrXqDr9qv2/X6PiKPrF6xe+R873iP9X8P/7Zd9PYL/6Z7+K8xDvPITzNvO8PXbMMDw6mJm5BJa7W2aeg3khb16IeTRvHo37Dt59B+7TmPdpAAAAAAAAACV8AcebDMLiSs2oAAAAAElFTkSuQmCC"
            ],
            "progressbar_indeterminate_holo3": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAl4AAAAwCAMAAAD3noS3AAAAM1BMVEUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteXQS9SJAAAAEHRSTlMABQIKDyEsGDkm9TMU8fft+mrRFgAAAchJREFUeNrs0ttuwyAQBNBZLsYY4vL/X1sbq/CKKky16pyHJJZWuyNnQERERERERERERERERP+BaT/mQ2UUgarIA2nXH+t9uj9E7m9jZLq2WRFdiVem7cfGBw3EWrkfxb5ABBCxiogARk3ilWl7TcYHBda56/l6ctO1zYroSrwybT82PmjhQnbWGOtymO/ZHBT5eRc6LEzbajI2KHXQIXsfrIgN/gX52axItmL0JF6aNtRjo4O55kOI0TsR5+M2Xdushq7EK9P2Y+ODMcCnFLNIjmmfrm1WQ1filWn7sfHB5PEp5YhAPMobEpCKKqm+Cy1Wpj23sWO1T/5TLl+1XhuwsV6PHdj01Gtl2jONHat9ikvqtQN7UYX1mlKvjfX68z9MV9pz/2W9EpBYr5Y4qarXsrTn6LEjsV7f7dsxCoAwEATAMlb+/7m2WlgYONjFmRccKCRcdhM+WNe0H34vh2PCcdM17Xm4e1V9sK5pA6/2FhMP1dPuLCasVa1VB9eqHoWKJy54FPKk3TtxwZP2aCBn1QVyVlUgZ8UHcsQJb8QJ32zGCYWhmyfOD0OrcqhyzFU5FNGaJ84voqnRqtGO1WgBAAAAAAD4gwuJzBUuUw2jkAAAAABJRU5ErkJggg=="
            ],
            "progressbar_indeterminate_holo4": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAl4AAAAwBAMAAAAybmm2AAAAMFBMVEUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteWkAkYNAAAAD3RSTlMAAwoGDyEsGDkmMxT39O9TQliZAAABzElEQVRo3u3ZP0sCcRgH8MehoCZ/6hvwDzSfNzZlRoOrIubiJAi1hHFEi6O01GJBEbgEBULQH6I3IOLSFjT5ElxFtOvH1XYafPGODvx+lpueh+89cMfvjxARERERES0tpVRYP0IK4dT5woniMecFF84hWliUaZqGEhU1EUrX+cOJ4jUjHFIL51C6iZJ0QjMkmgBgBQHonAyH0niOGU2SkspqSZXOArCCAHTOGNEUnmNGk4zsWpZ1klGpVwuhCyx/OFG8Vo9HchZg5kie49FcXV4K2qHaKEAegYIAdC7HI0dgiXskRd2kLMfVarWWVzsXVUAtbwIFWGfDh86t7Vhp4RytrVjpUvaazebptfl21wRgBf/f+f5p82rRHE6TWxna2qfc2JCxPNj+GOso3muvDWxM15Vjer4y/PqZ14ccBGVeIx3Fe41VdF59V45pZW3wO6+u7KNvdWb7YwREQeb1js7LlWNSWeW85ur9Na++dIIzr47tvcY6PC9Xjkmb88Lmxe9xvh7/Xx7877meANcTXK9i61Xuh7D9EPfb4H4bP89BCwLQuejZeQ7PC2eZf17I82jsPJr3Hdh9B+/TsPs03teC97VERERERERL6hv2rPU7MZ28hgAAAABJRU5ErkJggg=="
            ],
            "progressbar_indeterminate_holo5": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAl4AAAAwCAMAAAD3noS3AAAANlBMVEUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteV6AHYNAAAAEXRSTlMABQoQFyw5ITIm9R889PfwHc7yYP0AAAGqSURBVHja7NLbbsQgDARQc12T7KbL//9scfqQSyshdYWFpTmPEbFHMAQAAAAAAAAAAAAAAAAA8An3y/5VwbHMIBu5Tyn1Z5Nw/ka+O+cVHMvMsZH7lFJ/9k+/fLjx8p8PCo5l5tjIfUqpPlsONCHeBC+dizpaCNeWmSOXN3/ucSn7NZEDTVwfF2uUF29fFRzLjLGR+5RSf7YcIKJ3SRdlDc6FtSQFxzJjbOQembK8O7NlORE9OF9wkf8KZw1conOxLTNmzx1mzz0wZb8mcoCIvurNqxCVV1XCRFwN4v2SZjcw5ZY6s6VHf9RrSURpqUoyUa4G5f2SZjcw5cad2UtCvWZ8OBsp/10vJmK1m3sSPatBLTfPX6+BKbfcmb0w6jXjw9lIiXp9t2/HNgDDMAzA/v+6szcDHSIZ5AUCkqGN5aHn4DpSul5Dz8F1pFxcL5/2iR/NHSn9OQ49B9eRcnO9PKsGPlh2pNw8qxoK5Y1bOlJuhkJG2qdzJ4y0FXLO5k4o5KgTphX1OlIu6oTK0LdzB5ShrXLczR2wymER7XDu94toAAAAAAAAAD98BS4GIUUirlsAAAAASUVORK5CYII="
            ],
            "progressbar_indeterminate_holo6": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAl4AAAAwCAMAAAD3noS3AAAAM1BMVEUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteXQS9SJAAAAEHRSTlMABAoXECA5LAb1JjENTd7cUtpBCwAAAcdJREFUeNrt291ygyAQhuFdQCVgk9z/1ZbGtkfgTH/QVd+HQ2bYb8IeGEEBAAAAAAAAAAAAgL9Q1VgZqvXJ/uOrcjzcWIJbTt4h4LJmcyq6uo8sGl1P5iqfPfgSsMeazSkXqmanIurm0JG1ymcP3iHgsmZ0c3Uqisy+LjgRF/wOglMtlY+nBBfTwXsEDFHUhWYL+aHOO1Xnh57MVT578B4Bg1Odfauc+DTVpCGohiFNPRmrfPbgPQImP2ssazbKyTBW5RRiDCmPm8vJx+hL5aN5BQ+Gg/cImIegjd3KKajcnnW3JJLK5A6ySH4eUX79ZIZ1CPgIIm/NFmq31yQy7fNbjSLj84hK8Ml0e3UI+PDt9ppoL+O7Zz7g/ZftlUUy7fXT4Nl6e/13wPvQbq9MexnfPfMBaa82+7tnPiDt1WZ/98wHXG0vHu2NPzmbD3jnn2OT/d0zH3D9xQSvVW2/tTQfcP21KodCps9czAdcPxTiSPtCwXc40uZCzoWC9wjoVy/kcJ3Q9m098wHnteuEXIa+UPDtL0PzKceVgu/wKYe2SKE9Gax89uBSbLimvGhlfNPNxyc93LCffLHVkgAAAAAAAAAAALiGdyuD+5ssDOz3AAAAAElFTkSuQmCC"
            ],
            "progressbar_indeterminate_holo7": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAl4AAAAwBAMAAAAybmm2AAAAMFBMVEUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteWkAkYNAAAAD3RSTlMABQIKEBcsOSEm9jMd+vBmaXrxAAABc0lEQVRo3u2Zv0rDUBjFPzNEShZN4p7aJ4j6AkF9AFG3Dp0Et2wdfAFBBwe3OgtOydpdB1/A1UdwFy7xZvLDofY09HJpzm9qPw4/woGE+0cIIYQQQgghpLfsa9RgZTKRAIjjdnHq0in7c7iribPADmAAh0/21oWlMkkONXkW2EE38p0twIHbg8StS3cSy9GJ5jge2gEM4PDJ3rqwVC6nl5qLg5EdwAAOn+ytC0sVMr7VvOWJGuDgDtw+Gjt16dT9ubxfaZ6K1A5gAIdP9tYFpa5f5W6qmRfpbNqR+dke4MDt6cypS3dy8yhfjeb7YVA1HTF19AnEYfugcusyk9/Uy9++JmH3p6mjZo2UYeXWZepwvX2V2/rfRvX1zL7+xZQL+qoj7/uKKrcuo1If7Avri+/jEn3x++XV975P6wmuVxevV7kfwvZD3G9j+22e52DnOTwvhFIFz6OhVM77Duy+g/dpUCrjfS12X0sIIYQQQgghfeUH+E4C2CXdn30AAAAASUVORK5CYII="
            ],
            "progressbar_indeterminate_holo8": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAl4AAAAwBAMAAAAybmm2AAAAMFBMVEUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteWkAkYNAAAAD3RSTlMABQMQFwksOSEy9h4L8O0G0W7OAAABgElEQVRo3u3ZsU7CUBQG4GMHlc0WuzG0TdxcDJCY6GJgKwuSvoFhwIWtcXZpZWGT8ABGpg4Y4kr0PXgMw2Jd1Jv0NjbXHG5K+L/xkvzDP9B7zyEAAAAAAICd5WU5RGR4HBy1IPV00pTz2wiRa0o88kwWlmO4Zo5ypRfniEYssgOJRW7Aonu0ZwfsRLph68kRjXSpV5csvVqdxaXlvuWdlyu9OEc00qRGW9L0em0WreuTRt55udKLc0QjLfKjrFHHfH+NOLwsa37ETqSf+npyRh3ru5E5LfqSuXnRZ3F7Vl3knZcrvThHNHJDcZh1d2+eP4YcJlfHcchOpFdjPTmikQmtUskzPaQ8xpV0g8aHiaacp59GPmmV9+sg5TE8SDdouJ9oypnRAH0p5Kz/7GtG0+3oq5JoyvmgKfpCX+hrK/rC/33WGt/Hf94ncF9Vu6/iPaT2HsJ7W+29jXmO2jwH80K1eSHm0WrzaOw71PYd2Kep7dOwr1Xb1wIAAAAAAOyqL3DZCqyBVRiEAAAAAElFTkSuQmCC"
            ],
            "rate_star_big_half_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGgAAABoCAMAAAAqwkWTAAABEVBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAA+Pj4AAAAAAAAAAAAQPEwAAABoaGgAAAAAAAAAAAAAAAAAAAAGDRAAAAAAAAAAAAAAAAAdZ4IAAAAmh6sAAAAAAAChoaEqlLwjfZ4SQFJDQ0MAAAAAAAAAAAAAAAAwqtctocwhdZQ4ODgAAAAxsOCmpqafn58qlr6Xl5eJiYl3d3cKJC4hISEAAAAAAAAAAAAytOOysrKjo6MtoMormcKUlJSQkJCPj4+FhYVycnIfbYpeXl4OM0IxMTEMLDgGFhwxrtwsnMYpkrknjLGMjIx/f38YVWsAAAAuo8+bm5sieZofcI5vb28bYnsbXneqqqqnp6cea4gzteW3t7cki/zoAAAAWXRSTlMAgDIGGk5+mmF7N5lws1oWaGU8hXdTEguzD8x0beXYw5ycRCsmIvHmvZcd+eri29rMvY6NVklA/vnn5d3X09HJuraslZSSiPbh19DPw6cO6d7Aubivre/stqtpT24AAAQ9SURBVGje7ZnnUttAFEZ1ZEtxi7txsMEEHHoNoYReQ4AQ0ov8/g8SSTizlhCoLpnM+Pxnzvjq7nfvLsqQIUP+BSPlrvIklMmOKE9ADmgo8knVMUkr0qnCGWQU2aTa0AEWFMmo8M44foKvVIaW8RP0UUUq01AzjN4kTClSKcKcKVqGekqRyK0OM6aoNw+qIpEteGlYokOoKBIpwJ4t6tWkHtpXVm/fib6BpkhjAyb6oiXISmuHpg7v70Ry2yFnt0Jf9EFi4JXh6k5kAUgaSyUrFYToFLYUKWzC7wHRZxhTpNCG3QFR742kYTFtHaJB0bGko9SACYdoSU6yprIwI0QW5yBh8VIhbzhFR1BMXpSBa5foLejNpD2jOmy7RNagzSXoEPHjFh1IiKEKXDlENskvKSN2/AiRqF01Viunbbpqn00tA989RKtQ0LSc2idt49cfaVWtalqxUtHxZPeeyI4hT8YqFU2bMs0pd7w0yvjQMrxEq8LkTaGoDsiaOKnlbX686NNqXW4bDpFgaW3t+HmfZzZut+rMMfLfX8y1Wnuzs9uGHz0/lsbH19ZuTLNVxsHypTKIyDTii0Sv0C4pitv0NWHRIVAYcXd0EfiYqOi18DhMGpCfTU50CpRHH7g0crGXkGj8HNh4YC6qOnAdTyTa4LElaboNnCQgOgKy3cemTgV4ORtX9M1qA0dbe7dErRNLtGMd08xj0So+1EQM0T4mWoD1KF3wLZ/f6dFzwaZR0a98j3S1nW6lwAuCDnyJINrHcXoCli+/G1wkypZVww3zDUw6PqIYZRPkssBcMJEoWyPCMl4as8sXVHQsyhaWVAOTlUCiHVG2KKhZWA8kmhSHNBKlAswEEYGuxr2IfwoiegOxduNRuAhUutOY94oq/Agk2o95r8j4d534SLfxHn+2/UTiThbz9hVMdBDrPluE64Cit5BNxbnxLwaNoGfwKsaDYz5wqN6AFuOVaSKASLyjxHiq/RR8TJxHfoNaEInqZNF7vEZ+3Z/yHnydPPOHHqJlKEcO1Mt7mpkTLOaX75tqEYO16RWonQsgi8lRYsHavX8xe39yt4WqlurZeELh0ICW07OyDhSmrYeUDCYfXOEQscHrruG6ODe4VOfsH7XjMM1HavA0nA169t71f06fkYr9o+I3eNV5Jftyf2ur6q4ftRxp+hUHZ97lGdDuulcX+0cdOKZf+AQfSO7FCXt3b3r8bN3RfpMREnxBJPeV1Wz1rvc+Vh48UzcRPlL1b/7MvsSkePvQzNrSgfPVvx+pEuETdSxPC5PCIwXpn6nnvyKO2bb9P6kVqwn0KZ8/VttA7fBuzKZDb47rxsxXTDIl/5m/aQft595zyIWe4h/tXqurwY633RSTa6CF7oWanTjNwKtZHZtM2HXBIhOm4E1NtxsnnEgDKtNhH8cbhA7waluLsqWVtsYyypAhQ/57/gB4BXFFXDX4xQAAAABJRU5ErkJggg=="
            ],
            "rate_star_big_off_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGgAAABoCAMAAAAqwkWTAAAAyVBMVEUAAAAAAAA8PDwAAAAAAAAAAAAAAABoaGhBQUEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJiYkAAAAAAAAAAAA1NTUJCQkAAAAAAAAAAAChoaGPj48kJCQAAAAAAAAAAACmpqajo6Ofn5+WlpaUlJR1dXUVFRUAAACrq6uampqYmJhwcHBgYGAAAAAAAAAAAAC0tLSxsbF/f394eHgAAAAAAACMjIyFhYV9fX1tbW0sLCwAAAAAAACioqIAAACvr69YWFhUVFS3t7eP8DjqAAAAQnRSTlMAgJkyeRpOs5x+BQNzDmEWOsxaaAmVg29TLuTSjkQlHurn4tjXvIg18d3aua5kPhH7+MS+ZijPycK2klZJ5mz1qadtR87CAAAEB0lEQVRo3u2ZiVbaQBSG5wshhbCGTdZKVVQExIXW3bbz/g/VTMSGJUgWxp6ew/cA5Myd//73/oPYs2fPv2Ba/S4+g1wVcyo+gTOgKfRjm7ikhXbKUIei0E0uD8fAodBMCx7l4BNuqQqOPIdsQWjlEE6llBnoCa1U4Nb90BGYttBIIQvn0qUOKaGRS8hIRQdmQh9K20Pp0dDatF+Vtt8YgSW08QQ38o2+TjkoKfyUcwyNcigrKbzzQ6PhVeFE/gXQNJZKyhV8xnAptPAMD9JnCAdCB6qJ2nKBro5h4TeRz0BTKzXhXnrobaWaqfx0iTpoWLxSYMhl7qAidk4RfshlriFbE4od249cJQNnQqHHfnw6Gmxopuxnjd0vKVNoyHUyUE5kAmmPVmrOs1WEsVznGA4sq5yak/bYpg/3dy8tqzKbZQmkLQPoEsjrbGJZPffL9qq9NKts4U4GcdzlY/KVVG5BuyzTMDzGX+Y4zpHcRN9xRl/mZAzFKcu0ln0M93dvHWf48nIlE9N/aTvOjftl4GDxzuwiau/YNUNVu5IQq18ayd3SWf2Owq4Av+UuuVXfma73jgUY3+SuuPoFVAsb7IzTodwN7TrwZG9Ic1n8WZCMC/hoSTrMozad5NwB5kfTtzABMokvarQmt2BJNI5lEr6pNi1uHR+pLGrdic9JA7ByYivpg0TlU92TDTfga5X45Wsbyt1KoRcEVb7buGXzuydk+Yy2jMgAMKPFM/tJle8ketleSyIiZ2bE8p3g0rRj5K5o5RvNyxYDu4nLRbgm9csWh5QJXRkGZQaWnSC25lVWCQFkW0mDeF+GoAuFRBlCBfEwjKGcMEOMw2q7mCh9hVJd8lxRU+lrO8kz2Rlkwu9wlUQvqB0ZjuskbwG2CdcyJAZ8TfBWYsiw3CR4R3mOsvj3wczFf2Xqy9DUY79BHW5y1OAANYj9ut+DQVCaNDCCtHgE1diGup4ozx9QGAFZ8zSmsdaCDPX4FDCDw/M4pjm04NdqV3rHseyU6U/55ObQBGcli3SBAyWtaZH1hHMdT+C51YfAqwEL87ps+otzMoGnob6UsB+BvO8ypYl3qOQCLy+n9HtcmrXFI19mVw51FGv6VRZn3lFdHWce4VYO1VmafnacK7p+vx3vOE/+cVYO9eJPv+gOfug794kSm9kK3seqiz11A70YVzTwgyKVwqaT99ShHi/eL2kS44q8KOageuejgF0q4vKlr2oco5Py3n9SF0oE2Z69xUPyQKPzNmbTkTfHrjwf4VIsbbfFZ1zqQ/kQ2e6+w+97fBFsI+2JIuOAFVkLDVysWth2UJ6kKEZdFxSTdJRqW1mI/OeVBcyiNt+0qWotInGZt77GyVO914nYs2fPf88fm/2TZoiTETIAAAAASUVORK5CYII="
            ],
            "rate_star_big_on_holo_light": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGgAAABoCAMAAAAqwkWTAAAAvVBMVEUAAAAAAAAAAAAAAAARPEwdZ4ISQFIAAAAAAAAtoMsAAAAAAAAAAAAAAAAmia0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqlLwONEICCQwupNAsncYnjbMjfZ4hdZMKJC0AAAAqlr4GFRoAAAAAAAAvqtcebYobX3kAAAAAAAAAAAAysuErmcIpkrklhakfcY8AAAAMLDgAAAAxr94xrtwieZkYVWwQOUkkgqQAAAAzteXrvX7WAAAAPnRSTlMAgBkzmbOcfAXmA2FzTc14Og9uVC1pWiUUfmXYlYPq4tLDvY5E24g1C/G3rlA+CPve18u6HZJJ+PbAqJjHIJaA4UwAAAP2SURBVGje7dkHduIwEAZg/YaAwdh0FkyvIfSEtE2Z+x9rPQ5ZAzbgpuzb9/gOgKPRzEijiKurq3+hXq2In5CtIl0XP+AWQFnIp+ZhUYR0BaAFaEK2bA5oAngUklWAJ9r+wC5VAYPugEZRSPUJTIgoBYyEVDVgQERdIK8KiYoN4I4sLSAhJFoCKWI9wBTycG5vyNaWWrS/OLe/zABdSFMG+vSlIzMdpg3glXbeJaZDgVPhmyGx4VWBe/oLgKTuoHBXcMyBpZDiGZiRYwOUhAxcRBnaM3QOCxlF5NhKKiWniOSW0irN/fRAC5Bw8UoASTr0AdRE7DTAoEOvQGMlWMwnER1LAbeCyWk/jp6ENmRy+3GJ/5JSB9rklgIKkZqAYqskdp51DZiTWxMo6XohsaPYpuI863eXul4zzTQ8ZcjDEJ6qpqnrI+vL6nF7KVdxwQN5aQ5xXq6WyO4dnTjUTtrmNzsPRpdO6RjG9mYnlWQT7DvsHgsA1u8ODGOTyawpsk4mYxh968sASvs1rWoAPihuY45dXYjjL20pXj3nOw61BuCN4vTb/R2WtfcpQ3FZv3GaF0+0M0w2FI9uC0BZPTHNcakacaXBuUvSZw5804nuAUC+cu7UMQGkIm/UjNNAOd9OdW4MTYoiw2WqTS/eDXij+hResw1Az4qLlFKk8HH1pP0d8Kta+PBlktzdFN8XBA7fbwruvu2qnkvhC9UmBhy2YOOZWrbDJy9sjlsO3yBI2OAKm5TwbV1hCxY+jP0dqXbY6iIkLt4h+cHNYKFGuDfmeFbxAWhUog7iHfJhGHFEL/Ig7sccKEScIeZ+c1uLNn15Z13cc8WUpy9PMc9kt0DK/x2uFukFtUf+vADp0HWkpoEX8ikJ/IrwVpIkv/oR3lGeg1we+B0lG/6VqUO+tUK/QT2e6qjrU8frSIQy8j74mu9498rFLlAN3VDdE+XdDOy9Sy6TkI116tVQmxMAee/heR6yOVTcg9mrvRxdTeSdUz56cyi7/urxEEDpk48PDe4J5yVcgmfzR4frevC1nL07ZioTQ4IrQIv2bJ4A5JwuUzftRUVP8AIwO7q7o7zaX/LyeFFdQAvVuccHEykv55BiL6p3cPqpgbdor3Ov+/ZyXKOVa1GpEB380enc98PTE6lSheXD6eCjEFs0cAZF1IqnVj7iRT2NvzfJDLFFze/5GqVzAalrsNx0OMZAOmgl5YBXojEnQXqkXughOQDt3tcxqwS+OQ7pbguLVr88jD7D0trQTeB29wt468MzCc4kRcoA9MC50IZlsfJbDoU8bFrQ6wLTggR8qjeAwP+8WgAwgxZffcGxFoEsc4swtzRlVNLE1dXVf+8PiLJs5G2Z9ooAAAAASUVORK5CYII="
            ],
            "scrubber_control_disabled_holo": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAPFBMVEUAAACIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIg4st+Ci486sd5LqMtwlaJJqc0zteWzIZSAAAAAE3RSTlMATUg+Ihs3AywVCEUP4FHVmWCf15i9tgAAAYlJREFUaN7t2Itu6yAMBmD/NhBuabuT93/XI03TOm0qJXasdVK+B4iFTQyYTqfT6S/pIScRBlgk5dDpSDUkxjecQqVDLDHhgRQX++cDY4CDMURgPMGB9IpgghRtdjImZVWeqmCaVEV6GDvw7jRF7BQV33eMEAHXCAUq03WoDBWuNGURKMlCMzLUslMB7oo5QfYkBZiEpwtgmPBiWoB9CUuDUVssPcLeMRLMEg1UHKDqS2wvcwJ8c8Q4ANNDHYfoviUAgrpRX27XbbveLhjL2hq/rdu79U1bZcHIZd0+rOM1CD3SMHLbPv3DSFPu0us9wKrcpxjavsCQewD3FLkX2X2buv9ov9cqIg4R3du194HjfmS6H/ru1xbvi5f71dH98ut+ffd/gPg/ocYEBkLPdRj0V3iIG5IkLzIMIeqqCNydB0bllUZq96Gj39ixN+zQOu1WE6alShphvgEp9YQJ0kkvNjzRItlEwYBEsiuZH2zNXOgYS8ztR2pyXOhItYQsH3IolU6n0+kP+Q9bEx2UrsdzRwAAAABJRU5ErkJggg=="
            ],
            "scrubber_control_focused_holo": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAllBMVEUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteVtyu1yzO1ryuxexetjx+tTwelvy+1yzO1yzO1xzO1syuxqyuxwzO1wy+1nyOxZw+pNv+hxy+1wy+wzteU1tuVOv+k9ueY4t+ZixutDu+dJvehVwelYwupSwelryuxGvOiB2w4OAAAAJXRSTlMATQYKEQ0XGh02RUkgQSwmMjvw1flze2To3M/j3IyrpYRsX62hrNdO2wAAAttJREFUaN7tWWlz2jAQrZb4Ej6wjc0dIC2+OfL//1xllxl1Wq9AVjQhGV6+BD68xx7aXa1+PPHEE5KA7k8LoMXoCmjxseSM1TCMlyvYv+yLjxJp2Rm1aZqWZXewLPaBybQa6uzQsVt24IQepYSBUi90AtvqNABAmd5k5B75Dx4TMdUkOnrLnVCCgE5cq5MYTm+6zpgIMHbcP1YM4mfO4fS4BHPUAIXOOz4ld4D6nZ+k+U03JHcidE1UAXdPQMndoAHiJpzf8okUfEtCoeWfEElMWoX7+R0iDQdRwH+/sg14/vhkEPx7cgnAMAMyEIFpANx2kEuHClCXO0kQgJAMRngrDAA8AEPDACA2wKYqAtTmJiAGOEQJDjcBifBYTWAsjDM3QM0EXQZwE3ADhDVi9mu5jqbr5XYvrBjMBPwMeARFuqhO54bhfKoWO4LCQ88CE8CLxNuyOtdFWWZZWRZ1XsUzvGAwAekQJ/NjXWaHK7KyPkaJdJhHBuqh/TQvGD1HVuTTBPWRMcJO8Rjxz5zzc4XoDckj5DTDCC1D8ZHzc4VjjBakEUgl6aaqOT9XqKuNVKKCgRXqRV4eelDmK6xoIwJIjJPOgF4TEiTKvQJopX49FYdeFMdXtGbLJNGy9VC/j2KJNAJ4sUkv5k3WL5A1EelFv8AIE5iiAu9TGQHQJ8BjoNVFoCHIymn6U5ym6gctxQ4aUouQUrFSLxXifrNDi52o46iX6/NCslzjDWcW9TacmaDhSLbMtKdlXlLBWCHd9NPon6Z/jlJB0x8wtsziKq+LMmPoxpaFeGwZMnjtVtUpb5r3Jj9V882NwWvY6LjfxuvLZR1vE9nRUf/wy6uF+vhuGZ95AeGZqmIA6L4Ear/G6r6I614laF+G6F7nfP5CSm2lpnspCA+y1hy8mNW8WoaHWo7Lr/cf74FC6onlUR+JdD1z4Q919hV/PdR9hafGG4+lX+e994knvjF+A/DCfuTfcOFvAAAAAElFTkSuQmCC"
            ],
            "scrubber_control_normal_holo": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAhFBMVEUzteUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteVKvugzteUzteUzteUzteUzteUzteU/uuczteUzteVJvehJvegzteUzteVKvug7uOZHvOhHvOhDu+dDu+czteU5t+Y8ueZAuudFvOclVTOqAAAAJ3RSTlOZAAQJDxgTITo2HSomlX0uijJC6IZuYVFMSbJmgf74kHjvp8/MvLsvv+3mAAADbElEQVRo3syU23aiQBBFz4w0NA2t3AXvmqxE8P//bxqMFip0G4W1Zr8keTmbOlUd/BmZ/0fw945hBJQ9mUwsy7Ib1C/qT7K8J2jCVTJjQjg/CMGY8jQSo8CYrr6bCcf3ZqHLf3DDmec7gqlZyPGC4PztzPFnLs+zdBcEgQSk+rFLs5y7M99h5zl0An08Eyq9WE63eGA7XRbKIZheAU28+njPjZYJekmWkeupMTRFoTffquPnUwktcjqvFVbvEOiLt0UdjyeoFcLuU6Dv8/2woHiTogj9viHQma8+n6cSTyNTroYgg1bQtB/mAX5FkIfNJsyCph43k/glMnP9LgM68j2+wwvsuNdhwEO+8KIVXmIVeeLBgI78BC+SdBjw0E8U4GWC6KEl3NxnnZ/gDRKuNn1zrbi5f+bzFd5ipQz0Hu4EE9txd3iTnevYkzsBLTjM8DZZeLNo3Cwgl3gbmXvtNaBVkM8DDEDA/VZJaBeUYhBSKqktYF4hMQiy8BgJWhc0xUBMW5cEGmCOwZjTCKABVsCAI1y2gBEGoBFIYAnawDAjCIsEzRuIJAZERvVbIIHFZksMynLGrLbAcRMYOXzG8Xodx58HGElchwR1QwVMfO1PVVUqquq0/4KJou7oKjA3dIhP1fH43XA8lqf4YO6IBOYbWmwqlU4cq83CfEdXge3wrT5/XZ7zyVCu9YYtd+yLQK0g1/ezoXwybPQt5WoJjaBZQQYdMfXTbimGjqxewlWQau/nRPltw0l7SykJLBFqd7wvvzsp99oth8K6CrTPbEED3I+w0D41EuiP6KPqE1Qf+jO6CNSVSt2Ky+8eSt2apbrT5wSbfsHmaQE0rPsFa2jQTDC8YPyKtuMsmc40GO1Mx39o4/+rMP+z+1etGeMACEIx1BuQqJPRwUQG739BHYzFEMNHfBE5AAwov+2rv3vsfOKx0wHYc80PHH5k8kPfLlvWfNmSJbx8KLy8VXhJOhr837B08zTN3TLYpaPEb7kBjP8CXL7DBoS3UKAJHOVjcRvLG3E+SuDDED7O4QMpPlLjQ0E+1lQwW3TRfasLAKNlOhyn430aUNCI5XtIdGAu9wxz1QHqAtQ4mj6eEzXWA0vzca/2Nx2gIwzAWtu/gdybfZmQe35pwF1LAy4oDdRce0gVN/5SPYlXTe2cDUmLl89GXuGIAAAAAElFTkSuQmCC"
            ],
            "scrubber_control_pressed_holo": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAA1VBMVEUzteUAAAAzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteVsyu0zteVuy+0zteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteUzteVdxOszteVpyexuy+1tyuwzteUzteVZw+pNv+huy+1xy+1lx+xgxuszteUzteVryuwzteUzteVSweluy+1uy+0zteUzteUzteUzteU1tuVOv+k8uOZVwuo4t+ZJvehCu+dgxutjx+tEu+dGvOfyQddBAAAAO3RSTlNmAHzex6Jq682mwiLmgYUv7m3hTPX14fmJNNmeY1HSvbCMmI47/e21tI+IeufcnZRyHf4Gn4DVv2BIOFolky4AAARISURBVGje5Zr9e5owEMdvIKiooCKgnS9Tu9p29r3dW0Sttv3//6Stu0BkJQlIfLY9+/5qnnzkcsld7gLvDqz/B1AbaJNSpRIQElQq1qTl1hQCbvrVOnmjerV/owJQ03TCla7VCgL6FSJRpV8AYJZJBpXNPQH9JsmoJuwBcI+Sc1RODdu2TQDTtrvGaJikH7k5AbVJws5VDd5IqybWp+TkAbgeidU2TODINNpsnOdmB2gklmWDULbFxmoZAU6JTd8AqRpWwkxyQC9e3foZZNJZvM/1nhzwPfZ9AzLLiPfEsQxwHERDu5BD3ehvBcdiQC8aWGpBLplW9Md6IoAT2f8D5NaHaB0cASDynyrsoWr08TwA8//3sJfeR/uBB3AT/7/AN7jpAMfj2D/3OnhOKqBETQgFZNE50gDfqJu1igBa1M2/pQCG+NMYCqlL48NbgCk8H3KfGuYbAEaoOhRWHSPg3W+AFoLPigPOcKbWbwBcHAsUyEJnSQK+IrahAtDAub4mABi/dVAiHTOFXUANobYagI2z1XYA+FVtUKQ22nsH0M60B85nF/7trX8xe8i0F9oMcEM3B4h0OX9ahY8/Fa6e5lcgEt20NzGgL1/iT/42fF6uFz+1Xj6H24tP8mXux4CqNAxMO6vNekGoFuvNqnMuDQzVGIC7WxPM/zFc4vQRYhl+FBA0PHcQEDlpU2CfDpufEToCKzXRUSlggBsDuPJXbH5GWF0AV7hxBxSAH3TK95/ths3PCM9bvi+dotEpwJCkEifhmqRoHfqSBMOgAEscyqb4ASmf8MRd5zEezhRwJHaiL6slSdVyNRO70RECaCy45i4xWijNRp+Bo2uMCRTgYQgCjjqPi3TA4vEEOMIA6VEADgeePr4QHqADPOEICgjwqDscoIlrcDgT6ehFh1vkIQagw7npSJwSXRXYaAWPirnsqCh22G3kh93Bj+usAechd8ApY8DJHDKv0kLmVB4yk0HfyBf0p9LEiAV9kF/OHvxtuInSlk249YVpC173AAEsNQWhLk9eE6+Xl9fE6+QShGLJaSJ1nIBY05k/v72d+7NzEGtCU0cG6KpNfvFw6+4Aeuz+oe4G0tu9gAzVX0CGiRsOKPwEjboMA7Bb7EgFYIQHQ/o1dgyFNU6/xt55qi7i6PLeHaeUcA8Fdc8rJdDITLpKiiF6SrXFJQp2m0lrtK6gIGWpL0hROYGqklrgpBcFB0WLggZBDXhlzbGasmbjjxRmUY6uqLQsL45bZk7/HBGU18tY3q/nK+/XZeV9RigTqvv8y0uaxxlaLHreFsu4zVosOZtEIw2k0kZ5mkSoRvY2V8NiYxs5GnVBxkadzsYFgzytRqckbzUapWSrsViztIzN0l9W+dUsTXaCdXePdq/pkYzyWns2rLEbIFPz+q5Ay30om37YL/pooCF6NGDXlDx7MNOfPZg19Q83XmemDzf+tacnfy/gB/s76qMkz3F7AAAAAElFTkSuQmCC"
            ],
            "spinner_76_inner_holo": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOQAAADkCAMAAAC/iXi/AAACYVBMVEUAAABFRUVISEhVVVW9vb1NTU3BwcFSUlKysrK/v79ZWVleXl5KSkqkpKRmZmZjY2O6urqEhISbm5tpaWmSkpJubm53d3fDw8NPT0+2tra4uLi0tLStra2vr6+rq6upqamnp6dbW1tgYGChoaGfn5+dnZ1ra2t0dHSWlpaUlJSPj495eXmNjY2JiYmBgYF9fX17e3uLi4t/f39ycnJwcHCYmJiHh4eoqKiGhoaMjIxdXV2FhYW/v7+enp5WVlaGhoaxsbFdXV1HR0dISEiMjIyEhIS5ubmnp6fBwcG2trZvb29NTU1UVFRISEi0tLSoqKhSUlJwcHC8vLyZmZlwcHBbW1tNTU1OTk65ublSUlJpaWmqqqpUVFRQUFC/v79kZGRTU1NoaGitra1JSUlra2uioqKVlZWXl5dISEheXl67u7tLS0upqamurq7AwMB9fX10dHRdXV24uLigoKBVVVVJSUmQkJCqqqq3t7dwcHCurq6Li4uysrK/v7+KioplZWWEhIS9vb1nZ2dzc3N+fn5WVlaXl5eWlpZ8fHy9vb2Xl5dUVFRISEigoKCXl5ednZ21tbVra2uUlJReXl6+vr5JSUmioqJ7e3tHR0ednZ2RkZGmpqZkZGSZmZm5ubmQkJC+vr6qqqqTk5O0tLS+vr6fn59nZ2d0dHRgYGCMjIxLS0uenp5vb29MTEx1dXV4eHikpKRXV1eysrJ9fX1cXFyEhIRwcHC7u7uqqqpdXV2NjY21tbW9vb2kpKSQkJCMjIxqamrBwcF6enp0dHRTU1N0dHR7e3unp6ednZ1ISEhQUFB885iiAAAAy3RSTlMAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIADChkbBQUOCUMyGggyfEQzIhx5XlctFBMSDX17V1I6Mi4mGhkOeXNwXktCLi0dEnt5b29uV1ZUUEsmJSQde3h3c3FxXFtUUkJAQD03NTMrJxZ6enRzc25tbWxsaGhfXl5cW1hYUlFQR0A9Ozo6NzEsJiYhISAYend1dHNwZ2ZjY2NhX1NQRzd6dG5sZ1tHNWVKSrmNY9gAAAqQSURBVHja7NpNSxtBHMfxX22sD/XgrabGlr6MDZsQE0gTYmIImAcaRZqLTWqgwVARpXjwIHoQquBJLHooggdLwZb2UhBK+6o6jrWT/7r2YTK7O5b9vIMv/5l/ZkX4fD6fz+fz+Xw+n8/n8/l8Pp/P5/PWummaKSbOJBKJKv4nhllebW7f++XWLzvZWjwRxQ1npFdPv9zhSCSxuVs7NnBDmasrM7zPNpKa2621cdMUUiyQopFWPT09c9l4GDdGLLUywPxjJLd7QzrTn2cGLkhEsnkWj6G5yGGd1UlFCo2Szhu3sM+GKBXZQ2Vq09BTYS8QGJCPpIaKOmYW9gPMACERKcx90y0zsjoT4NRFDg3N1bS6m616gPur83p9I41kGkfQRaEZEGilfOTQhaweZ9Y4nAk4FclkShq8a83tAGUfud3cT6VMxgAM9qHVjsdr2R0SSRuFnQQ8djgc+EPkl+Zhax3XyB+Vspv2gxTmSvBSbIUGWitnmuVJ/FE+nt282ij09mbD8IxZH/5N5Jd9E3+t/W3zN5G9jTY8cjjMXFMZaLYM/BPjKDtn38iV4IXYyvC1kaepGCSE47sikjZ6c2QL26zQvnLFhLT2rv0gmZ1puGyyzvpsK5smupLI0kEKjTxcZS6yOrvKz+voWrVIGoXNBFyUTg7bRm6bUCKxIyI7ZY7hmlzy/rBN5UwKysQzl43ESAUuKd9nrlbuFaBQuHjZSLlUmWOJVyvrJhRrN3ptjBzBBa2kXeTnCJSLFm0aRzIJOC7NGy2VyTIcEc9YG5lMFQ5bX+SBtLK+DofkG7SRa0zDUYUtnkcr1R9VemRpIzMbhoMip8H7VypX4agabeTOonDOXjB4pTIFh8VHSCNXhGPKQYZWJnNwXGWENxJrcIiZDFork2m44Dhjbezra8MRsS0WSCsXTbgikaGJjFg+yi8kzUxKNCqo7OOKcEAu2Ik3tuCaI9LIVaBcYTForSzDRRXayGxMQ7W90aCl8gCuKpFERw5senTUUrkPl32njcwClDK2WCTJ/GTAZcYEayRmDah0wApJZT0G14Vn+yxKUGhykSeKzOQ6PFC1Rm7koc4yqyOVB/BEyVo5AWVaowS7kPDIhOhTvXtOR6nFAjwyvUESb98+gyLp/lGqDM+skURG1Sg/9feTzE/w0IRI5CZUDZITkZPwUP62aOSOocIybxSZq/BUTSSqG+UTHigy30XgqegsTxSqSgZJK8vw2JroUzXKyX5qy/N/qzFmLZV5dOtpP5WD5yqWyBfokvFOt0ECxhmNPImiOzn9Bnl1lBUVa0d4p8EgAeNE6eqJjdHIA2ihRCMHw+hGuZ+KQQvhDVq5hm4sj5FRzkMTUwrPa2zsnOhMQxMLCs9rbowRnUtarB2bB8FgBfLmxxjR+RTaGO8oZKa6eQmMEU+gjaoIPHdiQNYT2rgEjcyeFwpVyDqgkRqdVuDFILGm5EoyLWhkgUZOQdZSqLMxFIFGohsk8gSSJkPcZekytDIxSOQhJxdiROgbaGWcRr6FnDchQpvnju2lHIeceRqpyeP8UljN5lkijVr9Sp57TyLfQ0okRGjzBXJpapCISi5XQrO907F5HnF5yEjTSC3+utPp7XmdsAAZXx/8FOI0ep1fqD4i1iDj8QNCs+UKhGnkOGQ8JY0voZ1nJPIVZMyTyOfQzmsSOQUZH0jkB2jnI4n8CBnPSaR2P5PAFIl8DRlLJFKrL+YLLx7d7fAeMl5qH3m30zO5yIedHkM74woiH96syLt+5I/27falqTCM4/jvH2hSpq/DbFZaafbgNrYlbAh7U2PrzSKGMDeCYIYgiKCiokNQ0UDxCUFQE0UFU0pQQ8n6s7p3juvedTYdO4+3dT4vfP/luu5zdo7bfx35X5xJGvmPXl0/Xq/Ir1oiX8oWIJy3JPIz1Pj2Mp+In11J5HeosUAiRXwKqcnJRr6FGkckUsTnyZp8/VCjLdt25y/x3gzUEK1Q49cdQrx3PDRyDWp00cgOCOYLjYxBjdc0Urj3roM08g3U8NJI4W6UixUk0gdVPpJI4e4hnytkcmMc6izkN964IdQ/mgFfRb6aRajTluuTdUEosQqiFep0ZPs4wa48gzTyC9RJ3SBmIJR2GhmGSrskcleoQ+n7QBrjUGvhIk/EQ6k4kotQa5VGHkEgn2jkGtR6RyPHIZA4jQxBLdcurRToM3rI4XDkH0kXVDuikQK9sWt1MLyzH+p15CfevSvQvsYdOfwuqdIrXijZhCC2HPkqHG5oMMMLs4S5vvY7iHZo8Usq5AR5B+J2UGvQ4tVdahVCGHRQbmgyQyPHhfjRhCuudVupjvzE2tpaId70JBxUAtp4d3li1qQAo3RNVVbmN8Z90KgtP1GMUSYqs3hkK7R6zRMFGWV2kCQzDM3mLgqFGaU8SJ65CO3e1VLjXljKF5f6eGYIOpjJT7x3714bLDVYSbVDD5skkUnBQmFnJbUFXczwRMkcLNSu2yCpLpLIjMAyCeUgY9DJb6mRG/fDIu4fTifJPIBeurKJ3K1bli1su1NCBqmXOdLIrMISayyQVC5CPymSyETewQLbbFlJpjMMHa2SRmYyANO5p6qctHIQenJNkkRmzgWTudqrqlglVznlgq66aCNzDJMNskZaGYPOlkiiBRefIVZIM/uhN39EGfl8FCZKsDxa+eM9dNehbHwe6YJpYtEqZWUCBliiicxYEiYJSY0cX1adBSZpIzPhgSm2e55VUc4eNwyRjNBGZmwTJtiKPnumrAzBICPKxvv3I6MwXIw1KivXYJglZSMzAoOtN0uNpLITxvH+Jo2yFRhqSGqklQc+GMg/8Zw0Spa8MIyvs7m5oHLKDUO9HitofPBgOgWDhM9Yo7KyJwyDbUaUjczYCAyxHpUaaWV0G4YbjdBGmREr6+usq2suqIyGYBhaSRuZ29NJ6Cx0VscUVMZgipEijcxyADoKsDHySF65DpOMRgojme4R6GZ9p7quSGU0AdNsjikbZYce6GL7oLpajqQLG92CiZITpJFbTkGzcCdLLFbZE4KpUhO5Rhr58OGyR+MU09U5isieMEzmny7eyMwnoVpotl4OLBzlgR+mC8zzRhLJHAYDUCGwPltfzyNp5U83rLDCI2ljQ0NDd98GypRJ79RLaKRcWTcEiyQneCOJlPQel3E6Ped7jY2NPFJRafYlh65s0UZZU1NTb9+oHyX5M+lsoRRZvJKtqpVWLo1skj3q7TvZSOES4cxweu8Jc2XkECyWnL5skHKj5MWL/b6BYNDDgPEwweBAev8p80TSeHnlWQiWc610l47MamlpuXnhsYQVypFXjXJnyPIvDkn888UbaWQLj6SVV0b+9EMUG9OssXTkzVKRysrTDATiXekuGvlIU+SQD2LxL3eTxjIjCyvrO8XZVC61fOm2lhvJdIYhJv9xdwPd1pKRxfd151zEKeYETnp5YxmRpPJ0OADBJfu0Raa3cB0ETg7VRs6KP0TOfzKvbKSR9Mojmx0W+SQW5d047i0dmas8Pc8I9UPbMgQ2Bg57S0XuzQ5krtGSFufyBAf69otF7qcHgp7rOsBC/AErODzM/ngY2Gw2m81ms9lsNpvNZrPZbDabzSauP6UMJdVYd1vZAAAAAElFTkSuQmCC"
            ],
            "spinner_76_outer_holo": [
                null,
                null,
                null,
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOQAAADkCAMAAAC/iXi/AAAAsVBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+3mHKcAAAAO3RSTlMABgoSH/3yGiQO7CkW9vouMkDkRTfJzjvf0+jESqBcV2Hbt66ldlLXv06yZWmBqZtxu49tl5OLfXqFiHO5Lf0AAAtLSURBVHja7NxrU9NAFMbxZzeRNk1qYmxLWyxQLhYsooKI+v0/mHshOXu8dDTNZXHyO4X3/zmbDcMwoNfr9Xq9Xq/X6/V6vV6v1+v1er2eH7bb7WmWZSn+Zy8KL6cXj8eZxPMnNJhxI6n05fzT4ys8X8KCsIXit5HGwbvLCZ4fYVCjQIEl6nmyPN8GeEaEFAqvLEOdRP1FxuPxu9Nn0imkIhgq/M0mqVFnjlaH8J2QmmCVsIOdmxzrz9hY3Hh945pEW+k2FscVPNImUqbZpbH8NoCnTCJtkkDs3iRVlg4eQniIEqmSNqnnj5ukNVLkwejOu20KGUleyTa5+3alTGpUn+VXr55NlagaI75IsnuTFFk0HujRZq/hDRkp1PhLJuzs2iQVUqW28uTMikj5tfLXh3LHJsdm3MhCfi/Qvaiw48BCwCGyLJtst9/PZ/znHdZImdMMHROBE0mZbiV2iK8/3uZ079BZpcbRwfIGnZJB4FTyREmFu4XHF8sxXyQzGt0G6IyIqJGfV9uIv3f4PWfXThloZzFBR2Sg8UyKxL96czHii3RCR6OP6ET0lEiVdF4FqohOP9kfBHif/X4RoX2BZit/PrCobnLOd2hDjaME7aJGXikV7Ce7OKBd6sCychaiVcJJ5JXYX/yhSKQDa2xStIEaEzeTEuuRHbG7tTQ/RGtEQonu3SNQm22uEmmPhfwaLZGJolfJlylRp+Dzbza5XC5P0AqZGAHvjARqNpkVbdQ4Wuav0QKRWO5jGQUS9ZMf2Fld2plnaBg18kyBRpzmJo8qtXWMJlEjP7ARmhJP2Vm1lbMEzUpcgSXRHPmZ7dE6CtCkYMArE2psymW5R8o8k6gfNSoJhVJjg06Xdo8kz+/QGDnQElYp0LjrXBdSZq4qj9EQoQopkxobdzhfsj2qysZeJEkZqccQaEW6Lgvt5Pk0QhOCAaHGdmRzp9J6QAOk22hXKdCa13l5UovMt6jfYBD+VCnRohO2R22ToG5ByCupsSX3epH209SBlWFoKqkzQsu+qT7uFeo1CEP9oW0GaN1t7piruRKoUxQqJrQ4rGhfMOWN8/kNaiRCzWbaUIEOxPMy0TTmmxD1SUKrXKVEJ7bOGvVnvqrz1mHosLbu1q7RJBqvarx1DFomupIszCZ1o/Wu5kUSic6cUGJe6yoH4ZA1JujQrXkgyS1qIVXi0O0U6FC4nnOTehY5HKpCqgzQqUuWuF6vUAOhEt3MAbolp07hWn2l2F+iC02nzYzQseOyUY3q/FDHIjXb6cMilatii2q0IfYVDJnQgz93e0tbNL5iX26gGg8WCZytmanEfqIh1/kTqb3VaXOqvN77/cH48Ze2YrpmVtjPMGaRnvyt/03Zt9Ffm2jfayd2O+GHYEOVm816c4J9hLEqLEP9uHa0B6dQfb/APmLFdppMD94f1iEVaosI1UW6UI3i02lVropCW/kG1Q1ixXSazATeuNwwX1CdbnM6vTmtQKp3SKaoTMaMHy9JOq+uFFUFMePRaQUeWePidJ8XCPHqtAKvyj7jDlXFHHwiZ0+FGzNXqEjEcarHx0cSWC2eCq0Q1USp7jOl3j2SwL1KtJ3Ga1STpJYJ9eyRBCYL5h7VhKrPjObZIwlIHvmAamxdUerRz3TWGYs8QzUp49m9A3xZMAJVSB7p2b0D3BR5MzPDipcr48Vvd1xvVBnN4hBVBDzSs8sViItFWieoYsAa/fvPMtHMetrlfdU3SKbH10gcPeVZ7ytGZs749ppUzmeuO1QxzEpp6t9rElixyBWqiDOXd69J4AuLPEcVqe+Rjyzy7P+M/Moir2qI9Ob3yuR+NpvSVIvM/I+kRtVbLfJHe3faoyYUhmH4BUnEQCInYPkwKMSFiOKOtvr/f1jPIr6cVlOLLKcNF07Tr3ce3GYcxiseCkamoxHtY1/c/7lkyvK+5f+UXbJIwQee06ho+fnpqmLkooLIoepL/pAiVxVEKviy7iZFbqEMS4pU8AV6JkXuoAxTilTwrdZ2NPq6H9SlgkgFr2d5GOWV7PYdyjA8xr8fngpXcZIMvqiR+KK5JyjDpoV4+Op9j4f3iRsVQxk9PuSDIh/hQe4Xop0+lKH7EuWeKKMviQGl+BLlnkM2cqQGpThSZOsXVvvVXGqcQTmWX0BUu7asvvxafqEblGNgIFHvkcehZUt+cGsop8f6RCGhFHvkiZbMo9SFcnTWyAN5qmIv7C5LXsf/pfpQkvcIpBS7U2pT2scTeekKyrKwkFHqTuktEd3yCmX1iUSpt5T7pSSEsgZEotQbka0caUFpPilwiUI/bDYPh8MSraA8q5Co1vm6PlDY+R3Ks/NC1ui6Cj2+zlkhPe6hLpSn5YHEpYirzOPr8MCJUHobwAccwohCSpnXA4sDopVH+ESfEB6YU+R7IINpIZFK4BMaYYlIkdev4ZRVogF8xHElavyxHW0+pbDxBp+x3YLAdZX44ZbLG7GTwIeI1Bgo8SySsUjMnGnwIbOYSCkwJZneHURnCp/SRSE72C1Q4F6ZTRHL7MPHHD6iSFRiSne6mhZt4HMDFxOZtp8r9fFqKmVaUAGPJyILWhWtqCk7hBtUoScakQ4t6s9oIsvM5xxCJbygIAkSD1p0XTGik7lANWwsZEeSGNAaVzSKTLalBxXx80T6xQQatKQ3X0mV0yNAxVMmOR9aspnNZlKmB5Xx8jM1Z0IrEtY4W6HvUB0dd2TiJBlAC4ztjMExZ32okCklxnHcxksCPROFOGYIlSJSI+VD437MEM/MNKiULTUyQ2jYZCbgmA5UzLkXIgsalWy329l2VrCAqumBGDIXxqEBDfJZ4rY45rYHlTOKQ4b0FoZ9aIwz34olsZNADbwkRiET96Ah5ngrYOUe6qC5uCMNbLLSyNiQ0pY7HWrRS7AxZ0MDrPF8zitxzK0FNTF5olxpQO082oiV4uEngNo4YsncJJxMJibUjNwb54UlU6gR4Y1YyTKHUKt4/rDN3TSokR6EYZwXsoPxoT7amu8ob3keQK0GSWHHXH3vSfq38Xg8L3QymQ01s2O8P94zo9rumP5uzMhbjg2oXR/P1lwURUQDVN2pKhqlLccWNMDARLFjxMQ2VMy8jh9wyrkDjTCxETOrHlOPdrvdeHefErck0BBDVGKhMLGgMuS4Y5ECJo59aIzNE+XKdbReJz2ohPGDFvIh5c7dEBrUi7EQGylSQaYdZdnuTrpbZiY0apDgkML6zrU/XDHKmMeUuOSxDw3Tg2dDpus0TQP7g8T0LBqz36a89qBxmssqBRwy5WJLgxJ0b38+i8i8Ebdc6NCGIS6JQwqn1DXgL1mTy5nL5EwhgZbY4fMhT9ya2PA2I9kcj0eeiOcrTnk0oTWaizvikKd75X6fBtbgnasbTVghj5Qr8y33A2jT8MmQeaOQBo7Zgxdsy598v1Ci8enputsF0DI7jqIXQzKL/YKLYuI4+V9xsul/PC+YnG4ULeSRLzOvKnyWeBitXwwpMoUfzHdmw12ZR+TxwhOfnK9ZoMYnM3X3yZB7VolTvo7EKeUlxZQnZT5HDEYoDcnJOy54IycaNxiJjTilaLwq8yliRnNeRGImRgrPlpSnPCdqnKlIJ0/OVjxZMXLzZEnm1ynPE3XOVDQgT0/X95Y8/jKlmomM7q/xsVVekpOXlCrlJS+xqomMNpwUh1zIlfKSL6fcEOV+3f9X/SCliY8p31/yLlLhuf/P9GH8a+O7S6bqXbPhNd1JTrxRvk/KjRgprFX6jbf3aCaJ3llSVC4SS7UnxXfpph+mIvP1kj/WrmpX5i7BtvwkerLkJg1dp/+vDvj6T687juN5Dn/Tpdw1nDudTqfT6XQ6nU6n0+l0Op1Op9Mp+AmSZeem89KYswAAAABJRU5ErkJggg=="
            ]
        };
        var imageCache = {
            btn_check_off_disabled_focused_holo_light: null,
            btn_check_off_disabled_holo_light: null,
            btn_check_off_focused_holo_light: null,
            btn_check_off_holo_light: null,
            btn_check_off_pressed_holo_light: null,
            btn_check_on_disabled_focused_holo_light: null,
            btn_check_on_disabled_holo_light: null,
            btn_check_on_focused_holo_light: null,
            btn_check_on_holo_light: null,
            btn_check_on_pressed_holo_light: null,
            btn_radio_off_disabled_focused_holo_light: null,
            btn_radio_off_disabled_holo_light: null,
            btn_radio_off_focused_holo_light: null,
            btn_radio_off_holo_light: null,
            btn_radio_off_pressed_holo_light: null,
            btn_radio_on_disabled_focused_holo_light: null,
            btn_radio_on_disabled_holo_light: null,
            btn_radio_on_focused_holo_light: null,
            btn_radio_on_holo_light: null,
            btn_radio_on_pressed_holo_light: null,
            btn_rating_star_off_normal_holo_light: null,
            btn_rating_star_off_pressed_holo_light: null,
            btn_rating_star_on_normal_holo_light: null,
            btn_rating_star_on_pressed_holo_light: null,
            progressbar_indeterminate_holo1: null,
            progressbar_indeterminate_holo2: null,
            progressbar_indeterminate_holo3: null,
            progressbar_indeterminate_holo4: null,
            progressbar_indeterminate_holo5: null,
            progressbar_indeterminate_holo6: null,
            progressbar_indeterminate_holo7: null,
            progressbar_indeterminate_holo8: null,
            rate_star_big_half_holo_light: null,
            rate_star_big_off_holo_light: null,
            rate_star_big_on_holo_light: null,
            scrubber_control_disabled_holo: null,
            scrubber_control_focused_holo: null,
            scrubber_control_normal_holo: null,
            scrubber_control_pressed_holo: null,
            spinner_76_inner_holo: null,
            spinner_76_outer_holo: null
        };
        function findRatioImage(array) {
            if (array[window.devicePixelRatio])
                return new NetImage(array[window.devicePixelRatio], window.devicePixelRatio);
            for (let i = array.length; i >= 0; i--) {
                if (array[i]) {
                    return new NetImage(array[i], i);
                }
            }
            throw Error('Not find radio image. May something error in build.');
        }
        class image_base64 {
            static get btn_check_off_disabled_focused_holo_light() {
                return imageCache.btn_check_off_disabled_focused_holo_light || (imageCache.btn_check_off_disabled_focused_holo_light = findRatioImage(data.btn_check_off_disabled_focused_holo_light));
            }
            static get btn_check_off_disabled_holo_light() {
                return imageCache.btn_check_off_disabled_holo_light || (imageCache.btn_check_off_disabled_holo_light = findRatioImage(data.btn_check_off_disabled_holo_light));
            }
            static get btn_check_off_focused_holo_light() {
                return imageCache.btn_check_off_focused_holo_light || (imageCache.btn_check_off_focused_holo_light = findRatioImage(data.btn_check_off_focused_holo_light));
            }
            static get btn_check_off_holo_light() {
                return imageCache.btn_check_off_holo_light || (imageCache.btn_check_off_holo_light = findRatioImage(data.btn_check_off_holo_light));
            }
            static get btn_check_off_pressed_holo_light() {
                return imageCache.btn_check_off_pressed_holo_light || (imageCache.btn_check_off_pressed_holo_light = findRatioImage(data.btn_check_off_pressed_holo_light));
            }
            static get btn_check_on_disabled_focused_holo_light() {
                return imageCache.btn_check_on_disabled_focused_holo_light || (imageCache.btn_check_on_disabled_focused_holo_light = findRatioImage(data.btn_check_on_disabled_focused_holo_light));
            }
            static get btn_check_on_disabled_holo_light() {
                return imageCache.btn_check_on_disabled_holo_light || (imageCache.btn_check_on_disabled_holo_light = findRatioImage(data.btn_check_on_disabled_holo_light));
            }
            static get btn_check_on_focused_holo_light() {
                return imageCache.btn_check_on_focused_holo_light || (imageCache.btn_check_on_focused_holo_light = findRatioImage(data.btn_check_on_focused_holo_light));
            }
            static get btn_check_on_holo_light() {
                return imageCache.btn_check_on_holo_light || (imageCache.btn_check_on_holo_light = findRatioImage(data.btn_check_on_holo_light));
            }
            static get btn_check_on_pressed_holo_light() {
                return imageCache.btn_check_on_pressed_holo_light || (imageCache.btn_check_on_pressed_holo_light = findRatioImage(data.btn_check_on_pressed_holo_light));
            }
            static get btn_radio_off_disabled_focused_holo_light() {
                return imageCache.btn_radio_off_disabled_focused_holo_light || (imageCache.btn_radio_off_disabled_focused_holo_light = findRatioImage(data.btn_radio_off_disabled_focused_holo_light));
            }
            static get btn_radio_off_disabled_holo_light() {
                return imageCache.btn_radio_off_disabled_holo_light || (imageCache.btn_radio_off_disabled_holo_light = findRatioImage(data.btn_radio_off_disabled_holo_light));
            }
            static get btn_radio_off_focused_holo_light() {
                return imageCache.btn_radio_off_focused_holo_light || (imageCache.btn_radio_off_focused_holo_light = findRatioImage(data.btn_radio_off_focused_holo_light));
            }
            static get btn_radio_off_holo_light() {
                return imageCache.btn_radio_off_holo_light || (imageCache.btn_radio_off_holo_light = findRatioImage(data.btn_radio_off_holo_light));
            }
            static get btn_radio_off_pressed_holo_light() {
                return imageCache.btn_radio_off_pressed_holo_light || (imageCache.btn_radio_off_pressed_holo_light = findRatioImage(data.btn_radio_off_pressed_holo_light));
            }
            static get btn_radio_on_disabled_focused_holo_light() {
                return imageCache.btn_radio_on_disabled_focused_holo_light || (imageCache.btn_radio_on_disabled_focused_holo_light = findRatioImage(data.btn_radio_on_disabled_focused_holo_light));
            }
            static get btn_radio_on_disabled_holo_light() {
                return imageCache.btn_radio_on_disabled_holo_light || (imageCache.btn_radio_on_disabled_holo_light = findRatioImage(data.btn_radio_on_disabled_holo_light));
            }
            static get btn_radio_on_focused_holo_light() {
                return imageCache.btn_radio_on_focused_holo_light || (imageCache.btn_radio_on_focused_holo_light = findRatioImage(data.btn_radio_on_focused_holo_light));
            }
            static get btn_radio_on_holo_light() {
                return imageCache.btn_radio_on_holo_light || (imageCache.btn_radio_on_holo_light = findRatioImage(data.btn_radio_on_holo_light));
            }
            static get btn_radio_on_pressed_holo_light() {
                return imageCache.btn_radio_on_pressed_holo_light || (imageCache.btn_radio_on_pressed_holo_light = findRatioImage(data.btn_radio_on_pressed_holo_light));
            }
            static get btn_rating_star_off_normal_holo_light() {
                return imageCache.btn_rating_star_off_normal_holo_light || (imageCache.btn_rating_star_off_normal_holo_light = findRatioImage(data.btn_rating_star_off_normal_holo_light));
            }
            static get btn_rating_star_off_pressed_holo_light() {
                return imageCache.btn_rating_star_off_pressed_holo_light || (imageCache.btn_rating_star_off_pressed_holo_light = findRatioImage(data.btn_rating_star_off_pressed_holo_light));
            }
            static get btn_rating_star_on_normal_holo_light() {
                return imageCache.btn_rating_star_on_normal_holo_light || (imageCache.btn_rating_star_on_normal_holo_light = findRatioImage(data.btn_rating_star_on_normal_holo_light));
            }
            static get btn_rating_star_on_pressed_holo_light() {
                return imageCache.btn_rating_star_on_pressed_holo_light || (imageCache.btn_rating_star_on_pressed_holo_light = findRatioImage(data.btn_rating_star_on_pressed_holo_light));
            }
            static get progressbar_indeterminate_holo1() {
                return imageCache.progressbar_indeterminate_holo1 || (imageCache.progressbar_indeterminate_holo1 = findRatioImage(data.progressbar_indeterminate_holo1));
            }
            static get progressbar_indeterminate_holo2() {
                return imageCache.progressbar_indeterminate_holo2 || (imageCache.progressbar_indeterminate_holo2 = findRatioImage(data.progressbar_indeterminate_holo2));
            }
            static get progressbar_indeterminate_holo3() {
                return imageCache.progressbar_indeterminate_holo3 || (imageCache.progressbar_indeterminate_holo3 = findRatioImage(data.progressbar_indeterminate_holo3));
            }
            static get progressbar_indeterminate_holo4() {
                return imageCache.progressbar_indeterminate_holo4 || (imageCache.progressbar_indeterminate_holo4 = findRatioImage(data.progressbar_indeterminate_holo4));
            }
            static get progressbar_indeterminate_holo5() {
                return imageCache.progressbar_indeterminate_holo5 || (imageCache.progressbar_indeterminate_holo5 = findRatioImage(data.progressbar_indeterminate_holo5));
            }
            static get progressbar_indeterminate_holo6() {
                return imageCache.progressbar_indeterminate_holo6 || (imageCache.progressbar_indeterminate_holo6 = findRatioImage(data.progressbar_indeterminate_holo6));
            }
            static get progressbar_indeterminate_holo7() {
                return imageCache.progressbar_indeterminate_holo7 || (imageCache.progressbar_indeterminate_holo7 = findRatioImage(data.progressbar_indeterminate_holo7));
            }
            static get progressbar_indeterminate_holo8() {
                return imageCache.progressbar_indeterminate_holo8 || (imageCache.progressbar_indeterminate_holo8 = findRatioImage(data.progressbar_indeterminate_holo8));
            }
            static get rate_star_big_half_holo_light() {
                return imageCache.rate_star_big_half_holo_light || (imageCache.rate_star_big_half_holo_light = findRatioImage(data.rate_star_big_half_holo_light));
            }
            static get rate_star_big_off_holo_light() {
                return imageCache.rate_star_big_off_holo_light || (imageCache.rate_star_big_off_holo_light = findRatioImage(data.rate_star_big_off_holo_light));
            }
            static get rate_star_big_on_holo_light() {
                return imageCache.rate_star_big_on_holo_light || (imageCache.rate_star_big_on_holo_light = findRatioImage(data.rate_star_big_on_holo_light));
            }
            static get scrubber_control_disabled_holo() {
                return imageCache.scrubber_control_disabled_holo || (imageCache.scrubber_control_disabled_holo = findRatioImage(data.scrubber_control_disabled_holo));
            }
            static get scrubber_control_focused_holo() {
                return imageCache.scrubber_control_focused_holo || (imageCache.scrubber_control_focused_holo = findRatioImage(data.scrubber_control_focused_holo));
            }
            static get scrubber_control_normal_holo() {
                return imageCache.scrubber_control_normal_holo || (imageCache.scrubber_control_normal_holo = findRatioImage(data.scrubber_control_normal_holo));
            }
            static get scrubber_control_pressed_holo() {
                return imageCache.scrubber_control_pressed_holo || (imageCache.scrubber_control_pressed_holo = findRatioImage(data.scrubber_control_pressed_holo));
            }
            static get spinner_76_inner_holo() {
                return imageCache.spinner_76_inner_holo || (imageCache.spinner_76_inner_holo = findRatioImage(data.spinner_76_inner_holo));
            }
            static get spinner_76_outer_holo() {
                return imageCache.spinner_76_outer_holo || (imageCache.spinner_76_outer_holo = findRatioImage(data.spinner_76_outer_holo));
            }
        }
        R.image_base64 = image_base64;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
///<reference path="../../androidui/image/NetDrawable.ts"/>
///<reference path="../../androidui/image/OverrideSizeDrawable.ts"/>
///<reference path="image_base64.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var NetDrawable = androidui.image.NetDrawable;
        var OverrideSizeDrawable = androidui.image.ChangeImageSizeDrawable;
        const density = android.content.res.Resources.getDisplayMetrics().density;
        class image {
            static get btn_check_off_disabled_focused_holo_light() { return new NetDrawable(R.image_base64.btn_check_off_disabled_focused_holo_light); }
            static get btn_check_off_disabled_holo_light() { return new NetDrawable(R.image_base64.btn_check_off_disabled_holo_light); }
            static get btn_check_off_focused_holo_light() { return new NetDrawable(R.image_base64.btn_check_off_focused_holo_light); }
            static get btn_check_off_holo_light() { return new NetDrawable(R.image_base64.btn_check_off_holo_light); }
            static get btn_check_off_pressed_holo_light() { return new NetDrawable(R.image_base64.btn_check_off_pressed_holo_light); }
            static get btn_check_on_disabled_focused_holo_light() { return new NetDrawable(R.image_base64.btn_check_on_disabled_focused_holo_light); }
            static get btn_check_on_disabled_holo_light() { return new NetDrawable(R.image_base64.btn_check_on_disabled_holo_light); }
            static get btn_check_on_focused_holo_light() { return new NetDrawable(R.image_base64.btn_check_on_focused_holo_light); }
            static get btn_check_on_holo_light() { return new NetDrawable(R.image_base64.btn_check_on_holo_light); }
            static get btn_check_on_pressed_holo_light() { return new NetDrawable(R.image_base64.btn_check_on_pressed_holo_light); }
            static get btn_radio_off_disabled_focused_holo_light() { return new NetDrawable(R.image_base64.btn_radio_off_disabled_focused_holo_light); }
            static get btn_radio_off_disabled_holo_light() { return new NetDrawable(R.image_base64.btn_radio_off_disabled_holo_light); }
            static get btn_radio_off_focused_holo_light() { return new NetDrawable(R.image_base64.btn_radio_off_focused_holo_light); }
            static get btn_radio_off_holo_light() { return new NetDrawable(R.image_base64.btn_radio_off_holo_light); }
            static get btn_radio_off_pressed_holo_light() { return new NetDrawable(R.image_base64.btn_radio_off_pressed_holo_light); }
            static get btn_radio_on_disabled_focused_holo_light() { return new NetDrawable(R.image_base64.btn_radio_on_disabled_focused_holo_light); }
            static get btn_radio_on_disabled_holo_light() { return new NetDrawable(R.image_base64.btn_radio_on_disabled_holo_light); }
            static get btn_radio_on_focused_holo_light() { return new NetDrawable(R.image_base64.btn_radio_on_focused_holo_light); }
            static get btn_radio_on_holo_light() { return new NetDrawable(R.image_base64.btn_radio_on_holo_light); }
            static get btn_radio_on_pressed_holo_light() { return new NetDrawable(R.image_base64.btn_radio_on_pressed_holo_light); }
            static get btn_rating_star_off_pressed_holo_light() { return new NetDrawable(R.image_base64.btn_rating_star_off_pressed_holo_light); }
            static get btn_rating_star_off_normal_holo_light() { return new NetDrawable(R.image_base64.btn_rating_star_off_normal_holo_light); }
            static get btn_rating_star_on_pressed_holo_light() { return new NetDrawable(R.image_base64.btn_rating_star_on_pressed_holo_light); }
            static get btn_rating_star_on_normal_holo_light() { return new NetDrawable(R.image_base64.btn_rating_star_on_normal_holo_light); }
            static get progressbar_indeterminate_holo1() { return new NetDrawable(R.image_base64.progressbar_indeterminate_holo1); }
            static get progressbar_indeterminate_holo2() { return new NetDrawable(R.image_base64.progressbar_indeterminate_holo2); }
            static get progressbar_indeterminate_holo3() { return new NetDrawable(R.image_base64.progressbar_indeterminate_holo3); }
            static get progressbar_indeterminate_holo4() { return new NetDrawable(R.image_base64.progressbar_indeterminate_holo4); }
            static get progressbar_indeterminate_holo5() { return new NetDrawable(R.image_base64.progressbar_indeterminate_holo5); }
            static get progressbar_indeterminate_holo6() { return new NetDrawable(R.image_base64.progressbar_indeterminate_holo6); }
            static get progressbar_indeterminate_holo7() { return new NetDrawable(R.image_base64.progressbar_indeterminate_holo7); }
            static get progressbar_indeterminate_holo8() { return new NetDrawable(R.image_base64.progressbar_indeterminate_holo8); }
            static get rate_star_big_half_holo_light() { return new NetDrawable(R.image_base64.rate_star_big_half_holo_light); }
            static get rate_star_big_off_holo_light() { return new NetDrawable(R.image_base64.rate_star_big_off_holo_light); }
            static get rate_star_big_on_holo_light() { return new NetDrawable(R.image_base64.rate_star_big_on_holo_light); }
            static get scrubber_control_disabled_holo() { return new NetDrawable(R.image_base64.scrubber_control_disabled_holo); }
            static get scrubber_control_focused_holo() { return new NetDrawable(R.image_base64.scrubber_control_focused_holo); }
            static get scrubber_control_normal_holo() { return new NetDrawable(R.image_base64.scrubber_control_normal_holo); }
            static get scrubber_control_pressed_holo() { return new NetDrawable(R.image_base64.scrubber_control_pressed_holo); }
            static get spinner_76_inner_holo() { return new NetDrawable(R.image_base64.spinner_76_inner_holo); }
            static get spinner_76_outer_holo() { return new NetDrawable(R.image_base64.spinner_76_outer_holo); }
            static get spinner_48_outer_holo() { return new OverrideSizeDrawable(image.spinner_76_outer_holo, 48 * density, 48 * density); }
            static get spinner_48_inner_holo() { return new OverrideSizeDrawable(image.spinner_76_inner_holo, 48 * density, 48 * density); }
            static get spinner_16_outer_holo() { return new OverrideSizeDrawable(image.spinner_76_outer_holo, 16 * density, 16 * density); }
            static get spinner_16_inner_holo() { return new OverrideSizeDrawable(image.spinner_76_inner_holo, 16 * density, 16 * density); }
            static get rate_star_small_off_holo_light() { return new OverrideSizeDrawable(image.rate_star_big_half_holo_light, 16 * density, 16 * density); }
            static get rate_star_small_half_holo_light() { return new OverrideSizeDrawable(image.rate_star_big_off_holo_light, 16 * density, 16 * density); }
            static get rate_star_small_on_holo_light() { return new OverrideSizeDrawable(image.rate_star_big_on_holo_light, 16 * density, 16 * density); }
        }
        R.image = image;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
///<reference path="../view/View.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../content/res/ColorStateList.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/StateListDrawable.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var ColorStateList = android.content.res.ColorStateList;
        class color {
            static get textView_textColor() {
                let _defaultStates = [[-android.view.View.VIEW_STATE_ENABLED], []];
                let _defaultColors = [0xffc0c0c0, 0xff333333];
                class DefaultStyleTextColor extends ColorStateList {
                    constructor() {
                        super(_defaultStates, _defaultColors);
                    }
                }
                return new DefaultStyleTextColor();
            }
            static get primary_text_light_disable_only() {
                let _defaultStates = [[-android.view.View.VIEW_STATE_ENABLED], []];
                let _defaultColors = [0x80000000, 0xff000000];
                class DefaultStyleTextColor extends ColorStateList {
                    constructor() {
                        super(_defaultStates, _defaultColors);
                    }
                }
                return new DefaultStyleTextColor();
            }
        }
        R.color = color;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var goog;
(function (goog) {
    var math;
    (function (math) {
        class Long {
            constructor(low, high) {
                this.low_ = low | 0;
                this.high_ = high | 0;
            }
            toInt() {
                return this.low_;
            }
            toNumber() {
                return this.high_ * Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
            }
            toString(opt_radix) {
                var radix = opt_radix || 10;
                if (radix < 2 || 36 < radix) {
                    throw Error('radix out of range: ' + radix);
                }
                if (this.isZero()) {
                    return '0';
                }
                if (this.isNegative()) {
                    if (this.equals(Long.MIN_VALUE)) {
                        var radixLong = Long.fromNumber(radix);
                        var div = this.div(radixLong);
                        let rem = div.multiply(radixLong).subtract(this);
                        return div.toString(radix) + rem.toInt().toString(radix);
                    }
                    else {
                        return '-' + this.negate().toString(radix);
                    }
                }
                var radixToPower = Long.fromNumber(Math.pow(radix, 6));
                let rem = this;
                var result = '';
                while (true) {
                    var remDiv = rem.div(radixToPower);
                    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
                    var digits = intval.toString(radix);
                    rem = remDiv;
                    if (rem.isZero()) {
                        return digits + result;
                    }
                    else {
                        while (digits.length < 6) {
                            digits = '0' + digits;
                        }
                        result = '' + digits + result;
                    }
                }
            }
            getHighBits() {
                return this.high_;
            }
            getLowBits() {
                return this.low_;
            }
            getLowBitsUnsigned() {
                return (this.low_ >= 0) ? this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
            }
            getNumBitsAbs() {
                if (this.isNegative()) {
                    if (this.equals(Long.MIN_VALUE)) {
                        return 64;
                    }
                    else {
                        return this.negate().getNumBitsAbs();
                    }
                }
                else {
                    var val = this.high_ != 0 ? this.high_ : this.low_;
                    for (var bit = 31; bit > 0; bit--) {
                        if ((val & (1 << bit)) != 0) {
                            break;
                        }
                    }
                    return this.high_ != 0 ? bit + 33 : bit + 1;
                }
            }
            isZero() {
                return this.high_ == 0 && this.low_ == 0;
            }
            isNegative() {
                return this.high_ < 0;
            }
            isOdd() {
                return (this.low_ & 1) == 1;
            }
            equals(other) {
                return (this.high_ == other.high_) && (this.low_ == other.low_);
            }
            notEquals(other) {
                return (this.high_ != other.high_) || (this.low_ != other.low_);
            }
            lessThan(other) {
                return this.compare(other) < 0;
            }
            lessThanOrEqual(other) {
                return this.compare(other) <= 0;
            }
            greaterThan(other) {
                return this.compare(other) > 0;
            }
            greaterThanOrEqual(other) {
                return this.compare(other) >= 0;
            }
            compare(other) {
                if (this.equals(other)) {
                    return 0;
                }
                var thisNeg = this.isNegative();
                var otherNeg = other.isNegative();
                if (thisNeg && !otherNeg) {
                    return -1;
                }
                if (!thisNeg && otherNeg) {
                    return 1;
                }
                if (this.subtract(other).isNegative()) {
                    return -1;
                }
                else {
                    return 1;
                }
            }
            negate() {
                if (this.equals(Long.MIN_VALUE)) {
                    return Long.MIN_VALUE;
                }
                else {
                    return this.not().add(Long.ONE);
                }
            }
            add(other) {
                // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
                var a48 = this.high_ >>> 16;
                var a32 = this.high_ & 0xFFFF;
                var a16 = this.low_ >>> 16;
                var a00 = this.low_ & 0xFFFF;
                var b48 = other.high_ >>> 16;
                var b32 = other.high_ & 0xFFFF;
                var b16 = other.low_ >>> 16;
                var b00 = other.low_ & 0xFFFF;
                var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                c00 += a00 + b00;
                c16 += c00 >>> 16;
                c00 &= 0xFFFF;
                c16 += a16 + b16;
                c32 += c16 >>> 16;
                c16 &= 0xFFFF;
                c32 += a32 + b32;
                c48 += c32 >>> 16;
                c32 &= 0xFFFF;
                c48 += a48 + b48;
                c48 &= 0xFFFF;
                return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
            }
            subtract(other) {
                return this.add(other.negate());
            }
            multiply(other) {
                if (this.isZero()) {
                    return Long.ZERO;
                }
                else if (other.isZero()) {
                    return Long.ZERO;
                }
                if (this.equals(Long.MIN_VALUE)) {
                    return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
                }
                else if (other.equals(Long.MIN_VALUE)) {
                    return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
                }
                if (this.isNegative()) {
                    if (other.isNegative()) {
                        return this.negate().multiply(other.negate());
                    }
                    else {
                        return this.negate().multiply(other).negate();
                    }
                }
                else if (other.isNegative()) {
                    return this.multiply(other.negate()).negate();
                }
                if (this.lessThan(Long.TWO_PWR_24_) &&
                    other.lessThan(Long.TWO_PWR_24_)) {
                    return Long.fromNumber(this.toNumber() * other.toNumber());
                }
                var a48 = this.high_ >>> 16;
                var a32 = this.high_ & 0xFFFF;
                var a16 = this.low_ >>> 16;
                var a00 = this.low_ & 0xFFFF;
                var b48 = other.high_ >>> 16;
                var b32 = other.high_ & 0xFFFF;
                var b16 = other.low_ >>> 16;
                var b00 = other.low_ & 0xFFFF;
                var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                c00 += a00 * b00;
                c16 += c00 >>> 16;
                c00 &= 0xFFFF;
                c16 += a16 * b00;
                c32 += c16 >>> 16;
                c16 &= 0xFFFF;
                c16 += a00 * b16;
                c32 += c16 >>> 16;
                c16 &= 0xFFFF;
                c32 += a32 * b00;
                c48 += c32 >>> 16;
                c32 &= 0xFFFF;
                c32 += a16 * b16;
                c48 += c32 >>> 16;
                c32 &= 0xFFFF;
                c32 += a00 * b32;
                c48 += c32 >>> 16;
                c32 &= 0xFFFF;
                c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
                c48 &= 0xFFFF;
                return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
            }
            div(other) {
                if (other.isZero()) {
                    throw Error('division by zero');
                }
                else if (this.isZero()) {
                    return Long.ZERO;
                }
                if (this.equals(Long.MIN_VALUE)) {
                    if (other.equals(Long.ONE) ||
                        other.equals(Long.NEG_ONE)) {
                        return Long.MIN_VALUE;
                    }
                    else if (other.equals(Long.MIN_VALUE)) {
                        return Long.ONE;
                    }
                    else {
                        var halfThis = this.shiftRight(1);
                        let approx = halfThis.div(other).shiftLeft(1);
                        if (approx.equals(Long.ZERO)) {
                            return other.isNegative() ? Long.ONE : Long.NEG_ONE;
                        }
                        else {
                            var rem = this.subtract(other.multiply(approx));
                            var result = approx.add(rem.div(other));
                            return result;
                        }
                    }
                }
                else if (other.equals(Long.MIN_VALUE)) {
                    return Long.ZERO;
                }
                if (this.isNegative()) {
                    if (other.isNegative()) {
                        return this.negate().div(other.negate());
                    }
                    else {
                        return this.negate().div(other).negate();
                    }
                }
                else if (other.isNegative()) {
                    return this.div(other.negate()).negate();
                }
                var res = Long.ZERO;
                var rem = this;
                while (rem.greaterThanOrEqual(other)) {
                    let approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
                    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
                    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);
                    var approxRes = Long.fromNumber(approx);
                    var approxRem = approxRes.multiply(other);
                    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
                        approx -= delta;
                        approxRes = Long.fromNumber(approx);
                        approxRem = approxRes.multiply(other);
                    }
                    if (approxRes.isZero()) {
                        approxRes = Long.ONE;
                    }
                    res = res.add(approxRes);
                    rem = rem.subtract(approxRem);
                }
                return res;
            }
            modulo(other) {
                return this.subtract(this.div(other).multiply(other));
            }
            not() {
                return Long.fromBits(~this.low_, ~this.high_);
            }
            and(other) {
                return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
            }
            or(other) {
                return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
            }
            xor(other) {
                return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
            }
            shiftLeft(numBits) {
                numBits &= 63;
                if (numBits == 0) {
                    return this;
                }
                else {
                    var low = this.low_;
                    if (numBits < 32) {
                        var high = this.high_;
                        return Long.fromBits(low << numBits, (high << numBits) | (low >>> (32 - numBits)));
                    }
                    else {
                        return Long.fromBits(0, low << (numBits - 32));
                    }
                }
            }
            shiftRight(numBits) {
                numBits &= 63;
                if (numBits == 0) {
                    return this;
                }
                else {
                    var high = this.high_;
                    if (numBits < 32) {
                        var low = this.low_;
                        return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >> numBits);
                    }
                    else {
                        return Long.fromBits(high >> (numBits - 32), high >= 0 ? 0 : -1);
                    }
                }
            }
            shiftRightUnsigned(numBits) {
                numBits &= 63;
                if (numBits == 0) {
                    return this;
                }
                else {
                    var high = this.high_;
                    if (numBits < 32) {
                        var low = this.low_;
                        return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits);
                    }
                    else if (numBits == 32) {
                        return Long.fromBits(high, 0);
                    }
                    else {
                        return Long.fromBits(high >>> (numBits - 32), 0);
                    }
                }
            }
            static fromInt(value) {
                if (-128 <= value && value < 128) {
                    var cachedObj = Long.IntCache_[value];
                    if (cachedObj) {
                        return cachedObj;
                    }
                }
                var obj = new Long(value | 0, value < 0 ? -1 : 0);
                if (-128 <= value && value < 128) {
                    Long.IntCache_[value] = obj;
                }
                return obj;
            }
            static fromNumber(value) {
                if (isNaN(value) || !isFinite(value)) {
                    return Long.ZERO;
                }
                else if (value <= -Long.TWO_PWR_63_DBL_) {
                    return Long.MIN_VALUE;
                }
                else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
                    return Long.MAX_VALUE;
                }
                else if (value < 0) {
                    return Long.fromNumber(-value).negate();
                }
                else {
                    return new Long((value % Long.TWO_PWR_32_DBL_) | 0, (value / Long.TWO_PWR_32_DBL_) | 0);
                }
            }
            static fromBits(lowBits, highBits) {
                return new Long(lowBits, highBits);
            }
            static fromString(str, opt_radix) {
                if (str.length == 0) {
                    throw Error('number format error: empty string');
                }
                var radix = opt_radix || 10;
                if (radix < 2 || 36 < radix) {
                    throw Error('radix out of range: ' + radix);
                }
                if (str.charAt(0) == '-') {
                    return Long.fromString(str.substring(1), radix).negate();
                }
                else if (str.indexOf('-') >= 0) {
                    throw Error('number format error: interior "-" character: ' + str);
                }
                var radixToPower = Long.fromNumber(Math.pow(radix, 8));
                var result = Long.ZERO;
                for (var i = 0; i < str.length; i += 8) {
                    var size = Math.min(8, str.length - i);
                    var value = parseInt(str.substring(i, i + size), radix);
                    if (size < 8) {
                        var power = Long.fromNumber(Math.pow(radix, size));
                        result = result.multiply(power).add(Long.fromNumber(value));
                    }
                    else {
                        result = result.multiply(radixToPower);
                        result = result.add(Long.fromNumber(value));
                    }
                }
                return result;
            }
        }
        Long.IntCache_ = {};
        Long.TWO_PWR_16_DBL_ = 1 << 16;
        Long.TWO_PWR_24_DBL_ = 1 << 24;
        Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;
        Long.TWO_PWR_31_DBL_ = Long.TWO_PWR_32_DBL_ / 2;
        Long.TWO_PWR_48_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_16_DBL_;
        Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;
        Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;
        Long.TWO_PWR_24_ = Long.fromInt(1 << 24);
        Long.ZERO = Long.fromInt(0);
        Long.ONE = Long.fromInt(1);
        Long.NEG_ONE = Long.fromInt(-1);
        Long.MAX_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
        Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);
        math.Long = Long;
    })(math = goog.math || (goog.math = {}));
})(goog || (goog = {}));
/**
 * Created by linfaxin on 15/11/13.
 */
///<reference path="../../androidui/util/Long.ts"/>
var java;
(function (java) {
    var lang;
    (function (lang) {
        class Long {
        }
        Long.MIN_VALUE = goog.math.Long.MIN_VALUE.toNumber();
        Long.MAX_VALUE = goog.math.Long.MAX_VALUE.toNumber();
        lang.Long = Long;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class AccelerateDecelerateInterpolator {
                getInterpolation(input) {
                    return (Math.cos((input + 1) * Math.PI) / 2) + 0.5;
                }
            }
            animation.AccelerateDecelerateInterpolator = AccelerateDecelerateInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class DecelerateInterpolator {
                constructor(factor = 1) {
                    this.mFactor = factor;
                }
                getInterpolation(input) {
                    let result;
                    if (this.mFactor == 1.0) {
                        result = (1.0 - (1.0 - input) * (1.0 - input));
                    }
                    else {
                        result = (1.0 - Math.pow((1.0 - input), 2 * this.mFactor));
                    }
                    return result;
                }
            }
            animation.DecelerateInterpolator = DecelerateInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Matrix.ts"/>
///<reference path="../../../java/lang/StringBuilder.ts"/>
///<reference path="../../../android/view/animation/Animation.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            var Matrix = android.graphics.Matrix;
            var StringBuilder = java.lang.StringBuilder;
            class Transformation {
                constructor() {
                    this.mAlpha = 0;
                    this.mTransformationType = 0;
                    this.clear();
                }
                clear() {
                    if (this.mMatrix == null) {
                        this.mMatrix = new Matrix();
                    }
                    else {
                        this.mMatrix.reset();
                    }
                    this.mAlpha = 1.0;
                    this.mTransformationType = Transformation.TYPE_BOTH;
                }
                getTransformationType() {
                    return this.mTransformationType;
                }
                setTransformationType(transformationType) {
                    this.mTransformationType = transformationType;
                }
                set(t) {
                    this.mAlpha = t.getAlpha();
                    this.mMatrix.set(t.getMatrix());
                    this.mTransformationType = t.getTransformationType();
                }
                compose(t) {
                    this.mAlpha *= t.getAlpha();
                    this.mMatrix.preConcat(t.getMatrix());
                }
                postCompose(t) {
                    this.mAlpha *= t.getAlpha();
                    this.mMatrix.postConcat(t.getMatrix());
                }
                getMatrix() {
                    return this.mMatrix;
                }
                setAlpha(alpha) {
                    this.mAlpha = alpha;
                }
                getAlpha() {
                    return this.mAlpha;
                }
                toString() {
                    let sb = new StringBuilder(64);
                    sb.append("Transformation");
                    this.toShortString(sb);
                    return sb.toString();
                }
                toShortString(sb) {
                    sb = sb || new StringBuilder(64);
                    sb.append("{alpha=");
                    sb.append(this.mAlpha);
                    sb.append(" matrix=");
                    this.mMatrix.toShortString(sb);
                    sb.append('}');
                }
            }
            Transformation.TYPE_IDENTITY = 0x0;
            Transformation.TYPE_ALPHA = 0x1;
            Transformation.TYPE_MATRIX = 0x2;
            Transformation.TYPE_BOTH = Transformation.TYPE_ALPHA | Transformation.TYPE_MATRIX;
            animation.Transformation = Transformation;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/RectF.ts"/>
///<reference path="../../../android/os/Handler.ts"/>
///<reference path="../../../android/util/TypedValue.ts"/>
///<reference path="../../../java/lang/Long.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../../android/view/animation/AccelerateDecelerateInterpolator.ts"/>
///<reference path="../../../android/view/animation/AnimationUtils.ts"/>
///<reference path="../../../android/view/animation/DecelerateInterpolator.ts"/>
///<reference path="../../../android/view/animation/Interpolator.ts"/>
///<reference path="../../../android/view/animation/Transformation.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation_1) {
            var RectF = android.graphics.RectF;
            var TypedValue = android.util.TypedValue;
            var Long = java.lang.Long;
            var AccelerateDecelerateInterpolator = android.view.animation.AccelerateDecelerateInterpolator;
            var AnimationUtils = android.view.animation.AnimationUtils;
            var Transformation = android.view.animation.Transformation;
            class Animation {
                constructor() {
                    this.mEnded = false;
                    this.mStarted = false;
                    this.mCycleFlip = false;
                    this.mInitialized = false;
                    this.mFillBefore = true;
                    this.mFillAfter = false;
                    this.mFillEnabled = false;
                    this.mStartTime = -1;
                    this.mStartOffset = 0;
                    this.mDuration = 0;
                    this.mRepeatCount = 0;
                    this.mRepeated = 0;
                    this.mRepeatMode = Animation.RESTART;
                    this.mZAdjustment = 0;
                    this.mBackgroundColor = 0;
                    this.mScaleFactor = 1;
                    this.mDetachWallpaper = false;
                    this.mMore = true;
                    this.mOneMoreTime = true;
                    this.mPreviousRegion = new RectF();
                    this.mRegion = new RectF();
                    this.mTransformation = new Transformation();
                    this.mPreviousTransformation = new Transformation();
                    this.ensureInterpolator();
                }
                reset() {
                    this.mPreviousRegion.setEmpty();
                    this.mPreviousTransformation.clear();
                    this.mInitialized = false;
                    this.mCycleFlip = false;
                    this.mRepeated = 0;
                    this.mMore = true;
                    this.mOneMoreTime = true;
                    this.mListenerHandler = null;
                }
                cancel() {
                    if (this.mStarted && !this.mEnded) {
                        this.fireAnimationEnd();
                        this.mEnded = true;
                    }
                    this.mStartTime = Long.MIN_VALUE;
                    this.mMore = this.mOneMoreTime = false;
                }
                detach() {
                    if (this.mStarted && !this.mEnded) {
                        this.mEnded = true;
                        this.fireAnimationEnd();
                    }
                }
                isInitialized() {
                    return this.mInitialized;
                }
                initialize(width, height, parentWidth, parentHeight) {
                    this.reset();
                    this.mInitialized = true;
                }
                setListenerHandler(handler) {
                    if (this.mListenerHandler == null) {
                        const _this = this;
                        this.mOnStart = {
                            run() {
                                if (_this.mListener != null) {
                                    _this.mListener.onAnimationStart(_this);
                                }
                            }
                        };
                        this.mOnRepeat = {
                            run() {
                                if (_this.mListener != null) {
                                    _this.mListener.onAnimationRepeat(_this);
                                }
                            }
                        };
                        this.mOnEnd = {
                            run() {
                                if (_this.mListener != null) {
                                    _this.mListener.onAnimationEnd(_this);
                                }
                            }
                        };
                    }
                    this.mListenerHandler = handler;
                }
                setInterpolator(i) {
                    this.mInterpolator = i;
                }
                setStartOffset(startOffset) {
                    this.mStartOffset = startOffset;
                }
                setDuration(durationMillis) {
                    if (durationMillis < 0) {
                        throw Error(`new IllegalArgumentException("Animation duration cannot be negative")`);
                    }
                    this.mDuration = durationMillis;
                }
                restrictDuration(durationMillis) {
                    if (this.mStartOffset > durationMillis) {
                        this.mStartOffset = durationMillis;
                        this.mDuration = 0;
                        this.mRepeatCount = 0;
                        return;
                    }
                    let dur = this.mDuration + this.mStartOffset;
                    if (dur > durationMillis) {
                        this.mDuration = durationMillis - this.mStartOffset;
                        dur = durationMillis;
                    }
                    if (this.mDuration <= 0) {
                        this.mDuration = 0;
                        this.mRepeatCount = 0;
                        return;
                    }
                    if (this.mRepeatCount < 0 || this.mRepeatCount > durationMillis || (dur * this.mRepeatCount) > durationMillis) {
                        this.mRepeatCount = Math.floor((durationMillis / dur)) - 1;
                        if (this.mRepeatCount < 0) {
                            this.mRepeatCount = 0;
                        }
                    }
                }
                scaleCurrentDuration(scale) {
                    this.mDuration = Math.floor((this.mDuration * scale));
                    this.mStartOffset = Math.floor((this.mStartOffset * scale));
                }
                setStartTime(startTimeMillis) {
                    this.mStartTime = startTimeMillis;
                    this.mStarted = this.mEnded = false;
                    this.mCycleFlip = false;
                    this.mRepeated = 0;
                    this.mMore = true;
                }
                start() {
                    this.setStartTime(-1);
                }
                startNow() {
                    this.setStartTime(AnimationUtils.currentAnimationTimeMillis());
                }
                setRepeatMode(repeatMode) {
                    this.mRepeatMode = repeatMode;
                }
                setRepeatCount(repeatCount) {
                    if (repeatCount < 0) {
                        repeatCount = Animation.INFINITE;
                    }
                    this.mRepeatCount = repeatCount;
                }
                isFillEnabled() {
                    return this.mFillEnabled;
                }
                setFillEnabled(fillEnabled) {
                    this.mFillEnabled = fillEnabled;
                }
                setFillBefore(fillBefore) {
                    this.mFillBefore = fillBefore;
                }
                setFillAfter(fillAfter) {
                    this.mFillAfter = fillAfter;
                }
                setZAdjustment(zAdjustment) {
                    this.mZAdjustment = zAdjustment;
                }
                setBackgroundColor(bg) {
                    this.mBackgroundColor = bg;
                }
                getScaleFactor() {
                    return this.mScaleFactor;
                }
                setDetachWallpaper(detachWallpaper) {
                    this.mDetachWallpaper = detachWallpaper;
                }
                getInterpolator() {
                    return this.mInterpolator;
                }
                getStartTime() {
                    return this.mStartTime;
                }
                getDuration() {
                    return this.mDuration;
                }
                getStartOffset() {
                    return this.mStartOffset;
                }
                getRepeatMode() {
                    return this.mRepeatMode;
                }
                getRepeatCount() {
                    return this.mRepeatCount;
                }
                getFillBefore() {
                    return this.mFillBefore;
                }
                getFillAfter() {
                    return this.mFillAfter;
                }
                getZAdjustment() {
                    return this.mZAdjustment;
                }
                getBackgroundColor() {
                    return this.mBackgroundColor;
                }
                getDetachWallpaper() {
                    return this.mDetachWallpaper;
                }
                willChangeTransformationMatrix() {
                    return true;
                }
                willChangeBounds() {
                    return true;
                }
                setAnimationListener(listener) {
                    this.mListener = listener;
                }
                ensureInterpolator() {
                    if (this.mInterpolator == null) {
                        this.mInterpolator = new AccelerateDecelerateInterpolator();
                    }
                }
                computeDurationHint() {
                    return (this.getStartOffset() + this.getDuration()) * (this.getRepeatCount() + 1);
                }
                getTransformation(currentTime, outTransformation, scale) {
                    if (scale != null)
                        this.mScaleFactor = scale;
                    if (this.mStartTime == -1) {
                        this.mStartTime = currentTime;
                    }
                    const startOffset = this.getStartOffset();
                    const duration = this.mDuration;
                    let normalizedTime;
                    if (duration != 0) {
                        normalizedTime = (currentTime - (this.mStartTime + startOffset)) / duration;
                    }
                    else {
                        normalizedTime = currentTime < this.mStartTime ? 0.0 : 1.0;
                    }
                    const expired = normalizedTime >= 1.0;
                    this.mMore = !expired;
                    if (!this.mFillEnabled)
                        normalizedTime = Math.max(Math.min(normalizedTime, 1.0), 0.0);
                    if ((normalizedTime >= 0.0 || this.mFillBefore) && (normalizedTime <= 1.0 || this.mFillAfter)) {
                        if (!this.mStarted) {
                            this.fireAnimationStart();
                            this.mStarted = true;
                        }
                        if (this.mFillEnabled)
                            normalizedTime = Math.max(Math.min(normalizedTime, 1.0), 0.0);
                        if (this.mCycleFlip) {
                            normalizedTime = 1.0 - normalizedTime;
                        }
                        const interpolatedTime = this.mInterpolator.getInterpolation(normalizedTime);
                        this.applyTransformation(interpolatedTime, outTransformation);
                    }
                    if (expired) {
                        if (this.mRepeatCount == this.mRepeated) {
                            if (!this.mEnded) {
                                this.mEnded = true;
                                this.fireAnimationEnd();
                            }
                        }
                        else {
                            if (this.mRepeatCount > 0) {
                                this.mRepeated++;
                            }
                            if (this.mRepeatMode == Animation.REVERSE) {
                                this.mCycleFlip = !this.mCycleFlip;
                            }
                            this.mStartTime = -1;
                            this.mMore = true;
                            this.fireAnimationRepeat();
                        }
                    }
                    if (!this.mMore && this.mOneMoreTime) {
                        this.mOneMoreTime = false;
                        return true;
                    }
                    return this.mMore;
                }
                fireAnimationStart() {
                    if (this.mListener != null) {
                        if (this.mListenerHandler == null)
                            this.mListener.onAnimationStart(this);
                        else
                            this.mListenerHandler.postAtFrontOfQueue(this.mOnStart);
                    }
                }
                fireAnimationRepeat() {
                    if (this.mListener != null) {
                        if (this.mListenerHandler == null)
                            this.mListener.onAnimationRepeat(this);
                        else
                            this.mListenerHandler.postAtFrontOfQueue(this.mOnRepeat);
                    }
                }
                fireAnimationEnd() {
                    if (this.mListener != null) {
                        if (this.mListenerHandler == null)
                            this.mListener.onAnimationEnd(this);
                        else
                            this.mListenerHandler.postAtFrontOfQueue(this.mOnEnd);
                    }
                }
                hasStarted() {
                    return this.mStarted;
                }
                hasEnded() {
                    return this.mEnded;
                }
                applyTransformation(interpolatedTime, t) {
                }
                resolveSize(type, value, size, parentSize) {
                    switch (type) {
                        case Animation.ABSOLUTE:
                            return value;
                        case Animation.RELATIVE_TO_SELF:
                            return size * value;
                        case Animation.RELATIVE_TO_PARENT:
                            return parentSize * value;
                        default:
                            return value;
                    }
                }
                getInvalidateRegion(left, top, right, bottom, invalidate, transformation) {
                    const tempRegion = this.mRegion;
                    const previousRegion = this.mPreviousRegion;
                    invalidate.set(left, top, right, bottom);
                    transformation.getMatrix().mapRect(invalidate);
                    invalidate.inset(-1.0, -1.0);
                    tempRegion.set(invalidate);
                    invalidate.union(previousRegion);
                    previousRegion.set(tempRegion);
                    const tempTransformation = this.mTransformation;
                    const previousTransformation = this.mPreviousTransformation;
                    tempTransformation.set(transformation);
                    transformation.set(previousTransformation);
                    previousTransformation.set(tempTransformation);
                }
                initializeInvalidateRegion(left, top, right, bottom) {
                    const region = this.mPreviousRegion;
                    region.set(left, top, right, bottom);
                    region.inset(-1.0, -1.0);
                    if (this.mFillBefore) {
                        const previousTransformation = this.mPreviousTransformation;
                        this.applyTransformation(this.mInterpolator.getInterpolation(0.0), previousTransformation);
                    }
                }
                hasAlpha() {
                    return false;
                }
            }
            Animation.INFINITE = -1;
            Animation.RESTART = 1;
            Animation.REVERSE = 2;
            Animation.START_ON_FIRST_FRAME = -1;
            Animation.ABSOLUTE = 0;
            Animation.RELATIVE_TO_SELF = 1;
            Animation.RELATIVE_TO_PARENT = 2;
            Animation.ZORDER_NORMAL = 0;
            Animation.ZORDER_TOP = 1;
            Animation.ZORDER_BOTTOM = -1;
            Animation.USE_CLOSEGUARD = false;
            animation_1.Animation = Animation;
            (function (Animation) {
                class Description {
                    constructor() {
                        this.type = 0;
                        this.value = 0;
                    }
                    static parseValue(value) {
                        let d = new Description();
                        if (value == null) {
                            d.type = Animation.ABSOLUTE;
                            d.value = 0;
                        }
                        else {
                            if (value.endsWith('%p')) {
                                d.type = Animation.RELATIVE_TO_PARENT;
                                d.value = Number.parseFloat(value.substring(0, value.length - 2));
                            }
                            else if (value.endsWith('%')) {
                                d.type = Animation.RELATIVE_TO_SELF;
                                d.value = Number.parseFloat(value.substring(0, value.length - 1));
                            }
                            else {
                                d.type = Animation.ABSOLUTE;
                                d.value = TypedValue.complexToDimensionPixelSize(value);
                            }
                        }
                        d.type = Animation.ABSOLUTE;
                        d.value = 0.0;
                        return d;
                    }
                }
                Animation.Description = Description;
            })(Animation = animation_1.Animation || (animation_1.Animation = {}));
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/26.
 */
///<reference path="drawable.ts"/>
///<reference path="image.ts"/>
///<reference path="color.ts"/>
///<reference path="../view/Gravity.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../view/animation/Animation.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/StateListDrawable.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var Gravity = android.view.Gravity;
        var Color = android.graphics.Color;
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var StateListDrawable = android.graphics.drawable.StateListDrawable;
        class attr {
            static get viewStyle() {
                return attr._viewStyle;
            }
            static get textViewStyle() {
                return {
                    textSize: '14sp',
                    textColor: R.color.textView_textColor
                };
            }
            static get buttonStyle() {
                return Object.assign(attr.textViewStyle, {
                    background: R.drawable.button_background,
                    focusable: true,
                    clickable: true,
                    textSize: '18sp',
                    gravity: Gravity.CENTER
                });
            }
            static get imageButtonStyle() {
                return {
                    background: R.drawable.button_background,
                    focusable: true,
                    clickable: true,
                    gravity: Gravity.CENTER
                };
            }
            static get checkboxStyle() {
                return Object.assign(this.buttonStyle, {
                    background: null,
                    button: R.drawable.btn_check
                });
            }
            static get radiobuttonStyle() {
                return Object.assign(this.buttonStyle, {
                    background: null,
                    button: R.drawable.btn_radio
                });
            }
            static get checkedTextViewStyle() {
                return {
                    textAlignment: 'viewStart'
                };
            }
            static get progressBarStyle() {
                return {
                    indeterminateOnly: true,
                    indeterminateDrawable: R.drawable.progress_medium_holo,
                    indeterminateBehavior: 'repeat',
                    indeterminateDuration: 3500,
                    minWidth: '48dp',
                    maxWidth: '48dp',
                    minHeight: '48dp',
                    maxHeight: '48dp',
                    mirrorForRtl: false,
                };
            }
            static get progressBarStyleHorizontal() {
                return {
                    indeterminateOnly: false,
                    progressDrawable: R.drawable.progress_horizontal_holo,
                    indeterminateDrawable: R.drawable.progress_indeterminate_horizontal_holo,
                    indeterminateBehavior: 'repeat',
                    indeterminateDuration: 3500,
                    minHeight: '20dp',
                    maxHeight: '20dp',
                    mirrorForRtl: true,
                };
            }
            static get progressBarStyleSmall() {
                return Object.assign(this.progressBarStyle, {
                    indeterminateDrawable: R.drawable.progress_small_holo,
                    minWidth: '16dp',
                    maxWidth: '16dp',
                    minHeight: '16dp',
                    maxHeight: '16dp'
                });
            }
            static get progressBarStyleLarge() {
                return Object.assign(this.progressBarStyle, {
                    indeterminateDrawable: R.drawable.progress_large_holo,
                    minWidth: '76dp',
                    maxWidth: '76dp',
                    minHeight: '76dp',
                    maxHeight: '76dp'
                });
            }
            static get seekBarStyle() {
                return {
                    indeterminateOnly: false,
                    progressDrawable: R.drawable.scrubber_progress_horizontal_holo_light,
                    indeterminateDrawable: R.drawable.scrubber_progress_horizontal_holo_light,
                    minHeight: '13dp',
                    maxHeight: '13dp',
                    thumb: R.drawable.scrubber_control_selector_holo,
                    thumbOffset: '16dp',
                    focusable: true,
                    paddingLeft: '16dp',
                    paddingRight: '16dp',
                    mirrorForRtl: true,
                };
            }
            static get ratingBarStyle() {
                return {
                    indeterminateOnly: false,
                    progressDrawable: R.drawable.ratingbar_full_holo_light,
                    indeterminateDrawable: R.drawable.ratingbar_full_holo_light,
                    minHeight: '48dip',
                    maxHeight: '48dip',
                    numStars: '5',
                    stepSize: '0.5',
                    thumb: null,
                    mirrorForRtl: true,
                };
            }
            static get ratingBarStyleIndicator() {
                return Object.assign(this.ratingBarStyle, {
                    indeterminateOnly: false,
                    progressDrawable: R.drawable.ratingbar_holo_light,
                    indeterminateDrawable: R.drawable.ratingbar_holo_light,
                    minHeight: '35dip',
                    maxHeight: '35dip',
                    thumb: null,
                    isIndicator: true,
                });
            }
            static get ratingBarStyleSmall() {
                return Object.assign(this.ratingBarStyle, {
                    indeterminateOnly: false,
                    progressDrawable: R.drawable.ratingbar_small_holo_light,
                    indeterminateDrawable: R.drawable.ratingbar_small_holo_light,
                    minHeight: '16dip',
                    maxHeight: '16dip',
                    thumb: null,
                    isIndicator: true,
                });
            }
            static get gridViewStyle() {
                return {
                    listSelector: android.R.drawable.list_selector_background,
                    numColumns: 1
                };
            }
            static get listViewStyle() {
                return {
                    divider: android.R.drawable.list_divider,
                    listSelector: android.R.drawable.list_selector_background,
                    dividerHeight: 1
                };
            }
            static get expandableListViewStyle() {
                return Object.assign(this.listViewStyle, {
                    childDivider: android.R.drawable.list_divider,
                });
            }
            static get numberPickerStyle() {
                return {
                    orientation: 'vertical',
                    solidColor: 'transparent',
                    selectionDivider: new ColorDrawable(0xcc33b5e5),
                    selectionDividerHeight: '2dp',
                    selectionDividersDistance: '48dp',
                    internalMinWidth: '64dp',
                    internalMaxHeight: '180dp',
                    virtualButtonPressedDrawable: (() => {
                        let stateList = new StateListDrawable();
                        stateList.addState([android.view.View.VIEW_STATE_PRESSED], new ColorDrawable(0x44888888));
                        stateList.addState([android.view.View.VIEW_STATE_PRESSED], new ColorDrawable(0x44888888));
                        stateList.addState([], new ColorDrawable(Color.TRANSPARENT));
                        return stateList;
                    })(),
                };
            }
            static get popupWindowStyle() {
                return {
                    popupBackground: R.drawable.dropdown_background_dark,
                    popupEnterAnimation: R.anim.grow_fade_in_center,
                    popupExitAnimation: R.anim.shrink_fade_out_center,
                };
            }
            static get listPopupWindowStyle() {
                return {
                    popupBackground: R.drawable.menu_panel_holo_light,
                    popupEnterAnimation: R.anim.grow_fade_in_center,
                    popupExitAnimation: R.anim.shrink_fade_out_center,
                };
            }
            static get dropDownListViewStyle() {
                return this.listViewStyle;
            }
            static get spinnerStyle() {
                return {
                    clickable: true,
                    spinnerMode: 'dropdown',
                    gravity: Gravity.START | Gravity.CENTER_VERTICAL,
                    disableChildrenWhenDisabled: true,
                    background: R.drawable.button_background,
                    popupBackground: R.drawable.menu_panel_holo_light,
                    dropDownVerticalOffset: '0dp',
                    dropDownHorizontalOffset: '0dp',
                    dropDownWidth: -2,
                };
            }
        }
        attr._viewStyle = {};
        R.attr = attr;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/9/27.
 */
///<reference path="../util/SparseArray.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/ScrollBarDrawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ShadowDrawable.ts"/>
///<reference path="../graphics/drawable/RoundRectDrawable.ts"/>
///<reference path="../graphics/PixelFormat.ts"/>
///<reference path="../graphics/Matrix.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/Paint.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/Object.ts"/>
///<reference path="../../java/lang/util/concurrent/CopyOnWriteArrayList.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="ViewRootImpl.ts"/>
///<reference path="ViewParent.ts"/>
///<reference path="ViewGroup.ts"/>
///<reference path="ViewOverlay.ts"/>
///<reference path="ViewTreeObserver.ts"/>
///<reference path="MotionEvent.ts"/>
///<reference path="TouchDelegate.ts"/>
///<reference path="../os/Handler.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../content/Context.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../content/res/ColorStateList.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/RectF.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../util/Pools.ts"/>
///<reference path="../util/TypedValue.ts"/>
///<reference path="Gravity.ts"/>
///<reference path="../view/animation/LinearInterpolator.ts"/>
///<reference path="../view/animation/AnimationUtils.ts"/>
///<reference path="../../android/util/LayoutDirection.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../androidui/attr/StateAttrList.ts"/>
///<reference path="../../androidui/attr/StateAttr.ts"/>
///<reference path="../../androidui/attr/AttrBinder.ts"/>
///<reference path="../../androidui/util/PerformanceAdjuster.ts"/>
///<reference path="../../androidui/image/NetDrawable.ts"/>
///<reference path="KeyEvent.ts"/>
///<reference path="../R/attr.ts"/>
///<reference path="animation/Animation.ts"/>
///<reference path="animation/Transformation.ts"/>
var android;
(function (android) {
    var view;
    (function (view_2) {
        var LayoutDirection = android.util.LayoutDirection;
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var ScrollBarDrawable = android.graphics.drawable.ScrollBarDrawable;
        var InsetDrawable = android.graphics.drawable.InsetDrawable;
        var ShadowDrawable = android.graphics.drawable.ShadowDrawable;
        var RoundRectDrawable = android.graphics.drawable.RoundRectDrawable;
        var PixelFormat = android.graphics.PixelFormat;
        var Matrix = android.graphics.Matrix;
        var Color = android.graphics.Color;
        var Paint = android.graphics.Paint;
        var StringBuilder = java.lang.StringBuilder;
        var JavaObject = java.lang.JavaObject;
        var System = java.lang.System;
        var SystemClock = android.os.SystemClock;
        var Log = android.util.Log;
        var Rect = android.graphics.Rect;
        var RectF = android.graphics.RectF;
        var Point = android.graphics.Point;
        var Canvas = android.graphics.Canvas;
        var CopyOnWriteArrayList = java.lang.util.concurrent.CopyOnWriteArrayList;
        var ArrayList = java.util.ArrayList;
        var Resources = android.content.res.Resources;
        var Pools = android.util.Pools;
        var TypedValue = android.util.TypedValue;
        var LinearInterpolator = android.view.animation.LinearInterpolator;
        var AnimationUtils = android.view.animation.AnimationUtils;
        var StateAttrList = androidui.attr.StateAttrList;
        var AttrBinder = androidui.attr.AttrBinder;
        var NetDrawable = androidui.image.NetDrawable;
        var KeyEvent = android.view.KeyEvent;
        var Animation = view_2.animation.Animation;
        var Transformation = view_2.animation.Transformation;
        class View extends JavaObject {
            constructor(context, bindElement, defStyle = android.R.attr.viewStyle) {
                super();
                this.mPrivateFlags = 0;
                this.mPrivateFlags2 = 0;
                this.mPrivateFlags3 = 0;
                this.mCurrentAnimation = null;
                this.mOldWidthMeasureSpec = Number.MIN_SAFE_INTEGER;
                this.mOldHeightMeasureSpec = Number.MIN_SAFE_INTEGER;
                this.mMeasuredWidth = 0;
                this.mMeasuredHeight = 0;
                this.mBackgroundSizeChanged = false;
                this.mBackgroundWidth = 0;
                this.mBackgroundHeight = 0;
                this.mHasPerformedLongPress = false;
                this.mMinWidth = 0;
                this.mMinHeight = 0;
                this.mDrawingCacheBackgroundColor = 0;
                this.mTouchSlop = 0;
                this.mVerticalScrollFactor = 0;
                this.mOverScrollMode = 0;
                this.mViewFlags = 0;
                this.mLayerType = View.LAYER_TYPE_NONE;
                this.mCachingFailed = false;
                this.mWindowAttachCount = 0;
                this.mTransientStateCount = 0;
                this.mLastIsOpaque = false;
                this._mLeft = 0;
                this._mRight = 0;
                this._mTop = 0;
                this._mBottom = 0;
                this._mScrollX = 0;
                this._mScrollY = 0;
                this.mPaddingLeft = 0;
                this.mPaddingRight = 0;
                this.mPaddingTop = 0;
                this.mPaddingBottom = 0;
                this.mCornerRadiusTopLeft = 0;
                this.mCornerRadiusTopRight = 0;
                this.mCornerRadiusBottomRight = 0;
                this.mCornerRadiusBottomLeft = 0;
                this._attrBinder = new AttrBinder(this);
                this.mContext = context;
                this.mTouchSlop = view_2.ViewConfiguration.get().getScaledTouchSlop();
                this.setOverScrollMode(View.OVER_SCROLL_ALWAYS);
                this.initBindAttr(this._attrBinder);
                this.initBindElement(bindElement);
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
            }
            get mID() {
                if (this.bindElement) {
                    let id = this.bindElement.id;
                    return id ? id : null;
                }
                return null;
            }
            get mLeft() { return this._mLeft; }
            set mLeft(value) {
                this._mLeft = Math.floor(value);
                this.requestSyncBoundToElement();
            }
            get mRight() { return this._mRight; }
            set mRight(value) {
                this._mRight = Math.floor(value);
                this.requestSyncBoundToElement();
            }
            get mTop() { return this._mTop; }
            set mTop(value) {
                this._mTop = Math.floor(value);
                this.requestSyncBoundToElement();
            }
            get mBottom() { return this._mBottom; }
            set mBottom(value) {
                this._mBottom = Math.floor(value);
                this.requestSyncBoundToElement();
            }
            get mScrollX() { return this._mScrollX; }
            set mScrollX(value) { this._mScrollX = Math.floor(value); }
            get mScrollY() { return this._mScrollY; }
            set mScrollY(value) {
                if (Number.isNaN(value) || value == null) {
                    console.error('set mScrollY value is ' + value);
                    value = 0;
                }
                this._mScrollY = Math.floor(value);
            }
            initBindAttr(a) {
                a.addAttr('background', (value) => {
                    this.setBackground(a.parseDrawable(value));
                }, () => {
                    if (this.mBackground instanceof ColorDrawable) {
                        return Color.toRGBAFunc(this.mBackground.getColor());
                    }
                    return this.mBackground;
                });
                a.addAttr('padding', (value) => {
                    let [left, top, right, bottom] = a.parsePaddingMarginLTRB(value);
                    this._setPaddingWithUnit(left, top, right, bottom);
                }, () => {
                    return this.mPaddingTop + ' ' + this.mPaddingRight + ' ' + this.mPaddingBottom + ' ' + this.mPaddingLeft;
                }),
                    a.addAttr('paddingLeft', (value) => {
                        this._setPaddingWithUnit(value, this.mPaddingTop, this.mPaddingRight, this.mPaddingBottom);
                    }, () => {
                        return this.mPaddingLeft;
                    }),
                    a.addAttr('paddingStart', (value) => {
                        this._setPaddingWithUnit(value, this.mPaddingTop, this.mPaddingRight, this.mPaddingBottom);
                    }, () => {
                        return this.mPaddingLeft;
                    }),
                    a.addAttr('paddingTop', (value) => {
                        this._setPaddingWithUnit(this.mPaddingLeft, value, this.mPaddingRight, this.mPaddingBottom);
                    }, () => {
                        return this.mPaddingTop;
                    }),
                    a.addAttr('paddingRight', (value) => {
                        this._setPaddingWithUnit(this.mPaddingLeft, this.mPaddingTop, value, this.mPaddingBottom);
                    }, () => {
                        return this.mPaddingRight;
                    }),
                    a.addAttr('paddingEnd', (value) => {
                        this._setPaddingWithUnit(this.mPaddingLeft, this.mPaddingTop, value, this.mPaddingBottom);
                    }, () => {
                        return this.mPaddingRight;
                    }),
                    a.addAttr('paddingBottom', (value) => {
                        this._setPaddingWithUnit(this.mPaddingLeft, this.mPaddingTop, this.mPaddingRight, value);
                    }, () => {
                        return this.mPaddingBottom;
                    }),
                    a.addAttr('scrollX', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            this.scrollTo(value, this.mScrollY);
                    }),
                    a.addAttr('scrollY', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            this.scrollTo(this.mScrollX, value);
                    }),
                    a.addAttr('alpha', (value) => {
                        this.setAlpha(a.parseNumber(value));
                    }),
                    a.addAttr('transformPivotX', (value) => {
                        this.setPivotX(a.parseNumber(value, 0));
                    }),
                    a.addAttr('transformPivotY', (value) => {
                        this.setPivotY(a.parseNumber(value, 0));
                    }),
                    a.addAttr('translationX', (value) => {
                        this.setTranslationX(a.parseNumber(value, 0));
                    }),
                    a.addAttr('translationY', (value) => {
                        this.setTranslationY(a.parseNumber(value, 0));
                    }),
                    a.addAttr('rotation', (value) => {
                        this.setRotation(a.parseNumber(value, 0));
                    }),
                    a.addAttr('rotationX', (value) => {
                    }),
                    a.addAttr('rotationY', (value) => {
                    }),
                    a.addAttr('scaleX', (value) => {
                        this.setScaleX(a.parseNumber(value, 1));
                    }),
                    a.addAttr('scaleY', (value) => {
                        this.setScaleY(a.parseNumber(value, 1));
                    }),
                    a.addAttr('tag', (value) => {
                        this.setTag(value);
                    }),
                    a.addAttr('id', (value) => {
                        this.setId(value);
                    }),
                    a.addAttr('focusable', (value) => {
                        if (a.parseBoolean(value, false)) {
                            this.setFlags(View.FOCUSABLE, View.FOCUSABLE_MASK);
                        }
                    }),
                    a.addAttr('focusableInTouchMode', (value) => {
                        if (a.parseBoolean(value, false)) {
                            this.setFlags(View.FOCUSABLE_IN_TOUCH_MODE | View.FOCUSABLE, View.FOCUSABLE_IN_TOUCH_MODE | View.FOCUSABLE_MASK);
                        }
                    }),
                    a.addAttr('clickable', (value) => {
                        if (a.parseBoolean(value, false)) {
                            this.setFlags(View.CLICKABLE, View.CLICKABLE);
                        }
                    }),
                    a.addAttr('longClickable', (value) => {
                        if (a.parseBoolean(value, false)) {
                            this.setFlags(View.LONG_CLICKABLE, View.LONG_CLICKABLE);
                        }
                    }),
                    a.addAttr('saveEnabled', (value) => {
                        if (a.parseBoolean(value, false)) {
                        }
                    }),
                    a.addAttr('duplicateParentState', (value) => {
                        if (a.parseBoolean(value, false)) {
                            this.setFlags(View.DUPLICATE_PARENT_STATE, View.DUPLICATE_PARENT_STATE);
                        }
                    }),
                    a.addAttr('visibility', (value) => {
                        if (value === 'gone')
                            this.setVisibility(View.GONE);
                        else if (value === 'invisible')
                            this.setVisibility(View.INVISIBLE);
                        else if (value === 'visible')
                            this.setVisibility(View.VISIBLE);
                    }),
                    a.addAttr('scrollbars', (value) => {
                        if (value === 'none') {
                            this.setHorizontalScrollBarEnabled(false);
                            this.setVerticalScrollBarEnabled(false);
                        }
                    }),
                    a.addAttr('isScrollContainer', (value) => {
                        if (a.parseBoolean(value, false)) {
                            this.setScrollContainer(true);
                        }
                    }),
                    a.addAttr('minWidth', (value) => {
                        this.setMinimumWidth(a.parseNumber(value, 0));
                    }, () => {
                        return this.mMinWidth;
                    }),
                    a.addAttr('minHeight', (value) => {
                        this.setMinimumHeight(a.parseNumber(value, 0));
                    }, () => {
                        return this.mMinHeight;
                    }),
                    a.addAttr('onClick', (value) => {
                        if (a.parseBoolean(value))
                            this.setClickable(true);
                    }),
                    a.addAttr('overScrollMode', (value) => {
                        let scrollMode = View[('OVER_SCROLL_' + value).toUpperCase()];
                        if (scrollMode === undefined)
                            scrollMode = View.OVER_SCROLL_IF_CONTENT_SCROLLS;
                        this.setOverScrollMode(scrollMode);
                    }),
                    a.addAttr('layerType', (value) => {
                        if ((value + '').toLowerCase() == 'software') {
                            this.setLayerType(View.LAYER_TYPE_SOFTWARE);
                        }
                        else {
                            this.setLayerType(View.LAYER_TYPE_NONE);
                        }
                    });
                a.addAttr('backgroundUri', (value) => {
                    if (value == null)
                        this.setBackground(null);
                    else {
                        this.setBackground(new NetDrawable(value));
                    }
                }, () => {
                    let d = this.mBackground;
                    if (d instanceof NetDrawable)
                        return d.getImage().src;
                });
                a.addAttr('cornerRadius', (value) => {
                    let [leftTop, topRight, rightBottom, bottomLeft] = a.parsePaddingMarginLTRB(value);
                    this.setCornerRadius(a.parseNumber(leftTop, 0), a.parseNumber(topRight, 0), a.parseNumber(rightBottom, 0), a.parseNumber(bottomLeft, 0));
                }, () => {
                    return this.mCornerRadiusTopLeft + ' ' + this.mCornerRadiusTopRight + ' ' + this.mCornerRadiusBottomRight + ' ' + this.mCornerRadiusBottomLeft;
                });
                a.addAttr('cornerRadiusTopLeft', (value) => {
                    this.setCornerRadiusTopLeft(a.parseNumber(value, this.mCornerRadiusTopLeft));
                }, () => {
                    return this.mCornerRadiusTopLeft;
                });
                a.addAttr('cornerRadiusTopRight', (value) => {
                    this.setCornerRadiusTopRight(a.parseNumber(value, this.mCornerRadiusTopRight));
                }, () => {
                    return this.mCornerRadiusTopRight;
                });
                a.addAttr('cornerRadiusBottomLeft', (value) => {
                    this.setCornerRadiusBottomLeft(a.parseNumber(value, this.mCornerRadiusBottomLeft));
                }, () => {
                    return this.mCornerRadiusBottomLeft;
                });
                a.addAttr('cornerRadiusBottomRight', (value) => {
                    this.setCornerRadiusBottomRight(a.parseNumber(value, this.mCornerRadiusBottomRight));
                }, () => {
                    return this.mCornerRadiusBottomRight;
                });
                a.addAttr('viewShadowColor', (value) => {
                    if (!this.mShadowPaint)
                        this.mShadowPaint = new Paint();
                    this.setShadowView(this.mShadowPaint.shadowRadius, this.mShadowPaint.shadowDx, this.mShadowPaint.shadowDy, a.parseColor(value, this.mShadowPaint.shadowColor));
                }, () => {
                    if (this.mShadowPaint)
                        return this.mShadowPaint.shadowColor;
                });
                a.addAttr('viewShadowDx', (value) => {
                    if (!this.mShadowPaint)
                        this.mShadowPaint = new Paint();
                    let dx = this._attrBinder.parseNumber(value, this.mShadowPaint.shadowDx);
                    this.setShadowView(this.mShadowPaint.shadowRadius, dx, this.mShadowPaint.shadowDy, this.mShadowPaint.shadowColor);
                }, () => {
                    if (this.mShadowPaint)
                        return this.mShadowPaint.shadowDx;
                });
                a.addAttr('viewShadowDy', (value) => {
                    if (!this.mShadowPaint)
                        this.mShadowPaint = new Paint();
                    let dy = a.parseNumber(value, this.mShadowPaint.shadowDy);
                    this.setShadowView(this.mShadowPaint.shadowRadius, this.mShadowPaint.shadowDx, dy, this.mShadowPaint.shadowColor);
                }, () => {
                    if (this.mShadowPaint)
                        return this.mShadowPaint.shadowDy;
                });
                a.addAttr('viewShadowRadius', (value) => {
                    if (!this.mShadowPaint)
                        this.mShadowPaint = new Paint();
                    let radius = this._attrBinder.parseNumber(value, this.mShadowPaint.shadowRadius);
                    this.setShadowView(radius, this.mShadowPaint.shadowDx, this.mShadowPaint.shadowDy, this.mShadowPaint.shadowColor);
                }, () => {
                    if (this.mShadowPaint)
                        return this.mShadowPaint.shadowRadius;
                });
            }
            getContext() {
                if (this.mContext == null && this.mAttachInfo != null) {
                    return this.mAttachInfo.mRootView.mContext;
                }
                return this.mContext;
            }
            getWidth() {
                return this.mRight - this.mLeft;
            }
            getHeight() {
                return this.mBottom - this.mTop;
            }
            getPaddingLeft() {
                return this.mPaddingLeft;
            }
            getPaddingTop() {
                return this.mPaddingTop;
            }
            getPaddingRight() {
                return this.mPaddingRight;
            }
            getPaddingBottom() {
                return this.mPaddingBottom;
            }
            setPaddingLeft(left) {
                if (this.mPaddingLeft != left) {
                    this.mPaddingLeft = left;
                    this.requestLayout();
                }
            }
            setPaddingTop(top) {
                if (this.mPaddingTop != top) {
                    this.mPaddingTop = top;
                    this.requestLayout();
                }
            }
            setPaddingRight(right) {
                if (this.mPaddingRight != right) {
                    this.mPaddingRight = right;
                    this.requestLayout();
                }
            }
            setPaddingBottom(bottom) {
                if (this.mPaddingBottom != bottom) {
                    this.mPaddingBottom = bottom;
                    this.requestLayout();
                }
            }
            setPadding(left, top, right, bottom) {
                let changed = false;
                if (this.mPaddingLeft != left) {
                    changed = true;
                    this.mPaddingLeft = left;
                }
                if (this.mPaddingTop != top) {
                    changed = true;
                    this.mPaddingTop = top;
                }
                if (this.mPaddingRight != right) {
                    changed = true;
                    this.mPaddingRight = right;
                }
                if (this.mPaddingBottom != bottom) {
                    changed = true;
                    this.mPaddingBottom = bottom;
                }
                if (changed) {
                    this.requestLayout();
                }
            }
            _setPaddingWithUnit(left, top, right, bottom) {
                let view = this;
                let dm = Resources.getDisplayMetrics();
                let width = view.getWidth();
                let height = view.getHeight();
                let padLeft = TypedValue.complexToDimensionPixelSize(left, width, dm);
                let padTop = TypedValue.complexToDimensionPixelSize(top, height, dm);
                let padRight = TypedValue.complexToDimensionPixelSize(right, width, dm);
                let padBottom = TypedValue.complexToDimensionPixelSize(bottom, height, dm);
                view.setPadding(padLeft, padTop, padRight, padBottom);
                let unit = TypedValue.COMPLEX_UNIT_FRACTION;
                if ((typeof left === 'string' && left.endsWith(unit)) || (typeof top === 'string' && top.endsWith(unit))
                    || (typeof right === 'string' && right.endsWith(unit)) || (typeof bottom === 'string' && bottom.endsWith(unit))) {
                    view.post({
                        run: () => {
                            let width = view.getWidth();
                            let height = view.getHeight();
                            let padLeftN = TypedValue.complexToDimensionPixelSize(left, width, dm);
                            let padTopN = TypedValue.complexToDimensionPixelSize(top, height, dm);
                            let padRightN = TypedValue.complexToDimensionPixelSize(right, width, dm);
                            let padBottomN = TypedValue.complexToDimensionPixelSize(bottom, height, dm);
                            view.setPadding(padLeftN, padTopN, padRightN, padBottomN);
                        }
                    });
                }
            }
            resolvePadding() {
            }
            setScrollX(value) {
                this.scrollTo(value, this.mScrollY);
            }
            setScrollY(value) {
                this.scrollTo(this.mScrollX, value);
            }
            getScrollX() {
                return this.mScrollX;
            }
            getScrollY() {
                return this.mScrollY;
            }
            offsetTopAndBottom(offset) {
                if (offset != 0) {
                    this.updateMatrix();
                    const matrixIsIdentity = this.mTransformationInfo == null || this.mTransformationInfo.mMatrixIsIdentity;
                    if (matrixIsIdentity) {
                        const p = this.mParent;
                        if (p != null && this.mAttachInfo != null) {
                            const r = this.mAttachInfo.mTmpInvalRect;
                            let minTop;
                            let maxBottom;
                            let yLoc;
                            if (offset < 0) {
                                minTop = this.mTop + offset;
                                maxBottom = this.mBottom;
                                yLoc = offset;
                            }
                            else {
                                minTop = this.mTop;
                                maxBottom = this.mBottom + offset;
                                yLoc = 0;
                            }
                            r.set(0, yLoc, this.mRight - this.mLeft, maxBottom - minTop);
                            p.invalidateChild(this, r);
                        }
                    }
                    else {
                        this.invalidateViewProperty(false, false);
                    }
                    this.mTop += offset;
                    this.mBottom += offset;
                    if (!matrixIsIdentity) {
                        this.invalidateViewProperty(false, true);
                    }
                    this.invalidateParentIfNeeded();
                }
            }
            offsetLeftAndRight(offset) {
                if (offset != 0) {
                    this.updateMatrix();
                    const matrixIsIdentity = this.mTransformationInfo == null || this.mTransformationInfo.mMatrixIsIdentity;
                    if (matrixIsIdentity) {
                        const p = this.mParent;
                        if (p != null && this.mAttachInfo != null) {
                            const r = this.mAttachInfo.mTmpInvalRect;
                            let minLeft;
                            let maxRight;
                            if (offset < 0) {
                                minLeft = this.mLeft + offset;
                                maxRight = this.mRight;
                            }
                            else {
                                minLeft = this.mLeft;
                                maxRight = this.mRight + offset;
                            }
                            r.set(0, 0, maxRight - minLeft, this.mBottom - this.mTop);
                            p.invalidateChild(this, r);
                        }
                    }
                    else {
                        this.invalidateViewProperty(false, false);
                    }
                    this.mLeft += offset;
                    this.mRight += offset;
                    if (!matrixIsIdentity) {
                        this.invalidateViewProperty(false, true);
                    }
                    this.invalidateParentIfNeeded();
                }
            }
            getMatrix() {
                if (this.mTransformationInfo != null) {
                    this.updateMatrix();
                    return this.mTransformationInfo.mMatrix;
                }
                return Matrix.IDENTITY_MATRIX;
            }
            hasIdentityMatrix() {
                if (this.mTransformationInfo != null) {
                    this.updateMatrix();
                    return this.mTransformationInfo.mMatrixIsIdentity;
                }
                return true;
            }
            ensureTransformationInfo() {
                if (this.mTransformationInfo == null) {
                    this.mTransformationInfo = new View.TransformationInfo();
                }
            }
            updateMatrix() {
                const info = this.mTransformationInfo;
                if (info == null) {
                    return;
                }
                if (info.mMatrixDirty) {
                    if ((this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
                        if ((this.mRight - this.mLeft) != info.mPrevWidth || (this.mBottom - this.mTop) != info.mPrevHeight) {
                            info.mPrevWidth = this.mRight - this.mLeft;
                            info.mPrevHeight = this.mBottom - this.mTop;
                            info.mPivotX = info.mPrevWidth / 2;
                            info.mPivotY = info.mPrevHeight / 2;
                        }
                    }
                    info.mMatrix.reset();
                    info.mMatrix.setTranslate(info.mTranslationX, info.mTranslationY);
                    info.mMatrix.preRotate(info.mRotation, info.mPivotX, info.mPivotY);
                    info.mMatrix.preScale(info.mScaleX, info.mScaleY, info.mPivotX, info.mPivotY);
                    info.mMatrixDirty = false;
                    info.mMatrixIsIdentity = info.mMatrix.isIdentity();
                    info.mInverseMatrixDirty = true;
                }
            }
            getRotation() {
                return this.mTransformationInfo != null ? this.mTransformationInfo.mRotation : 0;
            }
            setRotation(rotation) {
                this.ensureTransformationInfo();
                const info = this.mTransformationInfo;
                if (info.mRotation != rotation) {
                    this.invalidateViewProperty(true, false);
                    info.mRotation = rotation;
                    info.mMatrixDirty = true;
                    this.invalidateViewProperty(false, true);
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getScaleX() {
                return this.mTransformationInfo != null ? this.mTransformationInfo.mScaleX : 1;
            }
            setScaleX(scaleX) {
                this.ensureTransformationInfo();
                const info = this.mTransformationInfo;
                if (info.mScaleX != scaleX) {
                    this.invalidateViewProperty(true, false);
                    info.mScaleX = scaleX;
                    info.mMatrixDirty = true;
                    this.invalidateViewProperty(false, true);
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getScaleY() {
                return this.mTransformationInfo != null ? this.mTransformationInfo.mScaleY : 1;
            }
            setScaleY(scaleY) {
                this.ensureTransformationInfo();
                const info = this.mTransformationInfo;
                if (info.mScaleY != scaleY) {
                    this.invalidateViewProperty(true, false);
                    info.mScaleY = scaleY;
                    info.mMatrixDirty = true;
                    this.invalidateViewProperty(false, true);
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getPivotX() {
                return this.mTransformationInfo != null ? this.mTransformationInfo.mPivotX : 0;
            }
            setPivotX(pivotX) {
                this.ensureTransformationInfo();
                const info = this.mTransformationInfo;
                let pivotSet = (this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == View.PFLAG_PIVOT_EXPLICITLY_SET;
                if (info.mPivotX != pivotX || !pivotSet) {
                    this.mPrivateFlags |= View.PFLAG_PIVOT_EXPLICITLY_SET;
                    this.invalidateViewProperty(true, false);
                    info.mPivotX = pivotX;
                    info.mMatrixDirty = true;
                    this.invalidateViewProperty(false, true);
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getPivotY() {
                return this.mTransformationInfo != null ? this.mTransformationInfo.mPivotY : 0;
            }
            setPivotY(pivotY) {
                this.ensureTransformationInfo();
                const info = this.mTransformationInfo;
                let pivotSet = (this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == View.PFLAG_PIVOT_EXPLICITLY_SET;
                if (info.mPivotY != pivotY || !pivotSet) {
                    this.mPrivateFlags |= View.PFLAG_PIVOT_EXPLICITLY_SET;
                    this.invalidateViewProperty(true, false);
                    info.mPivotY = pivotY;
                    info.mMatrixDirty = true;
                    this.invalidateViewProperty(false, true);
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getAlpha() {
                return this.mTransformationInfo != null ? this.mTransformationInfo.mAlpha : 1;
            }
            hasOverlappingRendering() {
                return true;
            }
            setAlpha(alpha) {
                this.ensureTransformationInfo();
                if (this.mTransformationInfo.mAlpha != alpha) {
                    this.mTransformationInfo.mAlpha = alpha;
                    if (this.onSetAlpha(Math.floor((alpha * 255)))) {
                        this.mPrivateFlags |= View.PFLAG_ALPHA_SET;
                        this.invalidateParentCaches();
                        this.invalidate(true);
                    }
                    else {
                        this.mPrivateFlags &= ~View.PFLAG_ALPHA_SET;
                        this.invalidateViewProperty(true, false);
                    }
                }
            }
            setAlphaNoInvalidation(alpha) {
                this.ensureTransformationInfo();
                if (this.mTransformationInfo.mAlpha != alpha) {
                    this.mTransformationInfo.mAlpha = alpha;
                    let subclassHandlesAlpha = this.onSetAlpha(Math.floor((alpha * 255)));
                    if (subclassHandlesAlpha) {
                        this.mPrivateFlags |= View.PFLAG_ALPHA_SET;
                        return true;
                    }
                    else {
                        this.mPrivateFlags &= ~View.PFLAG_ALPHA_SET;
                    }
                }
                return false;
            }
            setTransitionAlpha(alpha) {
                this.ensureTransformationInfo();
                if (this.mTransformationInfo.mTransitionAlpha != alpha) {
                    this.mTransformationInfo.mTransitionAlpha = alpha;
                    this.mPrivateFlags &= ~View.PFLAG_ALPHA_SET;
                    this.invalidateViewProperty(true, false);
                }
            }
            getFinalAlpha() {
                if (this.mTransformationInfo != null) {
                    return this.mTransformationInfo.mAlpha * this.mTransformationInfo.mTransitionAlpha;
                }
                return 1;
            }
            getTransitionAlpha() {
                return this.mTransformationInfo != null ? this.mTransformationInfo.mTransitionAlpha : 1;
            }
            getTop() {
                return this.mTop;
            }
            setTop(top) {
                if (top != this.mTop) {
                    this.updateMatrix();
                    const matrixIsIdentity = this.mTransformationInfo == null || this.mTransformationInfo.mMatrixIsIdentity;
                    if (matrixIsIdentity) {
                        if (this.mAttachInfo != null) {
                            let minTop;
                            let yLoc;
                            if (top < this.mTop) {
                                minTop = top;
                                yLoc = top - this.mTop;
                            }
                            else {
                                minTop = this.mTop;
                                yLoc = 0;
                            }
                            this.invalidate(0, yLoc, this.mRight - this.mLeft, this.mBottom - minTop);
                        }
                    }
                    else {
                        this.invalidate(true);
                    }
                    let width = this.mRight - this.mLeft;
                    let oldHeight = this.mBottom - this.mTop;
                    this.mTop = top;
                    this.sizeChange(width, this.mBottom - this.mTop, width, oldHeight);
                    if (!matrixIsIdentity) {
                        if ((this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
                            this.mTransformationInfo.mMatrixDirty = true;
                        }
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(true);
                    }
                    this.mBackgroundSizeChanged = true;
                    this.invalidateParentIfNeeded();
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getBottom() {
                return this.mBottom;
            }
            isDirty() {
                return (this.mPrivateFlags & View.PFLAG_DIRTY_MASK) != 0;
            }
            setBottom(bottom) {
                if (bottom != this.mBottom) {
                    this.updateMatrix();
                    const matrixIsIdentity = this.mTransformationInfo == null || this.mTransformationInfo.mMatrixIsIdentity;
                    if (matrixIsIdentity) {
                        if (this.mAttachInfo != null) {
                            let maxBottom;
                            if (bottom < this.mBottom) {
                                maxBottom = this.mBottom;
                            }
                            else {
                                maxBottom = bottom;
                            }
                            this.invalidate(0, 0, this.mRight - this.mLeft, maxBottom - this.mTop);
                        }
                    }
                    else {
                        this.invalidate(true);
                    }
                    let width = this.mRight - this.mLeft;
                    let oldHeight = this.mBottom - this.mTop;
                    this.mBottom = bottom;
                    this.sizeChange(width, this.mBottom - this.mTop, width, oldHeight);
                    if (!matrixIsIdentity) {
                        if ((this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
                            this.mTransformationInfo.mMatrixDirty = true;
                        }
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(true);
                    }
                    this.mBackgroundSizeChanged = true;
                    this.invalidateParentIfNeeded();
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getLeft() {
                return this.mLeft;
            }
            setLeft(left) {
                if (left != this.mLeft) {
                    this.updateMatrix();
                    const matrixIsIdentity = this.mTransformationInfo == null || this.mTransformationInfo.mMatrixIsIdentity;
                    if (matrixIsIdentity) {
                        if (this.mAttachInfo != null) {
                            let minLeft;
                            let xLoc;
                            if (left < this.mLeft) {
                                minLeft = left;
                                xLoc = left - this.mLeft;
                            }
                            else {
                                minLeft = this.mLeft;
                                xLoc = 0;
                            }
                            this.invalidate(xLoc, 0, this.mRight - minLeft, this.mBottom - this.mTop);
                        }
                    }
                    else {
                        this.invalidate(true);
                    }
                    let oldWidth = this.mRight - this.mLeft;
                    let height = this.mBottom - this.mTop;
                    this.mLeft = left;
                    this.sizeChange(this.mRight - this.mLeft, height, oldWidth, height);
                    if (!matrixIsIdentity) {
                        if ((this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
                            this.mTransformationInfo.mMatrixDirty = true;
                        }
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(true);
                    }
                    this.mBackgroundSizeChanged = true;
                    this.invalidateParentIfNeeded();
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getRight() {
                return this.mRight;
            }
            setRight(right) {
                if (right != this.mRight) {
                    this.updateMatrix();
                    const matrixIsIdentity = this.mTransformationInfo == null || this.mTransformationInfo.mMatrixIsIdentity;
                    if (matrixIsIdentity) {
                        if (this.mAttachInfo != null) {
                            let maxRight;
                            if (right < this.mRight) {
                                maxRight = this.mRight;
                            }
                            else {
                                maxRight = right;
                            }
                            this.invalidate(0, 0, maxRight - this.mLeft, this.mBottom - this.mTop);
                        }
                    }
                    else {
                        this.invalidate(true);
                    }
                    let oldWidth = this.mRight - this.mLeft;
                    let height = this.mBottom - this.mTop;
                    this.mRight = right;
                    this.sizeChange(this.mRight - this.mLeft, height, oldWidth, height);
                    if (!matrixIsIdentity) {
                        if ((this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
                            this.mTransformationInfo.mMatrixDirty = true;
                        }
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(true);
                    }
                    this.mBackgroundSizeChanged = true;
                    this.invalidateParentIfNeeded();
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getX() {
                return this.mLeft + (this.mTransformationInfo != null ? this.mTransformationInfo.mTranslationX : 0);
            }
            setX(x) {
                this.setTranslationX(x - this.mLeft);
            }
            getY() {
                return this.mTop + (this.mTransformationInfo != null ? this.mTransformationInfo.mTranslationY : 0);
            }
            setY(y) {
                this.setTranslationY(y - this.mTop);
            }
            getTranslationX() {
                return this.mTransformationInfo != null ? this.mTransformationInfo.mTranslationX : 0;
            }
            setTranslationX(translationX) {
                this.ensureTransformationInfo();
                const info = this.mTransformationInfo;
                if (info.mTranslationX != translationX) {
                    this.invalidateViewProperty(true, false);
                    info.mTranslationX = translationX;
                    info.mMatrixDirty = true;
                    this.invalidateViewProperty(false, true);
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            getTranslationY() {
                return this.mTransformationInfo != null ? this.mTransformationInfo.mTranslationY : 0;
            }
            setTranslationY(translationY) {
                this.ensureTransformationInfo();
                const info = this.mTransformationInfo;
                if (info.mTranslationY != translationY) {
                    this.invalidateViewProperty(true, false);
                    info.mTranslationY = translationY;
                    info.mMatrixDirty = true;
                    this.invalidateViewProperty(false, true);
                    if ((this.mPrivateFlags2 & View.PFLAG2_VIEW_QUICK_REJECTED) == View.PFLAG2_VIEW_QUICK_REJECTED) {
                        this.invalidateParentIfNeeded();
                    }
                }
            }
            transformRect(rect) {
                if (!this.getMatrix().isIdentity()) {
                    let boundingRect = this.mAttachInfo.mTmpTransformRect;
                    boundingRect.set(rect);
                    this.getMatrix().mapRect(boundingRect);
                    rect.set(boundingRect);
                }
            }
            pointInView(localX, localY, slop = 0) {
                return localX >= -slop && localY >= -slop && localX < ((this.mRight - this.mLeft) + slop) &&
                    localY < ((this.mBottom - this.mTop) + slop);
            }
            getHandler() {
                let attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    return attachInfo.mHandler;
                }
                return null;
            }
            getViewRootImpl() {
                if (this.mAttachInfo != null) {
                    return this.mAttachInfo.mViewRootImpl;
                }
                if (this.mContext != null) {
                    return this.mContext.androidUI._viewRootImpl;
                }
                return null;
            }
            post(action) {
                let attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    return attachInfo.mHandler.post(action);
                }
                view_2.ViewRootImpl.getRunQueue().post(action);
                return true;
            }
            postDelayed(action, delayMillis) {
                let attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    return attachInfo.mHandler.postDelayed(action, delayMillis);
                }
                view_2.ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);
                return true;
            }
            postOnAnimation(action) {
                return this.post(action);
            }
            postOnAnimationDelayed(action, delayMillis) {
                return this.postDelayed(action, delayMillis);
            }
            removeCallbacks(action) {
                if (action != null) {
                    let attachInfo = this.mAttachInfo;
                    if (attachInfo != null) {
                        attachInfo.mHandler.removeCallbacks(action);
                    }
                    else {
                        view_2.ViewRootImpl.getRunQueue().removeCallbacks(action);
                    }
                }
                return true;
            }
            getParent() {
                return this.mParent;
            }
            setFlags(flags, mask) {
                let old = this.mViewFlags;
                this.mViewFlags = (this.mViewFlags & ~mask) | (flags & mask);
                let changed = this.mViewFlags ^ old;
                if (changed == 0) {
                    return;
                }
                let privateFlags = this.mPrivateFlags;
                if (((changed & View.FOCUSABLE_MASK) != 0) &&
                    ((privateFlags & View.PFLAG_HAS_BOUNDS) != 0)) {
                    if (((old & View.FOCUSABLE_MASK) == View.FOCUSABLE)
                        && ((privateFlags & View.PFLAG_FOCUSED) != 0)) {
                        this.clearFocus();
                    }
                    else if (((old & View.FOCUSABLE_MASK) == View.NOT_FOCUSABLE)
                        && ((privateFlags & View.PFLAG_FOCUSED) == 0)) {
                        if (this.mParent != null)
                            this.mParent.focusableViewAvailable(this);
                    }
                }
                const newVisibility = flags & View.VISIBILITY_MASK;
                if (newVisibility == View.VISIBLE) {
                    if ((changed & View.VISIBILITY_MASK) != 0) {
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(true);
                        if ((this.mParent != null) && (this.mBottom > this.mTop) && (this.mRight > this.mLeft)) {
                            this.mParent.focusableViewAvailable(this);
                        }
                    }
                }
                if ((changed & View.GONE) != 0) {
                    this.requestLayout();
                    if (((this.mViewFlags & View.VISIBILITY_MASK) == View.GONE)) {
                        if (this.hasFocus())
                            this.clearFocus();
                        this.destroyDrawingCache();
                        if (this.mParent instanceof View) {
                            this.mParent.invalidate(true);
                        }
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                    }
                }
                if ((changed & View.INVISIBLE) != 0) {
                    this.mPrivateFlags |= View.PFLAG_DRAWN;
                    if (((this.mViewFlags & View.VISIBILITY_MASK) == View.INVISIBLE)) {
                        if (this.getRootView() != this) {
                            if (this.hasFocus())
                                this.clearFocus();
                        }
                    }
                }
                if ((changed & View.VISIBILITY_MASK) != 0) {
                    if (newVisibility != View.VISIBLE) {
                        this.cleanupDraw();
                    }
                    if (this.mParent instanceof view_2.ViewGroup) {
                        this.mParent.onChildVisibilityChanged(this, (changed & View.VISIBILITY_MASK), newVisibility);
                        this.mParent.invalidate(true);
                    }
                    else if (this.mParent != null) {
                        this.mParent.invalidateChild(this, null);
                    }
                    this.dispatchVisibilityChanged(this, newVisibility);
                    this.syncVisibleToElement();
                }
                if ((changed & View.WILL_NOT_CACHE_DRAWING) != 0) {
                    this.destroyDrawingCache();
                }
                if ((changed & View.DRAWING_CACHE_ENABLED) != 0) {
                    this.destroyDrawingCache();
                    this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                    this.invalidateParentCaches();
                }
                if ((changed & View.DRAW_MASK) != 0) {
                    if ((this.mViewFlags & View.WILL_NOT_DRAW) != 0) {
                        if (this.mBackground != null) {
                            this.mPrivateFlags &= ~View.PFLAG_SKIP_DRAW;
                            this.mPrivateFlags |= View.PFLAG_ONLY_DRAWS_BACKGROUND;
                        }
                        else {
                            this.mPrivateFlags |= View.PFLAG_SKIP_DRAW;
                        }
                    }
                    else {
                        this.mPrivateFlags &= ~View.PFLAG_SKIP_DRAW;
                    }
                    this.requestLayout();
                    this.invalidate(true);
                }
            }
            bringToFront() {
                if (this.mParent != null) {
                    this.mParent.bringChildToFront(this);
                }
            }
            onScrollChanged(l, t, oldl, oldt) {
                this.mBackgroundSizeChanged = true;
                let rootImpl = this.getViewRootImpl();
                if (rootImpl != null) {
                    rootImpl.mViewScrollChanged = true;
                }
            }
            onSizeChanged(w, h, oldw, oldh) {
            }
            getTouchables() {
                let result = new ArrayList();
                this.addTouchables(result);
                return result;
            }
            addTouchables(views) {
                const viewFlags = this.mViewFlags;
                if (((viewFlags & View.CLICKABLE) == View.CLICKABLE || (viewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE)
                    && (viewFlags & View.ENABLED_MASK) == View.ENABLED) {
                    views.add(this);
                }
            }
            requestRectangleOnScreen(rectangle, immediate = false) {
                if (this.mParent == null) {
                    return false;
                }
                let child = this;
                let position = (this.mAttachInfo != null) ? this.mAttachInfo.mTmpTransformRect : new RectF();
                position.set(rectangle);
                let parent = this.mParent;
                let scrolled = false;
                while (parent != null) {
                    rectangle.set(Math.floor(position.left), Math.floor(position.top), Math.floor(position.right), Math.floor(position.bottom));
                    scrolled = parent.requestChildRectangleOnScreen(child, rectangle, immediate) || scrolled;
                    if (!child.hasIdentityMatrix()) {
                        child.getMatrix().mapRect(position);
                    }
                    position.offset(child.mLeft, child.mTop);
                    if (!(parent instanceof View)) {
                        break;
                    }
                    let parentView = parent;
                    position.offset(-parentView.getScrollX(), -parentView.getScrollY());
                    child = parentView;
                    parent = child.getParent();
                }
                return scrolled;
            }
            onFocusLost() {
                this.resetPressedState();
            }
            resetPressedState() {
                if ((this.mViewFlags & View.ENABLED_MASK) == View.DISABLED) {
                    return;
                }
                if (this.isPressed()) {
                    this.setPressed(false);
                    if (!this.mHasPerformedLongPress) {
                        this.removeLongPressCallback();
                    }
                }
            }
            isFocused() {
                return (this.mPrivateFlags & View.PFLAG_FOCUSED) != 0;
            }
            findFocus() {
                return (this.mPrivateFlags & View.PFLAG_FOCUSED) != 0 ? this : null;
            }
            getNextFocusLeftId() {
                return this.mNextFocusLeftId;
            }
            setNextFocusLeftId(nextFocusLeftId) {
                this.mNextFocusLeftId = nextFocusLeftId;
            }
            getNextFocusRightId() {
                return this.mNextFocusRightId;
            }
            setNextFocusRightId(nextFocusRightId) {
                this.mNextFocusRightId = nextFocusRightId;
            }
            getNextFocusUpId() {
                return this.mNextFocusUpId;
            }
            setNextFocusUpId(nextFocusUpId) {
                this.mNextFocusUpId = nextFocusUpId;
            }
            getNextFocusDownId() {
                return this.mNextFocusDownId;
            }
            setNextFocusDownId(nextFocusDownId) {
                this.mNextFocusDownId = nextFocusDownId;
            }
            getNextFocusForwardId() {
                return this.mNextFocusForwardId;
            }
            setNextFocusForwardId(nextFocusForwardId) {
                this.mNextFocusForwardId = nextFocusForwardId;
            }
            setFocusable(focusable) {
                if (!focusable) {
                    this.setFlags(0, View.FOCUSABLE_IN_TOUCH_MODE);
                }
                this.setFlags(focusable ? View.FOCUSABLE : View.NOT_FOCUSABLE, View.FOCUSABLE_MASK);
            }
            isFocusable() {
                return View.FOCUSABLE == (this.mViewFlags & View.FOCUSABLE_MASK);
            }
            setFocusableInTouchMode(focusableInTouchMode) {
                this.setFlags(focusableInTouchMode ? View.FOCUSABLE_IN_TOUCH_MODE : 0, View.FOCUSABLE_IN_TOUCH_MODE);
                if (focusableInTouchMode) {
                    this.setFlags(View.FOCUSABLE, View.FOCUSABLE_MASK);
                }
            }
            isFocusableInTouchMode() {
                return View.FOCUSABLE_IN_TOUCH_MODE == (this.mViewFlags & View.FOCUSABLE_IN_TOUCH_MODE);
            }
            hasFocusable() {
                return (this.mViewFlags & View.VISIBILITY_MASK) == View.VISIBLE && this.isFocusable();
            }
            clearFocus() {
                if (View.DBG) {
                    System.out.println(this + " clearFocus()");
                }
                this.clearFocusInternal(true, true);
            }
            clearFocusInternal(propagate, refocus) {
                if ((this.mPrivateFlags & View.PFLAG_FOCUSED) != 0) {
                    this.mPrivateFlags &= ~View.PFLAG_FOCUSED;
                    if (propagate && this.mParent != null) {
                        this.mParent.clearChildFocus(this);
                    }
                    this.onFocusChanged(false, 0, null);
                    this.refreshDrawableState();
                    if (propagate && (!refocus || !this.rootViewRequestFocus())) {
                        this.notifyGlobalFocusCleared(this);
                    }
                }
            }
            notifyGlobalFocusCleared(oldFocus) {
            }
            rootViewRequestFocus() {
                const root = this.getRootView();
                return root != null && root.requestFocus();
            }
            unFocus() {
                if (View.DBG) {
                    System.out.println(this + " unFocus()");
                }
                this.clearFocusInternal(false, false);
            }
            hasFocus() {
                return (this.mPrivateFlags & View.PFLAG_FOCUSED) != 0;
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                if (!gainFocus) {
                    if (this.isPressed()) {
                        this.setPressed(false);
                    }
                    this.onFocusLost();
                }
                this.invalidate(true);
                let li = this.mListenerInfo;
                if (li != null && li.mOnFocusChangeListener != null) {
                    li.mOnFocusChangeListener.onFocusChange(this, gainFocus);
                }
                if (this.mAttachInfo != null) {
                    this.mAttachInfo.mKeyDispatchState.reset(this);
                }
            }
            focusSearch(direction) {
                if (this.mParent != null) {
                    return this.mParent.focusSearch(this, direction);
                }
                else {
                    return null;
                }
            }
            dispatchUnhandledMove(focused, direction) {
                return false;
            }
            findUserSetNextFocus(root, direction) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        if (!this.mNextFocusLeftId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusLeftId);
                    case View.FOCUS_RIGHT:
                        if (!this.mNextFocusRightId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusRightId);
                    case View.FOCUS_UP:
                        if (!this.mNextFocusUpId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusUpId);
                    case View.FOCUS_DOWN:
                        if (!this.mNextFocusDownId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusDownId);
                    case View.FOCUS_FORWARD:
                        if (!this.mNextFocusForwardId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusForwardId);
                    case View.FOCUS_BACKWARD: {
                        if (!this.mID)
                            return null;
                        let id = this.mID;
                        return root.findViewByPredicateInsideOut(this, {
                            apply(t) {
                                return t.mNextFocusForwardId == id;
                            }
                        });
                    }
                }
                return null;
            }
            findViewInsideOutShouldExist(root, id) {
                if (this.mMatchIdPredicate == null) {
                    this.mMatchIdPredicate = new MatchIdPredicate();
                }
                this.mMatchIdPredicate.mId = id;
                let result = root.findViewByPredicateInsideOut(this, this.mMatchIdPredicate);
                if (result == null) {
                    Log.w(View.VIEW_LOG_TAG, "couldn't find view with id " + id);
                }
                return result;
            }
            getFocusables(direction) {
                let result = new ArrayList(24);
                this.addFocusables(result, direction);
                return result;
            }
            addFocusables(views, direction, focusableMode = View.FOCUSABLES_TOUCH_MODE) {
                if (views == null) {
                    return;
                }
                if (!this.isFocusable()) {
                    return;
                }
                if ((focusableMode & View.FOCUSABLES_TOUCH_MODE) == View.FOCUSABLES_TOUCH_MODE
                    && this.isInTouchMode() && !this.isFocusableInTouchMode()) {
                    return;
                }
                views.add(this);
            }
            setOnFocusChangeListener(l) {
                this.getListenerInfo().mOnFocusChangeListener = l;
            }
            getOnFocusChangeListener() {
                let li = this.mListenerInfo;
                return li != null ? li.mOnFocusChangeListener : null;
            }
            requestFocus(direction = View.FOCUS_DOWN, previouslyFocusedRect = null) {
                return this.requestFocusNoSearch(direction, previouslyFocusedRect);
            }
            requestFocusNoSearch(direction, previouslyFocusedRect) {
                if ((this.mViewFlags & View.FOCUSABLE_MASK) != View.FOCUSABLE ||
                    (this.mViewFlags & View.VISIBILITY_MASK) != View.VISIBLE) {
                    return false;
                }
                if (this.isInTouchMode() &&
                    (View.FOCUSABLE_IN_TOUCH_MODE != (this.mViewFlags & View.FOCUSABLE_IN_TOUCH_MODE))) {
                    return false;
                }
                if (this.hasAncestorThatBlocksDescendantFocus()) {
                    return false;
                }
                this.handleFocusGainInternal(direction, previouslyFocusedRect);
                return true;
            }
            requestFocusFromTouch() {
                if (this.isInTouchMode()) {
                    let viewRoot = this.getViewRootImpl();
                    if (viewRoot != null) {
                        viewRoot.ensureTouchMode(false);
                    }
                }
                return this.requestFocus(View.FOCUS_DOWN);
            }
            hasAncestorThatBlocksDescendantFocus() {
                let ancestor = this.mParent;
                while (ancestor instanceof view_2.ViewGroup) {
                    const vgAncestor = ancestor;
                    if (vgAncestor.getDescendantFocusability() == view_2.ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                        return true;
                    }
                    else {
                        ancestor = vgAncestor.getParent();
                    }
                }
                return false;
            }
            handleFocusGainInternal(direction, previouslyFocusedRect) {
                if (View.DBG) {
                    System.out.println(this + " requestFocus()");
                }
                if ((this.mPrivateFlags & View.PFLAG_FOCUSED) == 0) {
                    this.mPrivateFlags |= View.PFLAG_FOCUSED;
                    let oldFocus = (this.mAttachInfo != null) ? this.getRootView().findFocus() : null;
                    if (this.mParent != null) {
                        this.mParent.requestChildFocus(this, this);
                    }
                    this.onFocusChanged(true, direction, previouslyFocusedRect);
                    this.refreshDrawableState();
                }
            }
            hasTransientState() {
                return (this.mPrivateFlags2 & View.PFLAG2_HAS_TRANSIENT_STATE) == View.PFLAG2_HAS_TRANSIENT_STATE;
            }
            setHasTransientState(hasTransientState) {
                this.mTransientStateCount = hasTransientState ? this.mTransientStateCount + 1 :
                    this.mTransientStateCount - 1;
                if (this.mTransientStateCount < 0) {
                    this.mTransientStateCount = 0;
                    Log.e(View.VIEW_LOG_TAG, "hasTransientState decremented below 0: " +
                        "unmatched pair of setHasTransientState calls");
                }
                else if ((hasTransientState && this.mTransientStateCount == 1) ||
                    (!hasTransientState && this.mTransientStateCount == 0)) {
                    this.mPrivateFlags2 = (this.mPrivateFlags2 & ~View.PFLAG2_HAS_TRANSIENT_STATE) |
                        (hasTransientState ? View.PFLAG2_HAS_TRANSIENT_STATE : 0);
                    if (this.mParent != null) {
                        this.mParent.childHasTransientStateChanged(this, hasTransientState);
                    }
                }
            }
            isScrollContainer() {
                return (this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER_ADDED) != 0;
            }
            setScrollContainer(isScrollContainer) {
                if (isScrollContainer) {
                    if (this.mAttachInfo != null && (this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER_ADDED) == 0) {
                        this.mAttachInfo.mScrollContainers.add(this);
                        this.mPrivateFlags |= View.PFLAG_SCROLL_CONTAINER_ADDED;
                    }
                    this.mPrivateFlags |= View.PFLAG_SCROLL_CONTAINER;
                }
                else {
                    if ((this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER_ADDED) != 0) {
                        this.mAttachInfo.mScrollContainers.delete(this);
                    }
                    this.mPrivateFlags &= ~(View.PFLAG_SCROLL_CONTAINER | View.PFLAG_SCROLL_CONTAINER_ADDED);
                }
            }
            isInTouchMode() {
                if (this.getViewRootImpl() != null) {
                    return this.getViewRootImpl().mInTouchMode;
                }
                else {
                    return false;
                }
            }
            isShown() {
                let current = this;
                do {
                    if ((current.mViewFlags & View.VISIBILITY_MASK) != View.VISIBLE) {
                        return false;
                    }
                    let parent = current.mParent;
                    if (parent == null) {
                        return false;
                    }
                    if (!(parent instanceof View)) {
                        return true;
                    }
                    current = parent;
                } while (current != null);
                return false;
            }
            getVisibility() {
                return this.mViewFlags & View.VISIBILITY_MASK;
            }
            setVisibility(visibility) {
                this.setFlags(visibility, View.VISIBILITY_MASK);
                if (this.mBackground != null)
                    this.mBackground.setVisible(visibility == View.VISIBLE, false);
            }
            dispatchVisibilityChanged(changedView, visibility) {
                this.onVisibilityChanged(changedView, visibility);
            }
            onVisibilityChanged(changedView, visibility) {
                if (visibility == View.VISIBLE) {
                    if (this.mAttachInfo != null) {
                        this.initialAwakenScrollBars();
                    }
                    else {
                        this.mPrivateFlags |= View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH;
                    }
                }
            }
            dispatchDisplayHint(hint) {
                this.onDisplayHint(hint);
            }
            onDisplayHint(hint) {
            }
            dispatchWindowVisibilityChanged(visibility) {
                this.onWindowVisibilityChanged(visibility);
            }
            onWindowVisibilityChanged(visibility) {
                if (visibility == View.VISIBLE) {
                    this.initialAwakenScrollBars();
                }
            }
            getWindowVisibility() {
                return this.mAttachInfo != null ? this.mAttachInfo.mWindowVisibility : View.GONE;
            }
            isEnabled() {
                return (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED;
            }
            setEnabled(enabled) {
                if (enabled == this.isEnabled())
                    return;
                this.setFlags(enabled ? View.ENABLED : View.DISABLED, View.ENABLED_MASK);
                this.refreshDrawableState();
                this.invalidate(true);
            }
            dispatchGenericMotionEvent(event) {
                if (event.isPointerEvent()) {
                    const action = event.getAction();
                    if (action == view_2.MotionEvent.ACTION_HOVER_ENTER
                        || action == view_2.MotionEvent.ACTION_HOVER_MOVE
                        || action == view_2.MotionEvent.ACTION_HOVER_EXIT) {
                    }
                    else if (this.dispatchGenericPointerEvent(event)) {
                        return true;
                    }
                }
                if (this.dispatchGenericMotionEventInternal(event)) {
                    return true;
                }
                return false;
            }
            dispatchGenericMotionEventInternal(event) {
                let li = this.mListenerInfo;
                if (li != null && li.mOnGenericMotionListener != null
                    && (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED
                    && li.mOnGenericMotionListener.onGenericMotion(this, event)) {
                    return true;
                }
                if (this.onGenericMotionEvent(event)) {
                    return true;
                }
                return false;
            }
            onGenericMotionEvent(event) {
                return false;
            }
            dispatchGenericPointerEvent(event) {
                return false;
            }
            dispatchKeyEvent(event) {
                let li = this.mListenerInfo;
                if (li != null && li.mOnKeyListener != null && (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED
                    && li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
                    return true;
                }
                if (event.dispatch(this, this.mAttachInfo != null
                    ? this.mAttachInfo.mKeyDispatchState : null, this)) {
                    return true;
                }
                return false;
            }
            setOnKeyListener(l) {
                this.getListenerInfo().mOnKeyListener = l;
            }
            getKeyDispatcherState() {
                return this.mAttachInfo != null ? this.mAttachInfo.mKeyDispatchState : null;
            }
            onKeyDown(keyCode, event) {
                let result = false;
                if (KeyEvent.isConfirmKey(keyCode)) {
                    if ((this.mViewFlags & View.ENABLED_MASK) == View.DISABLED) {
                        return true;
                    }
                    if (((this.mViewFlags & View.CLICKABLE) == View.CLICKABLE ||
                        (this.mViewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE) &&
                        (event.getRepeatCount() == 0)) {
                        this.setPressed(true);
                        this.checkForLongClick(0);
                        return true;
                    }
                }
                return result;
            }
            onKeyLongPress(keyCode, event) {
                return false;
            }
            onKeyUp(keyCode, event) {
                if (KeyEvent.isConfirmKey(keyCode)) {
                    if ((this.mViewFlags & View.ENABLED_MASK) == View.DISABLED) {
                        return true;
                    }
                    if ((this.mViewFlags & View.CLICKABLE) == View.CLICKABLE && this.isPressed()) {
                        this.setPressed(false);
                        if (!this.mHasPerformedLongPress) {
                            this.removeLongPressCallback();
                            return this.performClick();
                        }
                    }
                }
                return false;
            }
            dispatchTouchEvent(event) {
                if (this.onFilterTouchEventForSecurity(event)) {
                    let li = this.mListenerInfo;
                    if (li != null && li.mOnTouchListener != null && (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED
                        && li.mOnTouchListener.onTouch(this, event)) {
                        return true;
                    }
                    if (this.onTouchEvent(event)) {
                        return true;
                    }
                }
                return false;
            }
            onFilterTouchEventForSecurity(event) {
                return true;
            }
            onTouchEvent(event) {
                let viewFlags = this.mViewFlags;
                if ((viewFlags & View.ENABLED_MASK) == View.DISABLED) {
                    if (event.getAction() == view_2.MotionEvent.ACTION_UP && (this.mPrivateFlags & View.PFLAG_PRESSED) != 0) {
                        this.setPressed(false);
                    }
                    return (((viewFlags & View.CLICKABLE) == View.CLICKABLE ||
                        (viewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE));
                }
                if (this.mTouchDelegate != null) {
                    if (this.mTouchDelegate.onTouchEvent(event)) {
                        return true;
                    }
                }
                if (((viewFlags & View.CLICKABLE) == View.CLICKABLE ||
                    (viewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE)) {
                    switch (event.getAction()) {
                        case view_2.MotionEvent.ACTION_UP:
                            let prepressed = (this.mPrivateFlags & View.PFLAG_PREPRESSED) != 0;
                            if ((this.mPrivateFlags & View.PFLAG_PRESSED) != 0 || prepressed) {
                                let focusTaken = false;
                                if (this.isFocusable() && this.isFocusableInTouchMode() && !this.isFocused()) {
                                    focusTaken = this.requestFocus();
                                }
                                if (prepressed) {
                                    this.setPressed(true);
                                }
                                if (!this.mHasPerformedLongPress) {
                                    this.removeLongPressCallback();
                                    if (!focusTaken) {
                                        if (this.mPerformClick == null) {
                                            this.mPerformClick = new PerformClick(this);
                                        }
                                        if (!this.post(this.mPerformClick)) {
                                            this.performClick(event);
                                        }
                                    }
                                }
                                if (this.mUnsetPressedState == null) {
                                    this.mUnsetPressedState = new UnsetPressedState(this);
                                }
                                if (prepressed) {
                                    this.postDelayed(this.mUnsetPressedState, view_2.ViewConfiguration.getPressedStateDuration());
                                }
                                else if (!this.post(this.mUnsetPressedState)) {
                                    this.mUnsetPressedState.run();
                                }
                                this.removeTapCallback();
                            }
                            break;
                        case view_2.MotionEvent.ACTION_DOWN:
                            this.mHasPerformedLongPress = false;
                            let isInScrollingContainer = this.isInScrollingContainer();
                            if (isInScrollingContainer) {
                                this.mPrivateFlags |= View.PFLAG_PREPRESSED;
                                if (this.mPendingCheckForTap == null) {
                                    this.mPendingCheckForTap = new CheckForTap(this);
                                }
                                this.postDelayed(this.mPendingCheckForTap, view_2.ViewConfiguration.getTapTimeout());
                            }
                            else {
                                this.setPressed(true);
                                this.checkForLongClick(0);
                            }
                            break;
                        case view_2.MotionEvent.ACTION_CANCEL:
                            this.setPressed(false);
                            this.removeTapCallback();
                            this.removeLongPressCallback();
                            break;
                        case view_2.MotionEvent.ACTION_MOVE:
                            const x = event.getX();
                            const y = event.getY();
                            if (!this.pointInView(x, y, this.mTouchSlop)) {
                                this.removeTapCallback();
                                if ((this.mPrivateFlags & View.PFLAG_PRESSED) != 0) {
                                    this.removeLongPressCallback();
                                    this.setPressed(false);
                                }
                            }
                            break;
                    }
                    return true;
                }
                return false;
            }
            isInScrollingContainer() {
                let p = this.getParent();
                while (p != null && p instanceof view_2.ViewGroup) {
                    if (p.shouldDelayChildPressedState()) {
                        return true;
                    }
                    p = p.getParent();
                }
                return false;
            }
            cancelPendingInputEvents() {
                this.dispatchCancelPendingInputEvents();
            }
            dispatchCancelPendingInputEvents() {
                this.mPrivateFlags3 &= ~View.PFLAG3_CALLED_SUPER;
                this.onCancelPendingInputEvents();
                if ((this.mPrivateFlags3 & View.PFLAG3_CALLED_SUPER) != View.PFLAG3_CALLED_SUPER) {
                    throw Error(`new SuperNotCalledException("View " + this.getClass().getSimpleName() + " did not call through to super.onCancelPendingInputEvents()")`);
                }
            }
            onCancelPendingInputEvents() {
                this.removePerformClickCallback();
                this.cancelLongPress();
                this.mPrivateFlags3 |= View.PFLAG3_CALLED_SUPER;
            }
            removeLongPressCallback() {
                if (this.mPendingCheckForLongPress != null) {
                    this.removeCallbacks(this.mPendingCheckForLongPress);
                }
            }
            removePerformClickCallback() {
                if (this.mPerformClick != null) {
                    this.removeCallbacks(this.mPerformClick);
                }
            }
            removeUnsetPressCallback() {
                if ((this.mPrivateFlags & View.PFLAG_PRESSED) != 0 && this.mUnsetPressedState != null) {
                    this.setPressed(false);
                    this.removeCallbacks(this.mUnsetPressedState);
                }
            }
            removeTapCallback() {
                if (this.mPendingCheckForTap != null) {
                    this.mPrivateFlags &= ~View.PFLAG_PREPRESSED;
                    this.removeCallbacks(this.mPendingCheckForTap);
                }
            }
            cancelLongPress() {
                this.removeLongPressCallback();
                this.removeTapCallback();
            }
            setTouchDelegate(delegate) {
                this.mTouchDelegate = delegate;
            }
            getTouchDelegate() {
                return this.mTouchDelegate;
            }
            getListenerInfo() {
                if (this.mListenerInfo != null) {
                    return this.mListenerInfo;
                }
                this.mListenerInfo = new View.ListenerInfo();
                return this.mListenerInfo;
            }
            addOnLayoutChangeListener(listener) {
                let li = this.getListenerInfo();
                if (li.mOnLayoutChangeListeners == null) {
                    li.mOnLayoutChangeListeners = new ArrayList();
                }
                if (!li.mOnLayoutChangeListeners.contains(listener)) {
                    li.mOnLayoutChangeListeners.add(listener);
                }
            }
            removeOnLayoutChangeListener(listener) {
                let li = this.mListenerInfo;
                if (li == null || li.mOnLayoutChangeListeners == null) {
                    return;
                }
                li.mOnLayoutChangeListeners.remove(listener);
            }
            addOnAttachStateChangeListener(listener) {
                let li = this.getListenerInfo();
                if (li.mOnAttachStateChangeListeners == null) {
                    li.mOnAttachStateChangeListeners
                        = new CopyOnWriteArrayList();
                }
                li.mOnAttachStateChangeListeners.add(listener);
            }
            removeOnAttachStateChangeListener(listener) {
                let li = this.mListenerInfo;
                if (li == null || li.mOnAttachStateChangeListeners == null) {
                    return;
                }
                li.mOnAttachStateChangeListeners.remove(listener);
            }
            setOnClickListener(l) {
                if (!this.isClickable()) {
                    this.setClickable(true);
                }
                this.getListenerInfo().mOnClickListener = l;
            }
            hasOnClickListeners() {
                let li = this.mListenerInfo;
                return (li != null && li.mOnClickListener != null);
            }
            setOnLongClickListener(l) {
                if (!this.isLongClickable()) {
                    this.setLongClickable(true);
                }
                this.getListenerInfo().mOnLongClickListener = l;
            }
            playSoundEffect(soundConstant) {
            }
            performHapticFeedback(feedbackConstant) {
                return false;
            }
            performClick(event) {
                let handle = false;
                if (this.bindElementOnClickAttr) {
                    handle = eval(this.bindElementOnClickAttr);
                }
                let li = this.mListenerInfo;
                if (li != null && li.mOnClickListener != null) {
                    handle = li.mOnClickListener.onClick(this) || handle;
                }
                return handle;
            }
            callOnClick() {
                let li = this.mListenerInfo;
                if (li != null && li.mOnClickListener != null) {
                    li.mOnClickListener.onClick(this);
                    return true;
                }
                return false;
            }
            performLongClick() {
                let handled = false;
                let li = this.mListenerInfo;
                if (li != null && li.mOnLongClickListener != null) {
                    handled = li.mOnLongClickListener.onLongClick(this);
                }
                return handled;
            }
            performButtonActionOnTouchDown(event) {
                return false;
            }
            checkForLongClick(delayOffset = 0) {
                if ((this.mViewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE) {
                    this.mHasPerformedLongPress = false;
                    if (this.mPendingCheckForLongPress == null) {
                        this.mPendingCheckForLongPress = new CheckForLongPress(this);
                    }
                    this.mPendingCheckForLongPress.rememberWindowAttachCount();
                    this.postDelayed(this.mPendingCheckForLongPress, view_2.ViewConfiguration.getLongPressTimeout() - delayOffset);
                }
            }
            setOnTouchListener(l) {
                this.getListenerInfo().mOnTouchListener = l;
            }
            isClickable() {
                return (this.mViewFlags & View.CLICKABLE) == View.CLICKABLE;
            }
            setClickable(clickable) {
                this.setFlags(clickable ? View.CLICKABLE : 0, View.CLICKABLE);
            }
            isLongClickable() {
                return (this.mViewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE;
            }
            setLongClickable(longClickable) {
                this.setFlags(longClickable ? View.LONG_CLICKABLE : 0, View.LONG_CLICKABLE);
            }
            setPressed(pressed) {
                const needsRefresh = pressed != ((this.mPrivateFlags & View.PFLAG_PRESSED) == View.PFLAG_PRESSED);
                if (pressed) {
                    this.mPrivateFlags |= View.PFLAG_PRESSED;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_PRESSED;
                }
                if (needsRefresh) {
                    this.refreshDrawableState();
                }
                this.dispatchSetPressed(pressed);
            }
            dispatchSetPressed(pressed) {
            }
            isPressed() {
                return (this.mPrivateFlags & View.PFLAG_PRESSED) == View.PFLAG_PRESSED;
            }
            setSelected(selected) {
                if (((this.mPrivateFlags & View.PFLAG_SELECTED) != 0) != selected) {
                    this.mPrivateFlags = (this.mPrivateFlags & ~View.PFLAG_SELECTED) | (selected ? View.PFLAG_SELECTED : 0);
                    if (!selected)
                        this.resetPressedState();
                    this.invalidate(true);
                    this.refreshDrawableState();
                    this.dispatchSetSelected(selected);
                }
            }
            dispatchSetSelected(selected) {
            }
            isSelected() {
                return (this.mPrivateFlags & View.PFLAG_SELECTED) != 0;
            }
            setActivated(activated) {
                if (((this.mPrivateFlags & View.PFLAG_ACTIVATED) != 0) != activated) {
                    this.mPrivateFlags = (this.mPrivateFlags & ~View.PFLAG_ACTIVATED) | (activated ? View.PFLAG_ACTIVATED : 0);
                    this.invalidate(true);
                    this.refreshDrawableState();
                    this.dispatchSetActivated(activated);
                }
            }
            dispatchSetActivated(activated) {
            }
            isActivated() {
                return (this.mPrivateFlags & View.PFLAG_ACTIVATED) != 0;
            }
            getViewTreeObserver() {
                if (this.mAttachInfo != null) {
                    return this.mAttachInfo.mViewRootImpl.mTreeObserver;
                }
                if (this.mFloatingTreeObserver == null) {
                    this.mFloatingTreeObserver = new view_2.ViewTreeObserver();
                }
                return this.mFloatingTreeObserver;
            }
            setLayoutDirection(layoutDirection) {
            }
            getLayoutDirection() {
                return View.LAYOUT_DIRECTION_LTR;
            }
            isLayoutRtl() {
                return (this.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL);
            }
            getTextDirection() {
                return View.TEXT_DIRECTION_LTR;
            }
            setTextDirection(textDirection) {
            }
            getTextAlignment() {
                return View.TEXT_ALIGNMENT_DEFAULT;
            }
            setTextAlignment(textAlignment) {
            }
            getBaseline() {
                return -1;
            }
            isLayoutRequested() {
                return (this.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT;
            }
            getLayoutParams() {
                return this.mLayoutParams;
            }
            setLayoutParams(params) {
                if (params == null) {
                    throw new Error("Layout parameters cannot be null");
                }
                this.mLayoutParams = params;
                let p = this.mParent;
                if (p instanceof view_2.ViewGroup) {
                    p.onSetLayoutParams(this, params);
                }
                this.requestLayout();
            }
            isInLayout() {
                let viewRoot = this.getViewRootImpl();
                return (viewRoot != null && viewRoot.isInLayout());
            }
            requestLayout() {
                if (this.mMeasureCache != null)
                    this.mMeasureCache.clear();
                if (this.mAttachInfo != null && this.mAttachInfo.mViewRequestingLayout == null) {
                    let viewRoot = this.getViewRootImpl();
                    if (viewRoot != null && viewRoot.isInLayout()) {
                        if (!viewRoot.requestLayoutDuringLayout(this)) {
                            return;
                        }
                    }
                    this.mAttachInfo.mViewRequestingLayout = this;
                }
                this.mPrivateFlags |= View.PFLAG_FORCE_LAYOUT;
                this.mPrivateFlags |= View.PFLAG_INVALIDATED;
                if (this.mParent != null && !this.mParent.isLayoutRequested()) {
                    this.mParent.requestLayout();
                }
                if (this.mAttachInfo != null && this.mAttachInfo.mViewRequestingLayout == this) {
                    this.mAttachInfo.mViewRequestingLayout = null;
                }
            }
            forceLayout() {
                if (this.mMeasureCache != null)
                    this.mMeasureCache.clear();
                this.mPrivateFlags |= View.PFLAG_FORCE_LAYOUT;
                this.mPrivateFlags |= View.PFLAG_INVALIDATED;
            }
            isLaidOut() {
                return (this.mPrivateFlags3 & View.PFLAG3_IS_LAID_OUT) == View.PFLAG3_IS_LAID_OUT;
            }
            layout(l, t, r, b) {
                if ((this.mPrivateFlags3 & View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
                    this.onMeasure(this.mOldWidthMeasureSpec, this.mOldHeightMeasureSpec);
                    this.mPrivateFlags3 &= ~View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
                }
                let oldL = this.mLeft;
                let oldT = this.mTop;
                let oldB = this.mBottom;
                let oldR = this.mRight;
                let changed = this.setFrame(l, t, r, b);
                if (changed || (this.mPrivateFlags & View.PFLAG_LAYOUT_REQUIRED) == View.PFLAG_LAYOUT_REQUIRED) {
                    this.onLayout(changed, l, t, r, b);
                    this.mPrivateFlags &= ~View.PFLAG_LAYOUT_REQUIRED;
                    let li = this.mListenerInfo;
                    if (li != null && li.mOnLayoutChangeListeners != null) {
                        let listenersCopy = li.mOnLayoutChangeListeners.clone();
                        let numListeners = listenersCopy.size();
                        for (let i = 0; i < numListeners; ++i) {
                            listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
                        }
                    }
                }
                this.mPrivateFlags &= ~View.PFLAG_FORCE_LAYOUT;
                this.mPrivateFlags3 |= View.PFLAG3_IS_LAID_OUT;
            }
            onLayout(changed, left, top, right, bottom) {
            }
            setFrame(left, top, right, bottom) {
                let changed = false;
                if (View.DBG) {
                    Log.i("View", this + " View.setFrame(" + left + "," + top + ","
                        + right + "," + bottom + ")");
                }
                if (this.mLeft != left || this.mRight != right || this.mTop != top || this.mBottom != bottom) {
                    changed = true;
                    let drawn = this.mPrivateFlags & View.PFLAG_DRAWN;
                    let oldWidth = this.mRight - this.mLeft;
                    let oldHeight = this.mBottom - this.mTop;
                    let newWidth = right - left;
                    let newHeight = bottom - top;
                    let sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);
                    this.invalidate(sizeChanged);
                    this.mLeft = left;
                    this.mTop = top;
                    this.mRight = right;
                    this.mBottom = bottom;
                    this.mPrivateFlags |= View.PFLAG_HAS_BOUNDS;
                    if (sizeChanged) {
                        if ((this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
                        }
                        this.sizeChange(newWidth, newHeight, oldWidth, oldHeight);
                    }
                    if ((this.mViewFlags & View.VISIBILITY_MASK) == View.VISIBLE) {
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(sizeChanged);
                    }
                    this.mPrivateFlags |= drawn;
                    this.mBackgroundSizeChanged = true;
                }
                return changed;
            }
            sizeChange(newWidth, newHeight, oldWidth, oldHeight) {
                this.onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);
                if (this.mOverlay != null) {
                    this.mOverlay.getOverlayView().setRight(newWidth);
                    this.mOverlay.getOverlayView().setBottom(newHeight);
                }
            }
            getHitRect(outRect) {
                this.updateMatrix();
                const info = this.mTransformationInfo;
                if (info == null || info.mMatrixIsIdentity || this.mAttachInfo == null) {
                    outRect.set(this.mLeft, this.mTop, this.mRight, this.mBottom);
                }
                else {
                    const tmpRect = this.mAttachInfo.mTmpTransformRect;
                    tmpRect.set(0, 0, this.getWidth(), this.getHeight());
                    info.mMatrix.mapRect(tmpRect);
                    outRect.set(Math.floor(tmpRect.left) + this.mLeft, Math.floor(tmpRect.top) + this.mTop, Math.floor(tmpRect.right) + this.mLeft, Math.floor(tmpRect.bottom) + this.mTop);
                }
            }
            getFocusedRect(r) {
                this.getDrawingRect(r);
            }
            getDrawingRect(outRect) {
                outRect.left = this.mScrollX;
                outRect.top = this.mScrollY;
                outRect.right = this.mScrollX + (this.mRight - this.mLeft);
                outRect.bottom = this.mScrollY + (this.mBottom - this.mTop);
            }
            getGlobalVisibleRect(r, globalOffset = null) {
                let width = this.mRight - this.mLeft;
                let height = this.mBottom - this.mTop;
                if (width > 0 && height > 0) {
                    r.set(0, 0, width, height);
                    if (globalOffset != null) {
                        globalOffset.set(-this.mScrollX, -this.mScrollY);
                    }
                    return this.mParent == null || this.mParent.getChildVisibleRect(this, r, globalOffset);
                }
                return false;
            }
            getLocationOnScreen(location) {
                this.getLocationInWindow(location);
                const info = this.mAttachInfo;
            }
            getLocationInWindow(location) {
                if (location == null || location.length < 2) {
                    throw Error(`new IllegalArgumentException("location must be an array of two integers")`);
                }
                if (this.mAttachInfo == null) {
                    location[0] = location[1] = 0;
                    return;
                }
                let position = this.mAttachInfo.mTmpTransformLocation;
                position[0] = position[1] = 0.0;
                if (!this.hasIdentityMatrix()) {
                    this.getMatrix().mapPoints(position);
                }
                position[0] += this.mLeft;
                position[1] += this.mTop;
                let viewParent = this.mParent;
                while (viewParent instanceof View) {
                    const view = viewParent;
                    position[0] -= view.mScrollX;
                    position[1] -= view.mScrollY;
                    if (!view.hasIdentityMatrix()) {
                        view.getMatrix().mapPoints(position);
                    }
                    position[0] += view.mLeft;
                    position[1] += view.mTop;
                    viewParent = view.mParent;
                }
                location[0] = Math.floor((position[0] + 0.5));
                location[1] = Math.floor((position[1] + 0.5));
            }
            getWindowVisibleDisplayFrame(outRect) {
                if (this.mAttachInfo != null) {
                    let rootView = this.mAttachInfo.mRootView;
                    let xy = [0, 0];
                    rootView.getLocationOnScreen(xy);
                    outRect.set(xy[0], xy[1], rootView.getWidth() + xy[0], rootView.getHeight() + xy[1]);
                    return;
                }
                let dm = Resources.getSystem().getDisplayMetrics();
                outRect.set(0, 0, dm.widthPixels, dm.heightPixels);
            }
            isVisibleToUser(boundInView = null) {
                if (this.mAttachInfo != null) {
                    if (this.mAttachInfo.mWindowVisibility != View.VISIBLE) {
                        return false;
                    }
                    let current = this;
                    while (current instanceof View) {
                        let view = current;
                        if (view.getAlpha() <= 0 || view.getTransitionAlpha() <= 0 || view.getVisibility() != View.VISIBLE) {
                            return false;
                        }
                        current = view.mParent;
                    }
                    let visibleRect = this.mAttachInfo.mTmpInvalRect;
                    let offset = this.mAttachInfo.mPoint;
                    if (!this.getGlobalVisibleRect(visibleRect, offset)) {
                        return false;
                    }
                    if (boundInView != null) {
                        visibleRect.offset(-offset.x, -offset.y);
                        return boundInView.intersect(visibleRect);
                    }
                    return true;
                }
                return false;
            }
            getMeasuredWidth() {
                return this.mMeasuredWidth & View.MEASURED_SIZE_MASK;
            }
            getMeasuredWidthAndState() {
                return this.mMeasuredWidth;
            }
            getMeasuredHeight() {
                return this.mMeasuredHeight & View.MEASURED_SIZE_MASK;
            }
            getMeasuredHeightAndState() {
                return this.mMeasuredHeight;
            }
            getMeasuredState() {
                return (this.mMeasuredWidth & View.MEASURED_STATE_MASK)
                    | ((this.mMeasuredHeight >> View.MEASURED_HEIGHT_STATE_SHIFT)
                        & (View.MEASURED_STATE_MASK >> View.MEASURED_HEIGHT_STATE_SHIFT));
            }
            measure(widthMeasureSpec, heightMeasureSpec) {
                let key = widthMeasureSpec + ',' + heightMeasureSpec;
                if (this.mMeasureCache == null)
                    this.mMeasureCache = new Map();
                if ((this.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT ||
                    widthMeasureSpec != this.mOldWidthMeasureSpec ||
                    heightMeasureSpec != this.mOldHeightMeasureSpec) {
                    this.mPrivateFlags &= ~View.PFLAG_MEASURED_DIMENSION_SET;
                    let cacheValue = (this.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT ? null : this.mMeasureCache.get(key);
                    if (cacheValue == null) {
                        this.onMeasure(widthMeasureSpec, heightMeasureSpec);
                        this.mPrivateFlags3 &= ~View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
                    }
                    else {
                        this.setMeasuredDimension(cacheValue[0], cacheValue[1]);
                        this.mPrivateFlags3 |= View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
                    }
                    if ((this.mPrivateFlags & View.PFLAG_MEASURED_DIMENSION_SET) != View.PFLAG_MEASURED_DIMENSION_SET) {
                        throw new Error("onMeasure() did not set the"
                            + " measured dimension by calling"
                            + " setMeasuredDimension()");
                    }
                    this.mPrivateFlags |= View.PFLAG_LAYOUT_REQUIRED;
                }
                this.mOldWidthMeasureSpec = widthMeasureSpec;
                this.mOldHeightMeasureSpec = heightMeasureSpec;
                this.mMeasureCache.set(key, [this.mMeasuredWidth, this.mMeasuredHeight]);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                this.setMeasuredDimension(View.getDefaultSize(this.getSuggestedMinimumWidth(), widthMeasureSpec), View.getDefaultSize(this.getSuggestedMinimumHeight(), heightMeasureSpec));
            }
            setMeasuredDimension(measuredWidth, measuredHeight) {
                this.mMeasuredWidth = measuredWidth;
                this.mMeasuredHeight = measuredHeight;
                this.mPrivateFlags |= View.PFLAG_MEASURED_DIMENSION_SET;
            }
            static combineMeasuredStates(curState, newState) {
                return curState | newState;
            }
            static resolveSize(size, measureSpec) {
                return View.resolveSizeAndState(size, measureSpec, 0) & View.MEASURED_SIZE_MASK;
            }
            static resolveSizeAndState(size, measureSpec, childMeasuredState) {
                let MeasureSpec = View.MeasureSpec;
                let result = size;
                let specMode = MeasureSpec.getMode(measureSpec);
                let specSize = MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case MeasureSpec.UNSPECIFIED:
                        result = size;
                        break;
                    case MeasureSpec.AT_MOST:
                        if (specSize < size) {
                            result = specSize | View.MEASURED_STATE_TOO_SMALL;
                        }
                        else {
                            result = size;
                        }
                        break;
                    case MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result | (childMeasuredState & View.MEASURED_STATE_MASK);
            }
            static getDefaultSize(size, measureSpec) {
                let MeasureSpec = View.MeasureSpec;
                let result = size;
                let specMode = MeasureSpec.getMode(measureSpec);
                let specSize = MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case MeasureSpec.UNSPECIFIED:
                        result = size;
                        break;
                    case MeasureSpec.AT_MOST:
                    case MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result;
            }
            getSuggestedMinimumHeight() {
                return (this.mBackground == null) ? this.mMinHeight :
                    Math.max(this.mMinHeight, this.mBackground.getMinimumHeight());
            }
            getSuggestedMinimumWidth() {
                return (this.mBackground == null) ? this.mMinWidth :
                    Math.max(this.mMinWidth, this.mBackground.getMinimumWidth());
            }
            getMinimumHeight() {
                return this.mMinHeight;
            }
            setMinimumHeight(minHeight) {
                this.mMinHeight = minHeight;
                this.requestLayout();
            }
            getMinimumWidth() {
                return this.mMinWidth;
            }
            setMinimumWidth(minWidth) {
                this.mMinWidth = minWidth;
                this.requestLayout();
            }
            getAnimation() {
                return this.mCurrentAnimation;
            }
            startAnimation(animation) {
                animation.setStartTime(Animation.START_ON_FIRST_FRAME);
                this.setAnimation(animation);
                this.invalidateParentCaches();
                this.invalidate(true);
            }
            clearAnimation() {
                if (this.mCurrentAnimation != null) {
                    this.mCurrentAnimation.detach();
                }
                this.mCurrentAnimation = null;
                this.invalidateParentIfNeeded();
            }
            setAnimation(animation) {
                this.mCurrentAnimation = animation;
                if (animation != null) {
                    animation.reset();
                }
            }
            onAnimationStart() {
                this.mPrivateFlags |= View.PFLAG_ANIMATION_STARTED;
            }
            onAnimationEnd() {
                this.mPrivateFlags &= ~View.PFLAG_ANIMATION_STARTED;
            }
            onSetAlpha(alpha) {
                return false;
            }
            _invalidateRect(l, t, r, b) {
                if (this.skipInvalidate()) {
                    return;
                }
                if ((this.mPrivateFlags & (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS)) == (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS) ||
                    (this.mPrivateFlags & View.PFLAG_DRAWING_CACHE_VALID) == View.PFLAG_DRAWING_CACHE_VALID ||
                    (this.mPrivateFlags & View.PFLAG_INVALIDATED) != View.PFLAG_INVALIDATED) {
                    this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                    this.mPrivateFlags |= View.PFLAG_INVALIDATED;
                    this.mPrivateFlags |= View.PFLAG_DIRTY;
                    const p = this.mParent;
                    const ai = this.mAttachInfo;
                    if (p != null && ai != null && l < r && t < b) {
                        const scrollX = this.mScrollX;
                        const scrollY = this.mScrollY;
                        const tmpr = ai.mTmpInvalRect;
                        tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
                        p.invalidateChild(this, tmpr);
                    }
                }
            }
            _invalidateCache(invalidateCache = true) {
                if (this.skipInvalidate()) {
                    return;
                }
                if ((this.mPrivateFlags & (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS)) == (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS) ||
                    (invalidateCache && (this.mPrivateFlags & View.PFLAG_DRAWING_CACHE_VALID) == View.PFLAG_DRAWING_CACHE_VALID) ||
                    (this.mPrivateFlags & View.PFLAG_INVALIDATED) != View.PFLAG_INVALIDATED || this.isOpaque() != this.mLastIsOpaque) {
                    this.mLastIsOpaque = this.isOpaque();
                    this.mPrivateFlags &= ~View.PFLAG_DRAWN;
                    this.mPrivateFlags |= View.PFLAG_DIRTY;
                    if (invalidateCache) {
                        this.mPrivateFlags |= View.PFLAG_INVALIDATED;
                        this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                    }
                    const ai = this.mAttachInfo;
                    const p = this.mParent;
                    if (p != null && ai != null) {
                        const r = ai.mTmpInvalRect;
                        r.set(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        p.invalidateChild(this, r);
                    }
                }
            }
            invalidate(...args) {
                if (args.length === 0) {
                    this._invalidateCache(true);
                }
                else if (args.length === 1 && args[0] instanceof Rect) {
                    let rect = args[0];
                    this._invalidateRect(rect.left, rect.top, rect.right, rect.bottom);
                }
                else if (args.length === 1) {
                    this._invalidateCache(args[0]);
                }
                else if (args.length === 4) {
                    this._invalidateRect(...args);
                }
            }
            invalidateViewProperty(invalidateParent, forceRedraw) {
                if ((this.mPrivateFlags & View.PFLAG_DRAW_ANIMATION) == View.PFLAG_DRAW_ANIMATION) {
                    if (invalidateParent) {
                        this.invalidateParentCaches();
                    }
                    if (forceRedraw) {
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                    }
                    this.invalidate(false);
                }
                else {
                    const ai = this.mAttachInfo;
                    const p = this.mParent;
                    if (p != null && ai != null) {
                        const r = ai.mTmpInvalRect;
                        r.set(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        if (this.mParent instanceof view_2.ViewGroup) {
                            this.mParent.invalidateChildFast(this, r);
                        }
                        else {
                            this.mParent.invalidateChild(this, r);
                        }
                    }
                }
            }
            invalidateParentCaches() {
                if (this.mParent instanceof View) {
                    this.mParent.mPrivateFlags |= View.PFLAG_INVALIDATED;
                }
            }
            invalidateParentIfNeeded() {
            }
            postInvalidate(l, t, r, b) {
                this.postInvalidateDelayed(0, l, t, r, b);
            }
            postInvalidateDelayed(delayMilliseconds, left, top, right, bottom) {
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    if (!Number.isInteger(left) || !Number.isInteger(top) || !Number.isInteger(right) || !Number.isInteger(bottom)) {
                        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds);
                    }
                    else {
                        const info = View.AttachInfo.InvalidateInfo.obtain();
                        info.target = this;
                        info.left = left;
                        info.top = top;
                        info.right = right;
                        info.bottom = bottom;
                        attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds);
                    }
                }
            }
            postInvalidateOnAnimation(left, top, right, bottom) {
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    if (!Number.isInteger(left) || !Number.isInteger(top) || !Number.isInteger(right) || !Number.isInteger(bottom)) {
                        attachInfo.mViewRootImpl.dispatchInvalidateOnAnimation(this);
                    }
                    else {
                        const info = View.AttachInfo.InvalidateInfo.obtain();
                        info.target = this;
                        info.left = left;
                        info.top = top;
                        info.right = right;
                        info.bottom = bottom;
                        attachInfo.mViewRootImpl.dispatchInvalidateRectOnAnimation(info);
                    }
                }
            }
            skipInvalidate() {
                return (this.mViewFlags & View.VISIBILITY_MASK) != View.VISIBLE
                    && this.mCurrentAnimation == null;
            }
            isOpaque() {
                return (this.mPrivateFlags & View.PFLAG_OPAQUE_MASK) == View.PFLAG_OPAQUE_MASK &&
                    this.getFinalAlpha() >= 1;
            }
            computeOpaqueFlags() {
                // Opaque if:
                //   - Has a background
                //   - Background is opaque
                //   - Doesn't have scrollbars or scrollbars overlay
                if (this.mBackground != null && this.mBackground.getOpacity() == PixelFormat.OPAQUE) {
                    this.mPrivateFlags |= View.PFLAG_OPAQUE_BACKGROUND;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_OPAQUE_BACKGROUND;
                }
                const flags = this.mViewFlags;
                if (((flags & View.SCROLLBARS_VERTICAL) == 0 && (flags & View.SCROLLBARS_HORIZONTAL) == 0)) {
                    this.mPrivateFlags |= View.PFLAG_OPAQUE_SCROLLBARS;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_OPAQUE_SCROLLBARS;
                }
            }
            setLayerType(layerType) {
                if (layerType < View.LAYER_TYPE_NONE || layerType > View.LAYER_TYPE_SOFTWARE) {
                    throw Error(`new IllegalArgumentException("Layer type can only be one of: LAYER_TYPE_NONE, " + "LAYER_TYPE_SOFTWARE")`);
                }
                if (layerType == this.mLayerType) {
                    return;
                }
                switch (this.mLayerType) {
                    case View.LAYER_TYPE_SOFTWARE:
                        this.destroyDrawingCache();
                        break;
                    default:
                        break;
                }
                this.mLayerType = layerType;
                const layerDisabled = this.mLayerType == View.LAYER_TYPE_NONE;
                this.mLocalDirtyRect = layerDisabled ? null : new Rect();
                this.invalidateParentCaches();
                this.invalidate(true);
            }
            getLayerType() {
                return this.mLayerType;
            }
            setClipBounds(clipBounds) {
                if (clipBounds != null) {
                    if (clipBounds.equals(this.mClipBounds)) {
                        return;
                    }
                    if (this.mClipBounds == null) {
                        this.invalidate();
                        this.mClipBounds = new Rect(clipBounds);
                    }
                    else {
                        this.invalidate(Math.min(this.mClipBounds.left, clipBounds.left), Math.min(this.mClipBounds.top, clipBounds.top), Math.max(this.mClipBounds.right, clipBounds.right), Math.max(this.mClipBounds.bottom, clipBounds.bottom));
                        this.mClipBounds.set(clipBounds);
                    }
                }
                else {
                    if (this.mClipBounds != null) {
                        this.invalidate();
                        this.mClipBounds = null;
                    }
                }
            }
            getClipBounds() {
                return (this.mClipBounds != null) ? new Rect(this.mClipBounds) : null;
            }
            setCornerRadius(radiusTopLeft, radiusTopRight = radiusTopLeft, radiusBottomRight = radiusTopRight, radiusBottomLeft = radiusBottomRight) {
                this.setCornerRadiusTopLeft(radiusTopLeft);
                this.setCornerRadiusTopRight(radiusTopRight);
                this.setCornerRadiusBottomRight(radiusBottomRight);
                this.setCornerRadiusBottomLeft(radiusBottomLeft);
            }
            setCornerRadiusTopLeft(value) {
                if (this.mCornerRadiusTopLeft != value) {
                    this.mCornerRadiusTopLeft = value;
                    this.mShadowDrawable = null;
                    this.invalidate();
                }
            }
            getCornerRadiusTopLeft() {
                return this.mCornerRadiusTopLeft;
            }
            setCornerRadiusTopRight(value) {
                if (this.mCornerRadiusTopRight != value) {
                    this.mCornerRadiusTopRight = value;
                    this.mShadowDrawable = null;
                    this.invalidate();
                }
            }
            getCornerRadiusTopRight() {
                return this.mCornerRadiusTopRight;
            }
            setCornerRadiusBottomRight(value) {
                if (this.mCornerRadiusBottomRight != value) {
                    this.mCornerRadiusBottomRight = value;
                    this.mShadowDrawable = null;
                    this.invalidate();
                }
            }
            getCornerRadiusBottomRight() {
                return this.mCornerRadiusBottomRight;
            }
            setCornerRadiusBottomLeft(value) {
                if (this.mCornerRadiusBottomLeft != value) {
                    this.mCornerRadiusBottomLeft = value;
                    this.mShadowDrawable = null;
                    this.invalidate();
                }
            }
            getCornerRadiusBottomLeft() {
                return this.mCornerRadiusBottomLeft;
            }
            setShadowView(radius, dx, dy, color) {
                if (!this.mShadowPaint)
                    this.mShadowPaint = new Paint();
                this.mShadowPaint.setShadowLayer(radius, dx, dy, color);
                this.invalidate();
            }
            getDrawingTime() {
                return this.getViewRootImpl() != null ? this.getViewRootImpl().mDrawingTime : 0;
            }
            drawFromParent(canvas, parent, drawingTime) {
                let useDisplayListProperties = false;
                let more = false;
                let childHasIdentityMatrix = this.hasIdentityMatrix();
                let flags = parent.mGroupFlags;
                if ((flags & view_2.ViewGroup.FLAG_CLEAR_TRANSFORMATION) == view_2.ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
                    parent.getChildTransformation().clear();
                    parent.mGroupFlags &= ~view_2.ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                let transformToApply = null;
                let concatMatrix = false;
                let scalingRequired = false;
                let caching = false;
                let layerType = this.getLayerType();
                const hardwareAccelerated = false;
                if ((flags & view_2.ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 ||
                    (flags & view_2.ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
                    caching = true;
                }
                else {
                    caching = (layerType != View.LAYER_TYPE_NONE);
                }
                const a = this.getAnimation();
                if (a != null) {
                    more = this.drawAnimation(parent, drawingTime, a, scalingRequired);
                    concatMatrix = a.willChangeTransformationMatrix();
                    if (concatMatrix) {
                        this.mPrivateFlags3 |= View.PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
                    }
                    transformToApply = parent.getChildTransformation();
                }
                else {
                    if (!useDisplayListProperties && (flags & view_2.ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                        const t = parent.getChildTransformation();
                        const hasTransform = parent.getChildStaticTransformation(this, t);
                        if (hasTransform) {
                            const transformType = t.getTransformationType();
                            transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                            concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
                        }
                    }
                }
                concatMatrix = !childHasIdentityMatrix || concatMatrix;
                this.mPrivateFlags |= View.PFLAG_DRAWN;
                if (!concatMatrix &&
                    (flags & (view_2.ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS |
                        view_2.ViewGroup.FLAG_CLIP_CHILDREN)) == view_2.ViewGroup.FLAG_CLIP_CHILDREN &&
                    canvas.quickReject(this.mLeft, this.mTop, this.mRight, this.mBottom) &&
                    (this.mPrivateFlags & View.PFLAG_DRAW_ANIMATION) == 0) {
                    this.mPrivateFlags2 |= View.PFLAG2_VIEW_QUICK_REJECTED;
                    return more;
                }
                this.mPrivateFlags2 &= ~View.PFLAG2_VIEW_QUICK_REJECTED;
                let cache = null;
                if (caching) {
                    if (layerType != View.LAYER_TYPE_NONE) {
                        layerType = View.LAYER_TYPE_SOFTWARE;
                        this.buildDrawingCache(true);
                    }
                    cache = this.getDrawingCache(true);
                }
                this.computeScroll();
                let sx = this.mScrollX;
                let sy = this.mScrollY;
                this.requestSyncBoundToElement();
                let hasNoCache = cache == null;
                let offsetForScroll = cache == null;
                let restoreTo = canvas.save();
                if (offsetForScroll) {
                    canvas.translate(this.mLeft - sx, this.mTop - sy);
                }
                else {
                    canvas.translate(this.mLeft, this.mTop);
                }
                let alpha = this.getAlpha() * this.getTransitionAlpha();
                if (transformToApply != null || alpha < 1 || !this.hasIdentityMatrix() || (this.mPrivateFlags3 & View.PFLAG3_VIEW_IS_ANIMATING_ALPHA) == View.PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
                    if (transformToApply != null || !childHasIdentityMatrix) {
                        let transX = 0;
                        let transY = 0;
                        if (offsetForScroll) {
                            transX = -sx;
                            transY = -sy;
                        }
                        if (transformToApply != null) {
                            if (concatMatrix) {
                                canvas.translate(-transX, -transY);
                                canvas.concat(transformToApply.getMatrix());
                                canvas.translate(transX, transY);
                                parent.mGroupFlags |= view_2.ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                            }
                            let transformAlpha = transformToApply.getAlpha();
                            if (transformAlpha < 1) {
                                alpha *= transformAlpha;
                                parent.mGroupFlags |= view_2.ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                            }
                        }
                        if (!childHasIdentityMatrix && !useDisplayListProperties) {
                            canvas.translate(-transX, -transY);
                            canvas.concat(this.getMatrix());
                            canvas.translate(transX, transY);
                        }
                    }
                    if (alpha < 1 || (this.mPrivateFlags3 & View.PFLAG3_VIEW_IS_ANIMATING_ALPHA) == View.PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
                        if (alpha < 1) {
                            this.mPrivateFlags3 |= View.PFLAG3_VIEW_IS_ANIMATING_ALPHA;
                        }
                        else {
                            this.mPrivateFlags3 &= ~View.PFLAG3_VIEW_IS_ANIMATING_ALPHA;
                        }
                        parent.mGroupFlags |= view_2.ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                        if (hasNoCache) {
                            const multipliedAlpha = Math.floor((255 * alpha));
                            if (!this.onSetAlpha(multipliedAlpha)) {
                                canvas.multiplyAlpha(alpha);
                            }
                            else {
                                this.mPrivateFlags |= View.PFLAG_ALPHA_SET;
                            }
                        }
                    }
                }
                else if ((this.mPrivateFlags & View.PFLAG_ALPHA_SET) == View.PFLAG_ALPHA_SET) {
                    this.onSetAlpha(255);
                    this.mPrivateFlags &= ~View.PFLAG_ALPHA_SET;
                }
                if (this.mShadowPaint != null)
                    this.drawShadow(canvas);
                if ((flags & view_2.ViewGroup.FLAG_CLIP_CHILDREN) == view_2.ViewGroup.FLAG_CLIP_CHILDREN &&
                    !useDisplayListProperties && cache == null) {
                    if (offsetForScroll) {
                        canvas.clipRect(sx, sy, sx + (this.mRight - this.mLeft), sy + (this.mBottom - this.mTop), this.mCornerRadiusTopLeft, this.mCornerRadiusTopRight, this.mCornerRadiusBottomRight, this.mCornerRadiusBottomLeft);
                    }
                    else {
                        if (!scalingRequired || cache == null) {
                            canvas.clipRect(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop, this.mCornerRadiusTopLeft, this.mCornerRadiusTopRight, this.mCornerRadiusBottomRight, this.mCornerRadiusBottomLeft);
                        }
                        else {
                            canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight(), this.mCornerRadiusTopLeft, this.mCornerRadiusTopRight, this.mCornerRadiusBottomRight, this.mCornerRadiusBottomLeft);
                        }
                    }
                }
                if (hasNoCache) {
                    if ((this.mPrivateFlags & View.PFLAG_SKIP_DRAW) == View.PFLAG_SKIP_DRAW) {
                        this.mPrivateFlags &= ~View.PFLAG_DIRTY_MASK;
                        this.dispatchDraw(canvas);
                    }
                    else {
                        this.draw(canvas);
                    }
                }
                else if (cache != null) {
                    this.mPrivateFlags &= ~View.PFLAG_DIRTY_MASK;
                    canvas.multiplyAlpha(alpha);
                    if (layerType == View.LAYER_TYPE_NONE) {
                        if (alpha < 1) {
                            parent.mGroupFlags |= view_2.ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
                        }
                        else if ((flags & view_2.ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                            parent.mGroupFlags &= ~view_2.ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
                        }
                    }
                    canvas.drawCanvas(cache, 0, 0);
                }
                if (restoreTo >= 0) {
                    canvas.restoreToCount(restoreTo);
                }
                if (a != null && !more) {
                    if (!hardwareAccelerated && !a.getFillAfter()) {
                        this.onSetAlpha(255);
                    }
                    parent.finishAnimatingView(this, a);
                }
                return more;
            }
            drawShadow(canvas) {
                let shadowPaint = this.mShadowPaint;
                if (!shadowPaint || !shadowPaint.shadowRadius)
                    return;
                let color = shadowPaint.shadowColor;
                if (!this.mShadowDrawable) {
                    let drawable = new RoundRectDrawable(shadowPaint.shadowColor, this.mCornerRadiusTopLeft, this.mCornerRadiusTopRight, this.mCornerRadiusBottomLeft, this.mCornerRadiusBottomRight);
                    this.mShadowDrawable = new ShadowDrawable(drawable, shadowPaint.shadowRadius, shadowPaint.shadowDx, shadowPaint.shadowDy, shadowPaint.shadowColor);
                }
                this.mShadowDrawable.draw(canvas);
            }
            draw(canvas) {
                if (this.mClipBounds != null) {
                    canvas.clipRect(this.mClipBounds);
                }
                let privateFlags = this.mPrivateFlags;
                const dirtyOpaque = (privateFlags & View.PFLAG_DIRTY_MASK) == View.PFLAG_DIRTY_OPAQUE &&
                    (this.getViewRootImpl() == null || !this.getViewRootImpl().mIgnoreDirtyState);
                this.mPrivateFlags = (privateFlags & ~View.PFLAG_DIRTY_MASK) | View.PFLAG_DRAWN;
                if (!dirtyOpaque) {
                    let background = this.mBackground;
                    if (background != null) {
                        let scrollX = this.mScrollX;
                        let scrollY = this.mScrollY;
                        if (this.mBackgroundSizeChanged) {
                            background.setBounds(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                            this.mBackgroundSizeChanged = false;
                        }
                        if ((scrollX | scrollY) == 0) {
                            background.draw(canvas);
                        }
                        else {
                            canvas.translate(scrollX, scrollY);
                            background.draw(canvas);
                            canvas.translate(-scrollX, -scrollY);
                        }
                    }
                }
                if (!dirtyOpaque)
                    this.onDraw(canvas);
                this.dispatchDraw(canvas);
                this.onDrawScrollBars(canvas);
                if (this.mOverlay != null && !this.mOverlay.isEmpty()) {
                    this.mOverlay.getOverlayView().dispatchDraw(canvas);
                }
            }
            onDraw(canvas) {
            }
            dispatchDraw(canvas) {
            }
            drawAnimation(parent, drawingTime, a, scalingRequired) {
                let invalidationTransform;
                const flags = parent.mGroupFlags;
                const initialized = a.isInitialized();
                if (!initialized) {
                    a.initialize(this.mRight - this.mLeft, this.mBottom - this.mTop, parent.getWidth(), parent.getHeight());
                    a.initializeInvalidateRegion(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                    if (this.mAttachInfo != null)
                        a.setListenerHandler(this.mAttachInfo.mHandler);
                    this.onAnimationStart();
                }
                const t = parent.getChildTransformation();
                let more = a.getTransformation(drawingTime, t, 1);
                invalidationTransform = t;
                if (more) {
                    if (!a.willChangeBounds()) {
                        if ((flags & (view_2.ViewGroup.FLAG_OPTIMIZE_INVALIDATE | view_2.ViewGroup.FLAG_ANIMATION_DONE)) == view_2.ViewGroup.FLAG_OPTIMIZE_INVALIDATE) {
                            parent.mGroupFlags |= view_2.ViewGroup.FLAG_INVALIDATE_REQUIRED;
                        }
                        else if ((flags & view_2.ViewGroup.FLAG_INVALIDATE_REQUIRED) == 0) {
                            parent.mPrivateFlags |= View.PFLAG_DRAW_ANIMATION;
                            parent.invalidate(this.mLeft, this.mTop, this.mRight, this.mBottom);
                        }
                    }
                    else {
                        if (parent.mInvalidateRegion == null) {
                            parent.mInvalidateRegion = new RectF();
                        }
                        const region = parent.mInvalidateRegion;
                        a.getInvalidateRegion(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop, region, invalidationTransform);
                        parent.mPrivateFlags |= View.PFLAG_DRAW_ANIMATION;
                        const left = this.mLeft + Math.floor(region.left);
                        const top = this.mTop + Math.floor(region.top);
                        parent.invalidate(left, top, left + Math.floor((region.width() + .5)), top + Math.floor((region.height() + .5)));
                    }
                }
                return more;
            }
            onDrawScrollBars(canvas) {
                const cache = this.mScrollCache;
                if (cache != null) {
                    let state = cache.state;
                    if (state == ScrollabilityCache.OFF) {
                        return;
                    }
                    let invalidate = false;
                    if (state == ScrollabilityCache.FADING) {
                        cache._computeAlphaToScrollBar();
                        invalidate = true;
                    }
                    else {
                        cache.scrollBar.setAlpha(255);
                    }
                    const viewFlags = this.mViewFlags;
                    const drawHorizontalScrollBar = (viewFlags & View.SCROLLBARS_HORIZONTAL) == View.SCROLLBARS_HORIZONTAL;
                    const drawVerticalScrollBar = (viewFlags & View.SCROLLBARS_VERTICAL) == View.SCROLLBARS_VERTICAL
                        && !this.isVerticalScrollBarHidden();
                    if (drawVerticalScrollBar || drawHorizontalScrollBar) {
                        const width = this.mRight - this.mLeft;
                        const height = this.mBottom - this.mTop;
                        const scrollBar = cache.scrollBar;
                        const scrollX = this.mScrollX;
                        const scrollY = this.mScrollY;
                        const inside = true;
                        let left;
                        let top;
                        let right;
                        let bottom;
                        if (drawHorizontalScrollBar) {
                            let size = scrollBar.getSize(false);
                            if (size <= 0) {
                                size = cache.scrollBarSize;
                            }
                            scrollBar.setParameters(this.computeHorizontalScrollRange(), this.computeHorizontalScrollOffset(), this.computeHorizontalScrollExtent(), false);
                            const verticalScrollBarGap = drawVerticalScrollBar ?
                                this.getVerticalScrollbarWidth() : 0;
                            top = scrollY + height - size;
                            left = scrollX + (this.mPaddingLeft);
                            right = scrollX + width - -verticalScrollBarGap;
                            bottom = top + size;
                            this.onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                            if (invalidate) {
                                this.invalidate(left, top, right, bottom);
                            }
                        }
                        if (drawVerticalScrollBar) {
                            let size = scrollBar.getSize(true);
                            if (size <= 0) {
                                size = cache.scrollBarSize;
                            }
                            scrollBar.setParameters(this.computeVerticalScrollRange(), this.computeVerticalScrollOffset(), this.computeVerticalScrollExtent(), true);
                            left = scrollX + width - size;
                            top = scrollY + (this.mPaddingTop);
                            right = left + size;
                            bottom = scrollY + height;
                            this.onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                            if (invalidate) {
                                this.invalidate(left, top, right, bottom);
                            }
                        }
                    }
                }
            }
            isVerticalScrollBarHidden() {
                return false;
            }
            onDrawHorizontalScrollBar(canvas, scrollBar, l, t, r, b) {
                scrollBar.setBounds(l, t, r, b);
                scrollBar.draw(canvas);
            }
            onDrawVerticalScrollBar(canvas, scrollBar, l, t, r, b) {
                scrollBar.setBounds(l, t, r, b);
                scrollBar.draw(canvas);
            }
            isHardwareAccelerated() {
                return false;
            }
            setDrawingCacheEnabled(enabled) {
                this.mCachingFailed = false;
                this.setFlags(enabled ? View.DRAWING_CACHE_ENABLED : 0, View.DRAWING_CACHE_ENABLED);
            }
            isDrawingCacheEnabled() {
                return (this.mViewFlags & View.DRAWING_CACHE_ENABLED) == View.DRAWING_CACHE_ENABLED;
            }
            getDrawingCache(autoScale = false) {
                if ((this.mViewFlags & View.WILL_NOT_CACHE_DRAWING) == View.WILL_NOT_CACHE_DRAWING) {
                    return null;
                }
                if ((this.mViewFlags & View.DRAWING_CACHE_ENABLED) == View.DRAWING_CACHE_ENABLED) {
                    this.buildDrawingCache(autoScale);
                }
                return this.mUnscaledDrawingCache;
            }
            setDrawingCacheBackgroundColor(color) {
                if (color != this.mDrawingCacheBackgroundColor) {
                    this.mDrawingCacheBackgroundColor = color;
                    this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                }
            }
            getDrawingCacheBackgroundColor() {
                return this.mDrawingCacheBackgroundColor;
            }
            destroyDrawingCache() {
                if (this.mUnscaledDrawingCache != null) {
                    this.mUnscaledDrawingCache.recycle();
                    this.mUnscaledDrawingCache = null;
                }
            }
            buildDrawingCache(autoScale = false) {
                if ((this.mPrivateFlags & View.PFLAG_DRAWING_CACHE_VALID) == 0 || this.mUnscaledDrawingCache == null) {
                    this.mCachingFailed = false;
                    let width = this.mRight - this.mLeft;
                    let height = this.mBottom - this.mTop;
                    const attachInfo = this.mAttachInfo;
                    const drawingCacheBackgroundColor = this.mDrawingCacheBackgroundColor;
                    const opaque = drawingCacheBackgroundColor != 0 || this.isOpaque();
                    const projectedBitmapSize = width * height * 4;
                    const drawingCacheSize = view_2.ViewConfiguration.get().getScaledMaximumDrawingCacheSize();
                    if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
                        if (width > 0 && height > 0) {
                            Log.w(View.VIEW_LOG_TAG, "View too large to fit into drawing cache, needs " + projectedBitmapSize + " bytes, only " + drawingCacheSize + " available");
                        }
                        this.destroyDrawingCache();
                        this.mCachingFailed = true;
                        return;
                    }
                    if (this.mUnscaledDrawingCache &&
                        (this.mUnscaledDrawingCache.getWidth() !== width || this.mUnscaledDrawingCache.getHeight() !== height)) {
                        this.mUnscaledDrawingCache.recycle();
                        this.mUnscaledDrawingCache = null;
                    }
                    if (this.mUnscaledDrawingCache) {
                        this.mUnscaledDrawingCache.clearColor();
                    }
                    else {
                        this.mUnscaledDrawingCache = new Canvas(width, height);
                    }
                    const canvas = this.mUnscaledDrawingCache;
                    this.computeScroll();
                    const restoreCount = canvas.save();
                    canvas.translate(-this.mScrollX, -this.mScrollY);
                    this.mPrivateFlags |= View.PFLAG_DRAWN;
                    this.mPrivateFlags |= View.PFLAG_DRAWING_CACHE_VALID;
                    if ((this.mPrivateFlags & View.PFLAG_SKIP_DRAW) == View.PFLAG_SKIP_DRAW) {
                        this.mPrivateFlags &= ~View.PFLAG_DIRTY_MASK;
                        this.dispatchDraw(canvas);
                        if (this.mOverlay != null && !this.mOverlay.isEmpty()) {
                            this.mOverlay.getOverlayView().draw(canvas);
                        }
                    }
                    else {
                        this.draw(canvas);
                    }
                    canvas.restoreToCount(restoreCount);
                }
            }
            setWillNotDraw(willNotDraw) {
                this.setFlags(willNotDraw ? View.WILL_NOT_DRAW : 0, View.DRAW_MASK);
            }
            willNotDraw() {
                return (this.mViewFlags & View.DRAW_MASK) == View.WILL_NOT_DRAW;
            }
            setWillNotCacheDrawing(willNotCacheDrawing) {
                this.setFlags(willNotCacheDrawing ? View.WILL_NOT_CACHE_DRAWING : 0, View.WILL_NOT_CACHE_DRAWING);
            }
            willNotCacheDrawing() {
                return (this.mViewFlags & View.WILL_NOT_CACHE_DRAWING) == View.WILL_NOT_CACHE_DRAWING;
            }
            drawableSizeChange(who) {
                if (who === this.mBackground) {
                    let w = who.getIntrinsicWidth();
                    if (w < 0)
                        w = this.mBackgroundWidth;
                    let h = who.getIntrinsicHeight();
                    if (h < 0)
                        h = this.mBackgroundHeight;
                    if (w != this.mBackgroundWidth || h != this.mBackgroundHeight) {
                        this.mBackgroundWidth = w;
                        this.mBackgroundHeight = h;
                        this.requestLayout();
                    }
                }
                else if (this.verifyDrawable(who)) {
                    this.requestLayout();
                }
            }
            invalidateDrawable(drawable) {
                if (this.verifyDrawable(drawable)) {
                    const dirty = drawable.getBounds();
                    const scrollX = this.mScrollX;
                    const scrollY = this.mScrollY;
                    this.invalidate(dirty.left + scrollX, dirty.top + scrollY, dirty.right + scrollX, dirty.bottom + scrollY);
                }
            }
            scheduleDrawable(who, what, when) {
                if (this.verifyDrawable(who) && what != null) {
                    const delay = when - SystemClock.uptimeMillis();
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mHandler.postAtTime(what, who, when);
                    }
                    else {
                        view_2.ViewRootImpl.getRunQueue().postDelayed(what, delay);
                    }
                }
            }
            unscheduleDrawable(who, what) {
                if (this.verifyDrawable(who) && what != null) {
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mHandler.removeCallbacks(what, who);
                    }
                    else {
                        view_2.ViewRootImpl.getRunQueue().removeCallbacks(what);
                    }
                }
                else if (what === null) {
                    if (this.mAttachInfo != null && who != null) {
                        this.mAttachInfo.mHandler.removeCallbacksAndMessages(who);
                    }
                }
            }
            verifyDrawable(who) {
                return who == this.mBackground;
            }
            drawableStateChanged() {
                this.getDrawableState();
                let d = this.mBackground;
                if (d != null && d.isStateful()) {
                    d.setState(this.getDrawableState());
                }
            }
            resolveDrawables() {
            }
            refreshDrawableState() {
                this.mPrivateFlags |= View.PFLAG_DRAWABLE_STATE_DIRTY;
                this.drawableStateChanged();
                let parent = this.mParent;
                if (parent != null) {
                    parent.childDrawableStateChanged(this);
                }
            }
            getDrawableState() {
                if ((this.mDrawableState != null) && ((this.mPrivateFlags & View.PFLAG_DRAWABLE_STATE_DIRTY) == 0)) {
                    return this.mDrawableState;
                }
                else {
                    let oldDrawableState = this.mDrawableState;
                    this.mDrawableState = this.onCreateDrawableState(0);
                    this.mPrivateFlags &= ~View.PFLAG_DRAWABLE_STATE_DIRTY;
                    this._fireStateChangeToAttribute(oldDrawableState, this.mDrawableState);
                    this.syncDrawStateToElement();
                    return this.mDrawableState;
                }
            }
            onCreateDrawableState(extraSpace) {
                if ((this.mViewFlags & View.DUPLICATE_PARENT_STATE) == View.DUPLICATE_PARENT_STATE &&
                    this.mParent instanceof View) {
                    return this.mParent.onCreateDrawableState(extraSpace);
                }
                let drawableState;
                let privateFlags = this.mPrivateFlags;
                let viewStateIndex = 0;
                if ((privateFlags & View.PFLAG_PRESSED) != 0)
                    viewStateIndex |= View.VIEW_STATE_PRESSED;
                if ((this.mViewFlags & View.ENABLED_MASK) == View.ENABLED)
                    viewStateIndex |= View.VIEW_STATE_ENABLED;
                if (this.isFocused())
                    viewStateIndex |= View.VIEW_STATE_FOCUSED;
                if ((privateFlags & View.PFLAG_SELECTED) != 0)
                    viewStateIndex |= View.VIEW_STATE_SELECTED;
                if (this.hasWindowFocus())
                    viewStateIndex |= View.VIEW_STATE_WINDOW_FOCUSED;
                if ((privateFlags & View.PFLAG_ACTIVATED) != 0)
                    viewStateIndex |= View.VIEW_STATE_ACTIVATED;
                const privateFlags2 = this.mPrivateFlags2;
                drawableState = View.VIEW_STATE_SETS[viewStateIndex];
                if (extraSpace == 0) {
                    return drawableState;
                }
                let fullState;
                if (drawableState != null) {
                    fullState = new Array(drawableState.length + extraSpace);
                    System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
                }
                else {
                    fullState = new Array(extraSpace);
                }
                return fullState;
            }
            static mergeDrawableStates(baseState, additionalState) {
                const N = baseState.length;
                let i = N - 1;
                while (i >= 0 && !baseState[i]) {
                    i--;
                }
                System.arraycopy(additionalState, 0, baseState, i + 1, additionalState.length);
                return baseState;
            }
            jumpDrawablesToCurrentState() {
                if (this.mBackground != null) {
                    this.mBackground.jumpToCurrentState();
                }
            }
            setBackgroundColor(color) {
                if (this.mBackground instanceof ColorDrawable) {
                    this.mBackground.mutate().setColor(color);
                    this.computeOpaqueFlags();
                }
                else {
                    this.setBackground(new ColorDrawable(color));
                }
            }
            setBackground(background) {
                this.setBackgroundDrawable(background);
            }
            getBackground() {
                return this.mBackground;
            }
            setBackgroundDrawable(background) {
                this.computeOpaqueFlags();
                if (background == this.mBackground) {
                    return;
                }
                let requestLayout = false;
                if (this.mBackground != null) {
                    this.mBackground.setCallback(null);
                    this.unscheduleDrawable(this.mBackground);
                }
                if (background != null) {
                    let padding = new Rect();
                    if (background.getPadding(padding)) {
                        this.setPadding(padding.left, padding.top, padding.right, padding.bottom);
                    }
                    if (this.mBackground == null || this.mBackground.getMinimumHeight() != background.getMinimumHeight() ||
                        this.mBackground.getMinimumWidth() != background.getMinimumWidth()) {
                        requestLayout = true;
                    }
                    background.setCallback(this);
                    if (background.isStateful()) {
                        background.setState(this.getDrawableState());
                    }
                    background.setVisible(this.getVisibility() == View.VISIBLE, false);
                    this.mBackground = background;
                    this.mBackgroundWidth = background.getIntrinsicWidth();
                    this.mBackgroundHeight = background.getIntrinsicHeight();
                    if ((this.mPrivateFlags & View.PFLAG_SKIP_DRAW) != 0) {
                        this.mPrivateFlags &= ~View.PFLAG_SKIP_DRAW;
                        this.mPrivateFlags |= View.PFLAG_ONLY_DRAWS_BACKGROUND;
                        requestLayout = true;
                    }
                }
                else {
                    this.mBackground = null;
                    this.mBackgroundWidth = this.mBackgroundHeight = -1;
                    if ((this.mPrivateFlags & View.PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
                        this.mPrivateFlags &= ~View.PFLAG_ONLY_DRAWS_BACKGROUND;
                        this.mPrivateFlags |= View.PFLAG_SKIP_DRAW;
                    }
                    requestLayout = true;
                }
                this.computeOpaqueFlags();
                if (requestLayout) {
                    this.requestLayout();
                }
                this.mBackgroundSizeChanged = true;
                this.mShadowDrawable = null;
                this.invalidate(true);
            }
            computeHorizontalScrollRange() {
                return this.getWidth();
            }
            computeHorizontalScrollOffset() {
                return this.mScrollX;
            }
            computeHorizontalScrollExtent() {
                return this.getWidth();
            }
            computeVerticalScrollRange() {
                return this.getHeight();
            }
            computeVerticalScrollOffset() {
                return this.mScrollY;
            }
            computeVerticalScrollExtent() {
                return this.getHeight();
            }
            canScrollHorizontally(direction) {
                const offset = this.computeHorizontalScrollOffset();
                const range = this.computeHorizontalScrollRange() - this.computeHorizontalScrollExtent();
                if (range == 0)
                    return false;
                if (direction < 0) {
                    return offset > 0;
                }
                else {
                    return offset < range - 1;
                }
            }
            canScrollVertically(direction) {
                const offset = this.computeVerticalScrollOffset();
                const range = this.computeVerticalScrollRange() - this.computeVerticalScrollExtent();
                if (range == 0)
                    return false;
                if (direction < 0) {
                    return offset > 0;
                }
                else {
                    return offset < range - 1;
                }
            }
            overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent) {
                const overScrollMode = this.mOverScrollMode;
                const canScrollHorizontal = this.computeHorizontalScrollRange() > this.computeHorizontalScrollExtent();
                const canScrollVertical = this.computeVerticalScrollRange() > this.computeVerticalScrollExtent();
                const overScrollHorizontal = overScrollMode == View.OVER_SCROLL_ALWAYS ||
                    (overScrollMode == View.OVER_SCROLL_IF_CONTENT_SCROLLS && canScrollHorizontal);
                const overScrollVertical = overScrollMode == View.OVER_SCROLL_ALWAYS ||
                    (overScrollMode == View.OVER_SCROLL_IF_CONTENT_SCROLLS && canScrollVertical);
                if (isTouchEvent) {
                    if ((deltaX < 0 && scrollX <= 0) || (deltaX > 0 && scrollX >= scrollRangeX)) {
                        deltaX /= 2;
                    }
                    if ((deltaY < 0 && scrollY <= 0) || (deltaY > 0 && scrollY >= scrollRangeY)) {
                        deltaY /= 2;
                    }
                }
                let newScrollX = scrollX + deltaX;
                if (!overScrollHorizontal) {
                    maxOverScrollX = 0;
                }
                let newScrollY = scrollY + deltaY;
                if (!overScrollVertical) {
                    maxOverScrollY = 0;
                }
                const left = -maxOverScrollX;
                const right = maxOverScrollX + scrollRangeX;
                const top = -maxOverScrollY;
                const bottom = maxOverScrollY + scrollRangeY;
                let clampedX = false;
                if (newScrollX > right) {
                    newScrollX = right;
                    clampedX = true;
                }
                else if (newScrollX < left) {
                    newScrollX = left;
                    clampedX = true;
                }
                let clampedY = false;
                if (newScrollY > bottom) {
                    newScrollY = bottom;
                    clampedY = true;
                }
                else if (newScrollY < top) {
                    newScrollY = top;
                    clampedY = true;
                }
                this.onOverScrolled(newScrollX, newScrollY, clampedX, clampedY);
                return clampedX || clampedY;
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
            }
            getOverScrollMode() {
                return this.mOverScrollMode;
            }
            setOverScrollMode(overScrollMode) {
                if (overScrollMode != View.OVER_SCROLL_ALWAYS &&
                    overScrollMode != View.OVER_SCROLL_IF_CONTENT_SCROLLS &&
                    overScrollMode != View.OVER_SCROLL_NEVER) {
                    throw new Error("Invalid overscroll mode " + overScrollMode);
                }
                this.mOverScrollMode = overScrollMode;
            }
            getVerticalScrollFactor() {
                if (this.mVerticalScrollFactor == 0) {
                    this.mVerticalScrollFactor = Resources.getDisplayMetrics().density * 1;
                }
                return this.mVerticalScrollFactor;
            }
            getHorizontalScrollFactor() {
                return this.getVerticalScrollFactor();
            }
            computeScroll() {
            }
            scrollTo(x, y) {
                if (this.mScrollX != x || this.mScrollY != y) {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    this.mScrollX = x;
                    this.mScrollY = y;
                    this.invalidateParentCaches();
                    this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                    if (!this.awakenScrollBars()) {
                        this.postInvalidateOnAnimation();
                    }
                }
            }
            scrollBy(x, y) {
                this.scrollTo(this.mScrollX + x, this.mScrollY + y);
            }
            initialAwakenScrollBars() {
                return this.mScrollCache != null &&
                    this.awakenScrollBars(this.mScrollCache.scrollBarDefaultDelayBeforeFade * 4, true);
            }
            awakenScrollBars(startDelay, invalidate = true) {
                const scrollCache = this.mScrollCache;
                if (scrollCache == null)
                    return false;
                startDelay = startDelay || scrollCache.scrollBarDefaultDelayBeforeFade;
                if (scrollCache == null || !scrollCache.fadeScrollBars) {
                    return false;
                }
                if (scrollCache.scrollBar == null) {
                    scrollCache.scrollBar = new ScrollBarDrawable();
                }
                if (this.isHorizontalScrollBarEnabled() || this.isVerticalScrollBarEnabled()) {
                    if (invalidate) {
                        this.postInvalidateOnAnimation();
                    }
                    if (scrollCache.state == ScrollabilityCache.OFF) {
                        const KEY_REPEAT_FIRST_DELAY = 750;
                        startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
                    }
                    let fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
                    scrollCache.fadeStartTime = fadeStartTime;
                    scrollCache.state = ScrollabilityCache.ON;
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mHandler.removeCallbacks(scrollCache);
                        this.mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
                    }
                    return true;
                }
                return false;
            }
            getVerticalFadingEdgeLength() {
                return 0;
            }
            setVerticalFadingEdgeEnabled(enable) {
            }
            setHorizontalFadingEdgeEnabled(enable) {
            }
            setFadingEdgeLength(length) {
            }
            getHorizontalFadingEdgeLength() {
                return 0;
            }
            getVerticalScrollbarWidth() {
                let cache = this.mScrollCache;
                if (cache != null) {
                    let scrollBar = cache.scrollBar;
                    if (scrollBar != null) {
                        let size = scrollBar.getSize(true);
                        if (size <= 0) {
                            size = cache.scrollBarSize;
                        }
                        return size;
                    }
                    return 0;
                }
                return 0;
            }
            getHorizontalScrollbarHeight() {
                let cache = this.mScrollCache;
                if (cache != null) {
                    let scrollBar = cache.scrollBar;
                    if (scrollBar != null) {
                        let size = scrollBar.getSize(false);
                        if (size <= 0) {
                            size = cache.scrollBarSize;
                        }
                        return size;
                    }
                    return 0;
                }
                return 0;
            }
            initializeScrollbars(a) {
                this.initScrollCache();
            }
            initScrollCache() {
                if (this.mScrollCache == null) {
                    this.mScrollCache = new ScrollabilityCache(this);
                }
            }
            getScrollCache() {
                this.initScrollCache();
                return this.mScrollCache;
            }
            isHorizontalScrollBarEnabled() {
                return (this.mViewFlags & View.SCROLLBARS_HORIZONTAL) == View.SCROLLBARS_HORIZONTAL;
            }
            setHorizontalScrollBarEnabled(horizontalScrollBarEnabled) {
                if (this.isHorizontalScrollBarEnabled() != horizontalScrollBarEnabled) {
                    this.mViewFlags ^= View.SCROLLBARS_HORIZONTAL;
                    this.computeOpaqueFlags();
                }
            }
            isVerticalScrollBarEnabled() {
                return (this.mViewFlags & View.SCROLLBARS_VERTICAL) == View.SCROLLBARS_VERTICAL;
            }
            setVerticalScrollBarEnabled(verticalScrollBarEnabled) {
                if (this.isVerticalScrollBarEnabled() != verticalScrollBarEnabled) {
                    this.mViewFlags ^= View.SCROLLBARS_VERTICAL;
                    this.computeOpaqueFlags();
                }
            }
            setScrollbarFadingEnabled(fadeScrollbars) {
                this.initScrollCache();
                const scrollabilityCache = this.mScrollCache;
                scrollabilityCache.fadeScrollBars = fadeScrollbars;
                if (fadeScrollbars) {
                    scrollabilityCache.state = ScrollabilityCache.OFF;
                }
                else {
                    scrollabilityCache.state = ScrollabilityCache.ON;
                }
            }
            setVerticalScrollbarPosition(position) {
            }
            setHorizontalScrollbarPosition(position) {
            }
            setScrollBarStyle(position) {
            }
            getTopFadingEdgeStrength() {
                return 0;
            }
            getBottomFadingEdgeStrength() {
                return 0;
            }
            getLeftFadingEdgeStrength() {
                return 0;
            }
            getRightFadingEdgeStrength() {
                return 0;
            }
            isScrollbarFadingEnabled() {
                return this.mScrollCache != null && this.mScrollCache.fadeScrollBars;
            }
            getScrollBarDefaultDelayBeforeFade() {
                return this.mScrollCache == null ? view_2.ViewConfiguration.getScrollDefaultDelay() :
                    this.mScrollCache.scrollBarDefaultDelayBeforeFade;
            }
            setScrollBarDefaultDelayBeforeFade(scrollBarDefaultDelayBeforeFade) {
                this.getScrollCache().scrollBarDefaultDelayBeforeFade = scrollBarDefaultDelayBeforeFade;
            }
            getScrollBarFadeDuration() {
                return this.mScrollCache == null ? view_2.ViewConfiguration.getScrollBarFadeDuration() :
                    this.mScrollCache.scrollBarFadeDuration;
            }
            setScrollBarFadeDuration(scrollBarFadeDuration) {
                this.getScrollCache().scrollBarFadeDuration = scrollBarFadeDuration;
            }
            getScrollBarSize() {
                return this.mScrollCache == null ? view_2.ViewConfiguration.get().getScaledScrollBarSize() :
                    this.mScrollCache.scrollBarSize;
            }
            setScrollBarSize(scrollBarSize) {
                this.getScrollCache().scrollBarSize = scrollBarSize;
            }
            hasOpaqueScrollbars() {
                return true;
            }
            assignParent(parent) {
                if (this.mParent == null) {
                    this.mParent = parent;
                }
                else if (parent == null) {
                    this.mParent = null;
                }
                else {
                    throw new Error("view " + this + " being added, but"
                        + " it already has a parent");
                }
            }
            onFinishInflate() {
            }
            dispatchStartTemporaryDetach() {
                this.onStartTemporaryDetach();
            }
            onStartTemporaryDetach() {
                this.removeUnsetPressCallback();
                this.mPrivateFlags |= View.PFLAG_CANCEL_NEXT_UP_EVENT;
            }
            dispatchFinishTemporaryDetach() {
                this.onFinishTemporaryDetach();
            }
            onFinishTemporaryDetach() {
            }
            dispatchWindowFocusChanged(hasFocus) {
                this.onWindowFocusChanged(hasFocus);
            }
            onWindowFocusChanged(hasWindowFocus) {
                if (!hasWindowFocus) {
                    if (this.isPressed()) {
                        this.setPressed(false);
                    }
                    this.removeLongPressCallback();
                    this.removeTapCallback();
                    this.onFocusLost();
                }
                this.refreshDrawableState();
            }
            hasWindowFocus() {
                return this.mAttachInfo != null && this.mAttachInfo.mHasWindowFocus;
            }
            getWindowAttachCount() {
                return this.mWindowAttachCount;
            }
            isAttachedToWindow() {
                return this.mAttachInfo != null;
            }
            dispatchAttachedToWindow(info, visibility) {
                this.mAttachInfo = info;
                if (info.mRootView && info.mRootView.mContext)
                    this.mContext = info.mRootView.mContext;
                if (this.mOverlay != null) {
                    this.mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility);
                }
                this.mWindowAttachCount++;
                this.mPrivateFlags |= View.PFLAG_DRAWABLE_STATE_DIRTY;
                if (this.mFloatingTreeObserver != null) {
                    info.mViewRootImpl.mTreeObserver.merge(this.mFloatingTreeObserver);
                    this.mFloatingTreeObserver = null;
                }
                if ((this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER) != 0) {
                    this.mAttachInfo.mScrollContainers.add(this);
                    this.mPrivateFlags |= View.PFLAG_SCROLL_CONTAINER_ADDED;
                }
                this.onAttachedToWindow();
                let li = this.mListenerInfo;
                let listeners = li != null ? li.mOnAttachStateChangeListeners : null;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onViewAttachedToWindow(this);
                    }
                }
                let vis = info.mWindowVisibility;
                if (vis != View.GONE) {
                    this.onWindowVisibilityChanged(vis);
                }
                if ((this.mPrivateFlags & View.PFLAG_DRAWABLE_STATE_DIRTY) != 0) {
                    this.refreshDrawableState();
                }
            }
            onAttachedToWindow() {
                //if ((this.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
                //    this.mParent.requestTransparentRegion(this);
                //}
                if ((this.mPrivateFlags & View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
                    this.initialAwakenScrollBars();
                    this.mPrivateFlags &= ~View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH;
                }
                this.mPrivateFlags3 &= ~View.PFLAG3_IS_LAID_OUT;
                this.jumpDrawablesToCurrentState();
            }
            dispatchDetachedFromWindow() {
                let info = this.mAttachInfo;
                if (info != null) {
                    let vis = info.mWindowVisibility;
                    if (vis != View.GONE) {
                        this.onWindowVisibilityChanged(View.GONE);
                    }
                }
                this.onDetachedFromWindow();
                let li = this.mListenerInfo;
                let listeners = li != null ? li.mOnAttachStateChangeListeners : null;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onViewDetachedFromWindow(this);
                    }
                }
                if ((this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER_ADDED) != 0) {
                    this.mAttachInfo.mScrollContainers.delete(this);
                    this.mPrivateFlags &= ~View.PFLAG_SCROLL_CONTAINER_ADDED;
                }
                this.mAttachInfo = null;
                if (this.mOverlay != null) {
                    this.mOverlay.getOverlayView().dispatchDetachedFromWindow();
                }
            }
            onDetachedFromWindow() {
                this.mPrivateFlags &= ~View.PFLAG_CANCEL_NEXT_UP_EVENT;
                this.mPrivateFlags3 &= ~View.PFLAG3_IS_LAID_OUT;
                this.removeUnsetPressCallback();
                this.removeLongPressCallback();
                this.removePerformClickCallback();
                this.destroyDrawingCache();
                this.cleanupDraw();
                this.mCurrentAnimation = null;
            }
            cleanupDraw() {
                if (this.mAttachInfo != null) {
                    this.mAttachInfo.mViewRootImpl.cancelInvalidate(this);
                }
            }
            isInEditMode() {
                return false;
            }
            debug(depth = 0) {
                let originProto = Object.getPrototypeOf(this);
                console.dir(Object.assign(Object.create(originProto), this));
            }
            toString() {
                return this.tagName();
            }
            getRootView() {
                if (this.mAttachInfo != null) {
                    let v = this.mAttachInfo.mRootView;
                    if (v != null) {
                        return v;
                    }
                }
                let parent = this;
                while (parent.mParent != null && parent.mParent instanceof View) {
                    parent = parent.mParent;
                }
                return parent;
            }
            findViewByPredicateTraversal(predicate, childToSkip) {
                if (predicate.apply(this)) {
                    return this;
                }
                return null;
            }
            findViewById(id) {
                if (!id)
                    return null;
                if (id == this.bindElement.id) {
                    return this;
                }
                return this.findViewTraversal(id);
            }
            findViewTraversal(id) {
                let bindEle = this.bindElement.querySelector('#' + id);
                return bindEle ? bindEle[View.AndroidViewProperty] : null;
            }
            findViewByPredicate(predicate) {
                return this.findViewByPredicateTraversal(predicate, null);
            }
            findViewByPredicateInsideOut(start, predicate) {
                let childToSkip = null;
                for (;;) {
                    let view = start.findViewByPredicateTraversal(predicate, childToSkip);
                    if (view != null || start == this) {
                        return view;
                    }
                    let parent = start.getParent();
                    if (parent == null || !(parent instanceof View)) {
                        return null;
                    }
                    childToSkip = start;
                    start = parent;
                }
            }
            setId(id) {
                if (this.bindElement)
                    this.bindElement.id = id;
            }
            getId() {
                return this.mID;
            }
            getTag() {
                return this.mTag;
            }
            setTag(tag) {
                this.mTag = tag;
            }
            setIsRootNamespace(isRoot) {
                if (isRoot) {
                    this.mPrivateFlags |= View.PFLAG_IS_ROOT_NAMESPACE;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_IS_ROOT_NAMESPACE;
                }
            }
            isRootNamespace() {
                return (this.mPrivateFlags & View.PFLAG_IS_ROOT_NAMESPACE) != 0;
            }
            getResources() {
                let context = this.getContext();
                if (context != null) {
                    return context.getResources();
                }
                return Resources.getSystem();
            }
            static inflate(context, xml, root) {
                return view_2.LayoutInflater.from(context).inflate(xml, root);
            }
            _AttrObserverCallBack(arr, observer) {
                arr.forEach((record) => {
                    let target = record.target;
                    let androidView = target[View.AndroidViewProperty];
                    if (!androidView)
                        return;
                    let attrName = record.attributeName;
                    let newValue = target.getAttribute(attrName);
                    let oldValue = record.oldValue;
                    if (newValue === oldValue)
                        return;
                    androidView.onBindElementAttributeChanged(attrName, record.oldValue, newValue);
                });
            }
            initBindElement(bindElement) {
                if (this.bindElement) {
                    this.bindElement[View.AndroidViewProperty] = null;
                }
                this.bindElement = bindElement || document.createElement(this.tagName());
                this.bindElementOnClickAttr = this.bindElement.getAttribute('onclick');
                this.bindElement.removeAttribute('onclick');
                if (this.bindElementOnClickAttr)
                    this.setClickable(true);
                this.bindElement.style.position = 'absolute';
                let oldBindView = this.bindElement[View.AndroidViewProperty];
                if (oldBindView) {
                    if (oldBindView._AttrObserver)
                        oldBindView._AttrObserver.disconnect();
                }
                this.bindElement[View.AndroidViewProperty] = this;
                this._stateAttrList = new StateAttrList(this);
                this._parseInitedAttribute();
                this._initAttrObserver();
            }
            requestSyncBoundToElement(immediately = false) {
                let rootView = this.getRootView();
                if (!rootView)
                    return;
                if (!rootView._syncToElementRun) {
                    rootView._syncToElementRun = {
                        run: () => {
                            rootView._syncToElementLock = false;
                            rootView._syncToElementImmediatelyLock = false;
                            rootView._syncBoundAndScrollToElement();
                        }
                    };
                }
                if (immediately) {
                    if (rootView._syncToElementImmediatelyLock)
                        return;
                    rootView._syncToElementImmediatelyLock = true;
                    rootView._syncToElementLock = true;
                    rootView.removeCallbacks(rootView._syncToElementRun);
                    rootView.post(rootView._syncToElementRun);
                    return;
                }
                if (rootView._syncToElementLock)
                    return;
                rootView._syncToElementLock = true;
                rootView.postDelayed(rootView._syncToElementRun, 1000);
            }
            _syncBoundAndScrollToElement() {
                this._syncBoundToElement();
                this._syncScrollToElement();
                if (this instanceof view_2.ViewGroup) {
                    const group = this;
                    for (var i = 0, count = group.getChildCount(); i < count; i++) {
                        group.getChildAt(i)._syncBoundAndScrollToElement();
                    }
                }
            }
            _syncBoundToElement() {
                const left = this.mLeft;
                const top = this.mTop;
                const width = this.getWidth();
                const height = this.getHeight();
                if (left !== this._lastSyncLeft || top !== this._lastSyncTop
                    || width !== this._lastSyncWidth || height !== this._lastSyncHeight) {
                    this._lastSyncLeft = left;
                    this._lastSyncTop = top;
                    this._lastSyncWidth = width;
                    this._lastSyncHeight = height;
                    const density = this.getResources().getDisplayMetrics().density;
                    let bind = this.bindElement;
                    bind.style.transform = bind.style.webkitTransform = `translate(${left / density}px, ${top / density}px)`;
                    bind.style.width = width / density + 'px';
                    bind.style.height = height / density + 'px';
                }
            }
            _syncScrollToElement() {
                let sx = this.mScrollX;
                let sy = this.mScrollY;
                if (this._lastSyncScrollX !== sx || this._lastSyncScrollY !== sy) {
                    this._lastSyncScrollX = sx;
                    this._lastSyncScrollY = sy;
                    if (this instanceof view_2.ViewGroup) {
                        let group = this;
                        for (let i = 0, count = group.getChildCount(); i < count; i++) {
                            let child = group.getChildAt(i);
                            let item = child.bindElement;
                            const density = this.getResources().getDisplayMetrics().density;
                            let tx = (child.mLeft - sx) / density;
                            let ty = (child.mTop - sy) / density;
                            item.style.transform = item.style.webkitTransform = `translate(${tx}px, ${ty}px)`;
                        }
                    }
                }
            }
            syncVisibleToElement() {
                let visibility = this.getVisibility();
                if (visibility === View.VISIBLE) {
                    this.bindElement.style.display = '';
                    this.bindElement.style.visibility = '';
                }
                else if (visibility === View.INVISIBLE) {
                    this.bindElement.style.display = '';
                    this.bindElement.style.visibility = 'hidden';
                }
                else {
                    this.bindElement.style.display = 'none';
                    this.bindElement.style.visibility = '';
                }
            }
            syncDrawStateToElement() {
                const bind = this.bindElement;
                if (this.isPressed())
                    bind.classList.add('_pressed');
                else
                    bind.classList.remove('_pressed');
                if (this.isEnabled())
                    bind.classList.remove('_disabled');
                else
                    bind.classList.add('_disabled');
                if (this.isFocused())
                    bind.classList.add('_focused');
                else
                    bind.classList.remove('_focused');
                if (this.isSelected())
                    bind.classList.add('_selected');
                else
                    bind.classList.remove('_selected');
                if (this.isActivated())
                    bind.classList.add('_activated');
                else
                    bind.classList.remove('_activated');
            }
            _initAttrObserver() {
                if (!this._AttrObserver)
                    this._AttrObserver = new MutationObserver(this._AttrObserverCallBack);
                else
                    this._AttrObserver.disconnect();
                this._AttrObserver.observe(this.bindElement, { attributes: true, attributeOldValue: true });
            }
            _parseInitedAttribute() {
                for (let [key, value] of this._stateAttrList.getDefaultStateAttr().getAttrMap().entries()) {
                    key = 'android:' + key;
                    this.bindElement.removeAttribute(key);
                    if (value != null) {
                        this.bindElement.setAttribute(key, value);
                    }
                }
                let id = this.bindElement.getAttribute('android:id');
                if (id)
                    this.bindElement.id = id;
            }
            _fireInitedAttributeChange() {
                for (let attr of Array.from(this.bindElement.attributes)) {
                    this.onBindElementAttributeChanged(attr.name, null, attr.value);
                }
            }
            _fireStateChangeToAttribute(oldState, newState) {
                if (!this._stateAttrList)
                    return;
                if (oldState + '' === newState + '')
                    return;
                let oldMatchedAttr = oldState ? this._stateAttrList.getMatchedAttr(oldState) : null;
                let matchedAttr = this._stateAttrList.getMatchedAttr(newState);
                let attrMap = matchedAttr.mergeRemovedFrom(oldMatchedAttr);
                for (let [key, value] of attrMap.entries()) {
                    if (oldMatchedAttr) {
                        let oldValue;
                        if (key.startsWith('layout_')) {
                            let params = this.getLayoutParams();
                            if (params) {
                                let attrName = key.substring('layout_'.length);
                                oldValue = params._attrBinder.getAttrValue(attrName);
                            }
                        }
                        else {
                            oldValue = this._attrBinder.getAttrValue(key);
                        }
                        if (oldValue != null) {
                            oldMatchedAttr.setAttr(key, oldValue);
                        }
                    }
                    key = 'android:' + key;
                    if ((value === null || value === undefined)) {
                        if (this.bindElement.hasAttribute(key)) {
                            this.bindElement.removeAttribute(key);
                        }
                        else {
                            this.onBindElementAttributeChanged(key, null, null);
                        }
                    }
                    else {
                        this.bindElement.setAttribute(key, value);
                    }
                }
            }
            onBindElementAttributeChanged(attributeName, oldVal, newVal) {
                let parts = attributeName.split(":");
                let attrName = parts[parts.length - 1].toLowerCase();
                if (newVal === 'true')
                    newVal = true;
                else if (newVal === 'false')
                    newVal = false;
                if (attrName.startsWith('layout_')) {
                    attrName = attrName.substring('layout_'.length);
                    let params = this.getLayoutParams();
                    if (params) {
                        params._attrBinder.onAttrChange(attrName, newVal, this.getContext());
                        this.requestLayout();
                    }
                    return;
                }
                this._attrBinder.onAttrChange(attrName, newVal, this.getContext());
            }
            hasAttributeIgnoreCase(name) {
                return this.getAttributeIgnoreCase(name) != null;
            }
            getAttributeIgnoreCase(name) {
                if (!(typeof name === 'string'))
                    return null;
                name = name.toLowerCase();
                if (name.startsWith('android:'))
                    name = name.substring('android:'.length);
                for (let attr of Array.from(this.bindElement.attributes)) {
                    let attrName = attr.name.toLowerCase();
                    if (attrName.startsWith('android:'))
                        attrName = attrName.substring('android:'.length);
                    if (attrName == name)
                        return attr.value;
                }
                return null;
            }
            applyDefaultAttributes(attrs) {
                for (let key in attrs) {
                    if (!this.hasAttributeIgnoreCase(key)) {
                        this._attrBinder.onAttrChange(key, attrs[key], this.getContext());
                    }
                }
            }
            tagName() {
                return this.constructor.name;
            }
        }
        View.DBG = Log.View_DBG;
        View.VIEW_LOG_TAG = "View";
        View.PFLAG_WANTS_FOCUS = 0x00000001;
        View.PFLAG_FOCUSED = 0x00000002;
        View.PFLAG_SELECTED = 0x00000004;
        View.PFLAG_IS_ROOT_NAMESPACE = 0x00000008;
        View.PFLAG_HAS_BOUNDS = 0x00000010;
        View.PFLAG_DRAWN = 0x00000020;
        View.PFLAG_DRAW_ANIMATION = 0x00000040;
        View.PFLAG_SKIP_DRAW = 0x00000080;
        View.PFLAG_ONLY_DRAWS_BACKGROUND = 0x00000100;
        View.PFLAG_REQUEST_TRANSPARENT_REGIONS = 0x00000200;
        View.PFLAG_DRAWABLE_STATE_DIRTY = 0x00000400;
        View.PFLAG_MEASURED_DIMENSION_SET = 0x00000800;
        View.PFLAG_FORCE_LAYOUT = 0x00001000;
        View.PFLAG_LAYOUT_REQUIRED = 0x00002000;
        View.PFLAG_PRESSED = 0x00004000;
        View.PFLAG_DRAWING_CACHE_VALID = 0x00008000;
        View.PFLAG_ANIMATION_STARTED = 0x00010000;
        View.PFLAG_ALPHA_SET = 0x00040000;
        View.PFLAG_SCROLL_CONTAINER = 0x00080000;
        View.PFLAG_SCROLL_CONTAINER_ADDED = 0x00100000;
        View.PFLAG_DIRTY = 0x00200000;
        View.PFLAG_DIRTY_OPAQUE = 0x00400000;
        View.PFLAG_DIRTY_MASK = 0x00600000;
        View.PFLAG_OPAQUE_BACKGROUND = 0x00800000;
        View.PFLAG_OPAQUE_SCROLLBARS = 0x01000000;
        View.PFLAG_OPAQUE_MASK = 0x01800000;
        View.PFLAG_PREPRESSED = 0x02000000;
        View.PFLAG_CANCEL_NEXT_UP_EVENT = 0x04000000;
        View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH = 0x08000000;
        View.PFLAG_HOVERED = 0x10000000;
        View.PFLAG_PIVOT_EXPLICITLY_SET = 0x20000000;
        View.PFLAG_ACTIVATED = 0x40000000;
        View.PFLAG_INVALIDATED = 0x80000000;
        View.PFLAG2_VIEW_QUICK_REJECTED = 0x10000000;
        View.PFLAG2_HAS_TRANSIENT_STATE = 0x80000000;
        View.PFLAG3_VIEW_IS_ANIMATING_TRANSFORM = 0x1;
        View.PFLAG3_VIEW_IS_ANIMATING_ALPHA = 0x2;
        View.PFLAG3_IS_LAID_OUT = 0x4;
        View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT = 0x8;
        View.PFLAG3_CALLED_SUPER = 0x10;
        View.NOT_FOCUSABLE = 0x00000000;
        View.FOCUSABLE = 0x00000001;
        View.FOCUSABLE_MASK = 0x00000001;
        View.OVER_SCROLL_ALWAYS = 0;
        View.OVER_SCROLL_IF_CONTENT_SCROLLS = 1;
        View.OVER_SCROLL_NEVER = 2;
        View.MEASURED_SIZE_MASK = 0x00ffffff;
        View.MEASURED_STATE_MASK = 0xff000000;
        View.MEASURED_HEIGHT_STATE_SHIFT = 16;
        View.MEASURED_STATE_TOO_SMALL = 0x01000000;
        View.VISIBILITY_MASK = 0x0000000C;
        View.VISIBLE = 0x00000000;
        View.INVISIBLE = 0x00000004;
        View.GONE = 0x00000008;
        View.ENABLED = 0x00000000;
        View.DISABLED = 0x00000020;
        View.ENABLED_MASK = 0x00000020;
        View.WILL_NOT_DRAW = 0x00000080;
        View.DRAW_MASK = 0x00000080;
        View.SCROLLBARS_NONE = 0x00000000;
        View.SCROLLBARS_HORIZONTAL = 0x00000100;
        View.SCROLLBARS_VERTICAL = 0x00000200;
        View.SCROLLBARS_MASK = 0x00000300;
        View.FOCUSABLES_ALL = 0x00000000;
        View.FOCUSABLES_TOUCH_MODE = 0x00000001;
        View.FOCUS_BACKWARD = 0x00000001;
        View.FOCUS_FORWARD = 0x00000002;
        View.FOCUS_LEFT = 0x00000011;
        View.FOCUS_UP = 0x00000021;
        View.FOCUS_RIGHT = 0x00000042;
        View.FOCUS_DOWN = 0x00000082;
        View.VIEW_STATE_WINDOW_FOCUSED = 1;
        View.VIEW_STATE_SELECTED = 1 << 1;
        View.VIEW_STATE_FOCUSED = 1 << 2;
        View.VIEW_STATE_ENABLED = 1 << 3;
        View.VIEW_STATE_DISABLE = -View.VIEW_STATE_ENABLED;
        View.VIEW_STATE_PRESSED = 1 << 4;
        View.VIEW_STATE_ACTIVATED = 1 << 5;
        View.VIEW_STATE_HOVERED = 1 << 7;
        View.VIEW_STATE_CHECKED = 1 << 10;
        View.VIEW_STATE_MULTILINE = 1 << 11;
        View.VIEW_STATE_EXPANDED = 1 << 12;
        View.VIEW_STATE_EMPTY = 1 << 13;
        View.VIEW_STATE_LAST = 1 << 14;
        View.VIEW_STATE_IDS = [
            View.VIEW_STATE_WINDOW_FOCUSED, View.VIEW_STATE_WINDOW_FOCUSED,
            View.VIEW_STATE_SELECTED, View.VIEW_STATE_SELECTED,
            View.VIEW_STATE_FOCUSED, View.VIEW_STATE_FOCUSED,
            View.VIEW_STATE_ENABLED, View.VIEW_STATE_ENABLED,
            View.VIEW_STATE_PRESSED, View.VIEW_STATE_PRESSED,
            View.VIEW_STATE_ACTIVATED, View.VIEW_STATE_ACTIVATED,
            View.VIEW_STATE_HOVERED, View.VIEW_STATE_HOVERED,
        ];
        View._static = (() => {
            function Integer_bitCount(i) {
                i = i - ((i >>> 1) & 0x55555555);
                i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
                i = (i + (i >>> 4)) & 0x0f0f0f0f;
                i = i + (i >>> 8);
                i = i + (i >>> 16);
                return i & 0x3f;
            }
            let orderedIds = View.VIEW_STATE_IDS;
            const NUM_BITS = View.VIEW_STATE_IDS.length / 2;
            View.VIEW_STATE_SETS = new Array(1 << NUM_BITS);
            for (let i = 0; i < View.VIEW_STATE_SETS.length; i++) {
                let numBits = Integer_bitCount(i);
                const stataSet = new Array(numBits);
                let pos = 0;
                for (let j = 0; j < orderedIds.length; j += 2) {
                    if ((i & orderedIds[j + 1]) != 0) {
                        stataSet[pos++] = orderedIds[j];
                    }
                }
                View.VIEW_STATE_SETS[i] = stataSet;
            }
            View.EMPTY_STATE_SET = View.VIEW_STATE_SETS[0];
            View.WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED];
            View.SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED];
            View.SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED];
            View.FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED];
            View.FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED];
            View.FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED];
            View.FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED];
            View.ENABLED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_ENABLED];
            View.ENABLED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED];
            View.ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.PRESSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_PRESSED];
            View.PRESSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_PRESSED];
            View.PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
        })();
        View.CLICKABLE = 0x00004000;
        View.DRAWING_CACHE_ENABLED = 0x00008000;
        View.WILL_NOT_CACHE_DRAWING = 0x000020000;
        View.FOCUSABLE_IN_TOUCH_MODE = 0x00040000;
        View.LONG_CLICKABLE = 0x00200000;
        View.DUPLICATE_PARENT_STATE = 0x00400000;
        View.LAYER_TYPE_NONE = 0;
        View.LAYER_TYPE_SOFTWARE = 1;
        View.LAYOUT_DIRECTION_LTR = LayoutDirection.LTR;
        View.LAYOUT_DIRECTION_RTL = LayoutDirection.RTL;
        View.LAYOUT_DIRECTION_INHERIT = LayoutDirection.INHERIT;
        View.LAYOUT_DIRECTION_LOCALE = LayoutDirection.LOCALE;
        View.TEXT_DIRECTION_INHERIT = 0;
        View.TEXT_DIRECTION_FIRST_STRONG = 1;
        View.TEXT_DIRECTION_ANY_RTL = 2;
        View.TEXT_DIRECTION_LTR = 3;
        View.TEXT_DIRECTION_RTL = 4;
        View.TEXT_DIRECTION_LOCALE = 5;
        View.TEXT_DIRECTION_DEFAULT = View.TEXT_DIRECTION_INHERIT;
        View.TEXT_DIRECTION_RESOLVED_DEFAULT = View.TEXT_DIRECTION_FIRST_STRONG;
        View.TEXT_ALIGNMENT_INHERIT = 0;
        View.TEXT_ALIGNMENT_GRAVITY = 1;
        View.TEXT_ALIGNMENT_TEXT_START = 2;
        View.TEXT_ALIGNMENT_TEXT_END = 3;
        View.TEXT_ALIGNMENT_CENTER = 4;
        View.TEXT_ALIGNMENT_VIEW_START = 5;
        View.TEXT_ALIGNMENT_VIEW_END = 6;
        View.TEXT_ALIGNMENT_DEFAULT = View.TEXT_ALIGNMENT_GRAVITY;
        View.TEXT_ALIGNMENT_RESOLVED_DEFAULT = View.TEXT_ALIGNMENT_GRAVITY;
        View.AndroidViewProperty = 'AndroidView';
        view_2.View = View;
        (function (View) {
            class TransformationInfo {
                constructor() {
                    this.mMatrix = new Matrix();
                    this.mMatrixDirty = false;
                    this.mInverseMatrixDirty = true;
                    this.mMatrixIsIdentity = true;
                    this.mPrevWidth = -1;
                    this.mPrevHeight = -1;
                    this.mRotation = 0;
                    this.mTranslationX = 0;
                    this.mTranslationY = 0;
                    this.mScaleX = 1;
                    this.mScaleY = 1;
                    this.mPivotX = 0;
                    this.mPivotY = 0;
                    this.mAlpha = 1;
                    this.mTransitionAlpha = 1;
                }
            }
            View.TransformationInfo = TransformationInfo;
            class MeasureSpec {
                static makeMeasureSpec(size, mode) {
                    return (size & ~MeasureSpec.MODE_MASK) | (mode & MeasureSpec.MODE_MASK);
                }
                static getMode(measureSpec) {
                    return (measureSpec & MeasureSpec.MODE_MASK);
                }
                static getSize(measureSpec) {
                    return (measureSpec & ~MeasureSpec.MODE_MASK);
                }
                static adjust(measureSpec, delta) {
                    return MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(measureSpec + delta), MeasureSpec.getMode(measureSpec));
                }
                static toString(measureSpec) {
                    let mode = MeasureSpec.getMode(measureSpec);
                    let size = MeasureSpec.getSize(measureSpec);
                    let sb = new StringBuilder("MeasureSpec: ");
                    if (mode == MeasureSpec.UNSPECIFIED)
                        sb.append("UNSPECIFIED ");
                    else if (mode == MeasureSpec.EXACTLY)
                        sb.append("EXACTLY ");
                    else if (mode == MeasureSpec.AT_MOST)
                        sb.append("AT_MOST ");
                    else
                        sb.append(mode).append(" ");
                    sb.append(size);
                    return sb.toString();
                }
            }
            MeasureSpec.MODE_SHIFT = 30;
            MeasureSpec.MODE_MASK = 0x3 << MeasureSpec.MODE_SHIFT;
            MeasureSpec.UNSPECIFIED = 0 << MeasureSpec.MODE_SHIFT;
            MeasureSpec.EXACTLY = 1 << MeasureSpec.MODE_SHIFT;
            MeasureSpec.AT_MOST = 2 << MeasureSpec.MODE_SHIFT;
            View.MeasureSpec = MeasureSpec;
            class AttachInfo {
                constructor(mViewRootImpl, mHandler) {
                    this.mKeyDispatchState = new KeyEvent.DispatcherState();
                    this.mTmpInvalRect = new Rect();
                    this.mTmpTransformRect = new Rect();
                    this.mPoint = new Point();
                    this.mTmpMatrix = new Matrix();
                    this.mTmpTransformation = new Transformation();
                    this.mTmpTransformLocation = new Array(2);
                    this.mScrollContainers = new Set();
                    this.mInvalidateChildLocation = new Array(2);
                    this.mHasWindowFocus = false;
                    this.mWindowVisibility = 0;
                    this.mViewRootImpl = mViewRootImpl;
                    this.mHandler = mHandler;
                }
            }
            View.AttachInfo = AttachInfo;
            class ListenerInfo {
            }
            View.ListenerInfo = ListenerInfo;
        })(View = view_2.View || (view_2.View = {}));
        (function (View) {
            var AttachInfo;
            (function (AttachInfo) {
                class InvalidateInfo {
                    constructor() {
                        this.left = 0;
                        this.top = 0;
                        this.right = 0;
                        this.bottom = 0;
                    }
                    static obtain() {
                        let instance = InvalidateInfo.sPool.acquire();
                        return (instance != null) ? instance : new InvalidateInfo();
                    }
                    recycle() {
                        this.target = null;
                        InvalidateInfo.sPool.release(this);
                    }
                }
                InvalidateInfo.POOL_LIMIT = 10;
                InvalidateInfo.sPool = new Pools.SynchronizedPool(InvalidateInfo.POOL_LIMIT);
                AttachInfo.InvalidateInfo = InvalidateInfo;
            })(AttachInfo = View.AttachInfo || (View.AttachInfo = {}));
        })(View = view_2.View || (view_2.View = {}));
        class CheckForLongPress {
            constructor(View_this) {
                this.mOriginalWindowAttachCount = 0;
                this.View_this = View_this;
            }
            run() {
                if (this.View_this.isPressed() && (this.View_this.mParent != null)
                    && this.mOriginalWindowAttachCount == this.View_this.mWindowAttachCount) {
                    if (this.View_this.performLongClick()) {
                        this.View_this.mHasPerformedLongPress = true;
                    }
                }
            }
            rememberWindowAttachCount() {
                this.mOriginalWindowAttachCount = this.View_this.mWindowAttachCount;
            }
        }
        class CheckForTap {
            constructor(View_this) {
                this.View_this = View_this;
            }
            run() {
                this.View_this.mPrivateFlags &= ~View.PFLAG_PREPRESSED;
                this.View_this.setPressed(true);
                this.View_this.checkForLongClick(view_2.ViewConfiguration.getTapTimeout());
            }
        }
        class PerformClick {
            constructor(View_this) {
                this.View_this = View_this;
            }
            run() {
                this.View_this.performClick();
            }
        }
        class UnsetPressedState {
            constructor(View_this) {
                this.View_this = View_this;
            }
            run() {
                this.View_this.setPressed(false);
            }
        }
        class ScrollabilityCache {
            constructor(host) {
                this.fadeScrollBars = true;
                this.fadingEdgeLength = view_2.ViewConfiguration.get().getScaledFadingEdgeLength();
                this.scrollBarDefaultDelayBeforeFade = view_2.ViewConfiguration.getScrollDefaultDelay();
                this.scrollBarFadeDuration = view_2.ViewConfiguration.getScrollBarFadeDuration();
                this.scrollBarSize = view_2.ViewConfiguration.get().getScaledScrollBarSize();
                this.interpolator = new LinearInterpolator();
                this.state = ScrollabilityCache.OFF;
                this.host = host;
                this.scrollBar = new ScrollBarDrawable();
                let thumbColor = new ColorDrawable(0x44000000);
                let density = Resources.getDisplayMetrics().density;
                let thumb = new InsetDrawable(thumbColor, 0, 2 * density, view_2.ViewConfiguration.get().getScaledScrollBarSize() / 2, 2 * density);
                this.scrollBar.setHorizontalThumbDrawable(thumb);
                this.scrollBar.setVerticalThumbDrawable(thumb);
            }
            run() {
                let now = AnimationUtils.currentAnimationTimeMillis();
                if (now >= this.fadeStartTime) {
                    this.state = ScrollabilityCache.FADING;
                    this.host.invalidate(true);
                }
            }
            _computeAlphaToScrollBar() {
                let now = AnimationUtils.currentAnimationTimeMillis();
                let factor = (now - this.fadeStartTime) / this.scrollBarFadeDuration;
                if (factor >= 1) {
                    this.state = ScrollabilityCache.OFF;
                    factor = 1;
                }
                let alpha = 1 - this.interpolator.getInterpolation(factor);
                this.scrollBar.setAlpha(255 * alpha);
            }
        }
        ScrollabilityCache.OFF = 0;
        ScrollabilityCache.ON = 1;
        ScrollabilityCache.FADING = 2;
        class MatchIdPredicate {
            apply(view) {
                return view.mID === this.mId;
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="View.ts"/>
///<reference path="../graphics/Point.ts"/>
///<reference path="../graphics/Rect.ts"/>
/**
 * Created by linfaxin on 15/10/13.
 */
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../view/ViewRootImpl.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Rect = android.graphics.Rect;
        var Canvas = android.graphics.Canvas;
        class Surface {
            constructor(canvasElement, viewRoot) {
                this.mLockedRect = new Rect();
                this.mCanvasBound = new Rect();
                this.mSupportDirtyDraw = true;
                this.mLockSaveCount = 1;
                this.mCanvasElement = canvasElement;
                this.viewRoot = viewRoot;
                this.initImpl();
            }
            initImpl() {
                this.initCanvasBound();
            }
            isValid() {
                return true;
            }
            notifyBoundChange() {
                this.initCanvasBound();
            }
            initCanvasBound() {
                let density = android.content.res.Resources.getDisplayMetrics().density;
                let clientRect = this.mCanvasElement.getBoundingClientRect();
                this.mCanvasBound.set(clientRect.left * density, clientRect.top * density, clientRect.right * density, clientRect.bottom * density);
            }
            lockCanvas(dirty) {
                let rect = this.mLockedRect;
                rect.set(Math.floor(dirty.left), Math.floor(dirty.top), Math.ceil(dirty.right), Math.ceil(dirty.bottom));
                if (dirty.isEmpty()) {
                    let fullWidth = this.mCanvasBound.width();
                    let fullHeight = this.mCanvasBound.height();
                    rect.set(0, 0, fullWidth, fullHeight);
                }
                return this.lockCanvasImpl(rect.left, rect.top, rect.width(), rect.height());
            }
            lockCanvasImpl(left, top, width, height) {
                //let canvas = new Canvas(width, height);
                //if(left!=0||top!=0) canvas.translate(-left, -top);
                let canvas = new SurfaceLockCanvas(this.mCanvasBound.width(), this.mCanvasBound.height(), this.mCanvasElement);
                this.mLockSaveCount = canvas.save();
                canvas.clipRect(left, top, left + width, top + height);
                canvas.clearColor();
                return canvas;
            }
            unlockCanvasAndPost(canvas) {
                canvas.restoreToCount(this.mLockSaveCount);
            }
        }
        view.Surface = Surface;
        class SurfaceLockCanvas extends Canvas {
            constructor(width, height, canvasElement) {
                super(width, height);
                this.mCanvasElement = canvasElement;
                this._mCanvasContent = this.mCanvasElement.getContext("2d");
            }
            initImpl() {
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/12/30.
 *
 */
var PageStack;
(function (PageStack) {
    const DEBUG = false;
    const history_go = history.go;
    let historyLocking = false;
    let pendingFuncLock = [];
    function init() {
        removeLastHistoryIfFaked();
        ensureLockDo(_init);
        history.go = function (delta) {
            PageStack.go(delta);
        };
        history.back = function () {
            PageStack.go(-1);
        };
        history.forward = function () {
            PageStack.go(1);
        };
    }
    PageStack.init = init;
    function _init() {
        PageStack.currentStack = history.state;
        if (PageStack.currentStack && !PageStack.currentStack.isRoot) {
            console.log('already has history.state when _init PageState, restore page');
            restorePageFromStackIfNeed();
        }
        else {
            PageStack.currentStack = PageStack.currentStack || {
                pageId: '',
                isRoot: true,
                stack: [{ pageId: null }]
            };
            history.replaceState(PageStack.currentStack, null, '#');
        }
        ensureLastHistoryFaked();
        window.onpopstate = (ev) => {
            let stack = ev.state;
            if (historyLocking) {
                PageStack.currentStack = stack;
                return;
            }
            if (DEBUG)
                console.log('onpopstate', stack);
            if (!stack) {
                let pageId = location.hash;
                if (pageId[0] === '#')
                    pageId = pageId.substring(1);
                historyGo(-2, false);
                if (firePageOpen(pageId, null)) {
                    notifyNewPageOpened(pageId);
                }
                else {
                    ensureLastHistoryFaked();
                }
            }
            else if (PageStack.currentStack.stack.length != stack.stack.length) {
                let delta = stack.stack.length - PageStack.currentStack.stack.length;
                if (delta >= 0) {
                    console.warn('something error! stack: ', stack, 'last stack: ', PageStack.currentStack);
                    return;
                }
                var stackList = PageStack.currentStack.stack;
                PageStack.currentStack = stack;
                tryClosePageAfterHistoryChanged(stackList, delta);
            }
            else {
                PageStack.currentStack = stack;
                if (fireBackPressed()) {
                    ensureLastHistoryFaked();
                }
                else {
                    var stackList = PageStack.currentStack.stack;
                    if (firePageClose(stackList[stackList.length - 1].pageId, stackList[stackList.length - 1].extra)) {
                        historyGo(-1);
                    }
                    else {
                        ensureLastHistoryFaked();
                    }
                }
            }
        };
    }
    function go(delta, pageAlreadyClose = false) {
        if (historyLocking) {
            ensureLockDo(() => {
                go(delta);
            });
            return;
        }
        var stackList = PageStack.currentStack.stack;
        if (delta === -1 && !pageAlreadyClose) {
            if (!firePageClose(stackList[stackList.length - 1].pageId, stackList[stackList.length - 1].extra)) {
                return;
            }
        }
        removeLastHistoryIfFaked();
        historyGo(delta);
        if (delta < -1 && !pageAlreadyClose) {
            ensureLockDo(() => {
                tryClosePageAfterHistoryChanged(stackList, delta);
            });
        }
    }
    PageStack.go = go;
    function tryClosePageAfterHistoryChanged(stateListBeforeHistoryChange, delta) {
        let historyLength = stateListBeforeHistoryChange.length;
        for (let i = historyLength + delta; i < historyLength; i++) {
            let state = stateListBeforeHistoryChange[i];
            if (!firePageClose(state.pageId, state.extra)) {
                notifyNewPageOpened(state.pageId, state.extra);
            }
        }
    }
    function back(pageAlreadyClose = false) {
        go(-1, pageAlreadyClose);
    }
    PageStack.back = back;
    function openPage(pageId, extra) {
        pageId += '';
        if (firePageOpen(pageId, extra)) {
            notifyNewPageOpened(pageId);
        }
    }
    PageStack.openPage = openPage;
    let releaseLockingTimeout;
    let requestHistoryGoWhenLocking = 0;
    let ensureFakeAfterHistoryChange = false;
    function historyGo(delta, ensureFaked = true) {
        if (delta >= 0)
            return;
        if (history.length === 1)
            return;
        ensureFakeAfterHistoryChange = ensureFakeAfterHistoryChange || ensureFaked;
        if (historyLocking) {
            requestHistoryGoWhenLocking += delta;
            return;
        }
        if (DEBUG)
            console.log('historyGo', delta);
        historyLocking = true;
        const state = history.state;
        if (releaseLockingTimeout)
            clearTimeout(releaseLockingTimeout);
        function checkRelease() {
            clearTimeout(releaseLockingTimeout);
            if (history.state === state) {
                releaseLockingTimeout = setTimeout(checkRelease, 0);
            }
            else {
                let continueGo = requestHistoryGoWhenLocking;
                if (continueGo != 0) {
                    requestHistoryGoWhenLocking = 0;
                    historyLocking = false;
                    historyGo(continueGo, false);
                }
                else {
                    if (ensureFakeAfterHistoryChange)
                        ensureLastHistoryFakedImpl();
                    ensureFakeAfterHistoryChange = false;
                    releaseLockingTimeout = setTimeout(() => {
                        historyLocking = false;
                    }, 10);
                }
            }
        }
        releaseLockingTimeout = setTimeout(checkRelease, 0);
        history_go.call(history, delta);
    }
    function restorePageFromStackIfNeed() {
        if (PageStack.currentStack) {
            let copy = PageStack.currentStack.stack.concat();
            copy.shift();
            for (let saveState of copy) {
                firePageOpen(saveState.pageId, saveState.extra, true);
            }
        }
    }
    function fireBackPressed() {
        if (PageStack.backListener) {
            try {
                return PageStack.backListener();
            }
            catch (e) {
                console.error(e);
            }
        }
    }
    function firePageOpen(pageId, pageExtra, isRestore = false) {
        if (PageStack.pageOpenHandler) {
            try {
                return PageStack.pageOpenHandler(pageId, pageExtra, isRestore);
            }
            catch (e) {
                console.error(e);
            }
        }
    }
    function firePageClose(pageId, pageExtra) {
        if (PageStack.pageCloseHandler) {
            try {
                return PageStack.pageCloseHandler(pageId, pageExtra);
            }
            catch (e) {
                console.error(e);
            }
        }
    }
    function notifyPageClosed(pageId) {
        if (DEBUG)
            console.log('notifyPageClosed', pageId);
        if (historyLocking) {
            ensureLockDo(() => {
                notifyPageClosed(pageId);
            });
        }
        let stackList = PageStack.currentStack.stack;
        let historyLength = stackList.length;
        for (let i = historyLength - 1; i >= 0; i--) {
            let state = stackList[i];
            if (state.pageId == pageId) {
                if (i === historyLength - 1) {
                    removeLastHistoryIfFaked();
                    historyGo(-1);
                }
                else {
                    let delta = i - historyLength;
                    (function (delta) {
                        removeLastHistoryIfFaked();
                        historyGo(delta);
                        ensureLockDoAtFront(() => {
                            let historyLength = stackList.length;
                            let pageStartAddIndex = historyLength + delta + 1;
                            for (let j = pageStartAddIndex; j < historyLength; j++) {
                                notifyNewPageOpened(stackList[j].pageId, stackList[j].extra);
                            }
                        });
                    })(delta);
                }
                return;
            }
        }
    }
    PageStack.notifyPageClosed = notifyPageClosed;
    function notifyNewPageOpened(pageId, extra) {
        if (DEBUG)
            console.log('notifyNewPageOpened', pageId);
        let state = {
            pageId: pageId,
            extra: extra
        };
        ensureLockDo(function () {
            PageStack.currentStack.stack.push(state);
            PageStack.currentStack.pageId = pageId;
            PageStack.currentStack.isRoot = false;
            if (history.state.isFake) {
                history.replaceState(PageStack.currentStack, null, '#' + pageId);
            }
            else {
                history.pushState(PageStack.currentStack, null, '#' + pageId);
            }
            ensureLastHistoryFakedImpl();
        });
    }
    PageStack.notifyNewPageOpened = notifyNewPageOpened;
    function ensureLockDo(func) {
        if (!historyLocking) {
            func();
            return;
        }
        pendingFuncLock.push(func);
        _queryLockDo();
    }
    function ensureLockDoAtFront(func, runNowIfNotLock = false) {
        if (!historyLocking && runNowIfNotLock) {
            func();
            return;
        }
        pendingFuncLock.splice(0, 0, func);
        _queryLockDo();
    }
    let execLockedTimeoutId;
    function _queryLockDo() {
        if (execLockedTimeoutId)
            clearTimeout(execLockedTimeoutId);
        function execLockedFunctions() {
            if (historyLocking) {
                clearTimeout(execLockedTimeoutId);
                execLockedTimeoutId = setTimeout(execLockedFunctions, 0);
            }
            else {
                let f;
                while (f = pendingFuncLock.shift()) {
                    f();
                    if (historyLocking) {
                        clearTimeout(execLockedTimeoutId);
                        execLockedTimeoutId = setTimeout(execLockedFunctions, 0);
                        break;
                    }
                }
            }
        }
        execLockedTimeoutId = setTimeout(execLockedFunctions, 0);
    }
    function removeLastHistoryIfFaked() {
        if (history.state && history.state.isFake) {
            if (DEBUG)
                console.log('remove Fake History');
            history.replaceState({}, null, '');
            historyGo(-1, false);
        }
    }
    function ensureLastHistoryFaked() {
        ensureLockDo(ensureLastHistoryFakedImpl);
    }
    function ensureLastHistoryFakedImpl() {
        if (!history.state.isFake) {
            if (DEBUG)
                console.log('append Fake History');
            history.pushState({ isFake: true }, null, '');
        }
    }
})(PageStack || (PageStack = {}));
/**
 * Created by linfaxin on 16/1/5.
 * simple impl of android ActivityThread
 */
///<reference path="Activity.ts"/>
///<reference path="../content/Intent.ts"/>
///<reference path="../os/Bundle.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../view/KeyEvent.ts"/>
///<reference path="../view/animation/Animation.ts"/>
///<reference path="../../androidui/AndroidUI.ts"/>
///<reference path="../../androidui/util/PageStack.ts"/>
var android;
(function (android) {
    var app;
    (function (app) {
        var Bundle = android.os.Bundle;
        var Intent = android.content.Intent;
        var View = android.view.View;
        class ActivityThread {
            constructor(androidUI) {
                this.mLaunchedActivities = new Set();
                this.androidUI = androidUI;
                this.initWithPageStack();
            }
            initWithPageStack() {
                let backKeyDownEvent = android.view.KeyEvent.obtain(android.view.KeyEvent.ACTION_DOWN, android.view.KeyEvent.KEYCODE_BACK);
                let backKeyUpEvent = android.view.KeyEvent.obtain(android.view.KeyEvent.ACTION_UP, android.view.KeyEvent.KEYCODE_BACK);
                PageStack.backListener = () => {
                    let handleDown = this.androidUI._viewRootImpl.dispatchInputEvent(backKeyDownEvent);
                    let handleUp = this.androidUI._viewRootImpl.dispatchInputEvent(backKeyUpEvent);
                    return handleDown || handleUp;
                };
                PageStack.pageOpenHandler = (pageId, pageExtra, isRestore) => {
                    let intent = new Intent(pageId);
                    if (pageExtra)
                        intent.mExtras = new Bundle(pageExtra.mExtras);
                    if (isRestore)
                        this.overrideNextWindowAnimation(null, null, null, null);
                    let activity = this.handleLaunchActivity(intent);
                    return activity && !activity.mFinished;
                };
                PageStack.pageCloseHandler = (pageId, pageExtra) => {
                    if (this.mLaunchedActivities.size === 1) {
                        let rootActivity = Array.from(this.mLaunchedActivities)[0];
                        if (pageId == null || rootActivity.getIntent().activityName == pageId) {
                            this.handleDestroyActivity(rootActivity, true);
                            return true;
                        }
                        return false;
                    }
                    for (let activity of Array.from(this.mLaunchedActivities).reverse()) {
                        let intent = activity.getIntent();
                        if (intent.activityName == pageId) {
                            this.handleDestroyActivity(activity, true);
                            return true;
                        }
                    }
                };
                PageStack.init();
            }
            overrideNextWindowAnimation(enterAnimation, exitAnimation, resumeAnimation, hideAnimation) {
                this.overrideEnterAnimation = enterAnimation;
                this.overrideExitAnimation = exitAnimation;
                this.overrideResumeAnimation = resumeAnimation;
                this.overrideHideAnimation = hideAnimation;
            }
            getOverrideEnterAnimation() {
                let anim = this.overrideEnterAnimation;
                this.overrideEnterAnimation = undefined;
                return anim;
            }
            getOverrideExitAnimation() {
                let anim = this.overrideExitAnimation;
                this.overrideExitAnimation = undefined;
                return anim;
            }
            getOverrideResumeAnimation() {
                let anim = this.overrideResumeAnimation;
                this.overrideResumeAnimation = undefined;
                return anim;
            }
            getOverrideHideAnimation() {
                let anim = this.overrideHideAnimation;
                this.overrideHideAnimation = undefined;
                return anim;
            }
            scheduleApplicationHide() {
                let visibleActivities = this.getVisibleToUserActivities();
                if (visibleActivities.length == 0)
                    return;
                this.handlePauseActivity(visibleActivities[visibleActivities.length - 1]);
                for (let visibleActivity of visibleActivities) {
                    this.handleStopActivity(visibleActivity, true);
                }
            }
            scheduleApplicationShow() {
                this.scheduleActivityResume();
            }
            scheduleActivityResume() {
                if (this.activityResumeTimeout)
                    clearTimeout(this.activityResumeTimeout);
                this.activityResumeTimeout = setTimeout(() => {
                    let visibleActivities = this.getVisibleToUserActivities();
                    if (visibleActivities.length == 0)
                        return;
                    for (let visibleActivity of visibleActivities) {
                        visibleActivity.performRestart();
                    }
                    let activity = visibleActivities.pop();
                    this.handleResumeActivity(activity, false);
                    if (activity.getWindow().isFloating()) {
                        for (let visibleActivity of visibleActivities.reverse()) {
                            if (visibleActivity.mVisibleFromClient) {
                                visibleActivity.makeVisible();
                                if (!visibleActivity.getWindow().isFloating()) {
                                    break;
                                }
                            }
                        }
                    }
                }, 0);
            }
            scheduleLaunchActivity(callActivity, intent, options) {
                let activity = this.handleLaunchActivity(intent);
                activity.mCallActivity = callActivity;
                if (activity && !activity.mFinished) {
                    PageStack.notifyNewPageOpened(intent.activityName, intent);
                }
            }
            scheduleDestroyActivityByRequestCode(requestCode) {
                for (let activity of Array.from(this.mLaunchedActivities).reverse()) {
                    if (activity.getIntent() && requestCode == activity.getIntent().mRequestCode) {
                        this.scheduleDestroyActivity(activity);
                    }
                }
            }
            scheduleDestroyActivity(activity, finishing = true) {
                setTimeout(() => {
                    let isCreateSuc = this.mLaunchedActivities.has(activity);
                    let isRootActivity = this.isRootActivity(activity);
                    if (activity.mCallActivity && activity.getIntent() && activity.getIntent().mRequestCode >= 0) {
                        activity.mCallActivity.dispatchActivityResult(null, activity.getIntent().mRequestCode, activity.mResultCode, activity.mResultData);
                    }
                    this.handleDestroyActivity(activity, finishing);
                    if (!isCreateSuc)
                        return;
                    if (isRootActivity) {
                        PageStack.back(true);
                    }
                    else if (activity.getIntent()) {
                        PageStack.notifyPageClosed(activity.getIntent().activityName);
                    }
                }, 0);
            }
            scheduleBackTo(intent) {
                let destroyList = [];
                let findActivity = false;
                for (let activity of Array.from(this.mLaunchedActivities).reverse()) {
                    if (activity.getIntent() && activity.getIntent().activityName == intent.activityName) {
                        findActivity = true;
                        break;
                    }
                    destroyList.push(activity);
                }
                if (findActivity) {
                    for (let activity of destroyList) {
                        this.scheduleDestroyActivity(activity);
                    }
                    return true;
                }
                return false;
            }
            canBackTo(intent) {
                for (let activity of this.mLaunchedActivities) {
                    if (activity.getIntent().activityName == intent.activityName) {
                        return true;
                    }
                }
                return false;
            }
            scheduleBackToRoot() {
                let destroyList = Array.from(this.mLaunchedActivities).reverse();
                destroyList.shift();
                for (let activity of destroyList) {
                    this.scheduleDestroyActivity(activity);
                }
            }
            handlePauseActivity(activity) {
                this.performPauseActivity(activity);
            }
            performPauseActivity(activity) {
                //if (finished) {
                //    activity.mFinished = true;
                //}
                activity.mCalled = false;
                activity.performPause();
                if (!activity.mCalled) {
                    throw new Error("Activity " + ActivityThread.getActivityName(activity) + " did not call through to super.onPause()");
                }
            }
            handleStopActivity(activity, show = false) {
                this.performStopActivity(activity, true);
                this.updateVisibility(activity, show);
            }
            performStopActivity(activity, saveState) {
                if (!activity.mFinished && saveState) {
                    let state = new Bundle();
                    activity.performSaveInstanceState(state);
                }
                activity.performStop();
            }
            handleResumeActivity(a, launching) {
                this.performResumeActivity(a, launching);
                let willBeVisible = !a.mStartedActivity && !a.mFinished;
                if (willBeVisible && a.mVisibleFromClient) {
                    a.makeVisible();
                    this.overrideEnterAnimation = undefined;
                    this.overrideExitAnimation = undefined;
                    this.overrideResumeAnimation = undefined;
                    this.overrideHideAnimation = undefined;
                }
            }
            performResumeActivity(a, launching) {
                if (!launching) {
                    a.mStartedActivity = false;
                }
                a.performResume();
            }
            handleLaunchActivity(intent) {
                let visibleActivities = this.getVisibleToUserActivities();
                let a = this.performLaunchActivity(intent);
                if (a) {
                    this.handleResumeActivity(a, true);
                    if (!a.mFinished && visibleActivities.length > 0) {
                        this.handlePauseActivity(visibleActivities[visibleActivities.length - 1]);
                        if (!a.getWindow().getAttributes().isFloating()) {
                            for (let visibleActivity of visibleActivities) {
                                this.handleStopActivity(visibleActivity);
                            }
                        }
                    }
                }
                return a;
            }
            performLaunchActivity(intent) {
                let activity;
                let clazz = intent.activityName;
                try {
                    if (typeof clazz === 'string')
                        clazz = eval(clazz);
                }
                catch (e) { }
                if (typeof clazz === 'function')
                    activity = new clazz(this.androidUI);
                if (activity instanceof app.Activity) {
                    try {
                        let savedInstanceState = null;
                        activity.mIntent = intent;
                        activity.mStartedActivity = false;
                        activity.mCalled = false;
                        activity.performCreate(savedInstanceState);
                        if (!activity.mCalled) {
                            throw new Error("Activity " + intent.activityName + " did not call through to super.onCreate()");
                        }
                        if (!activity.mFinished) {
                            activity.performStart();
                            activity.performRestoreInstanceState(savedInstanceState);
                            activity.mCalled = false;
                            activity.onPostCreate(savedInstanceState);
                            if (!activity.mCalled) {
                                throw new Error("Activity " + intent.activityName + " did not call through to super.onPostCreate()");
                            }
                        }
                    }
                    catch (e) {
                        console.error(e);
                        return null;
                    }
                    if (!activity.mFinished) {
                        this.mLaunchedActivities.add(activity);
                    }
                    return activity;
                }
                return null;
            }
            handleDestroyActivity(activity, finishing) {
                let visibleActivities = this.getVisibleToUserActivities();
                let isTopVisibleActivity = activity == visibleActivities[visibleActivities.length - 1];
                let isRootActivity = this.isRootActivity(activity);
                this.performDestroyActivity(activity, finishing);
                if (isRootActivity)
                    activity.getWindow().setWindowAnimations(null, null);
                this.androidUI.windowManager.removeWindow(activity.getWindow());
                if (isTopVisibleActivity && !isRootActivity) {
                    this.scheduleActivityResume();
                }
            }
            performDestroyActivity(activity, finishing) {
                if (finishing) {
                    activity.mFinished = true;
                }
                activity.mCalled = false;
                activity.performPause();
                if (!activity.mCalled) {
                    throw new Error("Activity " + ActivityThread.getActivityName(activity) + " did not call through to super.onPause()");
                }
                activity.performStop();
                activity.mCalled = false;
                activity.performDestroy();
                if (!activity.mCalled) {
                    throw new Error("Activity " + ActivityThread.getActivityName(activity) + " did not call through to super.onDestroy()");
                }
                this.mLaunchedActivities.delete(activity);
            }
            updateVisibility(activity, show) {
                if (show) {
                    if (activity.mVisibleFromClient) {
                        activity.makeVisible();
                    }
                }
                else {
                    activity.getWindow().getDecorView().setVisibility(View.INVISIBLE);
                }
            }
            getVisibleToUserActivities() {
                let list = [];
                for (let activity of Array.from(this.mLaunchedActivities).reverse()) {
                    list.push(activity);
                    if (!activity.getWindow().getAttributes().isFloating())
                        break;
                }
                list.reverse();
                return list;
            }
            isRootActivity(activity) {
                return this.mLaunchedActivities.values().next().value == activity;
            }
            static getActivityName(activity) {
                if (activity.getIntent())
                    return activity.getIntent().activityName;
                return activity.constructor.name;
            }
        }
        app.ActivityThread = ActivityThread;
    })(app = android.app || (android.app = {}));
})(android || (android = {}));
var android;
(function (android) {
    var R;
    (function (R) {
        class string_ {
            static zh() {
                this.ok = '';
                this.cancel = '';
                this.close = '';
                this.crash_catch_alert = ', :';
                this.prll_header_state_normal = '';
                this.prll_header_state_ready = '';
                this.prll_header_state_loading = '...';
                this.prll_header_state_fail = '';
                this.prll_footer_state_normal = '';
                this.prll_footer_state_loading = '...';
                this.prll_footer_state_ready = '';
                this.prll_footer_state_no_more = '';
                this.prll_footer_state_fail = ',';
            }
        }
        string_.ok = 'OK';
        string_.cancel = 'Cancel';
        string_.close = 'Close';
        string_.crash_catch_alert = 'Some error happen, will refresh page:';
        string_.prll_header_state_normal = 'Pull to refresh';
        string_.prll_header_state_ready = 'Release to refresh';
        string_.prll_header_state_loading = 'Loading';
        string_.prll_header_state_fail = 'Refresh fail';
        string_.prll_footer_state_normal = 'Load more';
        string_.prll_footer_state_loading = 'Loading';
        string_.prll_footer_state_ready = 'Pull to load more';
        string_.prll_footer_state_fail = 'Click to reload';
        string_.prll_footer_state_no_more = 'Load Finish';
        R.string_ = string_;
        const lang = navigator.language.split('-')[0].toLowerCase();
        if (typeof string_[lang] === 'function')
            string_[lang].call(string_);
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/23.
 */
///<reference path="../android/app/Application.ts"/>
///<reference path="../android/view/View.ts"/>
///<reference path="../android/view/ViewGroup.ts"/>
///<reference path="../android/view/ViewRootImpl.ts"/>
///<reference path="../android/widget/FrameLayout.ts"/>
///<reference path="../android/view/MotionEvent.ts"/>
///<reference path="../android/view/KeyEvent.ts"/>
///<reference path="../android/view/WindowManager.ts"/>
///<reference path="../android/app/ActivityThread.ts"/>
///<reference path="../android/R/string.ts"/>
///<reference path="AndroidUIElement.ts"/>
var androidui;
(function (androidui) {
    var MotionEvent = android.view.MotionEvent;
    var KeyEvent = android.view.KeyEvent;
    var Intent = android.content.Intent;
    var ActivityThread = android.app.ActivityThread;
    class AndroidUI {
        constructor(androidUIElement) {
            this._canvas = document.createElement("canvas");
            this.mActivityThread = new ActivityThread(this);
            this._windowBound = new android.graphics.Rect();
            this.tempRect = new android.graphics.Rect();
            this.touchEvent = new MotionEvent();
            this.touchAvailable = false;
            this.ketEvent = new KeyEvent();
            this.androidUIElement = androidUIElement;
            if (androidUIElement[AndroidUI.BindToElementName]) {
                throw Error('already init a AndroidUI with this element');
            }
            androidUIElement[AndroidUI.BindToElementName] = this;
            this.init();
        }
        get windowManager() {
            return this.mApplication.getWindowManager();
        }
        get windowBound() {
            return this._windowBound;
        }
        init() {
            this.androidUIElement.classList.add(AndroidUI.DomClassName);
            this._viewRootImpl = new android.view.ViewRootImpl();
            this._viewRootImpl.androidUIElement = this.androidUIElement;
            this.rootResourceElement = this.androidUIElement.querySelector('resources');
            if (this.rootResourceElement)
                this.androidUIElement.removeChild(this.rootResourceElement);
            else
                this.rootResourceElement = document.createElement('resources');
            this.initApplication();
            this.androidUIElement.appendChild(this._canvas);
            this.initEvent();
            this.initRootSizeChange();
            this._viewRootImpl.setView(this.windowManager.getWindowsLayout());
            this._viewRootImpl.initSurface(this._canvas);
            this.initBrowserVisibleChange();
            this.initLaunchActivity();
            this.initAndroidUIElement();
            this.initGlobalCrashHandle();
        }
        initApplication() {
            this.mApplication = new android.app.Application(this);
            this.mApplication.onCreate();
        }
        initLaunchActivity() {
            for (let ele of Array.from(this.androidUIElement.children)) {
                let tagName = ele.tagName;
                if (tagName != 'ACTIVITY')
                    continue;
                let activityName = ele.getAttribute('name') || ele.getAttribute('android:name') || 'android.app.Activity';
                let intent = new Intent(activityName);
                let activity = this.mActivityThread.handleLaunchActivity(intent);
                if (activity) {
                    this.androidUIElement.removeChild(ele);
                    for (let element of Array.from(ele.children)) {
                        android.view.LayoutInflater.from(activity).inflate(element, activity.getWindow().mContentParent, true);
                    }
                    let onCreateFunc = ele.getAttribute('oncreate');
                    if (onCreateFunc && typeof window[onCreateFunc] === "function") {
                        window[onCreateFunc].call(this, activity);
                    }
                }
            }
        }
        initGlobalCrashHandle() {
            window.onerror = (sMsg, sUrl, sLine) => {
                if (window.confirm(android.R.string_.crash_catch_alert + '\n' + sMsg)) {
                    window.location.reload();
                }
            };
        }
        refreshWindowBound() {
            let rootViewBound = this.androidUIElement.getBoundingClientRect();
            let boundLeft = rootViewBound.left;
            let boundTop = rootViewBound.top;
            let boundRight = rootViewBound.right;
            let boundBottom = rootViewBound.bottom;
            if (this._windowBound && this._windowBound.left == boundLeft && this._windowBound.top == boundTop
                && this._windowBound.right == boundRight && this._windowBound.bottom == boundBottom) {
                return false;
            }
            this._windowBound.set(boundLeft, boundTop, boundRight, boundBottom);
            return true;
        }
        initAndroidUIElement() {
            if (this.androidUIElement.style.display === 'none') {
                this.androidUIElement.style.display = '';
            }
            this.androidUIElement.setAttribute('tabindex', '0');
            this.androidUIElement.focus();
        }
        initEvent() {
            this.initTouchEvent();
            this.initMouseEvent();
            this.initKeyEvent();
            this.initGenericEvent();
        }
        initTouchEvent() {
            this.androidUIElement.addEventListener('touchstart', (e) => {
                this.touchAvailable = true;
                this.refreshWindowBound();
                this.androidUIElement.focus();
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_DOWN, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
            this.androidUIElement.addEventListener('touchmove', (e) => {
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_MOVE, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
            this.androidUIElement.addEventListener('touchend', (e) => {
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_UP, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
            this.androidUIElement.addEventListener('touchcancel', (e) => {
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_CANCEL, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
        }
        initMouseEvent() {
            function mouseToTouchEvent(e) {
                let touch = {
                    identifier: 0,
                    target: null,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY
                };
                return {
                    changedTouches: [touch],
                    targetTouches: [touch],
                    touches: e.type === 'mouseup' ? [] : [touch],
                    timeStamp: e.timeStamp
                };
            }
            let isMouseDown = false;
            this.androidUIElement.addEventListener('mousedown', (e) => {
                if (this.touchAvailable)
                    return;
                isMouseDown = true;
                this.refreshWindowBound();
                this.androidUIElement.focus();
                this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_DOWN, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
            this.androidUIElement.addEventListener('mousemove', (e) => {
                if (this.touchAvailable)
                    return;
                if (!isMouseDown)
                    return;
                this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_MOVE, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
            this.androidUIElement.addEventListener('mouseup', (e) => {
                if (this.touchAvailable)
                    return;
                isMouseDown = false;
                this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_UP, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
            this.androidUIElement.addEventListener('mouseleave', (e) => {
                if (this.touchAvailable)
                    return;
                if (e.fromElement === this.androidUIElement) {
                    isMouseDown = false;
                    this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_CANCEL, this._windowBound);
                    if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                        e.stopPropagation();
                        e.preventDefault();
                        return true;
                    }
                }
            }, true);
            let scrollEvent = new MotionEvent();
            this.androidUIElement.addEventListener('mousewheel', (e) => {
                scrollEvent.initWithMouseWheel(e);
                if (this._viewRootImpl.dispatchInputEvent(scrollEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
        }
        initKeyEvent() {
            this.androidUIElement.addEventListener('keydown', (e) => {
                this.ketEvent.initKeyEvent(e, KeyEvent.ACTION_DOWN);
                if (this._viewRootImpl.dispatchInputEvent(this.ketEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
            this.androidUIElement.addEventListener('keyup', (e) => {
                this.ketEvent.initKeyEvent(e, KeyEvent.ACTION_UP);
                if (this._viewRootImpl.dispatchInputEvent(this.ketEvent)) {
                    e.stopPropagation();
                    e.preventDefault();
                    return true;
                }
            }, true);
        }
        initGenericEvent() {
        }
        initRootSizeChange() {
            const _this = this;
            window.addEventListener('resize', () => {
                _this.notifyRootSizeChange();
            });
            let lastWidth = this.androidUIElement.offsetWidth;
            let lastHeight = this.androidUIElement.offsetHeight;
            if (lastWidth > 0 && lastHeight > 0)
                this.notifyRootSizeChange();
            setInterval(() => {
                let width = _this.androidUIElement.offsetWidth;
                let height = _this.androidUIElement.offsetHeight;
                if (lastHeight !== height || lastWidth !== width) {
                    lastWidth = width;
                    lastHeight = height;
                    _this.notifyRootSizeChange();
                }
            }, 500);
        }
        initBrowserVisibleChange() {
            var eventName = 'visibilitychange';
            if (document['webkitHidden'] != undefined) {
                eventName = 'webkitvisibilitychange';
            }
            document.addEventListener(eventName, () => {
                if (document['hidden'] || document['webkitHidden']) {
                    this.mActivityThread.scheduleApplicationHide();
                }
                else {
                    this.mActivityThread.scheduleApplicationShow();
                    this._viewRootImpl.invalidate();
                }
            }, false);
        }
        notifyRootSizeChange() {
            if (this.refreshWindowBound()) {
                let density = android.content.res.Resources.getDisplayMetrics().density;
                this.tempRect.set(this._windowBound.left * density, this._windowBound.top * density, this._windowBound.right * density, this._windowBound.bottom * density);
                let width = this._windowBound.width();
                let height = this._windowBound.height();
                this._canvas.width = width * density;
                this._canvas.height = height * density;
                this._canvas.style.width = width + "px";
                this._canvas.style.height = height + "px";
                this._viewRootImpl.notifyResized(this.tempRect);
            }
        }
        showDebugLayout() {
            if (this.windowManager.getWindowsLayout().bindElement.parentNode === null) {
                this.androidUIElement.appendChild(this.windowManager.getWindowsLayout().bindElement);
            }
        }
    }
    AndroidUI.DomClassName = 'AndroidUI';
    AndroidUI.BindToElementName = 'AndroidUI';
    androidui.AndroidUI = AndroidUI;
    let styleElement = document.createElement('style');
    styleElement.innerHTML += `
        .${AndroidUI.DomClassName} {
            position : relative;
            overflow : hidden;
            display : block;
            outline: none;
        }
        .${AndroidUI.DomClassName} * {
            overflow : hidden;
            border : none;
            outline: none;
            pointer-events: auto;
        }
        .${AndroidUI.DomClassName} resources {
            display: none;
        }
        .${AndroidUI.DomClassName} Button {
            border: none;
            background: none;
        }
        .${AndroidUI.DomClassName} windowsgroup {
            pointer-events: none;
        }
        .${AndroidUI.DomClassName} > canvas {
            position: absolute;
            left: 0;
            top: 0;
        }
        `;
    document.head.appendChild(styleElement);
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 16/1/4.
 */
///<reference path="AndroidUI.ts"/>
var androidui;
(function (androidui) {
    if (typeof HTMLDivElement !== 'function') {
        var _HTMLDivElement = function () { };
        _HTMLDivElement.prototype = HTMLDivElement.prototype;
        HTMLDivElement = _HTMLDivElement;
    }
    class AndroidUIElement extends HTMLDivElement {
        performCreate() {
            this.AndroidUI = new androidui.AndroidUI(this);
            let debugAttr = this.getAttribute('debug');
            if (debugAttr != null && debugAttr != '0' && debugAttr != 'false')
                this.AndroidUI.showDebugLayout();
        }
        createdCallback() {
            $domReady(() => this.performCreate());
        }
        attachedCallback() {
        }
        detachedCallback() {
        }
        attributeChangedCallback(attributeName, oldVal, newVal) {
            if (attributeName === 'debug' && newVal != null && newVal != 'false' && newVal != '0') {
                this.AndroidUI.showDebugLayout();
            }
        }
    }
    androidui.AndroidUIElement = AndroidUIElement;
    if (typeof document['registerElement'] === "function") {
        document.registerElement("android-ui", AndroidUIElement);
    }
    else {
        $domReady(() => {
            let eles = document.getElementsByTagName('android-ui');
            for (let ele of Array.from(eles)) {
                ele.AndroidUI = new androidui.AndroidUI(ele);
            }
        });
    }
    function $domReady(func) {
        if (/^loaded|^complete|^interactive/.test(document.readyState)) {
            setTimeout(func, 0);
        }
        else {
            document.addEventListener('DOMContentLoaded', func);
        }
    }
})(androidui || (androidui = {}));
///<reference path="ViewParent.ts"/>
///<reference path="View.ts"/>
///<reference path="Surface.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../os/Handler.ts"/>
///<reference path="../os/Message.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Point.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../androidui/AndroidUIElement.ts"/>
var android;
(function (android) {
    var view;
    (function (view_3) {
        var View = android.view.View;
        var Rect = android.graphics.Rect;
        var Handler = android.os.Handler;
        var SystemClock = android.os.SystemClock;
        var System = java.lang.System;
        var Log = android.util.Log;
        var Surface = android.view.Surface;
        class ViewRootImpl {
            constructor() {
                this.mViewVisibility = View.GONE;
                this.mStopped = false;
                this.mWidth = -1;
                this.mHeight = -1;
                this.mDirty = new Rect();
                this.mIsAnimating = false;
                this.mTempRect = new Rect();
                this.mVisRect = new Rect();
                this.mTraversalScheduled = false;
                this.mWillDrawSoon = false;
                this.mIsInTraversal = false;
                this.mLayoutRequested = false;
                this.mFirst = true;
                this.mFullRedrawNeeded = false;
                this.mIsDrawing = false;
                this.mAdded = false;
                this.mAddedTouchMode = false;
                this.mInTouchMode = false;
                this.mWinFrame = new Rect();
                this.mLayoutRequesters = [];
                this.mHandler = new ViewRootHandler();
                this.mViewScrollChanged = false;
                this.mTreeObserver = new view_3.ViewTreeObserver();
                this.mIgnoreDirtyState = false;
                this.mSetIgnoreDirtyState = false;
                this.mDrawingTime = 0;
                this.mFpsStartTime = -1;
                this.mFpsPrevTime = -1;
                this.mFpsNumFrames = 0;
                this.mTraversalRunnable = new TraversalRunnable(this);
                this._continueTraversalesCount = 0;
                this.mInvalidateOnAnimationRunnable = new InvalidateOnAnimationRunnable(this.mHandler);
            }
            initSurface(canvasElement) {
                this.mSurface = new Surface(canvasElement, this);
            }
            notifyResized(frame) {
                this.mWinFrame.set(frame.left, frame.top, frame.right, frame.bottom);
                this.requestLayout();
                if (this.mSurface)
                    this.mSurface.notifyBoundChange();
            }
            setView(view) {
                if (this.mView == null) {
                    this.mView = view;
                    this.mAdded = true;
                    this.requestLayout();
                    view.assignParent(this);
                    this.mAddedTouchMode = true;
                    let syntheticInputStage = new SyntheticInputStage(this);
                    let viewPostImeStage = new ViewPostImeInputStage(this, syntheticInputStage);
                    let earlyPostImeStage = new EarlyPostImeInputStage(this, viewPostImeStage);
                    this.mFirstInputStage = earlyPostImeStage;
                }
            }
            getView() {
                return this.mView;
            }
            getHostVisibility() {
                return this.mView.getVisibility();
            }
            scheduleTraversals() {
                if (!this.mTraversalScheduled) {
                    this.mTraversalScheduled = true;
                    this.mHandler.postAsTraversal(this.mTraversalRunnable);
                }
            }
            unscheduleTraversals() {
                if (this.mTraversalScheduled) {
                    this.mTraversalScheduled = false;
                    this.mHandler.removeCallbacks(this.mTraversalRunnable);
                }
            }
            doTraversal() {
                if (this.mTraversalScheduled) {
                    this.mTraversalScheduled = false;
                    this.performTraversals();
                }
            }
            measureHierarchy(host, lp, desiredWindowWidth, desiredWindowHeight) {
                let windowSizeMayChange = false;
                if (ViewRootImpl.DEBUG_ORIENTATION || ViewRootImpl.DEBUG_LAYOUT)
                    Log.v(ViewRootImpl.TAG, "Measuring " + host + " in display " + desiredWindowWidth
                        + "x" + desiredWindowHeight + "...");
                let childWidthMeasureSpec = ViewRootImpl.getRootMeasureSpec(desiredWindowWidth, lp.width);
                let childHeightMeasureSpec = ViewRootImpl.getRootMeasureSpec(desiredWindowHeight, lp.height);
                this.performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                if (this.mWidth != host.getMeasuredWidth() || this.mHeight != host.getMeasuredHeight()) {
                    windowSizeMayChange = true;
                }
                if (ViewRootImpl.DBG) {
                    System.out.println("======================================");
                    System.out.println("performTraversals -- after measure");
                    host.debug();
                }
                return windowSizeMayChange;
            }
            static getRootMeasureSpec(windowSize, rootDimension) {
                let MeasureSpec = View.MeasureSpec;
                let measureSpec;
                switch (rootDimension) {
                    case view_3.ViewGroup.LayoutParams.MATCH_PARENT:
                        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
                        break;
                    case view_3.ViewGroup.LayoutParams.WRAP_CONTENT:
                        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
                        break;
                    default:
                        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
                        break;
                }
                return measureSpec;
            }
            performTraversals() {
                let host = this.mView;
                if (ViewRootImpl.DBG) {
                    System.out.println("======================================");
                    System.out.println("performTraversals");
                    host.debug();
                }
                if (host == null || !this.mAdded)
                    return;
                this.mIsInTraversal = true;
                this.mWillDrawSoon = true;
                let windowSizeMayChange = false;
                let newSurface = false;
                let surfaceChanged = false;
                let lp = new view_3.ViewGroup.LayoutParams(view_3.ViewGroup.LayoutParams.MATCH_PARENT, view_3.ViewGroup.LayoutParams.MATCH_PARENT);
                let desiredWindowWidth;
                let desiredWindowHeight;
                let viewVisibility = this.getHostVisibility();
                let viewVisibilityChanged = this.mViewVisibility != viewVisibility;
                let params = null;
                let frame = this.mWinFrame;
                desiredWindowWidth = frame.width();
                desiredWindowHeight = frame.height();
                if (this.mFirst) {
                    this.mFullRedrawNeeded = true;
                    this.mLayoutRequested = true;
                    viewVisibilityChanged = false;
                }
                else {
                    if (desiredWindowWidth != this.mWidth || desiredWindowHeight != this.mHeight) {
                        if (ViewRootImpl.DEBUG_ORIENTATION) {
                            Log.v(ViewRootImpl.TAG, "View " + host + " resized to: " + frame);
                        }
                        this.mFullRedrawNeeded = true;
                        this.mLayoutRequested = true;
                        windowSizeMayChange = true;
                    }
                }
                if (viewVisibilityChanged) {
                }
                ViewRootImpl.getRunQueue(this).executeActions(this.mHandler);
                let layoutRequested = this.mLayoutRequested;
                if (layoutRequested) {
                    if (this.mFirst) {
                        this.mInTouchMode = !this.mAddedTouchMode;
                        this.ensureTouchModeLocally(this.mAddedTouchMode);
                    }
                    else {
                        if (lp.width < 0 || lp.height < 0) {
                            windowSizeMayChange = true;
                        }
                    }
                    windowSizeMayChange == this.measureHierarchy(host, lp, desiredWindowWidth, desiredWindowHeight) || windowSizeMayChange;
                }
                if (layoutRequested) {
                    this.mLayoutRequested = false;
                }
                let windowShouldResize = layoutRequested && windowSizeMayChange
                    && ((this.mWidth != host.getMeasuredWidth() || this.mHeight != host.getMeasuredHeight())
                        || (lp.width < 0 && frame.width() !== desiredWindowWidth && frame.width() !== this.mWidth)
                        || (lp.height < 0 && frame.height() !== desiredWindowHeight && frame.height() !== this.mHeight));
                if (this.mFirst || windowShouldResize || viewVisibilityChanged) {
                    if (ViewRootImpl.DEBUG_LAYOUT) {
                        Log.i(ViewRootImpl.TAG, "host=w:" + host.getMeasuredWidth() + ", h:" +
                            host.getMeasuredHeight() + ", params=" + params);
                    }
                    if (ViewRootImpl.DEBUG_ORIENTATION)
                        Log.v(ViewRootImpl.TAG, "Relayout returned: frame=" + frame);
                    if (this.mWidth != frame.width() || this.mHeight != frame.height()) {
                        this.mWidth = frame.width();
                        this.mHeight = frame.height();
                    }
                    if (this.mWidth != host.getMeasuredWidth()
                        || this.mHeight != host.getMeasuredHeight()) {
                        let childWidthMeasureSpec = ViewRootImpl.getRootMeasureSpec(this.mWidth, lp.width);
                        let childHeightMeasureSpec = ViewRootImpl.getRootMeasureSpec(this.mHeight, lp.height);
                        if (ViewRootImpl.DEBUG_LAYOUT)
                            Log.v(ViewRootImpl.TAG, "Ooops, something changed!  mWidth="
                                + this.mWidth + " measuredWidth=" + host.getMeasuredWidth()
                                + " mHeight=" + this.mHeight
                                + " measuredHeight=" + host.getMeasuredHeight());
                        this.performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                        layoutRequested = true;
                    }
                }
                else {
                }
                const didLayout = layoutRequested;
                let triggerGlobalLayoutListener = didLayout;
                if (didLayout) {
                    this.performLayout(lp, desiredWindowWidth, desiredWindowHeight);
                    if (ViewRootImpl.DBG) {
                        System.out.println("======================================");
                        System.out.println("performTraversals -- after setFrame");
                        host.debug();
                    }
                }
                if (triggerGlobalLayoutListener) {
                    this.mTreeObserver.dispatchOnGlobalLayout();
                }
                let skipDraw = false;
                if (this.mFirst) {
                    if (ViewRootImpl.DEBUG_INPUT_RESIZE)
                        Log.v(ViewRootImpl.TAG, "First: mView.hasFocus()="
                            + this.mView.hasFocus());
                    if (this.mView != null) {
                        if (!this.mView.hasFocus()) {
                            this.mView.requestFocus(View.FOCUS_FORWARD);
                            if (ViewRootImpl.DEBUG_INPUT_RESIZE)
                                Log.v(ViewRootImpl.TAG, "First: requested focused view="
                                    + this.mView.findFocus());
                        }
                        else {
                            if (ViewRootImpl.DEBUG_INPUT_RESIZE)
                                Log.v(ViewRootImpl.TAG, "First: existing focused view="
                                    + this.mView.findFocus());
                        }
                    }
                }
                this.mFirst = false;
                this.mWillDrawSoon = false;
                this.mViewVisibility = viewVisibility;
                let cancelDraw = this.mTreeObserver.dispatchOnPreDraw() ||
                    viewVisibility != View.VISIBLE;
                if (!cancelDraw) {
                    if (!skipDraw) {
                        this.performDraw();
                    }
                }
                else {
                    if (viewVisibility == View.VISIBLE) {
                        this.scheduleTraversals();
                    }
                }
                this.mIsInTraversal = false;
                this.checkContinueTraversalsNextFrame();
            }
            performLayout(lp, desiredWindowWidth, desiredWindowHeight) {
                this.mLayoutRequested = false;
                this.mInLayout = true;
                let host = this.mView;
                if (ViewRootImpl.DEBUG_ORIENTATION || ViewRootImpl.DEBUG_LAYOUT) {
                    Log.v(ViewRootImpl.TAG, "Laying out " + host + " to (" +
                        host.getMeasuredWidth() + ", " + host.getMeasuredHeight() + ")");
                }
                host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
                this.mInLayout = false;
                let numViewsRequestingLayout = this.mLayoutRequesters.length;
                if (numViewsRequestingLayout > 0) {
                    let validLayoutRequesters = this.getValidLayoutRequesters(this.mLayoutRequesters, false);
                    if (validLayoutRequesters != null) {
                        this.mHandlingLayoutInLayoutRequest = true;
                        let numValidRequests = validLayoutRequesters.length;
                        for (let i = 0; i < numValidRequests; ++i) {
                            let view = validLayoutRequesters[i];
                            Log.w("View", "requestLayout() improperly called by " + view +
                                " during layout: running second layout pass");
                            view.requestLayout();
                        }
                        this.measureHierarchy(host, lp, desiredWindowWidth, desiredWindowHeight);
                        this.mInLayout = true;
                        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
                        this.mHandlingLayoutInLayoutRequest = false;
                        validLayoutRequesters = this.getValidLayoutRequesters(this.mLayoutRequesters, true);
                        if (validLayoutRequesters != null) {
                            let finalRequesters = validLayoutRequesters;
                            ViewRootImpl.getRunQueue(this).post({
                                run() {
                                    let numValidRequests = finalRequesters.length;
                                    for (let i = 0; i < numValidRequests; ++i) {
                                        const view = finalRequesters[i];
                                        Log.w("View", "requestLayout() improperly called by " + view +
                                            " during second layout pass: posting in next frame");
                                        view.requestLayout();
                                    }
                                }
                            });
                        }
                    }
                }
                this.mInLayout = false;
            }
            getValidLayoutRequesters(layoutRequesters, secondLayoutRequests) {
                let numViewsRequestingLayout = layoutRequesters.length;
                let validLayoutRequesters = null;
                for (let i = 0; i < numViewsRequestingLayout; ++i) {
                    let view = layoutRequesters[i];
                    if (view != null && view.mAttachInfo != null && view.mParent != null &&
                        (secondLayoutRequests || (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) ==
                            View.PFLAG_FORCE_LAYOUT)) {
                        let gone = false;
                        let parent = view;
                        while (parent != null) {
                            if ((parent.mViewFlags & View.VISIBILITY_MASK) == View.GONE) {
                                gone = true;
                                break;
                            }
                            if (parent.mParent instanceof View) {
                                parent = parent.mParent;
                            }
                            else {
                                parent = null;
                            }
                        }
                        if (!gone) {
                            if (validLayoutRequesters == null) {
                                validLayoutRequesters = [];
                            }
                            validLayoutRequesters.push(view);
                        }
                    }
                }
                if (!secondLayoutRequests) {
                    for (let i = 0; i < numViewsRequestingLayout; ++i) {
                        let view = layoutRequesters[i];
                        while (view != null &&
                            (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) != 0) {
                            view.mPrivateFlags &= ~View.PFLAG_FORCE_LAYOUT;
                            if (view.mParent instanceof View) {
                                view = view.mParent;
                            }
                            else {
                                view = null;
                            }
                        }
                    }
                }
                layoutRequesters.splice(0, layoutRequesters.length);
                return validLayoutRequesters;
            }
            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec) {
                this.mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            isInLayout() {
                return this.mInLayout;
            }
            requestLayoutDuringLayout(view) {
                if (view.mParent == null || view.mAttachInfo == null) {
                    return true;
                }
                if (this.mLayoutRequesters.indexOf(view) === -1) {
                    this.mLayoutRequesters.push(view);
                }
                if (!this.mHandlingLayoutInLayoutRequest) {
                    return true;
                }
                else {
                    return false;
                }
            }
            trackFPS() {
                let nowTime = System.currentTimeMillis();
                if (this.mFpsStartTime < 0) {
                    this.mFpsStartTime = this.mFpsPrevTime = nowTime;
                    this.mFpsNumFrames = 0;
                }
                else {
                    this.mFpsNumFrames++;
                    let frameTime = nowTime - this.mFpsPrevTime;
                    let totalTime = nowTime - this.mFpsStartTime;
                    this.mFpsPrevTime = nowTime;
                    if (totalTime > 1000) {
                        let fps = this.mFpsNumFrames * 1000 / totalTime;
                        Log.v(ViewRootImpl.TAG, "FPS:\t" + fps);
                        if (!this._showFPSNode) {
                            this._showFPSNode = document.createElement('div');
                            this._showFPSNode.style.position = 'absolute';
                            this._showFPSNode.style.top = '0';
                            this._showFPSNode.style.left = '0';
                            this._showFPSNode.style.width = '60px';
                            this._showFPSNode.style.fontSize = '14px';
                            this._showFPSNode.style.background = 'black';
                            this._showFPSNode.style.color = 'white';
                            this._showFPSNode.style.opacity = '0.7';
                            this.androidUIElement.appendChild(this._showFPSNode);
                        }
                        this._showFPSNode.innerText = 'FPS:' + fps.toFixed(1);
                        this.mFpsStartTime = nowTime;
                        this.mFpsNumFrames = 0;
                    }
                }
            }
            performDraw() {
                let fullRedrawNeeded = this.mFullRedrawNeeded || !this.mSurface.mSupportDirtyDraw;
                this.mFullRedrawNeeded = false;
                this.mIsDrawing = true;
                try {
                    this.draw(fullRedrawNeeded);
                }
                finally {
                    this.mIsDrawing = false;
                }
            }
            draw(fullRedrawNeeded) {
                let surface = this.mSurface;
                if (!surface.isValid()) {
                    return;
                }
                if (ViewRootImpl.DEBUG_FPS) {
                    this.trackFPS();
                }
                if (this.mViewScrollChanged) {
                    this.mViewScrollChanged = false;
                    this.mTreeObserver.dispatchOnScrollChanged();
                }
                if (fullRedrawNeeded) {
                    this.mIgnoreDirtyState = true;
                    this.mDirty.set(0, 0, this.mWidth, this.mHeight);
                }
                if (ViewRootImpl.DEBUG_ORIENTATION || ViewRootImpl.DEBUG_DRAW) {
                    Log.v(ViewRootImpl.TAG, "Draw " + this.mView + ", width=" + this.mWidth + ", height=" + this.mHeight + ", dirty=" + this.mDirty);
                }
                this.mTreeObserver.dispatchOnDraw();
                this.drawSoftware();
            }
            drawSoftware() {
                let canvas;
                try {
                    canvas = this.mSurface.lockCanvas(this.mDirty);
                }
                catch (e) {
                    return;
                }
                this.mDirty.setEmpty();
                this.mIsAnimating = false;
                this.mDrawingTime = SystemClock.uptimeMillis();
                this.mView.mPrivateFlags |= View.PFLAG_DRAWN;
                this.mSetIgnoreDirtyState = false;
                this.mView.draw(canvas);
                if (!this.mSetIgnoreDirtyState) {
                    this.mIgnoreDirtyState = false;
                }
                this.mSurface.unlockCanvasAndPost(canvas);
                if (ViewRootImpl.LOCAL_LOGV) {
                    Log.v(ViewRootImpl.TAG, "Surface unlockCanvasAndPost");
                }
            }
            checkContinueTraversalsNextFrame() {
                //AndroidUI add:
                //Because of some reason, sometime will skip a frame to traversals when scroll.
                //Let's continuing traversales next frame.
                const continueFrame = ViewRootImpl.DEBUG_FPS ? 60 : 5;
                if (!this.mTraversalScheduled && this._continueTraversalesCount < continueFrame) {
                    this._continueTraversalesCount++;
                    this.scheduleTraversals();
                }
                else {
                    this._continueTraversalesCount = 0;
                }
            }
            isLayoutRequested() {
                return this.mLayoutRequested;
            }
            dispatchInvalidateDelayed(view, delayMilliseconds) {
                let msg = this.mHandler.obtainMessage(ViewRootHandler.MSG_INVALIDATE, view);
                this.mHandler.sendMessageDelayed(msg, delayMilliseconds);
            }
            dispatchInvalidateRectDelayed(info, delayMilliseconds) {
                let msg = this.mHandler.obtainMessage(ViewRootHandler.MSG_INVALIDATE_RECT, info);
                this.mHandler.sendMessageDelayed(msg, delayMilliseconds);
            }
            dispatchInvalidateOnAnimation(view) {
                this.mInvalidateOnAnimationRunnable.addView(view);
            }
            dispatchInvalidateRectOnAnimation(info) {
                this.mInvalidateOnAnimationRunnable.addViewRect(info);
            }
            cancelInvalidate(view) {
                this.mHandler.removeMessages(ViewRootHandler.MSG_INVALIDATE, view);
                this.mHandler.removeMessages(ViewRootHandler.MSG_INVALIDATE_RECT, view);
                this.mInvalidateOnAnimationRunnable.removeView(view);
            }
            getParent() {
                return null;
            }
            requestLayout() {
                if (!this.mHandlingLayoutInLayoutRequest) {
                    this.mLayoutRequested = true;
                    this.scheduleTraversals();
                }
            }
            invalidate() {
                this.mDirty.set(0, 0, this.mWidth, this.mHeight);
                this.scheduleTraversals();
            }
            invalidateWorld(view) {
                view.invalidate();
                if (view instanceof view_3.ViewGroup) {
                    let parent = view;
                    for (let i = 0; i < parent.getChildCount(); i++) {
                        this.invalidateWorld(parent.getChildAt(i));
                    }
                }
            }
            invalidateChild(child, dirty) {
                this.invalidateChildInParent(null, dirty);
            }
            invalidateChildInParent(location, dirty) {
                if (ViewRootImpl.DEBUG_DRAW)
                    Log.v(ViewRootImpl.TAG, "Invalidate child: " + dirty);
                if (dirty == null) {
                    this.invalidate();
                    return null;
                }
                else if (dirty.isEmpty() && !this.mIsAnimating) {
                    return null;
                }
                const localDirty = this.mDirty;
                if (!localDirty.isEmpty() && !localDirty.contains(dirty)) {
                    this.mSetIgnoreDirtyState = true;
                    this.mIgnoreDirtyState = true;
                }
                localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);
                const intersected = localDirty.intersect(0, 0, this.mWidth, this.mHeight);
                if (!intersected) {
                    localDirty.setEmpty();
                }
                if (!this.mWillDrawSoon && (intersected || this.mIsAnimating)) {
                    this.scheduleTraversals();
                }
                return null;
            }
            requestChildFocus(child, focused) {
                if (ViewRootImpl.DEBUG_INPUT_RESIZE) {
                    Log.v(ViewRootImpl.TAG, "Request child focus: focus now " + focused);
                }
                this.scheduleTraversals();
            }
            clearChildFocus(focused) {
                if (ViewRootImpl.DEBUG_INPUT_RESIZE) {
                    Log.v(ViewRootImpl.TAG, "Request child focus: focus now " + focused);
                }
                this.scheduleTraversals();
            }
            getChildVisibleRect(child, r, offset) {
                if (child != this.mView) {
                    throw new Error("child is not mine, honest!");
                }
                return r.intersect(0, 0, this.mWidth, this.mHeight);
            }
            focusSearch(focused, direction) {
                if (!(this.mView instanceof view_3.ViewGroup)) {
                    return null;
                }
                return view_3.FocusFinder.getInstance().findNextFocus(this.mView, focused, direction);
            }
            bringChildToFront(child) {
            }
            focusableViewAvailable(v) {
                if (this.mView != null) {
                    if (!this.mView.hasFocus()) {
                        v.requestFocus();
                    }
                    else {
                        let focused = this.mView.findFocus();
                        if (focused instanceof view_3.ViewGroup) {
                            let group = focused;
                            if (group.getDescendantFocusability() == view_3.ViewGroup.FOCUS_AFTER_DESCENDANTS
                                && ViewRootImpl.isViewDescendantOf(v, focused)) {
                                v.requestFocus();
                            }
                        }
                    }
                }
            }
            static isViewDescendantOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof view_3.ViewGroup) && ViewRootImpl.isViewDescendantOf(theParent, parent);
            }
            childDrawableStateChanged(child) {
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                return false;
            }
            childHasTransientStateChanged(child, hasTransientState) {
            }
            dispatchInputEvent(event) {
                this.deliverInputEvent(event);
                let result = event[InputStage.FLAG_FINISHED_HANDLED];
                event[InputStage.FLAG_FINISHED] = false;
                event[InputStage.FLAG_FINISHED_HANDLED] = false;
                let continueToDom = event[ViewRootImpl.ContinueEventToDom];
                event[ViewRootImpl.ContinueEventToDom] = null;
                return result && !continueToDom;
            }
            deliverInputEvent(event) {
                this.mFirstInputStage.deliver(event);
            }
            finishInputEvent(event) {
            }
            checkForLeavingTouchModeAndConsume(event) {
                if (!this.mInTouchMode) {
                    return false;
                }
                const action = event.getAction();
                if (action != view_3.KeyEvent.ACTION_DOWN) {
                    return false;
                }
                if (ViewRootImpl.isNavigationKey(event)) {
                    return this.ensureTouchMode(false);
                }
                if (ViewRootImpl.isTypingKey(event)) {
                    this.ensureTouchMode(false);
                    return false;
                }
                return false;
            }
            static isNavigationKey(keyEvent) {
                switch (keyEvent.getKeyCode()) {
                    case view_3.KeyEvent.KEYCODE_DPAD_LEFT:
                    case view_3.KeyEvent.KEYCODE_DPAD_RIGHT:
                    case view_3.KeyEvent.KEYCODE_DPAD_UP:
                    case view_3.KeyEvent.KEYCODE_DPAD_DOWN:
                    case view_3.KeyEvent.KEYCODE_DPAD_CENTER:
                    case view_3.KeyEvent.KEYCODE_PAGE_UP:
                    case view_3.KeyEvent.KEYCODE_PAGE_DOWN:
                    case view_3.KeyEvent.KEYCODE_MOVE_HOME:
                    case view_3.KeyEvent.KEYCODE_MOVE_END:
                    case view_3.KeyEvent.KEYCODE_TAB:
                    case view_3.KeyEvent.KEYCODE_SPACE:
                    case view_3.KeyEvent.KEYCODE_ENTER:
                        return true;
                }
                return false;
            }
            static isTypingKey(keyEvent) {
                try {
                    return keyEvent.mIsTypingKey;
                }
                catch (e) {
                    console.warn(e);
                }
                return true;
            }
            ensureTouchMode(inTouchMode) {
                if (ViewRootImpl.DBG)
                    Log.d("touchmode", "ensureTouchMode(" + inTouchMode + "), current "
                        + "touch mode is " + this.mInTouchMode);
                if (this.mInTouchMode == inTouchMode)
                    return false;
                return this.ensureTouchModeLocally(inTouchMode);
            }
            ensureTouchModeLocally(inTouchMode) {
                if (ViewRootImpl.DBG)
                    Log.d("touchmode", "ensureTouchModeLocally(" + inTouchMode + "), current "
                        + "touch mode is " + this.mInTouchMode);
                if (this.mInTouchMode == inTouchMode)
                    return false;
                this.mInTouchMode = inTouchMode;
                this.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
                return (inTouchMode) ? this.enterTouchMode() : this.leaveTouchMode();
            }
            enterTouchMode() {
                if (this.mView != null && this.mView.hasFocus()) {
                    const focused = this.mView.findFocus();
                    if (focused != null && !focused.isFocusableInTouchMode()) {
                        const ancestorToTakeFocus = ViewRootImpl.findAncestorToTakeFocusInTouchMode(focused);
                        if (ancestorToTakeFocus != null) {
                            return ancestorToTakeFocus.requestFocus();
                        }
                        else {
                            focused.clearFocusInternal(true, false);
                            return true;
                        }
                    }
                }
                return false;
            }
            static findAncestorToTakeFocusInTouchMode(focused) {
                let parent = focused.getParent();
                while (parent instanceof view_3.ViewGroup) {
                    const vgParent = parent;
                    if (vgParent.getDescendantFocusability() == view_3.ViewGroup.FOCUS_AFTER_DESCENDANTS
                        && vgParent.isFocusableInTouchMode()) {
                        return vgParent;
                    }
                    if (vgParent.isRootNamespace()) {
                        return null;
                    }
                    else {
                        parent = vgParent.getParent();
                    }
                }
                return null;
            }
            leaveTouchMode() {
                if (this.mView != null) {
                    if (this.mView.hasFocus()) {
                        let focusedView = this.mView.findFocus();
                        if (!(focusedView instanceof view_3.ViewGroup)) {
                            return false;
                        }
                        else if (focusedView.getDescendantFocusability() !=
                            view_3.ViewGroup.FOCUS_AFTER_DESCENDANTS) {
                            return false;
                        }
                    }
                    const focused = this.focusSearch(null, View.FOCUS_DOWN);
                    if (focused != null) {
                        return focused.requestFocus(View.FOCUS_DOWN);
                    }
                }
                return false;
            }
            static getRunQueue(viewRoot) {
                if (viewRoot) {
                    if (!viewRoot.mRunQueue)
                        viewRoot.mRunQueue = new ViewRootImpl.RunQueue();
                    return viewRoot.mRunQueue;
                }
                else {
                    if (!this.RunQueueInstance) {
                        this.RunQueueInstance = new RunQueueForNoViewRoot();
                    }
                    return this.RunQueueInstance;
                }
            }
        }
        ViewRootImpl.TAG = "ViewRootImpl";
        ViewRootImpl.DBG = Log.View_DBG;
        ViewRootImpl.LOCAL_LOGV = ViewRootImpl.DBG;
        ViewRootImpl.DEBUG_DRAW = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_LAYOUT = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_INPUT_RESIZE = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_ORIENTATION = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_CONFIGURATION = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_FPS = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.ContinueEventToDom = Symbol();
        view_3.ViewRootImpl = ViewRootImpl;
        (function (ViewRootImpl) {
            class RunQueue {
                constructor() {
                    this.mActions = [];
                }
                post(action) {
                    this.postDelayed(action, 0);
                }
                postDelayed(action, delayMillis) {
                    let handlerAction = {
                        action: action,
                        delay: delayMillis
                    };
                    this.mActions.push(handlerAction);
                }
                removeCallbacks(action) {
                    this.mActions = this.mActions.filter((item) => {
                        return item.action == action;
                    });
                }
                executeActions(handler) {
                    for (let handlerAction of this.mActions) {
                        handler.postDelayed(handlerAction.action, handlerAction.delay);
                    }
                    this.mActions = [];
                }
            }
            ViewRootImpl.RunQueue = RunQueue;
        })(ViewRootImpl = view_3.ViewRootImpl || (view_3.ViewRootImpl = {}));
        class RunQueueForNoViewRoot extends ViewRootImpl.RunQueue {
            postDelayed(action, delayMillis) {
                RunQueueForNoViewRoot.Handler.postDelayed(action, delayMillis);
            }
            removeCallbacks(action) {
                RunQueueForNoViewRoot.Handler.removeCallbacks(action);
            }
        }
        RunQueueForNoViewRoot.Handler = new Handler();
        class TraversalRunnable {
            constructor(impl) {
                this.ViewRootImpl_this = impl;
            }
            run() {
                this.ViewRootImpl_this.doTraversal();
            }
        }
        class InvalidateOnAnimationRunnable {
            constructor(handler) {
                this.mPosted = false;
                this.mViews = new Set();
                this.mViewRects = new Map();
                this.mHandler = handler;
            }
            addView(view) {
                this.mViews.add(view);
                this.postIfNeededLocked();
            }
            addViewRect(info) {
                this.mViewRects.set(info.target, info);
                this.postIfNeededLocked();
            }
            removeView(view) {
                this.mViews.delete(view);
                this.mViewRects.delete(view);
                if (this.mPosted && this.mViews.size === 0 && this.mViewRects.size === 0) {
                    this.mHandler.removeCallbacks(this);
                    this.mPosted = false;
                }
            }
            run() {
                this.mPosted = false;
                for (let view of this.mViews) {
                    view.invalidate();
                }
                this.mViews.clear();
                for (let info of this.mViewRects.values()) {
                    info.target.invalidate(info.left, info.top, info.right, info.bottom);
                    info.recycle();
                }
                this.mViewRects.clear();
            }
            postIfNeededLocked() {
                if (!this.mPosted) {
                    this.mHandler.post(this);
                    this.mPosted = true;
                }
            }
        }
        class ViewRootHandler extends Handler {
            handleMessage(msg) {
                switch (msg.what) {
                    case ViewRootHandler.MSG_INVALIDATE:
                        msg.obj.invalidate();
                        break;
                    case ViewRootHandler.MSG_INVALIDATE_RECT:
                        const info = msg.obj;
                        info.target.invalidate(info.left, info.top, info.right, info.bottom);
                        info.recycle();
                        break;
                }
            }
        }
        ViewRootHandler.MSG_INVALIDATE = 1;
        ViewRootHandler.MSG_INVALIDATE_RECT = 2;
        class InputStage {
            constructor(impl, next) {
                this.ViewRootImpl_this = impl;
                this.mNext = next;
            }
            deliver(event) {
                if (event[InputStage.FLAG_FINISHED]) {
                    this.forward(event);
                }
                else if (this.shouldDropInputEvent(event)) {
                    this.finish(event, false);
                }
                else {
                    this.apply(event, this.onProcess(event));
                }
            }
            finish(event, handled) {
                event[InputStage.FLAG_FINISHED] = true;
                if (handled) {
                    event[InputStage.FLAG_FINISHED_HANDLED] = true;
                }
                this.forward(event);
            }
            forward(event) {
                this.onDeliverToNext(event);
            }
            apply(event, result) {
                if (result == InputStage.FORWARD) {
                    this.forward(event);
                }
                else if (result == InputStage.FINISH_HANDLED) {
                    this.finish(event, true);
                }
                else if (result == InputStage.FINISH_NOT_HANDLED) {
                    this.finish(event, false);
                }
                else {
                    throw new Error("Invalid result: " + result);
                }
            }
            onDeliverToNext(event) {
                if (this.mNext != null) {
                    this.mNext.deliver(event);
                }
                else {
                    this.ViewRootImpl_this.finishInputEvent(event);
                }
            }
            onProcess(event) {
                return InputStage.FORWARD;
            }
            shouldDropInputEvent(event) {
                if (this.ViewRootImpl_this.mView == null || !this.ViewRootImpl_this.mAdded) {
                    Log.w(ViewRootImpl.TAG, "Dropping event due to root view being removed: " + event);
                    return true;
                }
                return false;
            }
        }
        InputStage.FLAG_FINISHED = Symbol();
        InputStage.FLAG_FINISHED_HANDLED = Symbol();
        InputStage.FORWARD = 0;
        InputStage.FINISH_HANDLED = 1;
        InputStage.FINISH_NOT_HANDLED = 2;
        class EarlyPostImeInputStage extends InputStage {
            onProcess(event) {
                if (event instanceof view_3.MotionEvent) {
                    return this.processMotionEvent(event);
                }
                else if (event instanceof view_3.KeyEvent) {
                    return this.processKeyEvent(event);
                }
                return InputStage.FORWARD;
            }
            processKeyEvent(event) {
                if (this.ViewRootImpl_this.checkForLeavingTouchModeAndConsume(event)) {
                    return InputStage.FINISH_HANDLED;
                }
                return InputStage.FORWARD;
            }
            processMotionEvent(event) {
                const action = event.getAction();
                if (action == view_3.MotionEvent.ACTION_DOWN || action == view_3.MotionEvent.ACTION_SCROLL) {
                    this.ViewRootImpl_this.ensureTouchMode(true);
                }
                event.offsetLocation(this.ViewRootImpl_this.mWinFrame.left, this.ViewRootImpl_this.mWinFrame.top);
                return InputStage.FORWARD;
            }
        }
        class ViewPostImeInputStage extends InputStage {
            onProcess(event) {
                if (event instanceof view_3.KeyEvent) {
                    return this.processKeyEvent(event);
                }
                else if (event instanceof view_3.MotionEvent) {
                    if (event.isTouchEvent()) {
                        return this.processTouchEvent(event);
                    }
                    else {
                        return this.processGenericMotionEvent(event);
                    }
                }
                return InputStage.FORWARD;
            }
            processKeyEvent(event) {
                let mView = this.ViewRootImpl_this.mView;
                if (this.ViewRootImpl_this.mView.dispatchKeyEvent(event)) {
                    return InputStage.FINISH_HANDLED;
                }
                if (this.shouldDropInputEvent(event)) {
                    return InputStage.FINISH_NOT_HANDLED;
                }
                if (event.getAction() == view_3.KeyEvent.ACTION_DOWN
                    && event.isCtrlPressed()
                    && event.getRepeatCount() == 0) {
                    if (this.ViewRootImpl_this.shouldDropInputEvent(event)) {
                        return InputStage.FINISH_NOT_HANDLED;
                    }
                }
                if (this.shouldDropInputEvent(event)) {
                    return InputStage.FINISH_NOT_HANDLED;
                }
                if (event.getAction() == view_3.KeyEvent.ACTION_DOWN) {
                    let direction = 0;
                    switch (event.getKeyCode()) {
                        case view_3.KeyEvent.KEYCODE_DPAD_LEFT:
                            direction = View.FOCUS_LEFT;
                            break;
                        case view_3.KeyEvent.KEYCODE_DPAD_RIGHT:
                            direction = View.FOCUS_RIGHT;
                            break;
                        case view_3.KeyEvent.KEYCODE_DPAD_UP:
                            direction = View.FOCUS_UP;
                            break;
                        case view_3.KeyEvent.KEYCODE_DPAD_DOWN:
                            direction = View.FOCUS_DOWN;
                            break;
                        case view_3.KeyEvent.KEYCODE_TAB:
                            if (event.isShiftPressed()) {
                                direction = View.FOCUS_BACKWARD;
                            }
                            else {
                                direction = View.FOCUS_FORWARD;
                            }
                            break;
                    }
                    if (direction != 0) {
                        let focused = mView.findFocus();
                        if (focused != null) {
                            let v = focused.focusSearch(direction);
                            if (v != null && v != focused) {
                                focused.getFocusedRect(this.ViewRootImpl_this.mTempRect);
                                if (mView instanceof view_3.ViewGroup) {
                                    mView.offsetDescendantRectToMyCoords(focused, this.ViewRootImpl_this.mTempRect);
                                    mView.offsetRectIntoDescendantCoords(v, this.ViewRootImpl_this.mTempRect);
                                }
                                if (v.requestFocus(direction, this.ViewRootImpl_this.mTempRect)) {
                                    return InputStage.FINISH_HANDLED;
                                }
                            }
                            if (mView.dispatchUnhandledMove(focused, direction)) {
                                return InputStage.FINISH_HANDLED;
                            }
                        }
                        else {
                            let v = this.ViewRootImpl_this.focusSearch(null, direction);
                            if (v != null && v.requestFocus(direction)) {
                                return InputStage.FINISH_HANDLED;
                            }
                        }
                    }
                }
                return InputStage.FORWARD;
            }
            processGenericMotionEvent(event) {
                if (this.ViewRootImpl_this.mView.dispatchGenericMotionEvent(event)) {
                    return InputStage.FINISH_HANDLED;
                }
                return InputStage.FORWARD;
            }
            processTouchEvent(event) {
                let handled = this.ViewRootImpl_this.mView.dispatchTouchEvent(event);
                return handled ? InputStage.FINISH_HANDLED : InputStage.FORWARD;
            }
        }
        class SyntheticInputStage extends InputStage {
            onProcess(event) {
                return super.onProcess(event);
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/10.
 */
///<reference path="View.ts"/>
///<reference path="ViewGroup.ts"/>
var android;
(function (android) {
    var view;
    (function (view_4) {
        var View = android.view.View;
        var Rect = android.graphics.Rect;
        var ArrayList = java.util.ArrayList;
        class FocusFinder {
            constructor() {
                this.mFocusedRect = new Rect();
                this.mOtherRect = new Rect();
                this.mBestCandidateRect = new Rect();
                this.mSequentialFocusComparator = new SequentialFocusComparator();
                this.mTempList = new ArrayList();
            }
            static getInstance() {
                if (!FocusFinder.sFocusFinder) {
                    FocusFinder.sFocusFinder = new FocusFinder();
                }
                return FocusFinder.sFocusFinder;
            }
            findNextFocus(root, focused, direction) {
                return this._findNextFocus(root, focused, null, direction);
            }
            findNextFocusFromRect(root, focusedRect, direction) {
                this.mFocusedRect.set(focusedRect);
                return this._findNextFocus(root, null, this.mFocusedRect, direction);
            }
            _findNextFocus(root, focused, focusedRect, direction) {
                let next = null;
                if (focused != null) {
                    next = this.findNextUserSpecifiedFocus(root, focused, direction);
                }
                if (next != null) {
                    return next;
                }
                let focusables = this.mTempList;
                try {
                    focusables.clear();
                    root.addFocusables(focusables, direction);
                    if (!focusables.isEmpty()) {
                        next = this.__findNextFocus(root, focused, focusedRect, direction, focusables);
                    }
                }
                finally {
                    focusables.clear();
                }
                return next;
            }
            findNextUserSpecifiedFocus(root, focused, direction) {
                let userSetNextFocus = focused.findUserSetNextFocus(root, direction);
                if (userSetNextFocus != null && userSetNextFocus.isFocusable()
                    && (!userSetNextFocus.isInTouchMode()
                        || userSetNextFocus.isFocusableInTouchMode())) {
                    return userSetNextFocus;
                }
                return null;
            }
            __findNextFocus(root, focused, focusedRect, direction, focusables) {
                if (focused != null) {
                    if (focusedRect == null) {
                        focusedRect = this.mFocusedRect;
                    }
                    focused.getFocusedRect(focusedRect);
                    root.offsetDescendantRectToMyCoords(focused, focusedRect);
                }
                else {
                    if (focusedRect == null) {
                        focusedRect = this.mFocusedRect;
                        switch (direction) {
                            case View.FOCUS_RIGHT:
                            case View.FOCUS_DOWN:
                                this.setFocusTopLeft(root, focusedRect);
                                break;
                            case View.FOCUS_FORWARD:
                                this.setFocusTopLeft(root, focusedRect);
                                break;
                            case View.FOCUS_LEFT:
                            case View.FOCUS_UP:
                                this.setFocusBottomRight(root, focusedRect);
                                break;
                            case View.FOCUS_BACKWARD:
                                this.setFocusBottomRight(root, focusedRect);
                        }
                    }
                }
                switch (direction) {
                    case View.FOCUS_FORWARD:
                    case View.FOCUS_BACKWARD:
                        return this.findNextFocusInRelativeDirection(focusables, root, focused, focusedRect, direction);
                    case View.FOCUS_UP:
                    case View.FOCUS_DOWN:
                    case View.FOCUS_LEFT:
                    case View.FOCUS_RIGHT:
                        return this.findNextFocusInAbsoluteDirection(focusables, root, focused, focusedRect, direction);
                    default:
                        throw new Error("Unknown direction: " + direction);
                }
            }
            findNextFocusInRelativeDirection(focusables, root, focused, focusedRect, direction) {
                try {
                    this.mSequentialFocusComparator.setRoot(root);
                    this.mSequentialFocusComparator.sort(focusables);
                }
                finally {
                    this.mSequentialFocusComparator.recycle();
                }
                const count = focusables.size();
                switch (direction) {
                    case View.FOCUS_FORWARD:
                        return FocusFinder.getNextFocusable(focused, focusables, count);
                    case View.FOCUS_BACKWARD:
                        return FocusFinder.getPreviousFocusable(focused, focusables, count);
                }
                return focusables.get(count - 1);
            }
            setFocusBottomRight(root, focusedRect) {
                const rootBottom = root.getScrollY() + root.getHeight();
                const rootRight = root.getScrollX() + root.getWidth();
                focusedRect.set(rootRight, rootBottom, rootRight, rootBottom);
            }
            setFocusTopLeft(root, focusedRect) {
                const rootTop = root.getScrollY();
                const rootLeft = root.getScrollX();
                focusedRect.set(rootLeft, rootTop, rootLeft, rootTop);
            }
            findNextFocusInAbsoluteDirection(focusables, root, focused, focusedRect, direction) {
                this.mBestCandidateRect.set(focusedRect);
                switch (direction) {
                    case View.FOCUS_LEFT:
                        this.mBestCandidateRect.offset(focusedRect.width() + 1, 0);
                        break;
                    case View.FOCUS_RIGHT:
                        this.mBestCandidateRect.offset(-(focusedRect.width() + 1), 0);
                        break;
                    case View.FOCUS_UP:
                        this.mBestCandidateRect.offset(0, focusedRect.height() + 1);
                        break;
                    case View.FOCUS_DOWN:
                        this.mBestCandidateRect.offset(0, -(focusedRect.height() + 1));
                }
                let closest = null;
                let numFocusables = focusables.size();
                for (let i = 0; i < numFocusables; i++) {
                    let focusable = focusables.get(i);
                    if (focusable == focused || focusable == root)
                        continue;
                    focusable.getFocusedRect(this.mOtherRect);
                    root.offsetDescendantRectToMyCoords(focusable, this.mOtherRect);
                    if (this.isBetterCandidate(direction, focusedRect, this.mOtherRect, this.mBestCandidateRect)) {
                        this.mBestCandidateRect.set(this.mOtherRect);
                        closest = focusable;
                    }
                }
                return closest;
            }
            static getNextFocusable(focused, focusables, count) {
                if (focused != null) {
                    let position = focusables.lastIndexOf(focused);
                    if (position >= 0 && position + 1 < count) {
                        return focusables.get(position + 1);
                    }
                }
                if (!focusables.isEmpty()) {
                    return focusables.get(0);
                }
                return null;
            }
            static getPreviousFocusable(focused, focusables, count) {
                if (focused != null) {
                    let position = focusables.indexOf(focused);
                    if (position > 0) {
                        return focusables.get(position - 1);
                    }
                }
                if (!focusables.isEmpty()) {
                    return focusables.get(count - 1);
                }
                return null;
            }
            isBetterCandidate(direction, source, rect1, rect2) {
                if (!this.isCandidate(source, rect1, direction)) {
                    return false;
                }
                if (!this.isCandidate(source, rect2, direction)) {
                    return true;
                }
                if (this.beamBeats(direction, source, rect1, rect2)) {
                    return true;
                }
                if (this.beamBeats(direction, source, rect2, rect1)) {
                    return false;
                }
                return (this.getWeightedDistanceFor(FocusFinder.majorAxisDistance(direction, source, rect1), FocusFinder.minorAxisDistance(direction, source, rect1))
                    < this.getWeightedDistanceFor(FocusFinder.majorAxisDistance(direction, source, rect2), FocusFinder.minorAxisDistance(direction, source, rect2)));
            }
            beamBeats(direction, source, rect1, rect2) {
                const rect1InSrcBeam = this.beamsOverlap(direction, source, rect1);
                const rect2InSrcBeam = this.beamsOverlap(direction, source, rect2);
                if (rect2InSrcBeam || !rect1InSrcBeam) {
                    return false;
                }
                if (!this.isToDirectionOf(direction, source, rect2)) {
                    return true;
                }
                if ((direction == View.FOCUS_LEFT || direction == View.FOCUS_RIGHT)) {
                    return true;
                }
                return (FocusFinder.majorAxisDistance(direction, source, rect1)
                    < FocusFinder.majorAxisDistanceToFarEdge(direction, source, rect2));
            }
            getWeightedDistanceFor(majorAxisDistance, minorAxisDistance) {
                return 13 * majorAxisDistance * majorAxisDistance
                    + minorAxisDistance * minorAxisDistance;
            }
            isCandidate(srcRect, destRect, direction) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return (srcRect.right > destRect.right || srcRect.left >= destRect.right)
                            && srcRect.left > destRect.left;
                    case View.FOCUS_RIGHT:
                        return (srcRect.left < destRect.left || srcRect.right <= destRect.left)
                            && srcRect.right < destRect.right;
                    case View.FOCUS_UP:
                        return (srcRect.bottom > destRect.bottom || srcRect.top >= destRect.bottom)
                            && srcRect.top > destRect.top;
                    case View.FOCUS_DOWN:
                        return (srcRect.top < destRect.top || srcRect.bottom <= destRect.top)
                            && srcRect.bottom < destRect.bottom;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            beamsOverlap(direction, rect1, rect2) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                    case View.FOCUS_RIGHT:
                        return (rect2.bottom >= rect1.top) && (rect2.top <= rect1.bottom);
                    case View.FOCUS_UP:
                    case View.FOCUS_DOWN:
                        return (rect2.right >= rect1.left) && (rect2.left <= rect1.right);
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            isToDirectionOf(direction, src, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return src.left >= dest.right;
                    case View.FOCUS_RIGHT:
                        return src.right <= dest.left;
                    case View.FOCUS_UP:
                        return src.top >= dest.bottom;
                    case View.FOCUS_DOWN:
                        return src.bottom <= dest.top;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            static majorAxisDistance(direction, source, dest) {
                return Math.max(0, FocusFinder.majorAxisDistanceRaw(direction, source, dest));
            }
            static majorAxisDistanceRaw(direction, source, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return source.left - dest.right;
                    case View.FOCUS_RIGHT:
                        return dest.left - source.right;
                    case View.FOCUS_UP:
                        return source.top - dest.bottom;
                    case View.FOCUS_DOWN:
                        return dest.top - source.bottom;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            static majorAxisDistanceToFarEdge(direction, source, dest) {
                return Math.max(1, FocusFinder.majorAxisDistanceToFarEdgeRaw(direction, source, dest));
            }
            static majorAxisDistanceToFarEdgeRaw(direction, source, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return source.left - dest.left;
                    case View.FOCUS_RIGHT:
                        return dest.right - source.right;
                    case View.FOCUS_UP:
                        return source.top - dest.top;
                    case View.FOCUS_DOWN:
                        return dest.bottom - source.bottom;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            static minorAxisDistance(direction, source, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                    case View.FOCUS_RIGHT:
                        return Math.abs(((source.top + source.height() / 2) -
                            ((dest.top + dest.height() / 2))));
                    case View.FOCUS_UP:
                    case View.FOCUS_DOWN:
                        return Math.abs(((source.left + source.width() / 2) -
                            ((dest.left + dest.width() / 2))));
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            findNearestTouchable(root, x, y, direction, deltas) {
                let touchables = root.getTouchables();
                let minDistance = Number.MAX_SAFE_INTEGER;
                let closest = null;
                let numTouchables = touchables.size();
                let edgeSlop = view_4.ViewConfiguration.get().getScaledEdgeSlop();
                let closestBounds = new Rect();
                let touchableBounds = this.mOtherRect;
                for (let i = 0; i < numTouchables; i++) {
                    let touchable = touchables.get(i);
                    touchable.getDrawingRect(touchableBounds);
                    root.offsetRectBetweenParentAndChild(touchable, touchableBounds, true, true);
                    if (!this.isTouchCandidate(x, y, touchableBounds, direction)) {
                        continue;
                    }
                    let distance = Number.MAX_SAFE_INTEGER;
                    switch (direction) {
                        case View.FOCUS_LEFT:
                            distance = x - touchableBounds.right + 1;
                            break;
                        case View.FOCUS_RIGHT:
                            distance = touchableBounds.left;
                            break;
                        case View.FOCUS_UP:
                            distance = y - touchableBounds.bottom + 1;
                            break;
                        case View.FOCUS_DOWN:
                            distance = touchableBounds.top;
                            break;
                    }
                    if (distance < edgeSlop) {
                        if (closest == null ||
                            closestBounds.contains(touchableBounds) ||
                            (!touchableBounds.contains(closestBounds) && distance < minDistance)) {
                            minDistance = distance;
                            closest = touchable;
                            closestBounds.set(touchableBounds);
                            switch (direction) {
                                case View.FOCUS_LEFT:
                                    deltas[0] = -distance;
                                    break;
                                case View.FOCUS_RIGHT:
                                    deltas[0] = distance;
                                    break;
                                case View.FOCUS_UP:
                                    deltas[1] = -distance;
                                    break;
                                case View.FOCUS_DOWN:
                                    deltas[1] = distance;
                                    break;
                            }
                        }
                    }
                }
                return closest;
            }
            isTouchCandidate(x, y, destRect, direction) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return destRect.left <= x && destRect.top <= y && y <= destRect.bottom;
                    case View.FOCUS_RIGHT:
                        return destRect.left >= x && destRect.top <= y && y <= destRect.bottom;
                    case View.FOCUS_UP:
                        return destRect.top <= y && destRect.left <= x && x <= destRect.right;
                    case View.FOCUS_DOWN:
                        return destRect.top >= y && destRect.left <= x && x <= destRect.right;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
        }
        view_4.FocusFinder = FocusFinder;
        class SequentialFocusComparator {
            constructor() {
                this.mFirstRect = new Rect();
                this.mSecondRect = new Rect();
                this.mIsLayoutRtl = false;
                this.compareFn = (first, second) => {
                    if (first == second) {
                        return 0;
                    }
                    this.getRect(first, this.mFirstRect);
                    this.getRect(second, this.mSecondRect);
                    if (this.mFirstRect.top < this.mSecondRect.top) {
                        return -1;
                    }
                    else if (this.mFirstRect.top > this.mSecondRect.top) {
                        return 1;
                    }
                    else if (this.mFirstRect.left < this.mSecondRect.left) {
                        return this.mIsLayoutRtl ? 1 : -1;
                    }
                    else if (this.mFirstRect.left > this.mSecondRect.left) {
                        return this.mIsLayoutRtl ? -1 : 1;
                    }
                    else if (this.mFirstRect.bottom < this.mSecondRect.bottom) {
                        return -1;
                    }
                    else if (this.mFirstRect.bottom > this.mSecondRect.bottom) {
                        return 1;
                    }
                    else if (this.mFirstRect.right < this.mSecondRect.right) {
                        return this.mIsLayoutRtl ? 1 : -1;
                    }
                    else if (this.mFirstRect.right > this.mSecondRect.right) {
                        return this.mIsLayoutRtl ? -1 : 1;
                    }
                    else {
                        return 0;
                    }
                };
            }
            recycle() {
                this.mRoot = null;
            }
            setRoot(root) {
                this.mRoot = root;
            }
            getRect(view, rect) {
                view.getDrawingRect(rect);
                this.mRoot.offsetDescendantRectToMyCoords(view, rect);
            }
            sort(array) {
                array.sort(this.compareFn);
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class Integer {
            static parseInt(value) {
                return Number.parseInt(value);
            }
            static toHexString(n) {
                if (!n)
                    return n + '';
                return n.toString(16);
            }
        }
        Integer.MIN_VALUE = Number.MIN_SAFE_INTEGER;
        Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
        lang.Integer = Integer;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="ViewOverlay.ts"/>
///<reference path="ViewRootImpl.ts"/>
///<reference path="View.ts"/>
///<reference path="MotionEvent.ts"/>
///<reference path="ViewParent.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../graphics/Point.ts"/>
///<reference path="../graphics/Matrix.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/RectF.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../util/TypedValue.ts"/>
///<reference path="../content/Context.ts"/>
///<reference path="FocusFinder.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="animation/Animation.ts"/>
///<reference path="animation/Transformation.ts"/>
var android;
(function (android) {
    var view;
    (function (view_5) {
        var Rect = android.graphics.Rect;
        var SystemClock = android.os.SystemClock;
        var TypedValue = android.util.TypedValue;
        var System = java.lang.System;
        var ArrayList = java.util.ArrayList;
        var Integer = java.lang.Integer;
        var Transformation = view_5.animation.Transformation;
        class ViewGroup extends view_5.View {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mLastTouchDownTime = 0;
                this.mLastTouchDownIndex = -1;
                this.mLastTouchDownX = 0;
                this.mLastTouchDownY = 0;
                this.mGroupFlags = 0;
                this.mLayoutMode = ViewGroup.LAYOUT_MODE_UNDEFINED;
                this.mChildren = [];
                this.mSuppressLayout = false;
                this.mLayoutCalledWhileSuppressed = false;
                this.mChildCountWithTransientState = 0;
                this.initViewGroup();
                const a = this._attrBinder;
                a.addAttr('clipChildren', (value) => {
                    this.setClipChildren(a.parseBoolean(value));
                }, () => {
                    return this.getClipChildren();
                });
                a.addAttr('clipToPadding', (value) => {
                    this.setClipToPadding(a.parseBoolean(value));
                }, () => {
                    return this.isClipToPadding();
                });
                a.addAttr('animationCache', (value) => {
                    this.setAnimationCacheEnabled(a.parseBoolean(value, true));
                });
                a.addAttr('persistentDrawingCache', (value) => {
                    if (value == 'none')
                        this.setPersistentDrawingCache(ViewGroup.PERSISTENT_NO_CACHE);
                    else if (value == 'animation')
                        this.setPersistentDrawingCache(ViewGroup.PERSISTENT_ANIMATION_CACHE);
                    else if (value == 'scrolling')
                        this.setPersistentDrawingCache(ViewGroup.PERSISTENT_SCROLLING_CACHE);
                    else if (value == 'all')
                        this.setPersistentDrawingCache(ViewGroup.PERSISTENT_ALL_CACHES);
                });
                a.addAttr('addStatesFromChildren', (value) => {
                    this.setAddStatesFromChildren(a.parseBoolean(value, false));
                });
                a.addAttr('alwaysDrawnWithCache', (value) => {
                    this.setAlwaysDrawnWithCacheEnabled(a.parseBoolean(value, true));
                });
                a.addAttr('descendantFocusability', (value) => {
                    if (value == 'beforeDescendants')
                        this.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
                    else if (value == 'afterDescendants')
                        this.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
                    else if (value == 'blocksDescendants')
                        this.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
                });
                a.addAttr('splitMotionEvents', (value) => {
                    this.setMotionEventSplittingEnabled(a.parseBoolean(value, false));
                });
            }
            get mChildrenCount() {
                return this.mChildren.length;
            }
            initViewGroup() {
                this.setFlags(view_5.View.WILL_NOT_DRAW, view_5.View.DRAW_MASK);
                this.mGroupFlags |= ViewGroup.FLAG_CLIP_CHILDREN;
                this.mGroupFlags |= ViewGroup.FLAG_CLIP_TO_PADDING;
                this.mGroupFlags |= ViewGroup.FLAG_ANIMATION_DONE;
                this.mGroupFlags |= ViewGroup.FLAG_ANIMATION_CACHE;
                this.mGroupFlags |= ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE;
                this.mGroupFlags |= ViewGroup.FLAG_SPLIT_MOTION_EVENTS;
                this.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
                this.mPersistentDrawingCache = ViewGroup.PERSISTENT_SCROLLING_CACHE;
            }
            getDescendantFocusability() {
                return this.mGroupFlags & ViewGroup.FLAG_MASK_FOCUSABILITY;
            }
            setDescendantFocusability(focusability) {
                switch (focusability) {
                    case ViewGroup.FOCUS_BEFORE_DESCENDANTS:
                    case ViewGroup.FOCUS_AFTER_DESCENDANTS:
                    case ViewGroup.FOCUS_BLOCK_DESCENDANTS:
                        break;
                    default:
                        throw new Error("must be one of FOCUS_BEFORE_DESCENDANTS, "
                            + "FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS");
                }
                this.mGroupFlags &= ~ViewGroup.FLAG_MASK_FOCUSABILITY;
                this.mGroupFlags |= (focusability & ViewGroup.FLAG_MASK_FOCUSABILITY);
            }
            handleFocusGainInternal(direction, previouslyFocusedRect) {
                if (this.mFocused != null) {
                    this.mFocused.unFocus();
                    this.mFocused = null;
                }
                super.handleFocusGainInternal(direction, previouslyFocusedRect);
            }
            requestChildFocus(child, focused) {
                if (view_5.View.DBG) {
                    System.out.println(this + " requestChildFocus()");
                }
                if (this.getDescendantFocusability() == ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                    return;
                }
                super.unFocus();
                if (this.mFocused != child) {
                    if (this.mFocused != null) {
                        this.mFocused.unFocus();
                    }
                    this.mFocused = child;
                }
                if (this.mParent != null) {
                    this.mParent.requestChildFocus(this, focused);
                }
            }
            focusableViewAvailable(v) {
                if (this.mParent != null
                    && (this.getDescendantFocusability() != ViewGroup.FOCUS_BLOCK_DESCENDANTS)
                    && !(this.isFocused() && this.getDescendantFocusability() != ViewGroup.FOCUS_AFTER_DESCENDANTS)) {
                    this.mParent.focusableViewAvailable(v);
                }
            }
            focusSearch(...args) {
                if (arguments.length === 1) {
                    return super.focusSearch(args[0]);
                }
                let [focused, direction] = args;
                if (this.isRootNamespace()) {
                    return view_5.FocusFinder.getInstance().findNextFocus(this, focused, direction);
                }
                else if (this.mParent != null) {
                    return this.mParent.focusSearch(focused, direction);
                }
                return null;
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                return false;
            }
            childHasTransientStateChanged(child, childHasTransientState) {
                const oldHasTransientState = this.hasTransientState();
                if (childHasTransientState) {
                    this.mChildCountWithTransientState++;
                }
                else {
                    this.mChildCountWithTransientState--;
                }
                const newHasTransientState = this.hasTransientState();
                if (this.mParent != null && oldHasTransientState != newHasTransientState) {
                    this.mParent.childHasTransientStateChanged(this, newHasTransientState);
                }
            }
            hasTransientState() {
                return this.mChildCountWithTransientState > 0 || super.hasTransientState();
            }
            dispatchUnhandledMove(focused, direction) {
                return this.mFocused != null && this.mFocused.dispatchUnhandledMove(focused, direction);
            }
            clearChildFocus(child) {
                if (view_5.View.DBG) {
                    System.out.println(this + " clearChildFocus()");
                }
                this.mFocused = null;
                if (this.mParent != null) {
                    this.mParent.clearChildFocus(this);
                }
            }
            clearFocus() {
                if (view_5.View.DBG) {
                    System.out.println(this + " clearFocus()");
                }
                if (this.mFocused == null) {
                    super.clearFocus();
                }
                else {
                    let focused = this.mFocused;
                    this.mFocused = null;
                    focused.clearFocus();
                }
            }
            unFocus() {
                if (view_5.View.DBG) {
                    System.out.println(this + " unFocus()");
                }
                if (this.mFocused == null) {
                    super.unFocus();
                }
                else {
                    this.mFocused.unFocus();
                    this.mFocused = null;
                }
            }
            getFocusedChild() {
                return this.mFocused;
            }
            hasFocus() {
                return (this.mPrivateFlags & view_5.View.PFLAG_FOCUSED) != 0 || this.mFocused != null;
            }
            findFocus() {
                if (ViewGroup.DBG) {
                    System.out.println("Find focus in " + this + ": flags=" + this.isFocused() + ", child=" + this.mFocused);
                }
                if (this.isFocused()) {
                    return this;
                }
                if (this.mFocused != null) {
                    return this.mFocused.findFocus();
                }
                return null;
            }
            hasFocusable() {
                if ((this.mViewFlags & view_5.View.VISIBILITY_MASK) != view_5.View.VISIBLE) {
                    return false;
                }
                if (this.isFocusable()) {
                    return true;
                }
                const descendantFocusability = this.getDescendantFocusability();
                if (descendantFocusability != ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                    const count = this.mChildrenCount;
                    const children = this.mChildren;
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if (child.hasFocusable()) {
                            return true;
                        }
                    }
                }
                return false;
            }
            addFocusables(views, direction, focusableMode = view_5.View.FOCUSABLES_TOUCH_MODE) {
                const focusableCount = views.size();
                const descendantFocusability = this.getDescendantFocusability();
                if (descendantFocusability != ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                    const count = this.mChildrenCount;
                    const children = this.mChildren;
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if ((child.mViewFlags & view_5.View.VISIBILITY_MASK) == view_5.View.VISIBLE) {
                            child.addFocusables(views, direction, focusableMode);
                        }
                    }
                }
                if (descendantFocusability != ViewGroup.FOCUS_AFTER_DESCENDANTS
                    || (focusableCount == views.size())) {
                    super.addFocusables(views, direction, focusableMode);
                }
            }
            requestFocus(direction = view_5.View.FOCUS_DOWN, previouslyFocusedRect = null) {
                if (view_5.View.DBG) {
                    System.out.println(this + " ViewGroup.requestFocus direction="
                        + direction);
                }
                let descendantFocusability = this.getDescendantFocusability();
                switch (descendantFocusability) {
                    case ViewGroup.FOCUS_BLOCK_DESCENDANTS:
                        return super.requestFocus(direction, previouslyFocusedRect);
                    case ViewGroup.FOCUS_BEFORE_DESCENDANTS: {
                        const took = super.requestFocus(direction, previouslyFocusedRect);
                        return took ? took : this.onRequestFocusInDescendants(direction, previouslyFocusedRect);
                    }
                    case ViewGroup.FOCUS_AFTER_DESCENDANTS: {
                        const took = this.onRequestFocusInDescendants(direction, previouslyFocusedRect);
                        return took ? took : super.requestFocus(direction, previouslyFocusedRect);
                    }
                    default:
                        throw new Error("descendant focusability must be "
                            + "one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "
                            + "but is " + descendantFocusability);
                }
            }
            onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                let index;
                let increment;
                let end;
                let count = this.mChildrenCount;
                if ((direction & view_5.View.FOCUS_FORWARD) != 0) {
                    index = 0;
                    increment = 1;
                    end = count;
                }
                else {
                    index = count - 1;
                    increment = -1;
                    end = -1;
                }
                const children = this.mChildren;
                for (let i = index; i != end; i += increment) {
                    let child = children[i];
                    if ((child.mViewFlags & view_5.View.VISIBILITY_MASK) == view_5.View.VISIBLE) {
                        if (child.requestFocus(direction, previouslyFocusedRect)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            addView(...args) {
                let child = args[0];
                let params = child.getLayoutParams();
                let index = -1;
                if (args.length == 2) {
                    if (args[1] instanceof ViewGroup.LayoutParams)
                        params = args[1];
                    else if (typeof args[1] === 'number')
                        index = args[1];
                }
                else if (args.length == 3) {
                    if (args[2] instanceof ViewGroup.LayoutParams) {
                        index = args[1];
                        params = args[2];
                    }
                    else {
                        params = this.generateDefaultLayoutParams();
                        params.width = args[1];
                        params.height = args[2];
                    }
                }
                if (params == null) {
                    params = this.generateDefaultLayoutParams();
                    if (params == null) {
                        throw new Error("generateDefaultLayoutParams() cannot return null");
                    }
                }
                this.requestLayout();
                this.invalidate(true);
                this.addViewInner(child, index, params, false);
            }
            checkLayoutParams(p) {
                return p != null;
            }
            setOnHierarchyChangeListener(listener) {
                this.mOnHierarchyChangeListener = listener;
            }
            onViewAdded(child) {
                if (this.mOnHierarchyChangeListener != null) {
                    this.mOnHierarchyChangeListener.onChildViewAdded(this, child);
                }
            }
            onViewRemoved(child) {
                if (this.mOnHierarchyChangeListener != null) {
                    this.mOnHierarchyChangeListener.onChildViewRemoved(this, child);
                }
            }
            clearCachedLayoutMode() {
                if (!this.hasBooleanFlag(ViewGroup.FLAG_LAYOUT_MODE_WAS_EXPLICITLY_SET)) {
                    this.mLayoutMode = ViewGroup.LAYOUT_MODE_UNDEFINED;
                }
            }
            addViewInLayout(child, index, params, preventRequestLayout = false) {
                child.mParent = null;
                this.addViewInner(child, index, params, preventRequestLayout);
                child.mPrivateFlags = (child.mPrivateFlags & ~ViewGroup.PFLAG_DIRTY_MASK) | ViewGroup.PFLAG_DRAWN;
                return true;
            }
            cleanupLayoutState(child) {
                child.mPrivateFlags &= ~view_5.View.PFLAG_FORCE_LAYOUT;
            }
            addViewInner(child, index, params, preventRequestLayout) {
                if (child.getParent() != null) {
                    throw new Error("The specified child already has a parent. " +
                        "You must call removeView() on the child's parent first.");
                }
                if (!this.checkLayoutParams(params)) {
                    params = this.generateLayoutParams(params);
                }
                if (preventRequestLayout) {
                    child.mLayoutParams = params;
                }
                else {
                    child.setLayoutParams(params);
                }
                if (index < 0) {
                    index = this.mChildrenCount;
                }
                this.addInArray(child, index);
                if (preventRequestLayout) {
                    child.assignParent(this);
                }
                else {
                    child.mParent = this;
                }
                if (child.hasFocus()) {
                    this.requestChildFocus(child, child.findFocus());
                }
                let ai = this.mAttachInfo;
                if (ai != null && (this.mGroupFlags & ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW) == 0) {
                    child.dispatchAttachedToWindow(this.mAttachInfo, (this.mViewFlags & ViewGroup.VISIBILITY_MASK));
                }
                this.onViewAdded(child);
                if ((child.mViewFlags & ViewGroup.DUPLICATE_PARENT_STATE) == ViewGroup.DUPLICATE_PARENT_STATE) {
                    this.mGroupFlags |= ViewGroup.FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE;
                }
            }
            addInArray(child, index) {
                let count = this.mChildrenCount;
                if (index == count) {
                    this.mChildren.push(child);
                    this.addToBindElement(child.bindElement, null);
                }
                else if (index < count) {
                    let refChild = this.getChildAt(index);
                    this.mChildren.splice(index, 0, child);
                    this.addToBindElement(child.bindElement, refChild.bindElement);
                }
                else {
                    throw new Error("index=" + index + " count=" + count);
                }
            }
            addToBindElement(childElement, insertBeforeElement) {
                if (childElement.parentElement) {
                    if (childElement.parentElement == this.bindElement)
                        return;
                    childElement.parentElement.removeChild(childElement);
                }
                if (insertBeforeElement) {
                    this.bindElement.insertBefore(childElement, insertBeforeElement);
                }
                else {
                    this.bindElement.appendChild(childElement);
                }
            }
            removeChildElement(childElement) {
                try {
                    this.bindElement.removeChild(childElement);
                }
                catch (e) {
                }
            }
            removeFromArray(index, count = 1) {
                let start = Math.max(0, index);
                let end = Math.min(this.mChildrenCount, start + count);
                if (start == end) {
                    return;
                }
                for (let i = start; i < end; i++) {
                    this.mChildren[i].mParent = null;
                    this.removeChildElement(this.mChildren[i].bindElement);
                }
                this.mChildren.splice(index, end - start);
            }
            removeView(view) {
                this.removeViewInternal(view);
                this.requestLayout();
                this.invalidate(true);
            }
            removeViewInLayout(view) {
                this.removeViewInternal(view);
            }
            removeViewsInLayout(start, count) {
                this.removeViewsInternal(start, count);
            }
            removeViewAt(index) {
                this.removeViewsInternal(index, 1);
                this.requestLayout();
                this.invalidate(true);
            }
            removeViews(start, count) {
                this.removeViewsInternal(start, count);
                this.requestLayout();
                this.invalidate(true);
            }
            removeViewInternal(view) {
                let index = this.indexOfChild(view);
                if (index >= 0) {
                    this.removeViewsInternal(index, 1);
                }
            }
            removeViewsInternal(start, count) {
                let focused = this.mFocused;
                let clearChildFocus = false;
                const detach = this.mAttachInfo != null;
                const children = this.mChildren;
                const end = start + count;
                for (let i = start; i < end; i++) {
                    const view = children[i];
                    if (view == focused) {
                        view.unFocus();
                        clearChildFocus = true;
                    }
                    this.cancelTouchTarget(view);
                    if (view.getAnimation() != null) {
                        this.addDisappearingView(view);
                    }
                    else if (detach) {
                        view.dispatchDetachedFromWindow();
                    }
                    this.onViewRemoved(view);
                }
                this.removeFromArray(start, count);
                if (clearChildFocus) {
                    this.clearChildFocus(focused);
                    if (!this.rootViewRequestFocus()) {
                        this.notifyGlobalFocusCleared(focused);
                    }
                }
            }
            removeAllViews() {
                this.removeAllViewsInLayout();
                this.requestLayout();
                this.invalidate(true);
            }
            removeAllViewsInLayout() {
                const count = this.mChildrenCount;
                if (count <= 0) {
                    return;
                }
                this.removeViewsInternal(0, count);
            }
            detachViewFromParent(child) {
                if (child instanceof view_5.View)
                    child = this.indexOfChild(child);
                this.removeFromArray(child);
            }
            removeDetachedView(child, animate) {
                if (child == this.mFocused) {
                    child.clearFocus();
                }
                this.cancelTouchTarget(child);
                if ((animate && child.getAnimation() != null)) {
                    this.addDisappearingView(child);
                }
                else if (child.mAttachInfo != null) {
                    child.dispatchDetachedFromWindow();
                }
                if (child.hasTransientState()) {
                    this.childHasTransientStateChanged(child, false);
                }
                this.onViewRemoved(child);
            }
            attachViewToParent(child, index, params) {
                child.mLayoutParams = params;
                if (index < 0) {
                    index = this.mChildrenCount;
                }
                this.addInArray(child, index);
                child.mParent = this;
                child.mPrivateFlags = (child.mPrivateFlags & ~ViewGroup.PFLAG_DIRTY_MASK & ~ViewGroup.PFLAG_DRAWING_CACHE_VALID) | ViewGroup.PFLAG_DRAWN | ViewGroup.PFLAG_INVALIDATED;
                this.mPrivateFlags |= ViewGroup.PFLAG_INVALIDATED;
                if (child.hasFocus()) {
                    this.requestChildFocus(child, child.findFocus());
                }
            }
            detachViewsFromParent(start, count = 1) {
                this.removeFromArray(start, count);
            }
            detachAllViewsFromParent() {
                const count = this.mChildrenCount;
                if (count <= 0) {
                    return;
                }
                const children = this.mChildren;
                this.mChildren = [];
                for (let i = count - 1; i >= 0; i--) {
                    children[i].mParent = null;
                    this.removeChildElement(children[i].bindElement);
                }
            }
            indexOfChild(child) {
                return this.mChildren.indexOf(child);
            }
            getChildCount() {
                return this.mChildrenCount;
            }
            getChildAt(index) {
                if (index < 0 || index >= this.mChildrenCount) {
                    return null;
                }
                return this.mChildren[index];
            }
            bringChildToFront(child) {
                let index = this.indexOfChild(child);
                if (index >= 0) {
                    this.removeFromArray(index);
                    this.addInArray(child, this.mChildrenCount);
                    child.mParent = this;
                    this.requestLayout();
                    this.invalidate();
                }
            }
            hasBooleanFlag(flag) {
                return (this.mGroupFlags & flag) == flag;
            }
            setBooleanFlag(flag, value) {
                if (value) {
                    this.mGroupFlags |= flag;
                }
                else {
                    this.mGroupFlags &= ~flag;
                }
            }
            dispatchGenericPointerEvent(event) {
                const childrenCount = this.mChildrenCount;
                if (childrenCount != 0) {
                    const children = this.mChildren;
                    const x = event.getX();
                    const y = event.getY();
                    const customOrder = this.isChildrenDrawingOrderEnabled();
                    for (let i = childrenCount - 1; i >= 0; i--) {
                        const childIndex = customOrder ? this.getChildDrawingOrder(childrenCount, i) : i;
                        const child = children[childIndex];
                        if (!ViewGroup.canViewReceivePointerEvents(child)
                            || !this.isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        if (this.dispatchTransformedGenericPointerEvent(event, child)) {
                            return true;
                        }
                    }
                }
                return super.dispatchGenericPointerEvent(event);
            }
            dispatchTransformedGenericPointerEvent(event, child) {
                const offsetX = this.mScrollX - child.mLeft;
                const offsetY = this.mScrollY - child.mTop;
                let handled;
                if (!child.hasIdentityMatrix()) {
                }
                else {
                    event.offsetLocation(offsetX, offsetY);
                    handled = child.dispatchGenericMotionEvent(event);
                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            dispatchKeyEvent(event) {
                if ((this.mPrivateFlags & (view_5.View.PFLAG_FOCUSED | view_5.View.PFLAG_HAS_BOUNDS))
                    == (view_5.View.PFLAG_FOCUSED | view_5.View.PFLAG_HAS_BOUNDS)) {
                    if (super.dispatchKeyEvent(event)) {
                        return true;
                    }
                }
                else if (this.mFocused != null && (this.mFocused.mPrivateFlags & view_5.View.PFLAG_HAS_BOUNDS)
                    == view_5.View.PFLAG_HAS_BOUNDS) {
                    if (this.mFocused.dispatchKeyEvent(event)) {
                        return true;
                    }
                }
                return false;
            }
            dispatchWindowFocusChanged(hasFocus) {
                super.dispatchWindowFocusChanged(hasFocus);
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchWindowFocusChanged(hasFocus);
                }
            }
            addTouchables(views) {
                super.addTouchables(views);
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    const child = children[i];
                    if ((child.mViewFlags & view_5.View.VISIBILITY_MASK) == view_5.View.VISIBLE) {
                        child.addTouchables(views);
                    }
                }
            }
            onInterceptTouchEvent(ev) {
                return false;
            }
            dispatchTouchEvent(ev) {
                let handled = false;
                if (this.onFilterTouchEventForSecurity(ev)) {
                    let action = ev.getAction();
                    let actionMasked = action & view_5.MotionEvent.ACTION_MASK;
                    if (actionMasked == view_5.MotionEvent.ACTION_DOWN) {
                        this.cancelAndClearTouchTargets(ev);
                        this.resetTouchState();
                    }
                    let intercepted;
                    if (actionMasked == view_5.MotionEvent.ACTION_DOWN
                        || this.mFirstTouchTarget != null) {
                        let disallowIntercept = (this.mGroupFlags & ViewGroup.FLAG_DISALLOW_INTERCEPT) != 0;
                        if (!disallowIntercept) {
                            intercepted = this.onInterceptTouchEvent(ev);
                            ev.setAction(action);
                        }
                        else {
                            intercepted = false;
                        }
                    }
                    else {
                        intercepted = true;
                    }
                    let canceled = ViewGroup.resetCancelNextUpFlag(this)
                        || actionMasked == view_5.MotionEvent.ACTION_CANCEL;
                    let split = (this.mGroupFlags & ViewGroup.FLAG_SPLIT_MOTION_EVENTS) != 0;
                    let newTouchTarget = null;
                    let alreadyDispatchedToNewTouchTarget = false;
                    if (!canceled && !intercepted) {
                        if (actionMasked == view_5.MotionEvent.ACTION_DOWN
                            || (split && actionMasked == view_5.MotionEvent.ACTION_POINTER_DOWN)
                            || actionMasked == view_5.MotionEvent.ACTION_HOVER_MOVE) {
                            let actionIndex = ev.getActionIndex();
                            let idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                                : TouchTarget.ALL_POINTER_IDS;
                            this.removePointersFromTouchTargets(idBitsToAssign);
                            let childrenCount = this.mChildrenCount;
                            if (newTouchTarget == null && childrenCount != 0) {
                                let x = ev.getX(actionIndex);
                                let y = ev.getY(actionIndex);
                                let children = this.mChildren;
                                let customOrder = this.isChildrenDrawingOrderEnabled();
                                for (let i = childrenCount - 1; i >= 0; i--) {
                                    let childIndex = customOrder ? this.getChildDrawingOrder(childrenCount, i) : i;
                                    let child = children[childIndex];
                                    if (!ViewGroup.canViewReceivePointerEvents(child)
                                        || !this.isTransformedTouchPointInView(x, y, child, null)) {
                                        continue;
                                    }
                                    newTouchTarget = this.getTouchTarget(child);
                                    if (newTouchTarget != null) {
                                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                                        break;
                                    }
                                    ViewGroup.resetCancelNextUpFlag(child);
                                    if (this.dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                        this.mLastTouchDownTime = ev.getDownTime();
                                        this.mLastTouchDownIndex = childIndex;
                                        this.mLastTouchDownX = ev.getX();
                                        this.mLastTouchDownY = ev.getY();
                                        newTouchTarget = this.addTouchTarget(child, idBitsToAssign);
                                        alreadyDispatchedToNewTouchTarget = true;
                                        break;
                                    }
                                }
                            }
                            if (newTouchTarget == null && this.mFirstTouchTarget != null) {
                                newTouchTarget = this.mFirstTouchTarget;
                                while (newTouchTarget.next != null) {
                                    newTouchTarget = newTouchTarget.next;
                                }
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                            }
                        }
                    }
                    if (this.mFirstTouchTarget == null) {
                        handled = this.dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
                    }
                    else {
                        let predecessor = null;
                        let target = this.mFirstTouchTarget;
                        while (target != null) {
                            const next = target.next;
                            if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                                handled = true;
                            }
                            else {
                                let cancelChild = ViewGroup.resetCancelNextUpFlag(target.child)
                                    || intercepted;
                                if (this.dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                                    handled = true;
                                }
                                if (cancelChild) {
                                    if (predecessor == null) {
                                        this.mFirstTouchTarget = next;
                                    }
                                    else {
                                        predecessor.next = next;
                                    }
                                    target.recycle();
                                    target = next;
                                    continue;
                                }
                            }
                            predecessor = target;
                            target = next;
                        }
                    }
                    if (canceled
                        || actionMasked == view_5.MotionEvent.ACTION_UP
                        || actionMasked == view_5.MotionEvent.ACTION_HOVER_MOVE) {
                        this.resetTouchState();
                    }
                    else if (split && actionMasked == view_5.MotionEvent.ACTION_POINTER_UP) {
                        let actionIndex = ev.getActionIndex();
                        let idBitsToRemove = 1 << ev.getPointerId(actionIndex);
                        this.removePointersFromTouchTargets(idBitsToRemove);
                    }
                }
                return handled;
            }
            resetTouchState() {
                this.clearTouchTargets();
                ViewGroup.resetCancelNextUpFlag(this);
                this.mGroupFlags &= ~ViewGroup.FLAG_DISALLOW_INTERCEPT;
            }
            static resetCancelNextUpFlag(view) {
                if ((view.mPrivateFlags & view_5.View.PFLAG_CANCEL_NEXT_UP_EVENT) != 0) {
                    view.mPrivateFlags &= ~view_5.View.PFLAG_CANCEL_NEXT_UP_EVENT;
                    return true;
                }
                return false;
            }
            clearTouchTargets() {
                let target = this.mFirstTouchTarget;
                if (target != null) {
                    do {
                        let next = target.next;
                        target.recycle();
                        target = next;
                    } while (target != null);
                    this.mFirstTouchTarget = null;
                }
            }
            cancelAndClearTouchTargets(event) {
                if (this.mFirstTouchTarget != null) {
                    let syntheticEvent = false;
                    if (event == null) {
                        let now = SystemClock.uptimeMillis();
                        event = view_5.MotionEvent.obtainWithAction(now, now, view_5.MotionEvent.ACTION_CANCEL, 0, 0);
                        syntheticEvent = true;
                    }
                    for (let target = this.mFirstTouchTarget; target != null; target = target.next) {
                        ViewGroup.resetCancelNextUpFlag(target.child);
                        this.dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);
                    }
                    this.clearTouchTargets();
                    if (syntheticEvent) {
                        event.recycle();
                    }
                }
            }
            getTouchTarget(child) {
                for (let target = this.mFirstTouchTarget; target != null; target = target.next) {
                    if (target.child == child) {
                        return target;
                    }
                }
                return null;
            }
            addTouchTarget(child, pointerIdBits) {
                let target = TouchTarget.obtain(child, pointerIdBits);
                target.next = this.mFirstTouchTarget;
                this.mFirstTouchTarget = target;
                return target;
            }
            removePointersFromTouchTargets(pointerIdBits) {
                let predecessor = null;
                let target = this.mFirstTouchTarget;
                while (target != null) {
                    let next = target.next;
                    if ((target.pointerIdBits & pointerIdBits) != 0) {
                        target.pointerIdBits &= ~pointerIdBits;
                        if (target.pointerIdBits == 0) {
                            if (predecessor == null) {
                                this.mFirstTouchTarget = next;
                            }
                            else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }
            cancelTouchTarget(view) {
                let predecessor = null;
                let target = this.mFirstTouchTarget;
                while (target != null) {
                    let next = target.next;
                    if (target.child == view) {
                        if (predecessor == null) {
                            this.mFirstTouchTarget = next;
                        }
                        else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        let now = SystemClock.uptimeMillis();
                        let event = view_5.MotionEvent.obtainWithAction(now, now, view_5.MotionEvent.ACTION_CANCEL, 0, 0);
                        view.dispatchTouchEvent(event);
                        event.recycle();
                        return;
                    }
                    predecessor = target;
                    target = next;
                }
            }
            static canViewReceivePointerEvents(child) {
                return (child.mViewFlags & view_5.View.VISIBILITY_MASK) == view_5.View.VISIBLE
                    || child.getAnimation() != null;
            }
            isTransformedTouchPointInView(x, y, child, outLocalPoint) {
                let localX = x + this.mScrollX - child.mLeft;
                let localY = y + this.mScrollY - child.mTop;
                let isInView = child.pointInView(localX, localY);
                if (isInView && outLocalPoint != null) {
                    outLocalPoint.set(localX, localY);
                }
                return isInView;
            }
            dispatchTransformedTouchEvent(event, cancel, child, desiredPointerIdBits) {
                let handled;
                const oldAction = event.getAction();
                if (cancel || oldAction == view_5.MotionEvent.ACTION_CANCEL) {
                    event.setAction(view_5.MotionEvent.ACTION_CANCEL);
                    if (child == null) {
                        handled = super.dispatchTouchEvent(event);
                    }
                    else {
                        handled = child.dispatchTouchEvent(event);
                    }
                    event.setAction(oldAction);
                    return handled;
                }
                const oldPointerIdBits = event.getPointerIdBits();
                const newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;
                if (newPointerIdBits == 0) {
                    return false;
                }
                let transformedEvent;
                if (newPointerIdBits == oldPointerIdBits) {
                    if (child == null || child.hasIdentityMatrix()) {
                        if (child == null) {
                            handled = super.dispatchTouchEvent(event);
                        }
                        else {
                            let offsetX = this.mScrollX - child.mLeft;
                            let offsetY = this.mScrollY - child.mTop;
                            event.offsetLocation(offsetX, offsetY);
                            handled = child.dispatchTouchEvent(event);
                            event.offsetLocation(-offsetX, -offsetY);
                        }
                        return handled;
                    }
                    transformedEvent = view_5.MotionEvent.obtain(event);
                }
                else {
                    transformedEvent = event.split(newPointerIdBits);
                }
                if (child == null) {
                    handled = super.dispatchTouchEvent(transformedEvent);
                }
                else {
                    let offsetX = this.mScrollX - child.mLeft;
                    let offsetY = this.mScrollY - child.mTop;
                    transformedEvent.offsetLocation(offsetX, offsetY);
                    handled = child.dispatchTouchEvent(transformedEvent);
                }
                transformedEvent.recycle();
                return handled;
            }
            setMotionEventSplittingEnabled(split) {
                if (split) {
                    this.mGroupFlags |= ViewGroup.FLAG_SPLIT_MOTION_EVENTS;
                }
                else {
                    this.mGroupFlags &= ~ViewGroup.FLAG_SPLIT_MOTION_EVENTS;
                }
            }
            isMotionEventSplittingEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_SPLIT_MOTION_EVENTS) == ViewGroup.FLAG_SPLIT_MOTION_EVENTS;
            }
            isAnimationCacheEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_ANIMATION_CACHE) == ViewGroup.FLAG_ANIMATION_CACHE;
            }
            setAnimationCacheEnabled(enabled) {
                this.setBooleanFlag(ViewGroup.FLAG_ANIMATION_CACHE, enabled);
            }
            isAlwaysDrawnWithCacheEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) == ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE;
            }
            setAlwaysDrawnWithCacheEnabled(always) {
                this.setBooleanFlag(ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE, always);
            }
            isChildrenDrawnWithCacheEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) == ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE;
            }
            setChildrenDrawnWithCacheEnabled(enabled) {
                this.setBooleanFlag(ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE, enabled);
            }
            setChildrenDrawingCacheEnabled(enabled) {
                if (enabled || (this.mPersistentDrawingCache & ViewGroup.PERSISTENT_ALL_CACHES) != ViewGroup.PERSISTENT_ALL_CACHES) {
                    const children = this.mChildren;
                    const count = this.mChildrenCount;
                    for (let i = 0; i < count; i++) {
                        children[i].setDrawingCacheEnabled(enabled);
                    }
                }
            }
            onAnimationStart() {
                super.onAnimationStart();
                if ((this.mGroupFlags & ViewGroup.FLAG_ANIMATION_CACHE) == ViewGroup.FLAG_ANIMATION_CACHE) {
                    const count = this.mChildrenCount;
                    const children = this.mChildren;
                    const buildCache = !this.isHardwareAccelerated();
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if ((child.mViewFlags & ViewGroup.VISIBILITY_MASK) == ViewGroup.VISIBLE) {
                            child.setDrawingCacheEnabled(true);
                            if (buildCache) {
                                child.buildDrawingCache(true);
                            }
                        }
                    }
                    this.mGroupFlags |= ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE;
                }
            }
            onAnimationEnd() {
                super.onAnimationEnd();
                if ((this.mGroupFlags & ViewGroup.FLAG_ANIMATION_CACHE) == ViewGroup.FLAG_ANIMATION_CACHE) {
                    this.mGroupFlags &= ~ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE;
                    if ((this.mPersistentDrawingCache & ViewGroup.PERSISTENT_ANIMATION_CACHE) == 0) {
                        this.setChildrenDrawingCacheEnabled(false);
                    }
                }
            }
            getPersistentDrawingCache() {
                return this.mPersistentDrawingCache;
            }
            setPersistentDrawingCache(drawingCacheToKeep) {
                this.mPersistentDrawingCache = drawingCacheToKeep & ViewGroup.PERSISTENT_ALL_CACHES;
            }
            isChildrenDrawingOrderEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER) == ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER;
            }
            setChildrenDrawingOrderEnabled(enabled) {
                this.setBooleanFlag(ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER, enabled);
            }
            getChildDrawingOrder(childCount, i) {
                return i;
            }
            generateLayoutParams(p) {
                return p;
            }
            generateDefaultLayoutParams() {
                return new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            }
            measureChildren(widthMeasureSpec, heightMeasureSpec) {
                const size = this.mChildren.length;
                for (let i = 0; i < size; ++i) {
                    const child = this.mChildren[i];
                    if ((child.mViewFlags & view_5.View.VISIBILITY_MASK) != view_5.View.GONE) {
                        this.measureChild(child, widthMeasureSpec, heightMeasureSpec);
                    }
                }
            }
            measureChild(child, parentWidthMeasureSpec, parentHeightMeasureSpec) {
                let lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                const childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft + this.mPaddingRight, lp.width);
                const childHeightMeasureSpec = ViewGroup.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom, lp.height);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed) {
                let lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                if (lp instanceof ViewGroup.MarginLayoutParams) {
                    const childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft + this.mPaddingRight + lp.leftMargin + lp.rightMargin
                        + widthUsed, lp.width);
                    const childHeightMeasureSpec = ViewGroup.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom + lp.topMargin + lp.bottomMargin
                        + heightUsed, lp.height);
                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                }
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            static getChildMeasureSpec(spec, padding, childDimension) {
                let MeasureSpec = view_5.View.MeasureSpec;
                let specMode = MeasureSpec.getMode(spec);
                let specSize = MeasureSpec.getSize(spec);
                let size = Math.max(0, specSize - padding);
                let resultSize = 0;
                let resultMode = 0;
                switch (specMode) {
                    case MeasureSpec.EXACTLY:
                        if (childDimension >= 0) {
                            resultSize = childDimension;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.AT_MOST;
                        }
                        break;
                    case MeasureSpec.AT_MOST:
                        if (childDimension >= 0) {
                            resultSize = childDimension;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.AT_MOST;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.AT_MOST;
                        }
                        break;
                    case MeasureSpec.UNSPECIFIED:
                        if (childDimension >= 0) {
                            resultSize = childDimension;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {
                            resultSize = 0;
                            resultMode = MeasureSpec.UNSPECIFIED;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            resultSize = 0;
                            resultMode = MeasureSpec.UNSPECIFIED;
                        }
                        break;
                }
                return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
            }
            clearDisappearingChildren() {
                if (this.mDisappearingChildren != null) {
                    this.mDisappearingChildren.clear();
                    this.invalidate();
                }
            }
            addDisappearingView(v) {
                let disappearingChildren = this.mDisappearingChildren;
                if (disappearingChildren == null) {
                    disappearingChildren = this.mDisappearingChildren = new ArrayList();
                }
                disappearingChildren.add(v);
            }
            finishAnimatingView(view, animation) {
                const disappearingChildren = this.mDisappearingChildren;
                if (disappearingChildren != null) {
                    if (disappearingChildren.contains(view)) {
                        disappearingChildren.remove(view);
                        if (view.mAttachInfo != null) {
                            view.dispatchDetachedFromWindow();
                        }
                        view.clearAnimation();
                        this.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;
                    }
                }
                if (animation != null && !animation.getFillAfter()) {
                    view.clearAnimation();
                }
                if ((view.mPrivateFlags & ViewGroup.PFLAG_ANIMATION_STARTED) == ViewGroup.PFLAG_ANIMATION_STARTED) {
                    view.onAnimationEnd();
                    view.mPrivateFlags &= ~ViewGroup.PFLAG_ANIMATION_STARTED;
                    this.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;
                }
            }
            dispatchAttachedToWindow(info, visibility) {
                this.mGroupFlags |= ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
                super.dispatchAttachedToWindow(info, visibility);
                this.mGroupFlags &= ~ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    const child = children[i];
                    child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & view_5.View.VISIBILITY_MASK));
                }
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                this.clearCachedLayoutMode();
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.clearCachedLayoutMode();
            }
            dispatchDetachedFromWindow() {
                this.cancelAndClearTouchTargets(null);
                this.mLayoutCalledWhileSuppressed = false;
                this.mChildren.forEach((child) => child.dispatchDetachedFromWindow());
                super.dispatchDetachedFromWindow();
            }
            dispatchDisplayHint(hint) {
                super.dispatchDisplayHint(hint);
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchDisplayHint(hint);
                }
            }
            onChildVisibilityChanged(child, oldVisibility, newVisibility) {
            }
            dispatchVisibilityChanged(changedView, visibility) {
                super.dispatchVisibilityChanged(changedView, visibility);
                const count = this.mChildrenCount;
                let children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchVisibilityChanged(changedView, visibility);
                }
            }
            dispatchSetSelected(selected) {
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].setSelected(selected);
                }
            }
            dispatchSetActivated(activated) {
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].setActivated(activated);
                }
            }
            dispatchSetPressed(pressed) {
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    const child = children[i];
                    if (!pressed || (!child.isClickable() && !child.isLongClickable())) {
                        child.setPressed(pressed);
                    }
                }
            }
            dispatchCancelPendingInputEvents() {
                super.dispatchCancelPendingInputEvents();
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchCancelPendingInputEvents();
                }
            }
            offsetDescendantRectToMyCoords(descendant, rect) {
                this.offsetRectBetweenParentAndChild(descendant, rect, true, false);
            }
            offsetRectIntoDescendantCoords(descendant, rect) {
                this.offsetRectBetweenParentAndChild(descendant, rect, false, false);
            }
            offsetRectBetweenParentAndChild(descendant, rect, offsetFromChildToParent, clipToBounds) {
                if (descendant == this) {
                    return;
                }
                let theParent = descendant.mParent;
                while ((theParent != null)
                    && (theParent instanceof view_5.View)
                    && (theParent != this)) {
                    if (offsetFromChildToParent) {
                        rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
                        if (clipToBounds) {
                            let p = theParent;
                            rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
                        }
                    }
                    else {
                        if (clipToBounds) {
                            let p = theParent;
                            rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
                        }
                        rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
                    }
                    descendant = theParent;
                    theParent = descendant.mParent;
                }
                if (theParent == this) {
                    if (offsetFromChildToParent) {
                        rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
                    }
                    else {
                        rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
                    }
                }
                else {
                    throw new Error("parameter must be a descendant of this view");
                }
            }
            offsetChildrenTopAndBottom(offset) {
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    const v = children[i];
                    v.mTop += offset;
                    v.mBottom += offset;
                }
                this.invalidateViewProperty(false, false);
            }
            suppressLayout(suppress) {
                this.mSuppressLayout = suppress;
                if (!suppress) {
                    if (this.mLayoutCalledWhileSuppressed) {
                        this.requestLayout();
                        this.mLayoutCalledWhileSuppressed = false;
                    }
                }
            }
            isLayoutSuppressed() {
                return this.mSuppressLayout;
            }
            layout(l, t, r, b) {
                if (!this.mSuppressLayout) {
                    super.layout(l, t, r, b);
                }
                else {
                    this.mLayoutCalledWhileSuppressed = true;
                }
            }
            canAnimate() {
                return false;
            }
            getChildVisibleRect(child, r, offset) {
                const rect = this.mAttachInfo != null ? this.mAttachInfo.mTmpTransformRect : new Rect();
                rect.set(r);
                if (!child.hasIdentityMatrix()) {
                    child.getMatrix().mapRect(rect);
                }
                let dx = child.mLeft - this.mScrollX;
                let dy = child.mTop - this.mScrollY;
                rect.offset(dx, dy);
                if (offset != null) {
                    if (!child.hasIdentityMatrix()) {
                        let position = this.mAttachInfo != null ? this.mAttachInfo.mTmpTransformLocation : new Array(2);
                        position[0] = offset.x;
                        position[1] = offset.y;
                        child.getMatrix().mapPoints(position);
                        offset.x = Math.floor(position[0] + 0.5);
                        offset.y = Math.floor(position[1] + 0.5);
                    }
                    offset.x += dx;
                    offset.y += dy;
                }
                if (rect.intersect(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop)) {
                    if (this.mParent == null)
                        return true;
                    r.set(rect);
                    return this.mParent.getChildVisibleRect(this, r, offset);
                }
                return false;
            }
            dispatchDraw(canvas) {
                let count = this.mChildrenCount;
                let children = this.mChildren;
                let flags = this.mGroupFlags;
                let saveCount = 0;
                let clipToPadding = (flags & ViewGroup.CLIP_TO_PADDING_MASK) == ViewGroup.CLIP_TO_PADDING_MASK;
                if (clipToPadding) {
                    saveCount = canvas.save();
                    canvas.clipRect(this.mScrollX + this.mPaddingLeft, this.mScrollY + this.mPaddingTop, this.mScrollX + this.mRight - this.mLeft - this.mPaddingRight, this.mScrollY + this.mBottom - this.mTop - this.mPaddingBottom);
                }
                this.mPrivateFlags &= ~ViewGroup.PFLAG_DRAW_ANIMATION;
                this.mGroupFlags &= ~ViewGroup.FLAG_INVALIDATE_REQUIRED;
                let more = false;
                const drawingTime = this.getDrawingTime();
                if ((flags & ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER) == 0) {
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if ((child.mViewFlags & ViewGroup.VISIBILITY_MASK) == ViewGroup.VISIBLE || child.getAnimation() != null) {
                            more = this.drawChild(canvas, child, drawingTime) || more;
                        }
                    }
                }
                else {
                    for (let i = 0; i < count; i++) {
                        const child = children[this.getChildDrawingOrder(count, i)];
                        if ((child.mViewFlags & ViewGroup.VISIBILITY_MASK) == ViewGroup.VISIBLE || child.getAnimation() != null) {
                            more = this.drawChild(canvas, child, drawingTime) || more;
                        }
                    }
                }
                if (this.mDisappearingChildren != null) {
                    const disappearingChildren = this.mDisappearingChildren;
                    const disappearingCount = disappearingChildren.size() - 1;
                    for (let i = disappearingCount; i >= 0; i--) {
                        const child = disappearingChildren.get(i);
                        more = this.drawChild(canvas, child, drawingTime) || more;
                    }
                }
                if (clipToPadding) {
                    canvas.restoreToCount(saveCount);
                }
                flags = this.mGroupFlags;
                if ((flags & ViewGroup.FLAG_INVALIDATE_REQUIRED) == ViewGroup.FLAG_INVALIDATE_REQUIRED) {
                    this.invalidate(true);
                }
            }
            drawChild(canvas, child, drawingTime) {
                return child.drawFromParent(canvas, this, drawingTime);
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if ((this.mGroupFlags & ViewGroup.FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE) != 0) {
                    if ((this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) != 0) {
                        throw new Error("addStateFromChildren cannot be enabled if a"
                            + " child has duplicateParentState set to true");
                    }
                    const children = this.mChildren;
                    const count = this.mChildrenCount;
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if ((child.mViewFlags & view_5.View.DUPLICATE_PARENT_STATE) != 0) {
                            child.refreshDrawableState();
                        }
                    }
                }
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].jumpDrawablesToCurrentState();
                }
            }
            onCreateDrawableState(extraSpace) {
                if ((this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) == 0) {
                    return super.onCreateDrawableState(extraSpace);
                }
                let need = 0;
                let n = this.getChildCount();
                for (let i = 0; i < n; i++) {
                    let childState = this.getChildAt(i).getDrawableState();
                    if (childState != null) {
                        need += childState.length;
                    }
                }
                let state = super.onCreateDrawableState(extraSpace + need);
                for (let i = 0; i < n; i++) {
                    let childState = this.getChildAt(i).getDrawableState();
                    if (childState != null) {
                        state = view_5.View.mergeDrawableStates(state, childState);
                    }
                }
                return state;
            }
            setAddStatesFromChildren(addsStates) {
                if (addsStates) {
                    this.mGroupFlags |= ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN;
                }
                else {
                    this.mGroupFlags &= ~ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN;
                }
                this.refreshDrawableState();
            }
            addStatesFromChildren() {
                return (this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) != 0;
            }
            childDrawableStateChanged(child) {
                if ((this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) != 0) {
                    this.refreshDrawableState();
                }
            }
            getClipChildren() {
                return ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0);
            }
            setClipChildren(clipChildren) {
                let previousValue = (this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN;
                if (clipChildren != previousValue) {
                    this.setBooleanFlag(ViewGroup.FLAG_CLIP_CHILDREN, clipChildren);
                }
            }
            setClipToPadding(clipToPadding) {
                this.setBooleanFlag(ViewGroup.FLAG_CLIP_TO_PADDING, clipToPadding);
            }
            isClipToPadding() {
                return (this.mGroupFlags & ViewGroup.FLAG_CLIP_TO_PADDING) == ViewGroup.FLAG_CLIP_TO_PADDING;
            }
            invalidateChild(child, dirty) {
                let parent = this;
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    const drawAnimation = (child.mPrivateFlags & view_5.View.PFLAG_DRAW_ANIMATION)
                        == view_5.View.PFLAG_DRAW_ANIMATION;
                    let childMatrix = child.getMatrix();
                    const isOpaque = child.isOpaque() && !drawAnimation && child.getAnimation() == null && childMatrix.isIdentity();
                    let opaqueFlag = isOpaque ? view_5.View.PFLAG_DIRTY_OPAQUE : view_5.View.PFLAG_DIRTY;
                    if (child.mLayerType != view_5.View.LAYER_TYPE_NONE) {
                        this.mPrivateFlags |= view_5.View.PFLAG_INVALIDATED;
                        this.mPrivateFlags &= ~view_5.View.PFLAG_DRAWING_CACHE_VALID;
                        child.mLocalDirtyRect.union(dirty);
                    }
                    const location = attachInfo.mInvalidateChildLocation;
                    location[0] = child.mLeft;
                    location[1] = child.mTop;
                    if (!childMatrix.isIdentity() ||
                        (this.mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                        let boundingRect = attachInfo.mTmpTransformRect;
                        boundingRect.set(dirty);
                        let transformMatrix;
                        if ((this.mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                            let t = attachInfo.mTmpTransformation;
                            let transformed = this.getChildStaticTransformation(child, t);
                            if (transformed) {
                                transformMatrix = attachInfo.mTmpMatrix;
                                transformMatrix.set(t.getMatrix());
                                if (!childMatrix.isIdentity()) {
                                    transformMatrix.preConcat(childMatrix);
                                }
                            }
                            else {
                                transformMatrix = childMatrix;
                            }
                        }
                        else {
                            transformMatrix = childMatrix;
                        }
                        transformMatrix.mapRect(boundingRect);
                        dirty.set(boundingRect);
                    }
                    do {
                        let view = null;
                        if (parent instanceof view_5.View) {
                            view = parent;
                        }
                        if (drawAnimation) {
                            if (view != null) {
                                view.mPrivateFlags |= ViewGroup.PFLAG_DRAW_ANIMATION;
                            }
                            else if (parent instanceof view_5.ViewRootImpl) {
                                parent.mIsAnimating = true;
                            }
                        }
                        if (view != null) {
                            opaqueFlag = view_5.View.PFLAG_DIRTY;
                            if ((view.mPrivateFlags & view_5.View.PFLAG_DIRTY_MASK) != view_5.View.PFLAG_DIRTY) {
                                view.mPrivateFlags = (view.mPrivateFlags & ~view_5.View.PFLAG_DIRTY_MASK) | opaqueFlag;
                            }
                        }
                        parent = parent.invalidateChildInParent(location, dirty);
                        if (view != null) {
                            let m = view.getMatrix();
                            if (!m.isIdentity()) {
                                let boundingRect = attachInfo.mTmpTransformRect;
                                boundingRect.set(dirty);
                                m.mapRect(boundingRect);
                                dirty.set(boundingRect);
                            }
                        }
                    } while (parent != null);
                }
            }
            invalidateChildInParent(location, dirty) {
                if ((this.mPrivateFlags & view_5.View.PFLAG_DRAWN) == view_5.View.PFLAG_DRAWN ||
                    (this.mPrivateFlags & view_5.View.PFLAG_DRAWING_CACHE_VALID) == view_5.View.PFLAG_DRAWING_CACHE_VALID) {
                    if ((this.mGroupFlags & (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) !=
                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) {
                        dirty.offset(location[0] - this.mScrollX, location[1] - this.mScrollY);
                        if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == 0) {
                            dirty.union(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        const left = this.mLeft;
                        const top = this.mTop;
                        if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN) {
                            if (!dirty.intersect(0, 0, this.mRight - left, this.mBottom - top)) {
                                dirty.setEmpty();
                            }
                        }
                        this.mPrivateFlags &= ~view_5.View.PFLAG_DRAWING_CACHE_VALID;
                        location[0] = left;
                        location[1] = top;
                        if (this.mLayerType != view_5.View.LAYER_TYPE_NONE) {
                            this.mPrivateFlags |= view_5.View.PFLAG_INVALIDATED;
                        }
                        return this.mParent;
                    }
                    else {
                        this.mPrivateFlags &= ~view_5.View.PFLAG_DRAWN & ~view_5.View.PFLAG_DRAWING_CACHE_VALID;
                        location[0] = this.mLeft;
                        location[1] = this.mTop;
                        if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN) {
                            dirty.set(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        else {
                            dirty.union(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        if (this.mLayerType != view_5.View.LAYER_TYPE_NONE) {
                            this.mPrivateFlags |= view_5.View.PFLAG_INVALIDATED;
                        }
                        return this.mParent;
                    }
                }
                return null;
            }
            invalidateChildFast(child, dirty) {
                let parent = this;
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    let left = child.mLeft;
                    let top = child.mTop;
                    if (!child.getMatrix().isIdentity()) {
                        child.transformRect(dirty);
                    }
                    do {
                        if (parent instanceof ViewGroup) {
                            let parentVG = parent;
                            if (parentVG.mLayerType != view_5.View.LAYER_TYPE_NONE) {
                                parentVG.invalidate();
                                parent = null;
                            }
                            else {
                                parent = parentVG.invalidateChildInParentFast(left, top, dirty);
                                left = parentVG.mLeft;
                                top = parentVG.mTop;
                            }
                        }
                        else {
                            const location = attachInfo.mInvalidateChildLocation;
                            location[0] = left;
                            location[1] = top;
                            parent = parent.invalidateChildInParent(location, dirty);
                        }
                    } while (parent != null);
                }
            }
            invalidateChildInParentFast(left, top, dirty) {
                if ((this.mPrivateFlags & view_5.View.PFLAG_DRAWN) == view_5.View.PFLAG_DRAWN ||
                    (this.mPrivateFlags & view_5.View.PFLAG_DRAWING_CACHE_VALID) == view_5.View.PFLAG_DRAWING_CACHE_VALID) {
                    dirty.offset(left - this.mScrollX, top - this.mScrollY);
                    if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == 0) {
                        dirty.union(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                    }
                    if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == 0 ||
                        dirty.intersect(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop)) {
                        if (this.mLayerType != view_5.View.LAYER_TYPE_NONE) {
                        }
                        if (!this.getMatrix().isIdentity()) {
                            this.transformRect(dirty);
                        }
                        return this.mParent;
                    }
                }
                return null;
            }
            getChildStaticTransformation(child, t) {
                return false;
            }
            getChildTransformation() {
                if (this.mChildTransformation == null) {
                    this.mChildTransformation = new Transformation();
                }
                return this.mChildTransformation;
            }
            findViewByPredicateTraversal(predicate, childToSkip) {
                if (predicate.apply(this)) {
                    return this;
                }
                const where = this.mChildren;
                const len = this.mChildrenCount;
                for (let i = 0; i < len; i++) {
                    let v = where[i];
                    if (v != childToSkip && (v.mPrivateFlags & view_5.View.PFLAG_IS_ROOT_NAMESPACE) == 0) {
                        v = v.findViewByPredicate(predicate);
                        if (v != null) {
                            return v;
                        }
                    }
                }
                return null;
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept == ((this.mGroupFlags & ViewGroup.FLAG_DISALLOW_INTERCEPT) != 0)) {
                    return;
                }
                if (disallowIntercept) {
                    this.mGroupFlags |= ViewGroup.FLAG_DISALLOW_INTERCEPT;
                }
                else {
                    this.mGroupFlags &= ~ViewGroup.FLAG_DISALLOW_INTERCEPT;
                }
                if (this.mParent != null) {
                    this.mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
                }
            }
            shouldDelayChildPressedState() {
                return true;
            }
            onSetLayoutParams(child, layoutParams) {
            }
        }
        ViewGroup.FLAG_CLIP_CHILDREN = 0x1;
        ViewGroup.FLAG_CLIP_TO_PADDING = 0x2;
        ViewGroup.FLAG_INVALIDATE_REQUIRED = 0x4;
        ViewGroup.FLAG_RUN_ANIMATION = 0x8;
        ViewGroup.FLAG_ANIMATION_DONE = 0x10;
        ViewGroup.FLAG_PADDING_NOT_NULL = 0x20;
        ViewGroup.FLAG_ANIMATION_CACHE = 0x40;
        ViewGroup.FLAG_OPTIMIZE_INVALIDATE = 0x80;
        ViewGroup.FLAG_CLEAR_TRANSFORMATION = 0x100;
        ViewGroup.FLAG_NOTIFY_ANIMATION_LISTENER = 0x200;
        ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER = 0x400;
        ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS = 0x800;
        ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE = 0x1000;
        ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN = 0x2000;
        ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE = 0x4000;
        ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE = 0x8000;
        ViewGroup.FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE = 0x10000;
        ViewGroup.FLAG_MASK_FOCUSABILITY = 0x60000;
        ViewGroup.FOCUS_BEFORE_DESCENDANTS = 0x20000;
        ViewGroup.FOCUS_AFTER_DESCENDANTS = 0x40000;
        ViewGroup.FOCUS_BLOCK_DESCENDANTS = 0x60000;
        ViewGroup.FLAG_DISALLOW_INTERCEPT = 0x80000;
        ViewGroup.FLAG_SPLIT_MOTION_EVENTS = 0x200000;
        ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW = 0x400000;
        ViewGroup.FLAG_LAYOUT_MODE_WAS_EXPLICITLY_SET = 0x800000;
        ViewGroup.PERSISTENT_NO_CACHE = 0x0;
        ViewGroup.PERSISTENT_ANIMATION_CACHE = 0x1;
        ViewGroup.PERSISTENT_SCROLLING_CACHE = 0x2;
        ViewGroup.PERSISTENT_ALL_CACHES = 0x3;
        ViewGroup.LAYOUT_MODE_UNDEFINED = -1;
        ViewGroup.LAYOUT_MODE_CLIP_BOUNDS = 0;
        ViewGroup.LAYOUT_MODE_DEFAULT = ViewGroup.LAYOUT_MODE_CLIP_BOUNDS;
        ViewGroup.CLIP_TO_PADDING_MASK = ViewGroup.FLAG_CLIP_TO_PADDING | ViewGroup.FLAG_PADDING_NOT_NULL;
        view_5.ViewGroup = ViewGroup;
        (function (ViewGroup) {
            class LayoutParams {
                constructor(...args) {
                    this._width = 0;
                    this._height = 0;
                    this._measuringParentWidthMeasureSpec = 0;
                    this._measuringParentHeightMeasureSpec = 0;
                    if (args.length === 1) {
                        let src = args[0];
                        this.width = src._width;
                        this.height = src._height;
                    }
                    else if (args.length === 2) {
                        let [width = 0, height = 0] = args;
                        this.width = width;
                        this.height = height;
                    }
                    if (!this._attrBinder) {
                        this._attrBinder = new androidui.attr.AttrBinder(this);
                        this._attrBinder.addAttr('width', (value) => {
                            if (value == null)
                                value = -2;
                            this.width = value;
                        }, () => {
                            return this._widthOrig;
                        });
                        this._attrBinder.addAttr('height', (value) => {
                            if (value == null)
                                value = -2;
                            this.height = value;
                        }, () => {
                            return this._heightOrig;
                        });
                    }
                }
                get width() {
                    if (typeof this._width === 'number')
                        return this._width;
                    let up = (this._width + "").toUpperCase();
                    if (up === 'FILL_PARENT' || up === 'MATCH_PARENT')
                        this._width = -1;
                    else if (up === 'WRAP_CONTENT')
                        this._width = -2;
                    else {
                        let parentWidth = view_5.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                        try {
                            this._width = TypedValue.complexToDimensionPixelSize(this._width, parentWidth, this._measuringMeasureSpec);
                        }
                        catch (e) {
                            console.error(e);
                            this._width = -2;
                        }
                    }
                    return this._width;
                }
                set width(value) {
                    this._width = this._widthOrig = value;
                }
                get height() {
                    if (typeof this._height === 'number')
                        return this._height;
                    let up = (this._height + "").toUpperCase();
                    if (up === 'FILL_PARENT' || up === 'MATCH_PARENT')
                        this._height = -1;
                    else if (up === 'WRAP_CONTENT')
                        this._height = -2;
                    else {
                        let parentHeight = view_5.View.MeasureSpec.getSize(this._measuringParentHeightMeasureSpec);
                        try {
                            this._height = TypedValue.complexToDimensionPixelSize(this._height, parentHeight, this._measuringMeasureSpec);
                        }
                        catch (e) {
                            console.error(e);
                            this._height = -2;
                        }
                    }
                    return this._height;
                }
                set height(value) {
                    this._height = this._heightOrig = value;
                }
                parseAttributeFrom(node, context) {
                    Array.from(node.attributes).forEach((attr) => {
                        let layoutParamFiled = attr.name.split("layout_")[1];
                        this._attrBinder.onAttrChange(layoutParamFiled, attr.value, context);
                    });
                }
            }
            LayoutParams.FILL_PARENT = -1;
            LayoutParams.MATCH_PARENT = -1;
            LayoutParams.WRAP_CONTENT = -2;
            ViewGroup.LayoutParams = LayoutParams;
            class MarginLayoutParams extends LayoutParams {
                constructor(...args) {
                    super();
                    this._leftMargin = 0;
                    this._topMargin = 0;
                    this._rightMargin = 0;
                    this._bottomMargin = 0;
                    this._leftMarginOrig = 0;
                    this._topMarginOrig = 0;
                    this._rightMarginOrig = 0;
                    this._bottomMarginOrig = 0;
                    if (args.length === 1) {
                        let src = args[0];
                        super(src);
                        if (src instanceof MarginLayoutParams) {
                            this.leftMargin = src._leftMargin;
                            this.topMargin = src._topMargin;
                            this.rightMargin = src._rightMargin;
                            this.bottomMargin = src._bottomMargin;
                        }
                    }
                    else if (args.length == 2) {
                        super(args[0], args[1]);
                    }
                    this._attrBinder.addAttr('marginLeft', (value) => {
                        if (value == null)
                            value = 0;
                        this.leftMargin = value;
                    }, () => {
                        return this._leftMarginOrig;
                    });
                    this._attrBinder.addAttr('marginStart', (value) => {
                        if (value == null)
                            value = 0;
                        this.leftMargin = value;
                    }, () => {
                        return this._leftMarginOrig;
                    });
                    this._attrBinder.addAttr('marginTop', (value) => {
                        if (value == null)
                            value = 0;
                        this.topMargin = value;
                    }, () => {
                        return this._topMarginOrig;
                    });
                    this._attrBinder.addAttr('marginRight', (value) => {
                        if (value == null)
                            value = 0;
                        this.rightMargin = value;
                    }, () => {
                        return this._rightMarginOrig;
                    });
                    this._attrBinder.addAttr('marginEnd', (value) => {
                        if (value == null)
                            value = 0;
                        this.rightMargin = value;
                    }, () => {
                        return this._rightMarginOrig;
                    });
                    this._attrBinder.addAttr('marginBottom', (value) => {
                        if (value == null)
                            value = 0;
                        this.bottomMargin = value;
                    }, () => {
                        return this._bottomMargin;
                    });
                    this._attrBinder.addAttr('margin', (value) => {
                        if (value == null)
                            value = 0;
                        let [left, top, right, bottom] = this._attrBinder.parsePaddingMarginLTRB(value);
                        this.leftMargin = left;
                        this.topMargin = top;
                        this.rightMargin = right;
                        this.bottomMargin = bottom;
                    });
                }
                get leftMargin() {
                    if (typeof this._leftMargin === 'number')
                        return this._leftMargin;
                    let parentWidth = view_5.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._leftMargin = TypedValue.complexToDimensionPixelSize(this._leftMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._leftMargin = 0;
                    }
                    return this._leftMargin;
                }
                get topMargin() {
                    if (typeof this._topMargin === 'number')
                        return this._topMargin;
                    let parentWidth = view_5.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._topMargin = TypedValue.complexToDimensionPixelSize(this._topMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._topMargin = 0;
                    }
                    return this._topMargin;
                }
                get rightMargin() {
                    if (typeof this._rightMargin === 'number')
                        return this._rightMargin;
                    let parentWidth = view_5.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._rightMargin = TypedValue.complexToDimensionPixelSize(this._rightMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._rightMargin = 0;
                    }
                    return this._rightMargin;
                }
                get bottomMargin() {
                    if (typeof this._bottomMargin === 'number')
                        return this._bottomMargin;
                    let parentWidth = view_5.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._bottomMargin = TypedValue.complexToDimensionPixelSize(this._bottomMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._bottomMargin = 0;
                    }
                    return this._bottomMargin;
                }
                set leftMargin(value) {
                    this._leftMargin = this._leftMarginOrig = value;
                }
                set topMargin(value) {
                    this._topMargin = this._topMarginOrig = value;
                }
                set rightMargin(value) {
                    this._rightMargin = this._rightMarginOrig = value;
                }
                set bottomMargin(value) {
                    this._bottomMargin = this._bottomMarginOrig = value;
                }
                setMargins(left, top, right, bottom) {
                    this.leftMargin = left;
                    this.topMargin = top;
                    this.rightMargin = right;
                    this.bottomMargin = bottom;
                }
                setLayoutDirection(layoutDirection) {
                }
                getLayoutDirection() {
                    return view_5.View.LAYOUT_DIRECTION_LTR;
                }
                isLayoutRtl() {
                    return this.getLayoutDirection() == view_5.View.LAYOUT_DIRECTION_RTL;
                }
                resolveLayoutDirection(layoutDirection) {
                }
            }
            MarginLayoutParams.DEFAULT_MARGIN_RELATIVE = Integer.MIN_VALUE;
            ViewGroup.MarginLayoutParams = MarginLayoutParams;
        })(ViewGroup = view_5.ViewGroup || (view_5.ViewGroup = {}));
        class TouchTarget {
            static obtain(child, pointerIdBits) {
                let target;
                if (TouchTarget.sRecycleBin == null) {
                    target = new TouchTarget();
                }
                else {
                    target = TouchTarget.sRecycleBin;
                    TouchTarget.sRecycleBin = target.next;
                    TouchTarget.sRecycledCount--;
                    target.next = null;
                }
                target.child = child;
                target.pointerIdBits = pointerIdBits;
                return target;
            }
            recycle() {
                if (TouchTarget.sRecycledCount < TouchTarget.MAX_RECYCLED) {
                    this.next = TouchTarget.sRecycleBin;
                    TouchTarget.sRecycleBin = this;
                    TouchTarget.sRecycledCount += 1;
                }
                else {
                    this.next = null;
                }
                this.child = null;
            }
        }
        TouchTarget.MAX_RECYCLED = 32;
        TouchTarget.sRecycledCount = 0;
        TouchTarget.ALL_POINTER_IDS = -1;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/6.
 */
///<reference path="ViewGroup.ts"/>
///<reference path="ViewRootImpl.ts"/>
///<reference path="View.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Drawable = android.graphics.drawable.Drawable;
        class ViewOverlay {
            constructor(hostView) {
                this.mOverlayViewGroup = new ViewOverlay.OverlayViewGroup(hostView);
            }
            getOverlayView() {
                return this.mOverlayViewGroup;
            }
            add(drawable) {
                this.mOverlayViewGroup.add(drawable);
            }
            remove(drawable) {
            }
            clear() {
                this.mOverlayViewGroup.clear();
            }
            isEmpty() {
                return this.mOverlayViewGroup.isEmpty();
            }
        }
        view.ViewOverlay = ViewOverlay;
        (function (ViewOverlay) {
            class OverlayViewGroup extends view.ViewGroup {
                constructor(hostView) {
                    super();
                    this.mHostView = hostView;
                    this.mAttachInfo = hostView.mAttachInfo;
                    this.mRight = hostView.getWidth();
                    this.mBottom = hostView.getHeight();
                }
                addDrawable(drawable) {
                }
                addView(child) {
                }
                add(arg) {
                    if (arg instanceof Drawable)
                        this.addDrawable(arg);
                    else if (arg instanceof view.View)
                        this.addView(arg);
                }
                clear() {
                }
                isEmpty() {
                    return true;
                }
                onLayout(changed, l, t, r, b) {
                }
            }
            ViewOverlay.OverlayViewGroup = OverlayViewGroup;
        })(ViewOverlay = view.ViewOverlay || (view.ViewOverlay = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/9.
 */
///<reference path="../view/Gravity.ts"/>
///<reference path="../view/ViewOverlay.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Rect = android.graphics.Rect;
        class FrameLayout extends ViewGroup {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mMeasureAllChildren = false;
                this.mForegroundPaddingLeft = 0;
                this.mForegroundPaddingTop = 0;
                this.mForegroundPaddingRight = 0;
                this.mForegroundPaddingBottom = 0;
                this.mSelfBounds = new Rect();
                this.mOverlayBounds = new Rect();
                this.mForegroundGravity = Gravity.FILL;
                this.mForegroundInPadding = true;
                this.mForegroundBoundsChanged = false;
                this.mMatchParentChildren = new Array(1);
                this._attrBinder.addAttr('foregroundGravity', (value) => {
                    this.mForegroundGravity = this._attrBinder.parseGravity(value, this.mForegroundGravity);
                }, () => {
                    return this.mForegroundGravity;
                });
            }
            getForegroundGravity() {
                return this.mForegroundGravity;
            }
            setForegroundGravity(foregroundGravity) {
                if (this.mForegroundGravity != foregroundGravity) {
                    if ((foregroundGravity & Gravity.HORIZONTAL_GRAVITY_MASK) == 0) {
                        foregroundGravity |= Gravity.LEFT;
                    }
                    if ((foregroundGravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
                        foregroundGravity |= Gravity.TOP;
                    }
                    this.mForegroundGravity = foregroundGravity;
                    if (this.mForegroundGravity == Gravity.FILL && this.mForeground != null) {
                        let padding = new Rect();
                        if (this.mForeground.getPadding(padding)) {
                            this.mForegroundPaddingLeft = padding.left;
                            this.mForegroundPaddingTop = padding.top;
                            this.mForegroundPaddingRight = padding.right;
                            this.mForegroundPaddingBottom = padding.bottom;
                        }
                    }
                    else {
                        this.mForegroundPaddingLeft = 0;
                        this.mForegroundPaddingTop = 0;
                        this.mForegroundPaddingRight = 0;
                        this.mForegroundPaddingBottom = 0;
                    }
                    this.requestLayout();
                }
            }
            verifyDrawable(who) {
                return super.verifyDrawable(who) || (who == this.mForeground);
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mForeground != null)
                    this.mForeground.jumpToCurrentState();
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if (this.mForeground != null && this.mForeground.isStateful()) {
                    this.mForeground.setState(this.getDrawableState());
                }
            }
            generateDefaultLayoutParams() {
                return new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);
            }
            setForeground(drawable) {
                if (this.mForeground != drawable) {
                    if (this.mForeground != null) {
                        this.mForeground.setCallback(null);
                        this.unscheduleDrawable(this.mForeground);
                    }
                    this.mForeground = drawable;
                    this.mForegroundPaddingLeft = 0;
                    this.mForegroundPaddingTop = 0;
                    this.mForegroundPaddingRight = 0;
                    this.mForegroundPaddingBottom = 0;
                    if (drawable != null) {
                        this.setWillNotDraw(false);
                        drawable.setCallback(this);
                        if (drawable.isStateful()) {
                            drawable.setState(this.getDrawableState());
                        }
                        if (this.mForegroundGravity == Gravity.FILL) {
                            let padding = new Rect();
                            if (drawable.getPadding(padding)) {
                                this.mForegroundPaddingLeft = padding.left;
                                this.mForegroundPaddingTop = padding.top;
                                this.mForegroundPaddingRight = padding.right;
                                this.mForegroundPaddingBottom = padding.bottom;
                            }
                        }
                    }
                    else {
                        this.setWillNotDraw(true);
                    }
                    this.requestLayout();
                    this.invalidate();
                }
            }
            getForeground() {
                return this.mForeground;
            }
            getPaddingLeftWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingLeft, this.mForegroundPaddingLeft) :
                    this.mPaddingLeft + this.mForegroundPaddingLeft;
            }
            getPaddingRightWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingRight, this.mForegroundPaddingRight) :
                    this.mPaddingRight + this.mForegroundPaddingRight;
            }
            getPaddingTopWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingTop, this.mForegroundPaddingTop) :
                    this.mPaddingTop + this.mForegroundPaddingTop;
            }
            getPaddingBottomWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingBottom, this.mForegroundPaddingBottom) :
                    this.mPaddingBottom + this.mForegroundPaddingBottom;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let count = this.getChildCount();
                let measureMatchParentChildren = View.MeasureSpec.getMode(widthMeasureSpec) != View.MeasureSpec.EXACTLY ||
                    View.MeasureSpec.getMode(heightMeasureSpec) != View.MeasureSpec.EXACTLY;
                this.mMatchParentChildren = [];
                let maxHeight = 0;
                let maxWidth = 0;
                let childState = 0;
                for (let i = 0; i < count; i++) {
                    let child = this.getChildAt(i);
                    if (this.mMeasureAllChildren || child.getVisibility() != View.GONE) {
                        this.measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
                        let lp = child.getLayoutParams();
                        maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
                        maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
                        childState = View.combineMeasuredStates(childState, child.getMeasuredState());
                        if (measureMatchParentChildren) {
                            if (lp.width == FrameLayout.LayoutParams.MATCH_PARENT ||
                                lp.height == FrameLayout.LayoutParams.MATCH_PARENT) {
                                this.mMatchParentChildren.push(child);
                            }
                        }
                    }
                }
                maxWidth += this.getPaddingLeftWithForeground() + this.getPaddingRightWithForeground();
                maxHeight += this.getPaddingTopWithForeground() + this.getPaddingBottomWithForeground();
                maxHeight = Math.max(maxHeight, this.getSuggestedMinimumHeight());
                maxWidth = Math.max(maxWidth, this.getSuggestedMinimumWidth());
                let drawable = this.getForeground();
                if (drawable != null) {
                    maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());
                    maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());
                }
                this.setMeasuredDimension(View.resolveSizeAndState(maxWidth, widthMeasureSpec, childState), View.resolveSizeAndState(maxHeight, heightMeasureSpec, childState << View.MEASURED_HEIGHT_STATE_SHIFT));
                count = this.mMatchParentChildren.length;
                if (count > 1) {
                    for (let i = 0; i < count; i++) {
                        let child = this.mMatchParentChildren[i];
                        let lp = child.getLayoutParams();
                        let childWidthMeasureSpec;
                        let childHeightMeasureSpec;
                        if (lp.width == FrameLayout.LayoutParams.MATCH_PARENT) {
                            childWidthMeasureSpec = View.MeasureSpec.makeMeasureSpec(this.getMeasuredWidth() -
                                this.getPaddingLeftWithForeground() - this.getPaddingRightWithForeground() -
                                lp.leftMargin - lp.rightMargin, View.MeasureSpec.EXACTLY);
                        }
                        else {
                            childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(widthMeasureSpec, this.getPaddingLeftWithForeground() + this.getPaddingRightWithForeground() +
                                lp.leftMargin + lp.rightMargin, lp.width);
                        }
                        if (lp.height == FrameLayout.LayoutParams.MATCH_PARENT) {
                            childHeightMeasureSpec = View.MeasureSpec.makeMeasureSpec(this.getMeasuredHeight() -
                                this.getPaddingTopWithForeground() - this.getPaddingBottomWithForeground() -
                                lp.topMargin - lp.bottomMargin, View.MeasureSpec.EXACTLY);
                        }
                        else {
                            childHeightMeasureSpec = ViewGroup.getChildMeasureSpec(heightMeasureSpec, this.getPaddingTopWithForeground() + this.getPaddingBottomWithForeground() +
                                lp.topMargin + lp.bottomMargin, lp.height);
                        }
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            onLayout(changed, left, top, right, bottom) {
                this.layoutChildren(left, top, right, bottom, false);
            }
            layoutChildren(left, top, right, bottom, forceLeftGravity) {
                const count = this.getChildCount();
                const parentLeft = this.getPaddingLeftWithForeground();
                const parentRight = right - left - this.getPaddingRightWithForeground();
                const parentTop = this.getPaddingTopWithForeground();
                const parentBottom = bottom - top - this.getPaddingBottomWithForeground();
                this.mForegroundBoundsChanged = true;
                for (let i = 0; i < count; i++) {
                    let child = this.getChildAt(i);
                    if (child.getVisibility() != View.GONE) {
                        const lp = child.getLayoutParams();
                        const width = child.getMeasuredWidth();
                        const height = child.getMeasuredHeight();
                        let childLeft;
                        let childTop;
                        let gravity = lp.gravity;
                        if (gravity == -1) {
                            gravity = FrameLayout.DEFAULT_CHILD_GRAVITY;
                        }
                        const absoluteGravity = gravity;
                        const verticalGravity = gravity & Gravity.VERTICAL_GRAVITY_MASK;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.CENTER_HORIZONTAL:
                                childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +
                                    lp.leftMargin - lp.rightMargin;
                                break;
                            case Gravity.RIGHT:
                                if (!forceLeftGravity) {
                                    childLeft = parentRight - width - lp.rightMargin;
                                    break;
                                }
                            case Gravity.LEFT:
                            default:
                                childLeft = parentLeft + lp.leftMargin;
                        }
                        switch (verticalGravity) {
                            case Gravity.TOP:
                                childTop = parentTop + lp.topMargin;
                                break;
                            case Gravity.CENTER_VERTICAL:
                                childTop = parentTop + (parentBottom - parentTop - height) / 2 +
                                    lp.topMargin - lp.bottomMargin;
                                break;
                            case Gravity.BOTTOM:
                                childTop = parentBottom - height - lp.bottomMargin;
                                break;
                            default:
                                childTop = parentTop + lp.topMargin;
                        }
                        child.layout(childLeft, childTop, childLeft + width, childTop + height);
                    }
                }
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                this.mForegroundBoundsChanged = true;
            }
            draw(canvas) {
                super.draw(canvas);
                if (this.mForeground != null) {
                    const foreground = this.mForeground;
                    if (this.mForegroundBoundsChanged) {
                        this.mForegroundBoundsChanged = false;
                        const selfBounds = this.mSelfBounds;
                        const overlayBounds = this.mOverlayBounds;
                        const w = this.mRight - this.mLeft;
                        const h = this.mBottom - this.mTop;
                        if (this.mForegroundInPadding) {
                            selfBounds.set(0, 0, w, h);
                        }
                        else {
                            selfBounds.set(this.mPaddingLeft, this.mPaddingTop, w - this.mPaddingRight, h - this.mPaddingBottom);
                        }
                        Gravity.apply(this.mForegroundGravity, foreground.getIntrinsicWidth(), foreground.getIntrinsicHeight(), selfBounds, overlayBounds);
                        foreground.setBounds(overlayBounds);
                    }
                    foreground.draw(canvas);
                }
            }
            setMeasureAllChildren(measureAll) {
                this.mMeasureAllChildren = measureAll;
            }
            getMeasureAllChildren() {
                return this.mMeasureAllChildren;
            }
            shouldDelayChildPressedState() {
                return false;
            }
            checkLayoutParams(p) {
                return p instanceof FrameLayout.LayoutParams;
            }
            generateLayoutParams(p) {
                return new FrameLayout.LayoutParams(p);
            }
        }
        FrameLayout.DEFAULT_CHILD_GRAVITY = Gravity.TOP | Gravity.LEFT;
        widget.FrameLayout = FrameLayout;
        (function (FrameLayout) {
            class LayoutParams extends ViewGroup.MarginLayoutParams {
                constructor(...args) {
                    super();
                    this.gravity = -1;
                    if (args.length === 1 && args[0] instanceof LayoutParams) {
                        super(args[0]);
                        this.gravity = args[0].gravity;
                    }
                    else {
                        let [width, height, gravity = -1] = args;
                        super(width, height);
                        this.gravity = gravity;
                    }
                    this._attrBinder.addAttr('gravity', (value) => {
                        this.gravity = this._attrBinder.parseGravity(value, this.gravity);
                    }, () => {
                        return this.gravity;
                    });
                }
            }
            FrameLayout.LayoutParams = LayoutParams;
        })(FrameLayout = widget.FrameLayout || (widget.FrameLayout = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var text;
    (function (text) {
        var Spanned;
        (function (Spanned) {
            function isImplements(obj) {
                return obj && obj['getSpans'] && obj['getSpanStart'] && obj['getSpanEnd']
                    && obj['getSpanFlags'] && obj['nextSpanTransition'];
            }
            Spanned.isImplements = isImplements;
            Spanned.SPAN_POINT_MARK_MASK = 0x33;
            Spanned.SPAN_MARK_MARK = 0x11;
            Spanned.SPAN_MARK_POINT = 0x12;
            Spanned.SPAN_POINT_MARK = 0x21;
            Spanned.SPAN_POINT_POINT = 0x22;
            Spanned.SPAN_PARAGRAPH = 0x33;
            Spanned.SPAN_INCLUSIVE_EXCLUSIVE = Spanned.SPAN_MARK_MARK;
            Spanned.SPAN_INCLUSIVE_INCLUSIVE = Spanned.SPAN_MARK_POINT;
            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE = Spanned.SPAN_POINT_MARK;
            Spanned.SPAN_EXCLUSIVE_INCLUSIVE = Spanned.SPAN_POINT_POINT;
            Spanned.SPAN_COMPOSING = 0x100;
            Spanned.SPAN_INTERMEDIATE = 0x200;
            Spanned.SPAN_USER_SHIFT = 24;
            Spanned.SPAN_USER = 0xFFFFFFFF << Spanned.SPAN_USER_SHIFT;
            Spanned.SPAN_PRIORITY_SHIFT = 16;
            Spanned.SPAN_PRIORITY = 0xFF << Spanned.SPAN_PRIORITY_SHIFT;
        })(Spanned = text.Spanned || (text.Spanned = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/12/5.
 */
///<reference path="../graphics/Paint.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        class TextPaint extends android.graphics.Paint {
            constructor(...args) {
                super(...args);
                this.baselineShift = 0;
                this.bgColor = 0;
                this.linkColor = 0;
                this.underlineColor = 0;
                this.underlineThickness = 0;
            }
            set(tp) {
                super.set(tp);
                this.bgColor = tp.bgColor;
                this.baselineShift = tp.baselineShift;
                this.linkColor = tp.linkColor;
                this.underlineColor = tp.underlineColor;
                this.underlineThickness = tp.underlineThickness;
            }
            setUnderlineText(color, thickness) {
                this.underlineColor = color;
                this.underlineThickness = thickness;
            }
        }
        text.TextPaint = TextPaint;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/style/UpdateAppearance.ts"/>
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/style/UpdateLayout.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/TextPaint.ts"/>
///<reference path="../../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../../android/text/style/UpdateAppearance.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var style;
        (function (style) {
            var MetricAffectingSpan = android.text.style.MetricAffectingSpan;
            class CharacterStyle {
                constructor() {
                    this.mType = CharacterStyle.type;
                }
                static wrap(cs) {
                    if (cs instanceof MetricAffectingSpan) {
                        return new MetricAffectingSpan.Passthrough_MetricAffectingSpan(cs);
                    }
                    else {
                        return new CharacterStyle.Passthrough_CharacterStyle(cs);
                    }
                }
                getUnderlying() {
                    return this;
                }
            }
            CharacterStyle.type = Symbol();
            style.CharacterStyle = CharacterStyle;
            (function (CharacterStyle) {
                class Passthrough_CharacterStyle extends CharacterStyle {
                    constructor(cs) {
                        super();
                        this.mStyle = cs;
                    }
                    updateDrawState(tp) {
                        this.mStyle.updateDrawState(tp);
                    }
                    getUnderlying() {
                        return this.mStyle.getUnderlying();
                    }
                }
                CharacterStyle.Passthrough_CharacterStyle = Passthrough_CharacterStyle;
            })(CharacterStyle = style.CharacterStyle || (style.CharacterStyle = {}));
        })(style = text.style || (text.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/text/TextPaint.ts"/>
///<reference path="../../../android/text/style/CharacterStyle.ts"/>
///<reference path="../../../android/text/style/UpdateLayout.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var style;
        (function (style) {
            var CharacterStyle = android.text.style.CharacterStyle;
            class MetricAffectingSpan extends CharacterStyle {
                constructor(...args) {
                    super(...args);
                    this.mType = MetricAffectingSpan.type;
                }
                getUnderlying() {
                    return this;
                }
            }
            MetricAffectingSpan.type = Symbol();
            style.MetricAffectingSpan = MetricAffectingSpan;
            (function (MetricAffectingSpan) {
                class Passthrough_MetricAffectingSpan extends MetricAffectingSpan {
                    constructor(cs) {
                        super();
                        this.mStyle = cs;
                    }
                    updateDrawState(tp) {
                        this.mStyle.updateDrawState(tp);
                    }
                    updateMeasureState(tp) {
                        this.mStyle.updateMeasureState(tp);
                    }
                    getUnderlying() {
                        return this.mStyle.getUnderlying();
                    }
                }
                MetricAffectingSpan.Passthrough_MetricAffectingSpan = Passthrough_MetricAffectingSpan;
            })(MetricAffectingSpan = style.MetricAffectingSpan || (style.MetricAffectingSpan = {}));
        })(style = text.style || (text.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/text/TextPaint.ts"/>
///<reference path="../../../android/text/style/MetricAffectingSpan.ts"/>
var android;
(function (android) {
    var text;
    (function (text_1) {
        var style;
        (function (style) {
            var MetricAffectingSpan = android.text.style.MetricAffectingSpan;
            class ReplacementSpan extends MetricAffectingSpan {
                constructor(...args) {
                    super(...args);
                    this.mType = ReplacementSpan.type;
                }
                updateMeasureState(p) {
                }
                updateDrawState(ds) {
                }
            }
            ReplacementSpan.type = Symbol();
            style.ReplacementSpan = ReplacementSpan;
        })(style = text_1.style || (text_1.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var text;
    (function (text) {
        var style;
        (function (style) {
            var ParagraphStyle;
            (function (ParagraphStyle) {
                ParagraphStyle.type = Symbol();
            })(ParagraphStyle = style.ParagraphStyle || (style.ParagraphStyle = {}));
        })(style = text.style || (text.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/text/Layout.ts"/>
///<reference path="../../../android/text/TextUtils.ts"/>
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../../android/text/style/WrapTogetherSpan.ts"/>
var android;
(function (android) {
    var text;
    (function (text_2) {
        var style;
        (function (style) {
            var TextUtils = android.text.TextUtils;
            var LeadingMarginSpan;
            (function (LeadingMarginSpan) {
                function isImpl(obj) {
                    return obj && obj['getLeadingMargin'] && obj['drawLeadingMargin'];
                }
                LeadingMarginSpan.isImpl = isImpl;
                LeadingMarginSpan.type = Symbol();
                var LeadingMarginSpan2;
                (function (LeadingMarginSpan2) {
                    function isImpl(obj) {
                        return obj['getLeadingMarginLineCount'];
                    }
                    LeadingMarginSpan2.isImpl = isImpl;
                })(LeadingMarginSpan2 = LeadingMarginSpan.LeadingMarginSpan2 || (LeadingMarginSpan.LeadingMarginSpan2 = {}));
                class Standard {
                    constructor(first, rest = first) {
                        this.mFirst = 0;
                        this.mRest = 0;
                        this.mFirst = first;
                        this.mRest = rest;
                    }
                    getSpanTypeId() {
                        return TextUtils.LEADING_MARGIN_SPAN;
                    }
                    describeContents() {
                        return 0;
                    }
                    getLeadingMargin(first) {
                        return first ? this.mFirst : this.mRest;
                    }
                    drawLeadingMargin(c, p, x, dir, top, baseline, bottom, text, start, end, first, layout) {
                        ;
                    }
                }
                LeadingMarginSpan.Standard = Standard;
            })(LeadingMarginSpan = style.LeadingMarginSpan || (style.LeadingMarginSpan = {}));
        })(style = text_2.style || (text_2.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
var android;
(function (android) {
    var text;
    (function (text_3) {
        var style;
        (function (style) {
            var LineBackgroundSpan;
            (function (LineBackgroundSpan) {
                LineBackgroundSpan.type = Symbol();
            })(LineBackgroundSpan = style.LineBackgroundSpan || (style.LineBackgroundSpan = {}));
        })(style = text_3.style || (text_3.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var style;
        (function (style) {
            var TabStopSpan;
            (function (TabStopSpan) {
                TabStopSpan.type = Symbol();
                function isImpl(obj) {
                    return obj && obj['getTabStop'];
                }
                TabStopSpan.isImpl = isImpl;
                class Standard {
                    constructor(where) {
                        this.mTab = 0;
                        this.mTab = where;
                    }
                    getTabStop() {
                        return this.mTab;
                    }
                }
                TabStopSpan.Standard = Standard;
            })(TabStopSpan = style.TabStopSpan || (style.TabStopSpan = {}));
        })(style = text.style || (text.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/12/6.
 */
///<reference path="List.ts"/>
///<reference path="ArrayList.ts"/>
var java;
(function (java) {
    var util;
    (function (util) {
        class Arrays {
            static sort(a, fromIndex, toIndex) {
                Arrays.rangeCheck(a.length, fromIndex, toIndex);
                var sort = new Array(toIndex - fromIndex);
                for (let i = fromIndex; i < toIndex; i++) {
                    sort[i - fromIndex] = a[i];
                }
                sort.sort((a, b) => {
                    return a > b ? 1 : -1;
                });
                for (let i = fromIndex; i < toIndex; i++) {
                    a[i] = sort[i - fromIndex];
                }
            }
            static rangeCheck(arrayLength, fromIndex, toIndex) {
                if (fromIndex > toIndex) {
                    throw new Error("ArrayIndexOutOfBoundsException:fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
                }
                if (fromIndex < 0) {
                    throw new Error('ArrayIndexOutOfBoundsException:' + fromIndex);
                }
                if (toIndex > arrayLength) {
                    throw new Error('ArrayIndexOutOfBoundsException:' + toIndex);
                }
            }
            static asList(array) {
                let list = new util.ArrayList();
                list.array.push(...array);
                return list;
            }
        }
        util.Arrays = Arrays;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/text/Spanned.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        class SpanSet {
            constructor(type) {
                this.numberOfSpans = 0;
                this.classType = type;
                this.numberOfSpans = 0;
            }
            init(spanned, start, limit) {
                const allSpans = spanned.getSpans(start, limit, this.classType);
                const length = allSpans.length;
                if (length > 0 && (this.spans == null || this.spans.length < length)) {
                    this.spans = new Array(length);
                    this.spanStarts = new Array(length);
                    this.spanEnds = new Array(length);
                    this.spanFlags = new Array(length);
                }
                this.numberOfSpans = 0;
                for (let i = 0; i < length; i++) {
                    const span = allSpans[i];
                    const spanStart = spanned.getSpanStart(span);
                    const spanEnd = spanned.getSpanEnd(span);
                    if (spanStart == spanEnd)
                        continue;
                    const spanFlag = spanned.getSpanFlags(span);
                    this.spans[this.numberOfSpans] = span;
                    this.spanStarts[this.numberOfSpans] = spanStart;
                    this.spanEnds[this.numberOfSpans] = spanEnd;
                    this.spanFlags[this.numberOfSpans] = spanFlag;
                    this.numberOfSpans++;
                }
            }
            hasSpansIntersecting(start, end) {
                for (let i = 0; i < this.numberOfSpans; i++) {
                    if (this.spanStarts[i] >= end || this.spanEnds[i] <= start)
                        continue;
                    return true;
                }
                return false;
            }
            getNextTransition(start, limit) {
                for (let i = 0; i < this.numberOfSpans; i++) {
                    const spanStart = this.spanStarts[i];
                    const spanEnd = this.spanEnds[i];
                    if (spanStart > start && spanStart < limit)
                        limit = spanStart;
                    if (spanEnd > start && spanEnd < limit)
                        limit = spanEnd;
                }
                return limit;
            }
            recycle() {
                for (let i = 0; i < this.numberOfSpans; i++) {
                    this.spans[i] = null;
                }
            }
        }
        text.SpanSet = SpanSet;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        class TextDirectionHeuristics {
            static isRtlText(directionality) {
                return TextDirectionHeuristics.STATE_FALSE;
            }
            static isRtlTextOrFormat(directionality) {
                return TextDirectionHeuristics.STATE_FALSE;
            }
        }
        TextDirectionHeuristics.STATE_TRUE = 0;
        TextDirectionHeuristics.STATE_FALSE = 1;
        TextDirectionHeuristics.STATE_UNKNOWN = 2;
        text.TextDirectionHeuristics = TextDirectionHeuristics;
        (function (TextDirectionHeuristics) {
            class TextDirectionHeuristicImpl {
                constructor(algorithm) {
                    this.mAlgorithm = algorithm;
                }
                isRtl(cs, start, count) {
                    if (cs == null || start < 0 || count < 0 || cs.length - count < start) {
                        throw Error(`new IllegalArgumentException()`);
                    }
                    if (this.mAlgorithm == null) {
                        return this.defaultIsRtl();
                    }
                    return this.doCheck(cs, start, count);
                }
                doCheck(cs, start, count) {
                    switch (this.mAlgorithm.checkRtl(cs, start, count)) {
                        case TextDirectionHeuristics.STATE_TRUE:
                            return true;
                        case TextDirectionHeuristics.STATE_FALSE:
                            return false;
                        default:
                            return this.defaultIsRtl();
                    }
                }
            }
            TextDirectionHeuristics.TextDirectionHeuristicImpl = TextDirectionHeuristicImpl;
            class TextDirectionHeuristicInternal extends TextDirectionHeuristics.TextDirectionHeuristicImpl {
                constructor(algorithm, defaultIsRtl) {
                    super(algorithm);
                    this.mDefaultIsRtl = defaultIsRtl;
                }
                defaultIsRtl() {
                    return this.mDefaultIsRtl;
                }
            }
            TextDirectionHeuristics.TextDirectionHeuristicInternal = TextDirectionHeuristicInternal;
            class FirstStrong {
                constructor() {
                }
                checkRtl(cs, start, count) {
                    let result = TextDirectionHeuristics.STATE_UNKNOWN;
                    for (let i = start, e = start + count; i < e && result == TextDirectionHeuristics.STATE_UNKNOWN; ++i) {
                        result = TextDirectionHeuristics.STATE_FALSE;
                    }
                    return result;
                }
            }
            FirstStrong.INSTANCE = new FirstStrong();
            TextDirectionHeuristics.FirstStrong = FirstStrong;
            class AnyStrong {
                constructor(lookForRtl) {
                    this.mLookForRtl = lookForRtl;
                }
                checkRtl(cs, start, count) {
                    let haveUnlookedFor = false;
                    for (let i = start, e = start + count; i < e; ++i) {
                        switch (TextDirectionHeuristics.isRtlText(0)) {
                            case TextDirectionHeuristics.STATE_TRUE:
                                if (this.mLookForRtl) {
                                    return TextDirectionHeuristics.STATE_TRUE;
                                }
                                haveUnlookedFor = true;
                                break;
                            case TextDirectionHeuristics.STATE_FALSE:
                                if (!this.mLookForRtl) {
                                    return TextDirectionHeuristics.STATE_FALSE;
                                }
                                haveUnlookedFor = true;
                                break;
                            default:
                                break;
                        }
                    }
                    if (haveUnlookedFor) {
                        return this.mLookForRtl ? TextDirectionHeuristics.STATE_FALSE : TextDirectionHeuristics.STATE_TRUE;
                    }
                    return TextDirectionHeuristics.STATE_UNKNOWN;
                }
            }
            AnyStrong.INSTANCE_RTL = new AnyStrong(true);
            AnyStrong.INSTANCE_LTR = new AnyStrong(false);
            TextDirectionHeuristics.AnyStrong = AnyStrong;
            class TextDirectionHeuristicLocale extends TextDirectionHeuristics.TextDirectionHeuristicImpl {
                constructor() {
                    super(null);
                }
                defaultIsRtl() {
                    return false;
                }
            }
            TextDirectionHeuristicLocale.INSTANCE = new TextDirectionHeuristicLocale();
            TextDirectionHeuristics.TextDirectionHeuristicLocale = TextDirectionHeuristicLocale;
        })(TextDirectionHeuristics = text.TextDirectionHeuristics || (text.TextDirectionHeuristics = {}));
        TextDirectionHeuristics.LTR = new TextDirectionHeuristics.TextDirectionHeuristicInternal(null, false);
        TextDirectionHeuristics.RTL = new TextDirectionHeuristics.TextDirectionHeuristicInternal(null, true);
        TextDirectionHeuristics.FIRSTSTRONG_LTR = new TextDirectionHeuristics.TextDirectionHeuristicInternal(TextDirectionHeuristics.FirstStrong.INSTANCE, false);
        TextDirectionHeuristics.FIRSTSTRONG_RTL = new TextDirectionHeuristics.TextDirectionHeuristicInternal(TextDirectionHeuristics.FirstStrong.INSTANCE, true);
        TextDirectionHeuristics.ANYRTL_LTR = new TextDirectionHeuristics.TextDirectionHeuristicInternal(TextDirectionHeuristics.AnyStrong.INSTANCE_RTL, false);
        TextDirectionHeuristics.LOCALE = TextDirectionHeuristics.TextDirectionHeuristicLocale.INSTANCE;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/RectF.ts"/>
///<reference path="../../android/text/style/CharacterStyle.ts"/>
///<reference path="../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../android/text/style/ReplacementSpan.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/SpanSet.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text_4) {
        var Canvas = android.graphics.Canvas;
        var Paint = android.graphics.Paint;
        var CharacterStyle = android.text.style.CharacterStyle;
        var MetricAffectingSpan = android.text.style.MetricAffectingSpan;
        var ReplacementSpan = android.text.style.ReplacementSpan;
        var Log = android.util.Log;
        var Spanned = android.text.Spanned;
        var SpanSet = android.text.SpanSet;
        var TextPaint = android.text.TextPaint;
        var TextUtils = android.text.TextUtils;
        var Layout = android.text.Layout;
        window.addEventListener('AndroidUILoadFinish', () => {
            eval('Layout = android.text.Layout;');
        });
        class TextLine {
            constructor() {
                this.mStart = 0;
                this.mLen = 0;
                this.mDir = 0;
                this.mWorkPaint = new TextPaint();
                this.mMetricAffectingSpanSpanSet = new SpanSet(MetricAffectingSpan.type);
                this.mCharacterStyleSpanSet = new SpanSet(CharacterStyle.type);
                this.mReplacementSpanSpanSet = new SpanSet(ReplacementSpan.type);
            }
            static obtain() {
                let tl;
                {
                    for (let i = TextLine.sCached.length; --i >= 0;) {
                        if (TextLine.sCached[i] != null) {
                            tl = TextLine.sCached[i];
                            TextLine.sCached[i] = null;
                            return tl;
                        }
                    }
                }
                tl = new TextLine();
                if (TextLine.DEBUG) {
                    Log.v("TLINE", "new: " + tl);
                }
                return tl;
            }
            static recycle(tl) {
                tl.mText = null;
                tl.mPaint = null;
                tl.mDirections = null;
                tl.mMetricAffectingSpanSpanSet.recycle();
                tl.mCharacterStyleSpanSet.recycle();
                tl.mReplacementSpanSpanSet.recycle();
                {
                    for (let i = 0; i < TextLine.sCached.length; ++i) {
                        if (TextLine.sCached[i] == null) {
                            TextLine.sCached[i] = tl;
                            break;
                        }
                    }
                }
                return null;
            }
            set(paint, text, start, limit, dir, directions, hasTabs, tabStops) {
                this.mPaint = paint;
                this.mText = text;
                this.mStart = start;
                this.mLen = limit - start;
                this.mDir = dir;
                this.mDirections = directions;
                if (this.mDirections == null) {
                    throw Error(`new IllegalArgumentException("Directions cannot be null")`);
                }
                this.mHasTabs = hasTabs;
                this.mSpanned = null;
                let hasReplacement = false;
                if (Spanned.isImplements(text)) {
                    this.mSpanned = text;
                    this.mReplacementSpanSpanSet.init(this.mSpanned, start, limit);
                    hasReplacement = this.mReplacementSpanSpanSet.numberOfSpans > 0;
                }
                this.mCharsValid = hasReplacement || hasTabs || directions != Layout.DIRS_ALL_LEFT_TO_RIGHT;
                if (this.mCharsValid) {
                    this.mChars = text;
                    if (hasReplacement) {
                        let chars = this.mChars;
                        for (let i = start, inext; i < limit; i = inext) {
                            inext = this.mReplacementSpanSpanSet.getNextTransition(i, limit);
                            if (this.mReplacementSpanSpanSet.hasSpansIntersecting(i, inext)) {
                                chars[i - start] = '';
                                for (let j = i - start + 1, e = inext - start; j < e; ++j) {
                                    chars[j] = '';
                                }
                            }
                        }
                    }
                }
                this.mTabs = tabStops;
            }
            draw(c, x, top, y, bottom) {
                if (!this.mHasTabs) {
                    if (this.mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
                        this.drawRun(c, 0, this.mLen, false, x, top, y, bottom, false);
                        return;
                    }
                    if (this.mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
                        this.drawRun(c, 0, this.mLen, true, x, top, y, bottom, false);
                        return;
                    }
                }
                let h = 0;
                let runs = this.mDirections.mDirections;
                let emojiRect = null;
                let lastRunIndex = runs.length - 2;
                for (let i = 0; i < runs.length; i += 2) {
                    let runStart = runs[i];
                    let runLimit = runStart + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
                    if (runLimit > this.mLen) {
                        runLimit = this.mLen;
                    }
                    let runIsRtl = (runs[i + 1] & Layout.RUN_RTL_FLAG) != 0;
                    let segstart = runStart;
                    for (let j = this.mHasTabs ? runStart : runLimit; j <= runLimit; j++) {
                        let codept = 0;
                        if (this.mHasTabs && j < runLimit) {
                            codept = this.mChars.codePointAt(j);
                            if (codept >= 0xd800 && codept < 0xdc00 && j + 1 < runLimit) {
                                codept = this.mChars.codePointAt(j);
                                if (codept > 0xffff) {
                                    ++j;
                                    continue;
                                }
                            }
                        }
                        if (j == runLimit || codept == '\t'.codePointAt(0)) {
                            h += this.drawRun(c, segstart, j, runIsRtl, x + h, top, y, bottom, i != lastRunIndex || j != this.mLen);
                            if (codept == '\t'.codePointAt(0)) {
                                h = this.mDir * this.nextTab(h * this.mDir);
                            }
                            segstart = j + 1;
                        }
                    }
                }
            }
            metrics(fmi) {
                return this.measure(this.mLen, false, fmi);
            }
            measure(offset, trailing, fmi) {
                let target = trailing ? offset - 1 : offset;
                if (target < 0) {
                    return 0;
                }
                let h = 0;
                if (!this.mHasTabs) {
                    if (this.mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
                        return this.measureRun(0, offset, this.mLen, false, fmi);
                    }
                    if (this.mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
                        return this.measureRun(0, offset, this.mLen, true, fmi);
                    }
                }
                let chars = this.mChars;
                let runs = this.mDirections.mDirections;
                for (let i = 0; i < runs.length; i += 2) {
                    let runStart = runs[i];
                    let runLimit = runStart + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
                    if (runLimit > this.mLen) {
                        runLimit = this.mLen;
                    }
                    let runIsRtl = (runs[i + 1] & Layout.RUN_RTL_FLAG) != 0;
                    let segstart = runStart;
                    for (let j = this.mHasTabs ? runStart : runLimit; j <= runLimit; j++) {
                        let codept = 0;
                        if (this.mHasTabs && j < runLimit) {
                            codept = chars.codePointAt(j);
                            if (codept >= 0xd800 && codept < 0xdc00 && j + 1 < runLimit) {
                                codept = chars.codePointAt(j);
                                if (codept > 0xffff) {
                                    ++j;
                                    continue;
                                }
                            }
                        }
                        if (j == runLimit || codept == '\t'.codePointAt(0)) {
                            let inSegment = target >= segstart && target < j;
                            let advance = (this.mDir == Layout.DIR_RIGHT_TO_LEFT) == runIsRtl;
                            if (inSegment && advance) {
                                return h += this.measureRun(segstart, offset, j, runIsRtl, fmi);
                            }
                            let w = this.measureRun(segstart, j, j, runIsRtl, fmi);
                            h += advance ? w : -w;
                            if (inSegment) {
                                return h += this.measureRun(segstart, offset, j, runIsRtl, null);
                            }
                            if (codept == '\t'.codePointAt(0)) {
                                if (offset == j) {
                                    return h;
                                }
                                h = this.mDir * this.nextTab(h * this.mDir);
                                if (target == j) {
                                    return h;
                                }
                            }
                            segstart = j + 1;
                        }
                    }
                }
                return h;
            }
            drawRun(c, start, limit, runIsRtl, x, top, y, bottom, needWidth) {
                if ((this.mDir == Layout.DIR_LEFT_TO_RIGHT) == runIsRtl) {
                    let w = -this.measureRun(start, limit, limit, runIsRtl, null);
                    this.handleRun(start, limit, limit, runIsRtl, c, x + w, top, y, bottom, null, false);
                    return w;
                }
                return this.handleRun(start, limit, limit, runIsRtl, c, x, top, y, bottom, null, needWidth);
            }
            measureRun(start, offset, limit, runIsRtl, fmi) {
                return this.handleRun(start, offset, limit, runIsRtl, null, 0, 0, 0, 0, fmi, true);
            }
            getOffsetToLeftRightOf(cursor, toLeft) {
                let lineStart = 0;
                let lineEnd = this.mLen;
                let paraIsRtl = this.mDir == -1;
                let runs = this.mDirections.mDirections;
                let runIndex, runLevel = 0, runStart = lineStart, runLimit = lineEnd, newCaret = -1;
                let trailing = false;
                if (cursor == lineStart) {
                    runIndex = -2;
                }
                else if (cursor == lineEnd) {
                    runIndex = runs.length;
                }
                else {
                    for (runIndex = 0; runIndex < runs.length; runIndex += 2) {
                        runStart = lineStart + runs[runIndex];
                        if (cursor >= runStart) {
                            runLimit = runStart + (runs[runIndex + 1] & Layout.RUN_LENGTH_MASK);
                            if (runLimit > lineEnd) {
                                runLimit = lineEnd;
                            }
                            if (cursor < runLimit) {
                                runLevel = (runs[runIndex + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                                if (cursor == runStart) {
                                    let prevRunIndex, prevRunLevel, prevRunStart, prevRunLimit;
                                    let pos = cursor - 1;
                                    for (prevRunIndex = 0; prevRunIndex < runs.length; prevRunIndex += 2) {
                                        prevRunStart = lineStart + runs[prevRunIndex];
                                        if (pos >= prevRunStart) {
                                            prevRunLimit = prevRunStart + (runs[prevRunIndex + 1] & Layout.RUN_LENGTH_MASK);
                                            if (prevRunLimit > lineEnd) {
                                                prevRunLimit = lineEnd;
                                            }
                                            if (pos < prevRunLimit) {
                                                prevRunLevel = (runs[prevRunIndex + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                                                if (prevRunLevel < runLevel) {
                                                    runIndex = prevRunIndex;
                                                    runLevel = prevRunLevel;
                                                    runStart = prevRunStart;
                                                    runLimit = prevRunLimit;
                                                    trailing = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                    if (runIndex != runs.length) {
                        let runIsRtl = (runLevel & 0x1) != 0;
                        let advance = toLeft == runIsRtl;
                        if (cursor != (advance ? runLimit : runStart) || advance != trailing) {
                            newCaret = this.getOffsetBeforeAfter(runIndex, runStart, runLimit, runIsRtl, cursor, advance);
                            if (newCaret != (advance ? runLimit : runStart)) {
                                return newCaret;
                            }
                        }
                    }
                }
                while (true) {
                    let advance = toLeft == paraIsRtl;
                    let otherRunIndex = runIndex + (advance ? 2 : -2);
                    if (otherRunIndex >= 0 && otherRunIndex < runs.length) {
                        let otherRunStart = lineStart + runs[otherRunIndex];
                        let otherRunLimit = otherRunStart + (runs[otherRunIndex + 1] & Layout.RUN_LENGTH_MASK);
                        if (otherRunLimit > lineEnd) {
                            otherRunLimit = lineEnd;
                        }
                        let otherRunLevel = (runs[otherRunIndex + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                        let otherRunIsRtl = (otherRunLevel & 1) != 0;
                        advance = toLeft == otherRunIsRtl;
                        if (newCaret == -1) {
                            newCaret = this.getOffsetBeforeAfter(otherRunIndex, otherRunStart, otherRunLimit, otherRunIsRtl, advance ? otherRunStart : otherRunLimit, advance);
                            if (newCaret == (advance ? otherRunLimit : otherRunStart)) {
                                runIndex = otherRunIndex;
                                runLevel = otherRunLevel;
                                continue;
                            }
                            break;
                        }
                        if (otherRunLevel < runLevel) {
                            newCaret = advance ? otherRunStart : otherRunLimit;
                        }
                        break;
                    }
                    if (newCaret == -1) {
                        newCaret = advance ? this.mLen + 1 : -1;
                        break;
                    }
                    if (newCaret <= lineEnd) {
                        newCaret = advance ? lineEnd : lineStart;
                    }
                    break;
                }
                return newCaret;
            }
            getOffsetBeforeAfter(runIndex, runStart, runLimit, runIsRtl, offset, after) {
                if (runIndex < 0 || offset == (after ? this.mLen : 0)) {
                    if (after) {
                        return TextUtils.getOffsetAfter(this.mText, offset + this.mStart) - this.mStart;
                    }
                    return TextUtils.getOffsetBefore(this.mText, offset + this.mStart) - this.mStart;
                }
                let wp = this.mWorkPaint;
                wp.set(this.mPaint);
                let spanStart = runStart;
                let spanLimit;
                if (this.mSpanned == null) {
                    spanLimit = runLimit;
                }
                else {
                    let target = after ? offset + 1 : offset;
                    let limit = this.mStart + runLimit;
                    while (true) {
                        spanLimit = this.mSpanned.nextSpanTransition(this.mStart + spanStart, limit, MetricAffectingSpan.type) - this.mStart;
                        if (spanLimit >= target) {
                            break;
                        }
                        spanStart = spanLimit;
                    }
                    let spans = this.mSpanned.getSpans(this.mStart + spanStart, this.mStart + spanLimit, MetricAffectingSpan.type);
                    spans = TextUtils.removeEmptySpans(spans, this.mSpanned, MetricAffectingSpan.type);
                    if (spans.length > 0) {
                        let replacement = null;
                        for (let j = 0; j < spans.length; j++) {
                            let span = spans[j];
                            if (span instanceof ReplacementSpan) {
                                replacement = span;
                            }
                            else {
                                span.updateMeasureState(wp);
                            }
                        }
                        if (replacement != null) {
                            return after ? spanLimit : spanStart;
                        }
                    }
                }
                let flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
                let cursorOpt = after ? Paint.CURSOR_AFTER : Paint.CURSOR_BEFORE;
                if (this.mCharsValid) {
                    return wp.getTextRunCursor_len(this.mChars.toString(), spanStart, spanLimit - spanStart, flags, offset, cursorOpt);
                }
                else {
                    return wp.getTextRunCursor_end(this.mText.toString(), this.mStart + spanStart, this.mStart + spanLimit, flags, this.mStart + offset, cursorOpt) - this.mStart;
                }
            }
            static expandMetricsFromPaint(fmi, wp) {
                const previousTop = fmi.top;
                const previousAscent = fmi.ascent;
                const previousDescent = fmi.descent;
                const previousBottom = fmi.bottom;
                const previousLeading = fmi.leading;
                wp.getFontMetricsInt(fmi);
                TextLine.updateMetrics(fmi, previousTop, previousAscent, previousDescent, previousBottom, previousLeading);
            }
            static updateMetrics(fmi, previousTop, previousAscent, previousDescent, previousBottom, previousLeading) {
                fmi.top = Math.min(fmi.top, previousTop);
                fmi.ascent = Math.min(fmi.ascent, previousAscent);
                fmi.descent = Math.max(fmi.descent, previousDescent);
                fmi.bottom = Math.max(fmi.bottom, previousBottom);
                fmi.leading = Math.max(fmi.leading, previousLeading);
            }
            handleText(wp, start, end, contextStart, contextEnd, runIsRtl, c, x, top, y, bottom, fmi, needWidth) {
                if (fmi != null) {
                    TextLine.expandMetricsFromPaint(fmi, wp);
                }
                let runLen = end - start;
                if (runLen == 0) {
                    return 0;
                }
                let ret = 0;
                let contextLen = contextEnd - contextStart;
                if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
                    let flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
                    if (this.mCharsValid) {
                        ret = wp.getTextRunAdvances_count(this.mChars.toString(), start, runLen, contextStart, contextLen, flags, null, 0);
                    }
                    else {
                        let delta = this.mStart;
                        ret = wp.getTextRunAdvances_end(this.mText.toString(), delta + start, delta + end, delta + contextStart, delta + contextEnd, flags, null, 0);
                    }
                }
                if (c != null) {
                    if (runIsRtl) {
                        x -= ret;
                    }
                    if (wp.bgColor != 0) {
                        let previousColor = wp.getColor();
                        let previousStyle = wp.getStyle();
                        wp.setColor(wp.bgColor);
                        wp.setStyle(Paint.Style.FILL);
                        c.drawRect(x, top, x + ret, bottom, wp);
                        wp.setStyle(previousStyle);
                        wp.setColor(previousColor);
                    }
                    if (wp.underlineColor != 0) {
                        let underlineTop = y + wp.baselineShift + (1.0 / 9.0) * wp.getTextSize();
                        let previousColor = wp.getColor();
                        let previousStyle = wp.getStyle();
                        let previousAntiAlias = wp.isAntiAlias();
                        wp.setStyle(Paint.Style.FILL);
                        wp.setAntiAlias(true);
                        wp.setColor(wp.underlineColor);
                        c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
                        wp.setStyle(previousStyle);
                        wp.setColor(previousColor);
                        wp.setAntiAlias(previousAntiAlias);
                    }
                    this.drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
                }
                return runIsRtl ? -ret : ret;
            }
            handleReplacement(replacement, wp, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth) {
                let ret = 0;
                let textStart = this.mStart + start;
                let textLimit = this.mStart + limit;
                if (needWidth || (c != null && runIsRtl)) {
                    let previousTop = 0;
                    let previousAscent = 0;
                    let previousDescent = 0;
                    let previousBottom = 0;
                    let previousLeading = 0;
                    let needUpdateMetrics = (fmi != null);
                    if (needUpdateMetrics) {
                        previousTop = fmi.top;
                        previousAscent = fmi.ascent;
                        previousDescent = fmi.descent;
                        previousBottom = fmi.bottom;
                        previousLeading = fmi.leading;
                    }
                    ret = replacement.getSize(wp, this.mText, textStart, textLimit, fmi);
                    if (needUpdateMetrics) {
                        TextLine.updateMetrics(fmi, previousTop, previousAscent, previousDescent, previousBottom, previousLeading);
                    }
                }
                if (c != null) {
                    if (runIsRtl) {
                        x -= ret;
                    }
                    replacement.draw(c, this.mText, textStart, textLimit, x, top, y, bottom, wp);
                }
                return runIsRtl ? -ret : ret;
            }
            handleRun(start, measureLimit, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth) {
                if (start == measureLimit) {
                    let wp = this.mWorkPaint;
                    wp.set(this.mPaint);
                    if (fmi != null) {
                        TextLine.expandMetricsFromPaint(fmi, wp);
                    }
                    return 0;
                }
                if (this.mSpanned == null) {
                    let wp = this.mWorkPaint;
                    wp.set(this.mPaint);
                    const mlimit = measureLimit;
                    return this.handleText(wp, start, mlimit, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
                }
                this.mMetricAffectingSpanSpanSet.init(this.mSpanned, this.mStart + start, this.mStart + limit);
                this.mCharacterStyleSpanSet.init(this.mSpanned, this.mStart + start, this.mStart + limit);
                const originalX = x;
                for (let i = start, inext; i < measureLimit; i = inext) {
                    let wp = this.mWorkPaint;
                    wp.set(this.mPaint);
                    inext = this.mMetricAffectingSpanSpanSet.getNextTransition(this.mStart + i, this.mStart + limit) - this.mStart;
                    let mlimit = Math.min(inext, measureLimit);
                    let replacement = null;
                    for (let j = 0; j < this.mMetricAffectingSpanSpanSet.numberOfSpans; j++) {
                        if ((this.mMetricAffectingSpanSpanSet.spanStarts[j] >= this.mStart + mlimit) || (this.mMetricAffectingSpanSpanSet.spanEnds[j] <= this.mStart + i))
                            continue;
                        let span = this.mMetricAffectingSpanSpanSet.spans[j];
                        if (span instanceof ReplacementSpan) {
                            replacement = span;
                        }
                        else {
                            span.updateDrawState(wp);
                        }
                    }
                    if (replacement != null) {
                        x += this.handleReplacement(replacement, wp, i, mlimit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
                        continue;
                    }
                    for (let j = i, jnext; j < mlimit; j = jnext) {
                        jnext = this.mCharacterStyleSpanSet.getNextTransition(this.mStart + j, this.mStart + mlimit) - this.mStart;
                        wp.set(this.mPaint);
                        for (let k = 0; k < this.mCharacterStyleSpanSet.numberOfSpans; k++) {
                            if ((this.mCharacterStyleSpanSet.spanStarts[k] >= this.mStart + jnext) || (this.mCharacterStyleSpanSet.spanEnds[k] <= this.mStart + j))
                                continue;
                            let span = this.mCharacterStyleSpanSet.spans[k];
                            span.updateDrawState(wp);
                        }
                        x += this.handleText(wp, j, jnext, i, inext, runIsRtl, c, x, top, y, bottom, fmi, needWidth || jnext < measureLimit);
                    }
                }
                return x - originalX;
            }
            drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y) {
                let flags = runIsRtl ? Canvas.DIRECTION_RTL : Canvas.DIRECTION_LTR;
                if (this.mCharsValid) {
                    let count = end - start;
                    let contextCount = contextEnd - contextStart;
                    c.drawTextRun_count(this.mChars.toString(), start, count, contextStart, contextCount, x, y, flags, wp);
                }
                else {
                    let delta = this.mStart;
                    c.drawTextRun_end(this.mText.toString(), delta + start, delta + end, delta + contextStart, delta + contextEnd, x, y, flags, wp);
                }
            }
            ascent(pos) {
                if (this.mSpanned == null) {
                    return this.mPaint.ascent();
                }
                pos += this.mStart;
                let spans = this.mSpanned.getSpans(pos, pos + 1, MetricAffectingSpan.type);
                if (spans.length == 0) {
                    return this.mPaint.ascent();
                }
                let wp = this.mWorkPaint;
                wp.set(this.mPaint);
                for (let span of spans) {
                    span.updateMeasureState(wp);
                }
                return wp.ascent();
            }
            nextTab(h) {
                if (this.mTabs != null) {
                    return this.mTabs.nextTab(h);
                }
                return Layout.TabStops.nextDefaultStop(h, TextLine.TAB_INCREMENT);
            }
        }
        TextLine.DEBUG = false;
        TextLine.sCached = new Array(3);
        TextLine.TAB_INCREMENT = 20;
        text_4.TextLine = TextLine;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/Path.ts"/>
///<reference path="../../android/text/style/LeadingMarginSpan.ts"/>
///<reference path="../../android/text/style/LineBackgroundSpan.ts"/>
///<reference path="../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../android/text/style/ReplacementSpan.ts"/>
///<reference path="../../android/text/style/TabStopSpan.ts"/>
///<reference path="../../java/util/Arrays.ts"/>
///<reference path="../../java/lang/Float.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../android/text/MeasuredText.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/SpanSet.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextLine.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/text/TextWatcher.ts"/>
var android;
(function (android) {
    var text;
    (function (text_5) {
        var Rect = android.graphics.Rect;
        var LeadingMarginSpan = android.text.style.LeadingMarginSpan;
        var LeadingMarginSpan2 = android.text.style.LeadingMarginSpan.LeadingMarginSpan2;
        var LineBackgroundSpan = android.text.style.LineBackgroundSpan;
        var ParagraphStyle = android.text.style.ParagraphStyle;
        var ReplacementSpan = android.text.style.ReplacementSpan;
        var TabStopSpan = android.text.style.TabStopSpan;
        var Arrays = java.util.Arrays;
        var Float = java.lang.Float;
        var System = java.lang.System;
        var MeasuredText = android.text.MeasuredText;
        var Spanned = android.text.Spanned;
        var SpanSet = android.text.SpanSet;
        var TextDirectionHeuristics = android.text.TextDirectionHeuristics;
        var TextLine = android.text.TextLine;
        var TextPaint = android.text.TextPaint;
        var TextUtils = android.text.TextUtils;
        window.addEventListener('AndroidUILoadFinish', () => {
            eval(`TextUtils = android.text.TextUtils;
              MeasuredText = android.text.MeasuredText;
              `);
        });
        class Layout {
            constructor(text, paint, width, align, textDir = TextDirectionHeuristics.FIRSTSTRONG_LTR, spacingMult = 1, spacingAdd = 0) {
                this.mWidth = 0;
                this.mAlignment = Layout.Alignment.ALIGN_NORMAL;
                this.mSpacingMult = 0;
                this.mSpacingAdd = 0;
                if (width < 0)
                    throw Error(`new IllegalArgumentException("Layout: " + width + " < 0")`);
                if (paint != null) {
                    paint.bgColor = 0;
                    paint.baselineShift = 0;
                }
                this.mText = text;
                this.mPaint = paint;
                this.mWorkPaint = new TextPaint();
                this.mWidth = width;
                this.mAlignment = align;
                this.mSpacingMult = spacingMult;
                this.mSpacingAdd = spacingAdd;
                this.mSpannedText = Spanned.isImplements(text);
                this.mTextDir = textDir;
            }
            static getDesiredWidth(...args) {
                if (args.length == 2)
                    return Layout.getDesiredWidth_2(...args);
                if (args.length == 4)
                    return Layout.getDesiredWidth_4(...args);
            }
            static getDesiredWidth_2(source, paint) {
                return Layout.getDesiredWidth(source, 0, source.length, paint);
            }
            static getDesiredWidth_4(source, start, end, paint) {
                let need = 0;
                let next;
                for (let i = start; i <= end; i = next) {
                    next = source.substring(0, end).indexOf('\n', i);
                    if (next < 0)
                        next = end;
                    let w = Layout.measurePara(paint, source, i, next);
                    if (w > need)
                        need = w;
                    next++;
                }
                return need;
            }
            replaceWith(text, paint, width, align, spacingmult, spacingadd) {
                if (width < 0) {
                    throw Error(`new IllegalArgumentException("Layout: " + width + " < 0")`);
                }
                this.mText = text;
                this.mPaint = paint;
                this.mWidth = width;
                this.mAlignment = align;
                this.mSpacingMult = spacingmult;
                this.mSpacingAdd = spacingadd;
                this.mSpannedText = Spanned.isImplements(text);
            }
            draw(canvas, highlight = null, highlightPaint = null, cursorOffsetVertical = 0) {
                const lineRange = this.getLineRangeForDraw(canvas);
                let firstLine = TextUtils.unpackRangeStartFromLong(lineRange);
                let lastLine = TextUtils.unpackRangeEndFromLong(lineRange);
                if (lastLine < 0)
                    return;
                this.drawBackground(canvas, highlight, highlightPaint, cursorOffsetVertical, firstLine, lastLine);
                this.drawText(canvas, firstLine, lastLine);
            }
            drawText(canvas, firstLine, lastLine) {
                let previousLineBottom = this.getLineTop(firstLine);
                let previousLineEnd = this.getLineStart(firstLine);
                let spans = Layout.NO_PARA_SPANS;
                let spanEnd = 0;
                let paint = this.mPaint;
                let buf = this.mText;
                let paraAlign = this.mAlignment;
                let tabStops = null;
                let tabStopsIsInitialized = false;
                let tl = TextLine.obtain();
                for (let i = firstLine; i <= lastLine; i++) {
                    let start = previousLineEnd;
                    previousLineEnd = this.getLineStart(i + 1);
                    let end = this.getLineVisibleEnd(i, start, previousLineEnd);
                    let ltop = previousLineBottom;
                    let lbottom = this.getLineTop(i + 1);
                    previousLineBottom = lbottom;
                    let lbaseline = lbottom - this.getLineDescent(i);
                    let dir = this.getParagraphDirection(i);
                    let left = 0;
                    let right = this.mWidth;
                    if (this.mSpannedText) {
                        let sp = buf;
                        let textLength = buf.length;
                        let isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
                        if (start >= spanEnd && (i == firstLine || isFirstParaLine)) {
                            spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.type);
                            spans = Layout.getParagraphSpans(sp, start, spanEnd, ParagraphStyle.type);
                            paraAlign = this.mAlignment;
                            tabStopsIsInitialized = false;
                        }
                        const length = spans.length;
                        for (let n = 0; n < length; n++) {
                            if (LeadingMarginSpan.isImpl(spans[n])) {
                                let margin = spans[n];
                                let useFirstLineMargin = isFirstParaLine;
                                if (LeadingMarginSpan2.isImpl(margin)) {
                                    let count = margin.getLeadingMarginLineCount();
                                    let startLine = this.getLineForOffset(sp.getSpanStart(margin));
                                    useFirstLineMargin = i < startLine + count;
                                }
                                if (dir == Layout.DIR_RIGHT_TO_LEFT) {
                                    margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                                    right -= margin.getLeadingMargin(useFirstLineMargin);
                                }
                                else {
                                    margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                                    left += margin.getLeadingMargin(useFirstLineMargin);
                                }
                            }
                        }
                    }
                    let hasTabOrEmoji = this.getLineContainsTab(i);
                    if (hasTabOrEmoji && !tabStopsIsInitialized) {
                        if (tabStops == null) {
                            tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, spans);
                        }
                        else {
                            tabStops.reset(Layout.TAB_INCREMENT, spans);
                        }
                        tabStopsIsInitialized = true;
                    }
                    let align = paraAlign;
                    if (align == Layout.Alignment.ALIGN_LEFT) {
                        align = (dir == Layout.DIR_LEFT_TO_RIGHT) ? Layout.Alignment.ALIGN_NORMAL : Layout.Alignment.ALIGN_OPPOSITE;
                    }
                    else if (align == Layout.Alignment.ALIGN_RIGHT) {
                        align = (dir == Layout.DIR_LEFT_TO_RIGHT) ? Layout.Alignment.ALIGN_OPPOSITE : Layout.Alignment.ALIGN_NORMAL;
                    }
                    let x;
                    if (align == Layout.Alignment.ALIGN_NORMAL) {
                        if (dir == Layout.DIR_LEFT_TO_RIGHT) {
                            x = left;
                        }
                        else {
                            x = right;
                        }
                    }
                    else {
                        let max = Math.floor(this.getLineExtent(i, tabStops, false));
                        if (align == Layout.Alignment.ALIGN_OPPOSITE) {
                            if (dir == Layout.DIR_LEFT_TO_RIGHT) {
                                x = right - max;
                            }
                            else {
                                x = left - max;
                            }
                        }
                        else {
                            max = max & ~1;
                            x = (right + left - max) >> 1;
                        }
                    }
                    let directions = this.getLineDirections(i);
                    if (directions == Layout.DIRS_ALL_LEFT_TO_RIGHT && !this.mSpannedText && !hasTabOrEmoji) {
                        canvas.drawText_end(buf.toString(), start, end, x, lbaseline, paint);
                    }
                    else {
                        tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
                        tl.draw(canvas, x, ltop, lbaseline, lbottom);
                    }
                }
                TextLine.recycle(tl);
            }
            drawBackground(canvas, highlight, highlightPaint, cursorOffsetVertical, firstLine, lastLine) {
                if (this.mSpannedText) {
                    if (this.mLineBackgroundSpans == null) {
                        this.mLineBackgroundSpans = new SpanSet(LineBackgroundSpan.type);
                    }
                    let buffer = this.mText;
                    let textLength = buffer.length;
                    this.mLineBackgroundSpans.init(buffer, 0, textLength);
                    if (this.mLineBackgroundSpans.numberOfSpans > 0) {
                        let previousLineBottom = this.getLineTop(firstLine);
                        let previousLineEnd = this.getLineStart(firstLine);
                        let spans = Layout.NO_PARA_SPANS;
                        let spansLength = 0;
                        let paint = this.mPaint;
                        let spanEnd = 0;
                        const width = this.mWidth;
                        for (let i = firstLine; i <= lastLine; i++) {
                            let start = previousLineEnd;
                            let end = this.getLineStart(i + 1);
                            previousLineEnd = end;
                            let ltop = previousLineBottom;
                            let lbottom = this.getLineTop(i + 1);
                            previousLineBottom = lbottom;
                            let lbaseline = lbottom - this.getLineDescent(i);
                            if (start >= spanEnd) {
                                spanEnd = this.mLineBackgroundSpans.getNextTransition(start, textLength);
                                spansLength = 0;
                                if (start != end || start == 0) {
                                    for (let j = 0; j < this.mLineBackgroundSpans.numberOfSpans; j++) {
                                        if (this.mLineBackgroundSpans.spanStarts[j] >= end || this.mLineBackgroundSpans.spanEnds[j] <= start)
                                            continue;
                                        if (spansLength == spans.length) {
                                            let newSize = (2 * spansLength);
                                            let newSpans = new Array(newSize);
                                            System.arraycopy(spans, 0, newSpans, 0, spansLength);
                                            spans = newSpans;
                                        }
                                        spans[spansLength++] = this.mLineBackgroundSpans.spans[j];
                                    }
                                }
                            }
                            for (let n = 0; n < spansLength; n++) {
                                let lineBackgroundSpan = spans[n];
                                lineBackgroundSpan.drawBackground(canvas, paint, 0, width, ltop, lbaseline, lbottom, buffer, start, end, i);
                            }
                        }
                    }
                    this.mLineBackgroundSpans.recycle();
                }
                if (highlight != null) {
                    if (cursorOffsetVertical != 0)
                        canvas.translate(0, cursorOffsetVertical);
                    canvas.drawPath(highlight, highlightPaint);
                    if (cursorOffsetVertical != 0)
                        canvas.translate(0, -cursorOffsetVertical);
                }
            }
            getLineRangeForDraw(canvas) {
                let dtop, dbottom;
                {
                    if (!canvas.getClipBounds(Layout.sTempRect)) {
                        return TextUtils.packRangeInLong(0, -1);
                    }
                    dtop = Layout.sTempRect.top;
                    dbottom = Layout.sTempRect.bottom;
                }
                const top = Math.max(dtop, 0);
                const bottom = Math.min(this.getLineTop(this.getLineCount()), dbottom);
                if (top >= bottom)
                    return TextUtils.packRangeInLong(0, -1);
                return TextUtils.packRangeInLong(this.getLineForVertical(top), this.getLineForVertical(bottom));
            }
            getLineStartPos(line, left, right) {
                let align = this.getParagraphAlignment(line);
                let dir = this.getParagraphDirection(line);
                if (align == Layout.Alignment.ALIGN_LEFT) {
                    align = (dir == Layout.DIR_LEFT_TO_RIGHT) ? Layout.Alignment.ALIGN_NORMAL : Layout.Alignment.ALIGN_OPPOSITE;
                }
                else if (align == Layout.Alignment.ALIGN_RIGHT) {
                    align = (dir == Layout.DIR_LEFT_TO_RIGHT) ? Layout.Alignment.ALIGN_OPPOSITE : Layout.Alignment.ALIGN_NORMAL;
                }
                let x;
                if (align == Layout.Alignment.ALIGN_NORMAL) {
                    if (dir == Layout.DIR_LEFT_TO_RIGHT) {
                        x = left;
                    }
                    else {
                        x = right;
                    }
                }
                else {
                    let tabStops = null;
                    if (this.mSpannedText && this.getLineContainsTab(line)) {
                        let spanned = this.mText;
                        let start = this.getLineStart(line);
                        let spanEnd = spanned.nextSpanTransition(start, spanned.length, TabStopSpan.type);
                        let tabSpans = Layout.getParagraphSpans(spanned, start, spanEnd, TabStopSpan.type);
                        if (tabSpans.length > 0) {
                            tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, tabSpans);
                        }
                    }
                    let max = Math.floor(this.getLineExtent(line, tabStops, false));
                    if (align == Layout.Alignment.ALIGN_OPPOSITE) {
                        if (dir == Layout.DIR_LEFT_TO_RIGHT) {
                            x = right - max;
                        }
                        else {
                            x = left - max;
                        }
                    }
                    else {
                        max = max & ~1;
                        x = (left + right - max) >> 1;
                    }
                }
                return x;
            }
            getText() {
                return this.mText;
            }
            getPaint() {
                return this.mPaint;
            }
            getWidth() {
                return this.mWidth;
            }
            getEllipsizedWidth() {
                return this.mWidth;
            }
            increaseWidthTo(wid) {
                if (wid < this.mWidth) {
                    throw Error(`new RuntimeException("attempted to reduce Layout width")`);
                }
                this.mWidth = wid;
            }
            getHeight() {
                return this.getLineTop(this.getLineCount());
            }
            getAlignment() {
                return this.mAlignment;
            }
            getSpacingMultiplier() {
                return this.mSpacingMult;
            }
            getSpacingAdd() {
                return this.mSpacingAdd;
            }
            getTextDirectionHeuristic() {
                return this.mTextDir;
            }
            getLineBounds(line, bounds) {
                if (bounds != null) {
                    bounds.left = 0;
                    bounds.top = this.getLineTop(line);
                    bounds.right = this.mWidth;
                    bounds.bottom = this.getLineTop(line + 1);
                }
                return this.getLineBaseline(line);
            }
            isLevelBoundary(offset) {
                let line = this.getLineForOffset(offset);
                let dirs = this.getLineDirections(line);
                if (dirs == Layout.DIRS_ALL_LEFT_TO_RIGHT || dirs == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
                    return false;
                }
                let runs = dirs.mDirections;
                let lineStart = this.getLineStart(line);
                let lineEnd = this.getLineEnd(line);
                if (offset == lineStart || offset == lineEnd) {
                    let paraLevel = this.getParagraphDirection(line) == 1 ? 0 : 1;
                    let runIndex = offset == lineStart ? 0 : runs.length - 2;
                    return ((runs[runIndex + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK) != paraLevel;
                }
                offset -= lineStart;
                for (let i = 0; i < runs.length; i += 2) {
                    if (offset == runs[i]) {
                        return true;
                    }
                }
                return false;
            }
            isRtlCharAt(offset) {
                let line = this.getLineForOffset(offset);
                let dirs = this.getLineDirections(line);
                if (dirs == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
                    return false;
                }
                if (dirs == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
                    return true;
                }
                let runs = dirs.mDirections;
                let lineStart = this.getLineStart(line);
                for (let i = 0; i < runs.length; i += 2) {
                    let start = lineStart + (runs[i] & Layout.RUN_LENGTH_MASK);
                    if (offset >= start) {
                        let level = (runs[i + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                        return ((level & 1) != 0);
                    }
                }
                return false;
            }
            primaryIsTrailingPrevious(offset) {
                let line = this.getLineForOffset(offset);
                let lineStart = this.getLineStart(line);
                let lineEnd = this.getLineEnd(line);
                let runs = this.getLineDirections(line).mDirections;
                let levelAt = -1;
                for (let i = 0; i < runs.length; i += 2) {
                    let start = lineStart + runs[i];
                    let limit = start + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
                    if (limit > lineEnd) {
                        limit = lineEnd;
                    }
                    if (offset >= start && offset < limit) {
                        if (offset > start) {
                            return false;
                        }
                        levelAt = (runs[i + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                        break;
                    }
                }
                if (levelAt == -1) {
                    levelAt = this.getParagraphDirection(line) == 1 ? 0 : 1;
                }
                let levelBefore = -1;
                if (offset == lineStart) {
                    levelBefore = this.getParagraphDirection(line) == 1 ? 0 : 1;
                }
                else {
                    offset -= 1;
                    for (let i = 0; i < runs.length; i += 2) {
                        let start = lineStart + runs[i];
                        let limit = start + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
                        if (limit > lineEnd) {
                            limit = lineEnd;
                        }
                        if (offset >= start && offset < limit) {
                            levelBefore = (runs[i + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                            break;
                        }
                    }
                }
                return levelBefore < levelAt;
            }
            getPrimaryHorizontal(offset, clamped = false) {
                let trailing = this.primaryIsTrailingPrevious(offset);
                return this.getHorizontal(offset, trailing, clamped);
            }
            getSecondaryHorizontal(offset, clamped = false) {
                let trailing = this.primaryIsTrailingPrevious(offset);
                return this.getHorizontal(offset, !trailing, clamped);
            }
            getHorizontal(offset, trailing, clamped) {
                let line = this.getLineForOffset(offset);
                return this.getHorizontal_4(offset, trailing, line, clamped);
            }
            getHorizontal_4(offset, trailing, line, clamped) {
                let start = this.getLineStart(line);
                let end = this.getLineEnd(line);
                let dir = this.getParagraphDirection(line);
                let hasTabOrEmoji = this.getLineContainsTab(line);
                let directions = this.getLineDirections(line);
                let tabStops = null;
                if (hasTabOrEmoji && Spanned.isImplements(this.mText)) {
                    let tabs = Layout.getParagraphSpans(this.mText, start, end, TabStopSpan.type);
                    if (tabs.length > 0) {
                        tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, tabs);
                    }
                }
                let tl = TextLine.obtain();
                tl.set(this.mPaint, this.mText, start, end, dir, directions, hasTabOrEmoji, tabStops);
                let wid = tl.measure(offset - start, trailing, null);
                TextLine.recycle(tl);
                if (clamped && wid > this.mWidth) {
                    wid = this.mWidth;
                }
                let left = this.getParagraphLeft(line);
                let right = this.getParagraphRight(line);
                return this.getLineStartPos(line, left, right) + wid;
            }
            getLineLeft(line) {
                let dir = this.getParagraphDirection(line);
                let align = this.getParagraphAlignment(line);
                if (align == Layout.Alignment.ALIGN_LEFT) {
                    return 0;
                }
                else if (align == Layout.Alignment.ALIGN_NORMAL) {
                    if (dir == Layout.DIR_RIGHT_TO_LEFT)
                        return this.getParagraphRight(line) - this.getLineMax(line);
                    else
                        return 0;
                }
                else if (align == Layout.Alignment.ALIGN_RIGHT) {
                    return this.mWidth - this.getLineMax(line);
                }
                else if (align == Layout.Alignment.ALIGN_OPPOSITE) {
                    if (dir == Layout.DIR_RIGHT_TO_LEFT)
                        return 0;
                    else
                        return this.mWidth - this.getLineMax(line);
                }
                else {
                    let left = this.getParagraphLeft(line);
                    let right = this.getParagraphRight(line);
                    let max = (Math.floor(this.getLineMax(line))) & ~1;
                    return left + ((right - left) - max) / 2;
                }
            }
            getLineRight(line) {
                let dir = this.getParagraphDirection(line);
                let align = this.getParagraphAlignment(line);
                if (align == Layout.Alignment.ALIGN_LEFT) {
                    return this.getParagraphLeft(line) + this.getLineMax(line);
                }
                else if (align == Layout.Alignment.ALIGN_NORMAL) {
                    if (dir == Layout.DIR_RIGHT_TO_LEFT)
                        return this.mWidth;
                    else
                        return this.getParagraphLeft(line) + this.getLineMax(line);
                }
                else if (align == Layout.Alignment.ALIGN_RIGHT) {
                    return this.mWidth;
                }
                else if (align == Layout.Alignment.ALIGN_OPPOSITE) {
                    if (dir == Layout.DIR_RIGHT_TO_LEFT)
                        return this.getLineMax(line);
                    else
                        return this.mWidth;
                }
                else {
                    let left = this.getParagraphLeft(line);
                    let right = this.getParagraphRight(line);
                    let max = (Math.floor(this.getLineMax(line))) & ~1;
                    return right - ((right - left) - max) / 2;
                }
            }
            getLineMax(line) {
                let margin = this.getParagraphLeadingMargin(line);
                let signedExtent = this.getLineExtent(line, false);
                return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
            }
            getLineWidth(line) {
                let margin = this.getParagraphLeadingMargin(line);
                let signedExtent = this.getLineExtent(line, true);
                return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
            }
            getLineExtent(...args) {
                if (args.length === 2)
                    return this.getLineExtent_2(...args);
                if (args.length === 3)
                    return this.getLineExtent_3(...args);
            }
            getLineExtent_2(line, full) {
                let start = this.getLineStart(line);
                let end = full ? this.getLineEnd(line) : this.getLineVisibleEnd(line);
                let hasTabsOrEmoji = this.getLineContainsTab(line);
                let tabStops = null;
                if (hasTabsOrEmoji && Spanned.isImplements(this.mText)) {
                    let tabs = Layout.getParagraphSpans(this.mText, start, end, TabStopSpan.type);
                    if (tabs.length > 0) {
                        tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, tabs);
                    }
                }
                let directions = this.getLineDirections(line);
                if (directions == null) {
                    return 0;
                }
                let dir = this.getParagraphDirection(line);
                let tl = TextLine.obtain();
                tl.set(this.mPaint, this.mText, start, end, dir, directions, hasTabsOrEmoji, tabStops);
                let width = tl.metrics(null);
                TextLine.recycle(tl);
                return width;
            }
            getLineExtent_3(line, tabStops, full) {
                let start = this.getLineStart(line);
                let end = full ? this.getLineEnd(line) : this.getLineVisibleEnd(line);
                let hasTabsOrEmoji = this.getLineContainsTab(line);
                let directions = this.getLineDirections(line);
                let dir = this.getParagraphDirection(line);
                let tl = TextLine.obtain();
                tl.set(this.mPaint, this.mText, start, end, dir, directions, hasTabsOrEmoji, tabStops);
                let width = tl.metrics(null);
                TextLine.recycle(tl);
                return width;
            }
            getLineForVertical(vertical) {
                let high = this.getLineCount(), low = -1, guess;
                while (high - low > 1) {
                    guess = Math.floor((high + low) / 2);
                    if (this.getLineTop(guess) > vertical)
                        high = guess;
                    else
                        low = guess;
                }
                if (low < 0)
                    return 0;
                else
                    return low;
            }
            getLineForOffset(offset) {
                let high = this.getLineCount(), low = -1, guess;
                while (high - low > 1) {
                    guess = Math.floor((high + low) / 2);
                    if (this.getLineStart(guess) > offset)
                        high = guess;
                    else
                        low = guess;
                }
                if (low < 0)
                    return 0;
                else
                    return low;
            }
            getOffsetForHorizontal(line, horiz) {
                let max = this.getLineEnd(line) - 1;
                let min = this.getLineStart(line);
                let dirs = this.getLineDirections(line);
                if (line == this.getLineCount() - 1)
                    max++;
                let best = min;
                let bestdist = Math.abs(this.getPrimaryHorizontal(best) - horiz);
                for (let i = 0; i < dirs.mDirections.length; i += 2) {
                    let here = min + dirs.mDirections[i];
                    let there = here + (dirs.mDirections[i + 1] & Layout.RUN_LENGTH_MASK);
                    let swap = (dirs.mDirections[i + 1] & Layout.RUN_RTL_FLAG) != 0 ? -1 : 1;
                    if (there > max)
                        there = max;
                    let high = there - 1 + 1, low = here + 1 - 1, guess;
                    while (high - low > 1) {
                        guess = Math.floor((high + low) / 2);
                        let adguess = this.getOffsetAtStartOf(guess);
                        if (this.getPrimaryHorizontal(adguess) * swap >= horiz * swap)
                            high = guess;
                        else
                            low = guess;
                    }
                    if (low < here + 1)
                        low = here + 1;
                    if (low < there) {
                        low = this.getOffsetAtStartOf(low);
                        let dist = Math.abs(this.getPrimaryHorizontal(low) - horiz);
                        let aft = TextUtils.getOffsetAfter(this.mText, low);
                        if (aft < there) {
                            let other = Math.abs(this.getPrimaryHorizontal(aft) - horiz);
                            if (other < dist) {
                                dist = other;
                                low = aft;
                            }
                        }
                        if (dist < bestdist) {
                            bestdist = dist;
                            best = low;
                        }
                    }
                    let dist = Math.abs(this.getPrimaryHorizontal(here) - horiz);
                    if (dist < bestdist) {
                        bestdist = dist;
                        best = here;
                    }
                }
                let dist = Math.abs(this.getPrimaryHorizontal(max) - horiz);
                if (dist <= bestdist) {
                    bestdist = dist;
                    best = max;
                }
                return best;
            }
            getLineEnd(line) {
                return this.getLineStart(line + 1);
            }
            getLineVisibleEnd(line, start = this.getLineStart(line), end = this.getLineStart(line + 1)) {
                let text = this.mText;
                let ch;
                if (line == this.getLineCount() - 1) {
                    return end;
                }
                for (; end > start; end--) {
                    ch = text.charAt(end - 1);
                    if (ch == '\n') {
                        return end - 1;
                    }
                    if (ch != ' ' && ch != '\t') {
                        break;
                    }
                }
                return end;
            }
            getLineBottom(line) {
                return this.getLineTop(line + 1);
            }
            getLineBaseline(line) {
                return this.getLineTop(line + 1) - this.getLineDescent(line);
            }
            getLineAscent(line) {
                return this.getLineTop(line) - (this.getLineTop(line + 1) - this.getLineDescent(line));
            }
            getOffsetToLeftOf(offset) {
                return this.getOffsetToLeftRightOf(offset, true);
            }
            getOffsetToRightOf(offset) {
                return this.getOffsetToLeftRightOf(offset, false);
            }
            getOffsetToLeftRightOf(caret, toLeft) {
                let line = this.getLineForOffset(caret);
                let lineStart = this.getLineStart(line);
                let lineEnd = this.getLineEnd(line);
                let lineDir = this.getParagraphDirection(line);
                let lineChanged = false;
                let advance = toLeft == (lineDir == Layout.DIR_RIGHT_TO_LEFT);
                if (advance) {
                    if (caret == lineEnd) {
                        if (line < this.getLineCount() - 1) {
                            lineChanged = true;
                            ++line;
                        }
                        else {
                            return caret;
                        }
                    }
                }
                else {
                    if (caret == lineStart) {
                        if (line > 0) {
                            lineChanged = true;
                            --line;
                        }
                        else {
                            return caret;
                        }
                    }
                }
                if (lineChanged) {
                    lineStart = this.getLineStart(line);
                    lineEnd = this.getLineEnd(line);
                    let newDir = this.getParagraphDirection(line);
                    if (newDir != lineDir) {
                        toLeft = !toLeft;
                        lineDir = newDir;
                    }
                }
                let directions = this.getLineDirections(line);
                let tl = TextLine.obtain();
                tl.set(this.mPaint, this.mText, lineStart, lineEnd, lineDir, directions, false, null);
                caret = lineStart + tl.getOffsetToLeftRightOf(caret - lineStart, toLeft);
                tl = TextLine.recycle(tl);
                return caret;
            }
            getOffsetAtStartOf(offset) {
                if (offset == 0)
                    return 0;
                let text = this.mText;
                let c = text.codePointAt(offset);
                let questionMark = '?'.codePointAt(0);
                if (c >= questionMark && c <= questionMark) {
                    let c1 = text.codePointAt(offset - 1);
                    if (c1 >= questionMark && c1 <= questionMark)
                        offset -= 1;
                }
                if (this.mSpannedText) {
                    let spans = text.getSpans(offset, offset, ReplacementSpan.type);
                    for (let i = 0; i < spans.length; i++) {
                        let start = text.getSpanStart(spans[i]);
                        let end = text.getSpanEnd(spans[i]);
                        if (start < offset && end > offset)
                            offset = start;
                    }
                }
                return offset;
            }
            shouldClampCursor(line) {
                switch (this.getParagraphAlignment(line)) {
                    case Layout.Alignment.ALIGN_LEFT:
                        return true;
                    case Layout.Alignment.ALIGN_NORMAL:
                        return this.getParagraphDirection(line) > 0;
                    default:
                        return false;
                }
            }
            getCursorPath(point, dest, editingBuffer) {
                dest.reset();
            }
            addSelection(line, start, end, top, bottom, dest) {
            }
            getSelectionPath(start, end, dest) {
                dest.reset();
            }
            getParagraphAlignment(line) {
                let align = this.mAlignment;
                return align;
            }
            getParagraphLeft(line) {
                let left = 0;
                let dir = this.getParagraphDirection(line);
                if (dir == Layout.DIR_RIGHT_TO_LEFT || !this.mSpannedText) {
                    return left;
                }
                return this.getParagraphLeadingMargin(line);
            }
            getParagraphRight(line) {
                let right = this.mWidth;
                let dir = this.getParagraphDirection(line);
                if (dir == Layout.DIR_LEFT_TO_RIGHT || !this.mSpannedText) {
                    return right;
                }
                return right - this.getParagraphLeadingMargin(line);
            }
            getParagraphLeadingMargin(line) {
                if (!this.mSpannedText) {
                    return 0;
                }
                let spanned = this.mText;
                let lineStart = this.getLineStart(line);
                let lineEnd = this.getLineEnd(line);
                let spanEnd = spanned.nextSpanTransition(lineStart, lineEnd, LeadingMarginSpan.type);
                let spans = Layout.getParagraphSpans(spanned, lineStart, spanEnd, LeadingMarginSpan.type);
                if (spans.length == 0) {
                    return 0;
                }
                let margin = 0;
                let isFirstParaLine = lineStart == 0 || spanned.charAt(lineStart - 1) == '\n';
                for (let i = 0; i < spans.length; i++) {
                    let span = spans[i];
                    let useFirstLineMargin = isFirstParaLine;
                    if (LeadingMarginSpan2.isImpl(span)) {
                        let spStart = spanned.getSpanStart(span);
                        let spanLine = this.getLineForOffset(spStart);
                        let count = span.getLeadingMarginLineCount();
                        useFirstLineMargin = line < spanLine + count;
                    }
                    margin += span.getLeadingMargin(useFirstLineMargin);
                }
                return margin;
            }
            static measurePara(paint, text, start, end) {
                let mt = MeasuredText.obtain();
                let tl = TextLine.obtain();
                try {
                    mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
                    let directions;
                    let dir;
                    directions = Layout.DIRS_ALL_LEFT_TO_RIGHT;
                    dir = Layout.DIR_LEFT_TO_RIGHT;
                    let chars = mt.mChars;
                    let len = mt.mLen;
                    let hasTabs = false;
                    let tabStops = null;
                    for (let i = 0; i < len; ++i) {
                        if (chars[i] == '\t') {
                            hasTabs = true;
                            if (Spanned.isImplements(text)) {
                                let spanned = text;
                                let spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.type);
                                let spans = Layout.getParagraphSpans(spanned, start, spanEnd, TabStopSpan.type);
                                if (spans.length > 0) {
                                    tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, spans);
                                }
                            }
                            break;
                        }
                    }
                    tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
                    return tl.metrics(null);
                }
                finally {
                    TextLine.recycle(tl);
                    MeasuredText.recycle(mt);
                }
            }
            static nextTab(text, start, end, h, tabs) {
                let nh = Float.MAX_VALUE;
                let alltabs = false;
                if (Spanned.isImplements(text)) {
                    if (tabs == null) {
                        tabs = Layout.getParagraphSpans(text, start, end, TabStopSpan.type);
                        alltabs = true;
                    }
                    for (let i = 0; i < tabs.length; i++) {
                        if (!alltabs) {
                            if (!(TabStopSpan.isImpl(tabs[i])))
                                continue;
                        }
                        let where = tabs[i].getTabStop();
                        if (where < nh && where > h)
                            nh = where;
                    }
                    if (nh != Float.MAX_VALUE)
                        return nh;
                }
                return (Math.floor(((h + Layout.TAB_INCREMENT) / Layout.TAB_INCREMENT))) * Layout.TAB_INCREMENT;
            }
            isSpanned() {
                return this.mSpannedText;
            }
            static getParagraphSpans(text, start, end, type) {
                if (start == end && start > 0) {
                    return [];
                }
                return text.getSpans(start, end, type);
            }
            getEllipsisChar(method) {
                return (method == TextUtils.TruncateAt.END_SMALL) ? Layout.ELLIPSIS_TWO_DOTS[0] : Layout.ELLIPSIS_NORMAL[0];
            }
            ellipsize(start, end, line, dest, destoff, method) {
                let ellipsisCount = this.getEllipsisCount(line);
                if (ellipsisCount == 0) {
                    return;
                }
                let ellipsisStart = this.getEllipsisStart(line);
                let linestart = this.getLineStart(line);
                for (let i = ellipsisStart; i < ellipsisStart + ellipsisCount; i++) {
                    let c;
                    if (i == ellipsisStart) {
                        c = this.getEllipsisChar(method);
                    }
                    else {
                        c = String.fromCharCode(20);
                    }
                    let a = i + linestart;
                    if (a >= start && a < end) {
                        dest[destoff + a - start] = c;
                    }
                }
            }
        }
        Layout.NO_PARA_SPANS = [];
        Layout.sTempRect = new Rect();
        Layout.DIR_LEFT_TO_RIGHT = 1;
        Layout.DIR_RIGHT_TO_LEFT = -1;
        Layout.DIR_REQUEST_LTR = 1;
        Layout.DIR_REQUEST_RTL = -1;
        Layout.DIR_REQUEST_DEFAULT_LTR = 2;
        Layout.DIR_REQUEST_DEFAULT_RTL = -2;
        Layout.RUN_LENGTH_MASK = 0x03ffffff;
        Layout.RUN_LEVEL_SHIFT = 26;
        Layout.RUN_LEVEL_MASK = 0x3f;
        Layout.RUN_RTL_FLAG = 1 << Layout.RUN_LEVEL_SHIFT;
        Layout.TAB_INCREMENT = 20;
        Layout.ELLIPSIS_NORMAL = [''];
        Layout.ELLIPSIS_TWO_DOTS = [''];
        text_5.Layout = Layout;
        (function (Layout) {
            class TabStops {
                constructor(increment, spans) {
                    this.mNumStops = 0;
                    this.mIncrement = 0;
                    this.reset(increment, spans);
                }
                reset(increment, spans) {
                    this.mIncrement = increment;
                    let ns = 0;
                    if (spans != null) {
                        let stops = this.mStops;
                        for (let o of spans) {
                            if (TabStopSpan.isImpl(o)) {
                                if (stops == null) {
                                    stops = new Array(10);
                                }
                                else if (ns == stops.length) {
                                    let nstops = new Array(ns * 2);
                                    for (let i = 0; i < ns; ++i) {
                                        nstops[i] = stops[i];
                                    }
                                    stops = nstops;
                                }
                                stops[ns++] = o.getTabStop();
                            }
                        }
                        if (ns > 1) {
                            Arrays.sort(stops, 0, ns);
                        }
                        if (stops != this.mStops) {
                            this.mStops = stops;
                        }
                    }
                    this.mNumStops = ns;
                }
                nextTab(h) {
                    let ns = this.mNumStops;
                    if (ns > 0) {
                        let stops = this.mStops;
                        for (let i = 0; i < ns; ++i) {
                            let stop = stops[i];
                            if (stop > h) {
                                return stop;
                            }
                        }
                    }
                    return TabStops.nextDefaultStop(h, this.mIncrement);
                }
                static nextDefaultStop(h, inc) {
                    return (Math.floor(((h + inc) / inc))) * inc;
                }
            }
            Layout.TabStops = TabStops;
            class Directions {
                constructor(dirs) {
                    this.mDirections = dirs;
                }
            }
            Layout.Directions = Directions;
            class Ellipsizer extends String {
                constructor(s) {
                    super(s);
                    this.mWidth = 0;
                    this.mText = s;
                }
                toString() {
                    let line1 = this.mLayout.getLineForOffset(0);
                    let line2 = this.mLayout.getLineForOffset(this.mText.length);
                    let dest = this.mText.split('');
                    for (let i = line1; i <= line2; i++) {
                        this.mLayout.ellipsize(0, this.mText.length, i, dest, 0, this.mMethod);
                    }
                    return dest.join('');
                }
            }
            Layout.Ellipsizer = Ellipsizer;
            class SpannedEllipsizer extends Layout.Ellipsizer {
                constructor(display) {
                    super(display);
                    this.mSpanned = display;
                }
                getSpans(start, end, type) {
                    return this.mSpanned.getSpans(start, end, type);
                }
                getSpanStart(tag) {
                    return this.mSpanned.getSpanStart(tag);
                }
                getSpanEnd(tag) {
                    return this.mSpanned.getSpanEnd(tag);
                }
                getSpanFlags(tag) {
                    return this.mSpanned.getSpanFlags(tag);
                }
                nextSpanTransition(start, limit, type) {
                    return this.mSpanned.nextSpanTransition(start, limit, type);
                }
            }
            Layout.SpannedEllipsizer = SpannedEllipsizer;
            (function (Alignment) {
                Alignment[Alignment["ALIGN_NORMAL"] = 0] = "ALIGN_NORMAL";
                Alignment[Alignment["ALIGN_OPPOSITE"] = 1] = "ALIGN_OPPOSITE";
                Alignment[Alignment["ALIGN_CENTER"] = 2] = "ALIGN_CENTER";
                Alignment[Alignment["ALIGN_LEFT"] = 3] = "ALIGN_LEFT";
                Alignment[Alignment["ALIGN_RIGHT"] = 4] = "ALIGN_RIGHT";
            })(Layout.Alignment || (Layout.Alignment = {}));
            var Alignment = Layout.Alignment;
        })(Layout = text_5.Layout || (text_5.Layout = {}));
        Layout.DIRS_ALL_LEFT_TO_RIGHT = new Layout.Directions([0, Layout.RUN_LENGTH_MASK]);
        Layout.DIRS_ALL_RIGHT_TO_LEFT = new Layout.Directions([0, Layout.RUN_LENGTH_MASK | Layout.RUN_RTL_FLAG]);
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../android/text/style/ReplacementSpan.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text_6) {
        var Canvas = android.graphics.Canvas;
        var ReplacementSpan = android.text.style.ReplacementSpan;
        var Log = android.util.Log;
        var Spanned = android.text.Spanned;
        var TextPaint = android.text.TextPaint;
        class MeasuredText {
            constructor() {
                this.mTextStart = 0;
                this.mDir = 0;
                this.mLen = 0;
                this.mPos = 0;
                this.mWorkPaint = new TextPaint();
            }
            static obtain() {
                let mt;
                {
                    for (let i = MeasuredText.sCached.length; --i >= 0;) {
                        if (MeasuredText.sCached[i] != null) {
                            mt = MeasuredText.sCached[i];
                            MeasuredText.sCached[i] = null;
                            return mt;
                        }
                    }
                }
                mt = new MeasuredText();
                if (MeasuredText.localLOGV) {
                    Log.v("MEAS", "new: " + mt);
                }
                return mt;
            }
            static recycle(mt) {
                mt.mText = null;
                if (mt.mLen < 1000) {
                    {
                        for (let i = 0; i < MeasuredText.sCached.length; ++i) {
                            if (MeasuredText.sCached[i] == null) {
                                MeasuredText.sCached[i] = mt;
                                mt.mText = null;
                                break;
                            }
                        }
                    }
                }
                return null;
            }
            setPos(pos) {
                this.mPos = pos - this.mTextStart;
            }
            setPara(text, start, end, textDir) {
                this.mText = text;
                this.mTextStart = start;
                let len = end - start;
                this.mLen = len;
                this.mPos = 0;
                if (this.mWidths == null || this.mWidths.length < len) {
                    this.mWidths = new Array(len);
                }
                this.mChars = text.toString().substring(start, end);
                if (Spanned.isImplements(text)) {
                    let spanned = text;
                    let spans = spanned.getSpans(start, end, ReplacementSpan.type);
                    for (let i = 0; i < spans.length; i++) {
                        let startInPara = spanned.getSpanStart(spans[i]) - start;
                        let endInPara = spanned.getSpanEnd(spans[i]) - start;
                        if (startInPara < 0)
                            startInPara = 0;
                        if (endInPara > len)
                            endInPara = len;
                        for (let j = startInPara; j < endInPara; j++) {
                            this.mChars[j] = '';
                        }
                    }
                }
                this.mDir = android.text.Layout.DIR_LEFT_TO_RIGHT;
                this.mEasy = true;
            }
            addStyleRun(...args) {
                if (args.length === 3)
                    return this.addStyleRun_3(...args);
                if (args.length === 4)
                    return this.addStyleRun_4(...args);
            }
            addStyleRun_3(paint, len, fm) {
                if (fm != null) {
                    paint.getFontMetricsInt(fm);
                }
                let p = this.mPos;
                this.mPos = p + len;
                if (this.mEasy) {
                    let flags = this.mDir == android.text.Layout.DIR_LEFT_TO_RIGHT ? Canvas.DIRECTION_LTR : Canvas.DIRECTION_RTL;
                    return paint.getTextRunAdvances_count(this.mChars, p, len, p, len, flags, this.mWidths, p);
                }
                let totalAdvance = 0;
                let level = this.mLevels[p];
                for (let q = p, i = p + 1, e = p + len;; ++i) {
                    if (i == e || this.mLevels[i] != level) {
                        let flags = (level & 0x1) == 0 ? Canvas.DIRECTION_LTR : Canvas.DIRECTION_RTL;
                        totalAdvance += paint.getTextRunAdvances_count(this.mChars, q, i - q, q, i - q, flags, this.mWidths, q);
                        if (i == e) {
                            break;
                        }
                        q = i;
                        level = this.mLevels[i];
                    }
                }
                return totalAdvance;
            }
            addStyleRun_4(paint, spans, len, fm) {
                let workPaint = this.mWorkPaint;
                workPaint.set(paint);
                workPaint.baselineShift = 0;
                let replacement = null;
                for (let i = 0; i < spans.length; i++) {
                    let span = spans[i];
                    if (span instanceof ReplacementSpan) {
                        replacement = span;
                    }
                    else {
                        span.updateMeasureState(workPaint);
                    }
                }
                let wid;
                if (replacement == null) {
                    wid = this.addStyleRun(workPaint, len, fm);
                }
                else {
                    wid = replacement.getSize(workPaint, this.mText, this.mTextStart + this.mPos, this.mTextStart + this.mPos + len, fm);
                    let w = this.mWidths;
                    w[this.mPos] = wid;
                    for (let i = this.mPos + 1, e = this.mPos + len; i < e; i++)
                        w[i] = 0;
                    this.mPos += len;
                }
                if (fm != null) {
                    if (workPaint.baselineShift < 0) {
                        fm.ascent += workPaint.baselineShift;
                        fm.top += workPaint.baselineShift;
                    }
                    else {
                        fm.descent += workPaint.baselineShift;
                        fm.bottom += workPaint.baselineShift;
                    }
                }
                return wid;
            }
            breakText(limit, forwards, width) {
                let w = this.mWidths;
                if (forwards) {
                    let i = 0;
                    while (i < limit) {
                        width -= w[i];
                        if (width < 0.0)
                            break;
                        i++;
                    }
                    while (i > 0 && this.mChars[i - 1] == ' ')
                        i--;
                    return i;
                }
                else {
                    let i = limit - 1;
                    while (i >= 0) {
                        width -= w[i];
                        if (width < 0.0)
                            break;
                        i--;
                    }
                    while (i < limit - 1 && this.mChars[i + 1] == ' ')
                        i++;
                    return limit - i - 1;
                }
            }
            measure(start, limit) {
                let width = 0;
                let w = this.mWidths;
                for (let i = start; i < limit; ++i) {
                    width += w[i];
                }
                return width;
            }
        }
        MeasuredText.localLOGV = false;
        MeasuredText.sLock = new Array(0);
        MeasuredText.sCached = new Array(3);
        text_6.MeasuredText = MeasuredText;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/14.
 */
///<reference path="Spanned.ts"/>
///<reference path="style/ReplacementSpan.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../android/text/MeasuredText.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
var android;
(function (android) {
    var text;
    (function (text_7) {
        var System = java.lang.System;
        var StringBuilder = java.lang.StringBuilder;
        var MeasuredText = android.text.MeasuredText;
        var Spanned = android.text.Spanned;
        var TextDirectionHeuristics = android.text.TextDirectionHeuristics;
        class TextUtils {
            static isEmpty(str) {
                if (str == null || str.length == 0)
                    return true;
                else
                    return false;
            }
            static getOffsetBefore(text, offset) {
                if (offset == 0)
                    return 0;
                if (offset == 1)
                    return 0;
                let c = text.codePointAt(offset - 1);
                if (c >= '?'.codePointAt(0) && c <= '?'.codePointAt(0)) {
                    let c1 = text.codePointAt(offset - 2);
                    if (c1 >= '?'.codePointAt(0) && c1 <= '?'.codePointAt(0))
                        offset -= 2;
                    else
                        offset -= 1;
                }
                else {
                    offset -= 1;
                }
                if (Spanned.isImplements(text)) {
                    let spans = text.getSpans(offset, offset, android.text.style.ReplacementSpan.type);
                    for (let i = 0; i < spans.length; i++) {
                        let start = text.getSpanStart(spans[i]);
                        let end = text.getSpanEnd(spans[i]);
                        if (start < offset && end > offset)
                            offset = start;
                    }
                }
                return offset;
            }
            static getOffsetAfter(text, offset) {
                let len = text.length;
                if (offset == len)
                    return len;
                if (offset == len - 1)
                    return len;
                let c = text.codePointAt(offset);
                if (c >= '?'.codePointAt(0) && c <= '?'.codePointAt(0)) {
                    let c1 = text.codePointAt(offset + 1);
                    if (c1 >= '?'.codePointAt(0) && c1 <= '?'.codePointAt(0))
                        offset += 2;
                    else
                        offset += 1;
                }
                else {
                    offset += 1;
                }
                if (Spanned.isImplements(text)) {
                    let spans = text.getSpans(offset, offset, android.text.style.ReplacementSpan.type);
                    for (let i = 0; i < spans.length; i++) {
                        let start = text.getSpanStart(spans[i]);
                        let end = text.getSpanEnd(spans[i]);
                        if (start < offset && end > offset)
                            offset = end;
                    }
                }
                return offset;
            }
            static ellipsize(text, paint, avail, where, preserveLength = false, callback = null, textDir = TextDirectionHeuristics.FIRSTSTRONG_LTR, ellipsis = undefined) {
                ellipsis = ellipsis || (where == TextUtils.TruncateAt.END_SMALL ? android.text.Layout.ELLIPSIS_TWO_DOTS[0] : android.text.Layout.ELLIPSIS_NORMAL[0]);
                let len = text.length;
                let mt = MeasuredText.obtain();
                try {
                    let width = TextUtils.setPara(mt, paint, text, 0, text.length, textDir);
                    if (width <= avail) {
                        if (callback != null) {
                            callback.ellipsized(0, 0);
                        }
                        return text;
                    }
                    let ellipsiswid = paint.measureText(ellipsis);
                    avail -= ellipsiswid;
                    let left = 0;
                    let right = len;
                    if (avail < 0) {
                    }
                    else if (where == TextUtils.TruncateAt.START) {
                        right = len - mt.breakText(len, false, avail);
                    }
                    else if (where == TextUtils.TruncateAt.END || where == TextUtils.TruncateAt.END_SMALL) {
                        left = mt.breakText(len, true, avail);
                    }
                    else {
                        right = len - mt.breakText(len, false, avail / 2);
                        avail -= mt.measure(right, len);
                        left = mt.breakText(right, true, avail);
                    }
                    if (callback != null) {
                        callback.ellipsized(left, right);
                    }
                    let buf = mt.mChars.split('');
                    let sp = Spanned.isImplements(text) ? text : null;
                    let remaining = len - (right - left);
                    if (preserveLength) {
                        if (remaining > 0) {
                            buf[left++] = ellipsis.charAt(0);
                        }
                        for (let i = left; i < right; i++) {
                            buf[i] = TextUtils.ZWNBS_CHAR;
                        }
                        let s = buf.join('');
                        return s;
                    }
                    if (remaining == 0) {
                        return "";
                    }
                    let sb = new StringBuilder(remaining + ellipsis.length());
                    sb.append(buf.join('').substr(0, left));
                    sb.append(ellipsis);
                    sb.append(buf.join('').substr(right, len - right));
                    return sb.toString();
                }
                finally {
                    MeasuredText.recycle(mt);
                }
            }
            static setPara(mt, paint, text, start, end, textDir) {
                mt.setPara(text, start, end, textDir);
                let width;
                let sp = Spanned.isImplements(text) ? text : null;
                let len = end - start;
                if (sp == null) {
                    width = mt.addStyleRun(paint, len, null);
                }
                else {
                    width = 0;
                    let spanEnd;
                    for (let spanStart = 0; spanStart < len; spanStart = spanEnd) {
                        spanEnd = sp.nextSpanTransition(spanStart, len, android.text.style.MetricAffectingSpan.type);
                        let spans = sp.getSpans(spanStart, spanEnd, android.text.style.MetricAffectingSpan.type);
                        spans = TextUtils.removeEmptySpans(spans, sp, android.text.style.MetricAffectingSpan.type);
                        width += mt.addStyleRun(paint, spans, spanEnd - spanStart, null);
                    }
                }
                return width;
            }
            static removeEmptySpans(spans, spanned, klass) {
                let copy = null;
                let count = 0;
                for (let i = 0; i < spans.length; i++) {
                    const span = spans[i];
                    const start = spanned.getSpanStart(span);
                    const end = spanned.getSpanEnd(span);
                    if (start == end) {
                        if (copy == null) {
                            copy = new Array(spans.length - 1);
                            System.arraycopy(spans, 0, copy, 0, i);
                            count = i;
                        }
                    }
                    else {
                        if (copy != null) {
                            copy[count] = span;
                            count++;
                        }
                    }
                }
                if (copy != null) {
                    let result = new Array(count);
                    System.arraycopy(copy, 0, result, 0, count);
                    return result;
                }
                else {
                    return spans;
                }
            }
            static packRangeInLong(start, end) {
                return [start, end];
            }
            static unpackRangeStartFromLong(range) {
                return range[0] || 0;
            }
            static unpackRangeEndFromLong(range) {
                return range[1] || 0;
            }
        }
        TextUtils.ALIGNMENT_SPAN = 1;
        TextUtils.FIRST_SPAN = TextUtils.ALIGNMENT_SPAN;
        TextUtils.FOREGROUND_COLOR_SPAN = 2;
        TextUtils.RELATIVE_SIZE_SPAN = 3;
        TextUtils.SCALE_X_SPAN = 4;
        TextUtils.STRIKETHROUGH_SPAN = 5;
        TextUtils.UNDERLINE_SPAN = 6;
        TextUtils.STYLE_SPAN = 7;
        TextUtils.BULLET_SPAN = 8;
        TextUtils.QUOTE_SPAN = 9;
        TextUtils.LEADING_MARGIN_SPAN = 10;
        TextUtils.URL_SPAN = 11;
        TextUtils.BACKGROUND_COLOR_SPAN = 12;
        TextUtils.TYPEFACE_SPAN = 13;
        TextUtils.SUPERSCRIPT_SPAN = 14;
        TextUtils.SUBSCRIPT_SPAN = 15;
        TextUtils.ABSOLUTE_SIZE_SPAN = 16;
        TextUtils.TEXT_APPEARANCE_SPAN = 17;
        TextUtils.ANNOTATION = 18;
        TextUtils.SUGGESTION_SPAN = 19;
        TextUtils.SPELL_CHECK_SPAN = 20;
        TextUtils.SUGGESTION_RANGE_SPAN = 21;
        TextUtils.EASY_EDIT_SPAN = 22;
        TextUtils.LOCALE_SPAN = 23;
        TextUtils.LAST_SPAN = TextUtils.LOCALE_SPAN;
        TextUtils.EMPTY_STRING_ARRAY = [];
        TextUtils.ZWNBS_CHAR = String.fromCodePoint(20);
        TextUtils.ARAB_SCRIPT_SUBTAG = "Arab";
        TextUtils.HEBR_SCRIPT_SUBTAG = "Hebr";
        text_7.TextUtils = TextUtils;
        (function (TextUtils) {
            (function (TruncateAt) {
                TruncateAt[TruncateAt["START"] = 0] = "START";
                TruncateAt[TruncateAt["MIDDLE"] = 1] = "MIDDLE";
                TruncateAt[TruncateAt["END"] = 2] = "END";
                TruncateAt[TruncateAt["MARQUEE"] = 3] = "MARQUEE";
                TruncateAt[TruncateAt["END_SMALL"] = 4] = "END_SMALL";
            })(TextUtils.TruncateAt || (TextUtils.TruncateAt = {}));
            var TruncateAt = TextUtils.TruncateAt;
        })(TextUtils = text_7.TextUtils || (text_7.TextUtils = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/Window.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/graphics/PixelFormat.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/content/Context.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/animation/Animation.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        class WindowManager {
            constructor(context) {
                this.mWindowsLayout = new WindowManager.Layout(context, this);
                let viewRootImpl = context.androidUI._viewRootImpl;
                let fakeAttachInfo = new View.AttachInfo(viewRootImpl, viewRootImpl.mHandler);
                fakeAttachInfo.mRootView = this.mWindowsLayout;
                this.mWindowsLayout.dispatchAttachedToWindow(fakeAttachInfo, 0);
                this.mWindowsLayout.mGroupFlags |= ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
            }
            getWindowsLayout() {
                return this.mWindowsLayout;
            }
            addWindow(window) {
                let wparams = window.getAttributes();
                if (!wparams) {
                    wparams = new WindowManager.LayoutParams();
                }
                if (!(wparams instanceof WindowManager.LayoutParams)) {
                    throw Error('can\'t addWindow, params must be WindowManager.LayoutParams : ' + wparams);
                }
                window.setContainer(this);
                let decorView = window.getDecorView();
                let type = wparams.type;
                this.mWindowsLayout.addView(decorView, wparams);
                decorView.dispatchAttachedToWindow(window.mAttachInfo, 0);
                if (wparams.isFocusable()) {
                    this.clearWindowFocus();
                    decorView.dispatchWindowFocusChanged(true);
                }
                if (decorView instanceof ViewGroup) {
                    decorView.setMotionEventSplittingEnabled(wparams.isSplitTouch());
                }
                let enterAnimation = window.getContext().androidUI.mActivityThread.getOverrideEnterAnimation();
                if (enterAnimation === undefined)
                    enterAnimation = wparams.enterAnimation;
                if (enterAnimation) {
                    decorView.startAnimation(enterAnimation);
                }
            }
            updateWindowLayout(window, params) {
                if (!(params instanceof WindowManager.LayoutParams)) {
                    throw Error('can\'t updateWindowLayout, params must be WindowManager.LayoutParams');
                }
                window.getDecorView().setLayoutParams(params);
            }
            removeWindow(window) {
                let decor = window.getDecorView();
                if (decor.getParent() == null)
                    return;
                if (decor.getParent() !== this.mWindowsLayout) {
                    console.error('removeWindow fail, don\'t has the window, decor belong to ', decor.getParent());
                    return;
                }
                let wparams = decor.getLayoutParams();
                let exitAnimation = window.getContext().androidUI.mActivityThread.getOverrideExitAnimation();
                if (exitAnimation === undefined)
                    exitAnimation = wparams.exitAnimation;
                if (exitAnimation) {
                    let t = this;
                    exitAnimation.setAnimationListener({
                        onAnimationStart(animation) {
                            decor.postOnAnimation({
                                run() {
                                    let group = decor.getParent();
                                    group.removeView(decor);
                                }
                            });
                        },
                        onAnimationEnd(animation) { },
                        onAnimationRepeat(animation) { }
                    });
                    decor.startAnimation(exitAnimation);
                }
                else {
                    decor.getParent().removeView(decor);
                }
            }
            clearWindowFocus() {
            }
        }
        view.WindowManager = WindowManager;
        (function (WindowManager) {
            class Layout extends android.widget.FrameLayout {
                constructor(context, windowManager) {
                    super(context);
                    this.mWindowManager = windowManager;
                }
                dispatchKeyEvent(event) {
                    const count = this.getChildCount();
                    for (let i = count - 1; i >= 0; i--) {
                        let child = this.getChildAt(i);
                        let wparams = child.getLayoutParams();
                        if (wparams.isFocusable() && child.dispatchKeyEvent(event)) {
                            return true;
                        }
                    }
                    return super.dispatchKeyEvent(event);
                }
                isTransformedTouchPointInView(x, y, child, outLocalPoint) {
                    let wparams = child.getLayoutParams();
                    if (wparams.isFocusable() && wparams.isTouchable()) {
                        return true;
                    }
                    return false;
                }
                onChildVisibilityChanged(child, oldVisibility, newVisibility) {
                    super.onChildVisibilityChanged(child, oldVisibility, newVisibility);
                    let wparams = child.getLayoutParams();
                    if (newVisibility === View.VISIBLE) {
                        let resumeAnimation = child.getContext().androidUI.mActivityThread.getOverrideResumeAnimation();
                        if (resumeAnimation === undefined)
                            resumeAnimation = wparams.resumeAnimation;
                        if (resumeAnimation) {
                            child.startAnimation(resumeAnimation);
                        }
                    }
                    else {
                        let hideAnimation = child.getContext().androidUI.mActivityThread.getOverrideHideAnimation();
                        if (hideAnimation === undefined)
                            hideAnimation = wparams.hideAnimation;
                        if (hideAnimation) {
                            child.startAnimation(hideAnimation);
                            child.drawAnimation(this, android.os.SystemClock.uptimeMillis(), hideAnimation);
                        }
                    }
                }
                tagName() {
                    return 'windowsGroup';
                }
            }
            WindowManager.Layout = Layout;
            class LayoutParams extends android.widget.FrameLayout.LayoutParams {
                constructor(_type = LayoutParams.TYPE_APPLICATION) {
                    super(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT);
                    this.x = 0;
                    this.y = 0;
                    this.type = 0;
                    this.flags = 0;
                    this.exitAnimation = android.R.anim.activity_close_exit;
                    this.enterAnimation = android.R.anim.activity_open_enter;
                    this.resumeAnimation = android.R.anim.activity_close_enter;
                    this.hideAnimation = android.R.anim.activity_open_exit;
                    this.dimAmount = 0;
                    this.mTitle = "";
                    this.type = _type;
                }
                setTitle(title) {
                    if (null == title)
                        title = "";
                    this.mTitle = title;
                }
                getTitle() {
                    return this.mTitle;
                }
                copyFrom(o) {
                    let changes = 0;
                    if (this.width != o.width) {
                        this.width = o.width;
                        changes |= LayoutParams.LAYOUT_CHANGED;
                    }
                    if (this.height != o.height) {
                        this.height = o.height;
                        changes |= LayoutParams.LAYOUT_CHANGED;
                    }
                    if (this.x != o.x) {
                        this.x = o.x;
                        changes |= LayoutParams.LAYOUT_CHANGED;
                    }
                    if (this.y != o.y) {
                        this.y = o.y;
                        changes |= LayoutParams.LAYOUT_CHANGED;
                    }
                    if (this.type != o.type) {
                        this.type = o.type;
                        changes |= LayoutParams.TYPE_CHANGED;
                    }
                    if (this.flags != o.flags) {
                        const diff = this.flags ^ o.flags;
                        this.flags = o.flags;
                        changes |= LayoutParams.FLAGS_CHANGED;
                    }
                    if (this.gravity != o.gravity) {
                        this.gravity = o.gravity;
                        changes |= LayoutParams.LAYOUT_CHANGED;
                    }
                    if (this.mTitle != (o.mTitle)) {
                        this.mTitle = o.mTitle;
                        changes |= LayoutParams.TITLE_CHANGED;
                    }
                    if (this.dimAmount != o.dimAmount) {
                        this.dimAmount = o.dimAmount;
                        changes |= LayoutParams.DIM_AMOUNT_CHANGED;
                    }
                    return changes;
                }
                get leftMargin() {
                    if ((this.gravity & Gravity.LEFT) != 0)
                        return super.leftMargin + this.x;
                    return super.leftMargin;
                }
                get topMargin() {
                    if ((this.gravity & Gravity.TOP) != 0)
                        return super.topMargin + this.y;
                    return super.topMargin;
                }
                get rightMargin() {
                    if ((this.gravity & Gravity.RIGHT) != 0)
                        return super.rightMargin + this.x;
                    return super.rightMargin;
                }
                get bottomMargin() {
                    if ((this.gravity & Gravity.BOTTOM) != 0)
                        return super.bottomMargin + this.y;
                    return super.bottomMargin;
                }
                set leftMargin(value) {
                    super.leftMargin = value;
                }
                set topMargin(value) {
                    super.topMargin = value;
                }
                set rightMargin(value) {
                    super.rightMargin = value;
                }
                set bottomMargin(value) {
                    super.bottomMargin = value;
                }
                isFocusable() {
                    return (this.flags & LayoutParams.FLAG_NOT_FOCUSABLE) == 0;
                }
                isTouchable() {
                    return (this.flags & LayoutParams.FLAG_NOT_TOUCHABLE) == 0;
                }
                isTouchModal() {
                    return (this.flags & LayoutParams.FLAG_NOT_TOUCH_MODAL) == 0;
                }
                isFloating() {
                    return (this.flags & LayoutParams.FLAG_FLOATING) != 0;
                }
                isSplitTouch() {
                    return (this.flags & LayoutParams.FLAG_SPLIT_TOUCH) != 0;
                }
                isWatchTouchOutside() {
                    return (this.flags & LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0;
                }
            }
            LayoutParams.FIRST_APPLICATION_WINDOW = 1;
            LayoutParams.TYPE_BASE_APPLICATION = 1;
            LayoutParams.TYPE_APPLICATION = 2;
            LayoutParams.TYPE_APPLICATION_STARTING = 3;
            LayoutParams.LAST_APPLICATION_WINDOW = 99;
            LayoutParams.FIRST_SUB_WINDOW = 1000;
            LayoutParams.TYPE_APPLICATION_PANEL = LayoutParams.FIRST_SUB_WINDOW;
            LayoutParams.TYPE_APPLICATION_MEDIA = LayoutParams.FIRST_SUB_WINDOW + 1;
            LayoutParams.TYPE_APPLICATION_SUB_PANEL = LayoutParams.FIRST_SUB_WINDOW + 2;
            LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG = LayoutParams.FIRST_SUB_WINDOW + 3;
            LayoutParams.TYPE_APPLICATION_MEDIA_OVERLAY = LayoutParams.FIRST_SUB_WINDOW + 4;
            LayoutParams.LAST_SUB_WINDOW = 1999;
            LayoutParams.FIRST_SYSTEM_WINDOW = 2000;
            LayoutParams.TYPE_STATUS_BAR = LayoutParams.FIRST_SYSTEM_WINDOW;
            LayoutParams.TYPE_SEARCH_BAR = LayoutParams.FIRST_SYSTEM_WINDOW + 1;
            LayoutParams.TYPE_PHONE = LayoutParams.FIRST_SYSTEM_WINDOW + 2;
            LayoutParams.TYPE_SYSTEM_ALERT = LayoutParams.FIRST_SYSTEM_WINDOW + 3;
            LayoutParams.TYPE_KEYGUARD = LayoutParams.FIRST_SYSTEM_WINDOW + 4;
            LayoutParams.TYPE_TOAST = LayoutParams.FIRST_SYSTEM_WINDOW + 5;
            LayoutParams.TYPE_SYSTEM_OVERLAY = LayoutParams.FIRST_SYSTEM_WINDOW + 6;
            LayoutParams.TYPE_PRIORITY_PHONE = LayoutParams.FIRST_SYSTEM_WINDOW + 7;
            LayoutParams.TYPE_SYSTEM_DIALOG = LayoutParams.FIRST_SYSTEM_WINDOW + 8;
            LayoutParams.LAST_SYSTEM_WINDOW = 2999;
            LayoutParams.FLAG_NOT_FOCUSABLE = 0x00000008;
            LayoutParams.FLAG_NOT_TOUCHABLE = 0x00000010;
            LayoutParams.FLAG_NOT_TOUCH_MODAL = 0x00000020;
            LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH = 0x00040000;
            LayoutParams.FLAG_SPLIT_TOUCH = 0x00800000;
            LayoutParams.FLAG_FLOATING = 0x40000000;
            LayoutParams.LAYOUT_CHANGED = 1 << 0;
            LayoutParams.TYPE_CHANGED = 1 << 1;
            LayoutParams.FLAGS_CHANGED = 1 << 2;
            LayoutParams.FORMAT_CHANGED = 1 << 3;
            LayoutParams.ANIMATION_CHANGED = 1 << 4;
            LayoutParams.DIM_AMOUNT_CHANGED = 1 << 5;
            LayoutParams.TITLE_CHANGED = 1 << 6;
            LayoutParams.ALPHA_CHANGED = 1 << 7;
            WindowManager.LayoutParams = LayoutParams;
        })(WindowManager = view.WindowManager || (view.WindowManager = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/view/animation/Animation.ts"/>
///<reference path="../../../android/view/animation/Transformation.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            var Animation = android.view.animation.Animation;
            class TranslateAnimation extends Animation {
                constructor(...args) {
                    super();
                    this.mFromXType = TranslateAnimation.ABSOLUTE;
                    this.mToXType = TranslateAnimation.ABSOLUTE;
                    this.mFromYType = TranslateAnimation.ABSOLUTE;
                    this.mToYType = TranslateAnimation.ABSOLUTE;
                    this.mFromXValue = 0.0;
                    this.mToXValue = 0.0;
                    this.mFromYValue = 0.0;
                    this.mToYValue = 0.0;
                    this.mFromXDelta = 0;
                    this.mToXDelta = 0;
                    this.mFromYDelta = 0;
                    this.mToYDelta = 0;
                    if (args.length === 4) {
                        this.mFromXValue = args[0];
                        this.mToXValue = args[1];
                        this.mFromYValue = args[2];
                        this.mToYValue = args[3];
                        this.mFromXType = TranslateAnimation.ABSOLUTE;
                        this.mToXType = TranslateAnimation.ABSOLUTE;
                        this.mFromYType = TranslateAnimation.ABSOLUTE;
                        this.mToYType = TranslateAnimation.ABSOLUTE;
                    }
                    else {
                        this.mFromXType = args[0];
                        this.mFromXValue = args[1];
                        this.mToXType = args[2];
                        this.mToXValue = args[3];
                        this.mFromYType = args[4];
                        this.mFromYValue = args[5];
                        this.mToYType = args[6];
                        this.mToYValue = args[7];
                    }
                }
                applyTransformation(interpolatedTime, t) {
                    let dx = this.mFromXDelta;
                    let dy = this.mFromYDelta;
                    if (this.mFromXDelta != this.mToXDelta) {
                        dx = this.mFromXDelta + ((this.mToXDelta - this.mFromXDelta) * interpolatedTime);
                    }
                    if (this.mFromYDelta != this.mToYDelta) {
                        dy = this.mFromYDelta + ((this.mToYDelta - this.mFromYDelta) * interpolatedTime);
                    }
                    t.getMatrix().setTranslate(dx, dy);
                }
                initialize(width, height, parentWidth, parentHeight) {
                    super.initialize(width, height, parentWidth, parentHeight);
                    this.mFromXDelta = this.resolveSize(this.mFromXType, this.mFromXValue, width, parentWidth);
                    this.mToXDelta = this.resolveSize(this.mToXType, this.mToXValue, width, parentWidth);
                    this.mFromYDelta = this.resolveSize(this.mFromYType, this.mFromYValue, height, parentHeight);
                    this.mToYDelta = this.resolveSize(this.mToYType, this.mToYValue, height, parentHeight);
                }
            }
            animation.TranslateAnimation = TranslateAnimation;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/view/animation/Animation.ts"/>
///<reference path="../../../android/view/animation/Transformation.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            var Animation = android.view.animation.Animation;
            class AlphaAnimation extends Animation {
                constructor(fromAlpha, toAlpha) {
                    super();
                    this.mFromAlpha = 0;
                    this.mToAlpha = 0;
                    this.mFromAlpha = fromAlpha;
                    this.mToAlpha = toAlpha;
                }
                applyTransformation(interpolatedTime, t) {
                    const alpha = this.mFromAlpha;
                    t.setAlpha(alpha + ((this.mToAlpha - alpha) * interpolatedTime));
                }
                willChangeTransformationMatrix() {
                    return false;
                }
                willChangeBounds() {
                    return false;
                }
                hasAlpha() {
                    return true;
                }
            }
            animation.AlphaAnimation = AlphaAnimation;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/content/res/Resources.ts"/>
///<reference path="../../../android/util/TypedValue.ts"/>
///<reference path="../../../android/view/animation/Animation.ts"/>
///<reference path="../../../android/view/animation/Transformation.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            var Animation = android.view.animation.Animation;
            class ScaleAnimation extends Animation {
                constructor(fromX, toX, fromY, toY, pivotXType = ScaleAnimation.ABSOLUTE, pivotXValue = 0, pivotYType = ScaleAnimation.ABSOLUTE, pivotYValue = 0) {
                    super();
                    this.mFromX = 0;
                    this.mToX = 0;
                    this.mFromY = 0;
                    this.mToY = 0;
                    this.mFromXData = 0;
                    this.mToXData = 0;
                    this.mFromYData = 0;
                    this.mToYData = 0;
                    this.mPivotXType = ScaleAnimation.ABSOLUTE;
                    this.mPivotYType = ScaleAnimation.ABSOLUTE;
                    this.mPivotXValue = 0.0;
                    this.mPivotYValue = 0.0;
                    this.mPivotX = 0;
                    this.mPivotY = 0;
                    this.mResources = null;
                    this.mFromX = fromX;
                    this.mToX = toX;
                    this.mFromY = fromY;
                    this.mToY = toY;
                    this.mPivotXValue = pivotXValue;
                    this.mPivotXType = pivotXType;
                    this.mPivotYValue = pivotYValue;
                    this.mPivotYType = pivotYType;
                    this.initializePivotPoint();
                }
                initializePivotPoint() {
                    if (this.mPivotXType == ScaleAnimation.ABSOLUTE) {
                        this.mPivotX = this.mPivotXValue;
                    }
                    if (this.mPivotYType == ScaleAnimation.ABSOLUTE) {
                        this.mPivotY = this.mPivotYValue;
                    }
                }
                applyTransformation(interpolatedTime, t) {
                    let sx = 1.0;
                    let sy = 1.0;
                    let scale = this.getScaleFactor();
                    if (this.mFromX != 1.0 || this.mToX != 1.0) {
                        sx = this.mFromX + ((this.mToX - this.mFromX) * interpolatedTime);
                    }
                    if (this.mFromY != 1.0 || this.mToY != 1.0) {
                        sy = this.mFromY + ((this.mToY - this.mFromY) * interpolatedTime);
                    }
                    if (this.mPivotX == 0 && this.mPivotY == 0) {
                        t.getMatrix().setScale(sx, sy);
                    }
                    else {
                        t.getMatrix().setScale(sx, sy, scale * this.mPivotX, scale * this.mPivotY);
                    }
                }
                initialize(width, height, parentWidth, parentHeight) {
                    super.initialize(width, height, parentWidth, parentHeight);
                    this.mPivotX = this.resolveSize(this.mPivotXType, this.mPivotXValue, width, parentWidth);
                    this.mPivotY = this.resolveSize(this.mPivotYType, this.mPivotYValue, height, parentHeight);
                }
            }
            animation.ScaleAnimation = ScaleAnimation;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/RectF.ts"/>
///<reference path="../../../java/util/ArrayList.ts"/>
///<reference path="../../../java/util/List.ts"/>
///<reference path="../../../java/lang/Long.ts"/>
///<reference path="../../../android/view/animation/Animation.ts"/>
///<reference path="../../../android/view/animation/Interpolator.ts"/>
///<reference path="../../../android/view/animation/Transformation.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            var ArrayList = java.util.ArrayList;
            var Long = java.lang.Long;
            var Animation = android.view.animation.Animation;
            var Transformation = android.view.animation.Transformation;
            class AnimationSet extends Animation {
                constructor(shareInterpolator = false) {
                    super();
                    this.mFlags = 0;
                    this.mAnimations = new ArrayList();
                    this.mTempTransformation = new Transformation();
                    this.mLastEnd = 0;
                    this.setFlag(AnimationSet.PROPERTY_SHARE_INTERPOLATOR_MASK, shareInterpolator);
                    this.init();
                }
                setFlag(mask, value) {
                    if (value) {
                        this.mFlags |= mask;
                    }
                    else {
                        this.mFlags &= ~mask;
                    }
                }
                init() {
                    this.mStartTime = 0;
                }
                setFillAfter(fillAfter) {
                    this.mFlags |= AnimationSet.PROPERTY_FILL_AFTER_MASK;
                    super.setFillAfter(fillAfter);
                }
                setFillBefore(fillBefore) {
                    this.mFlags |= AnimationSet.PROPERTY_FILL_BEFORE_MASK;
                    super.setFillBefore(fillBefore);
                }
                setRepeatMode(repeatMode) {
                    this.mFlags |= AnimationSet.PROPERTY_REPEAT_MODE_MASK;
                    super.setRepeatMode(repeatMode);
                }
                setStartOffset(startOffset) {
                    this.mFlags |= AnimationSet.PROPERTY_START_OFFSET_MASK;
                    super.setStartOffset(startOffset);
                }
                hasAlpha() {
                    if (this.mDirty) {
                        this.mDirty = this.mHasAlpha = false;
                        const count = this.mAnimations.size();
                        const animations = this.mAnimations;
                        for (let i = 0; i < count; i++) {
                            if (animations.get(i).hasAlpha()) {
                                this.mHasAlpha = true;
                                break;
                            }
                        }
                    }
                    return this.mHasAlpha;
                }
                setDuration(durationMillis) {
                    this.mFlags |= AnimationSet.PROPERTY_DURATION_MASK;
                    super.setDuration(durationMillis);
                    this.mLastEnd = this.mStartOffset + this.mDuration;
                }
                addAnimation(a) {
                    this.mAnimations.add(a);
                    let noMatrix = (this.mFlags & AnimationSet.PROPERTY_MORPH_MATRIX_MASK) == 0;
                    if (noMatrix && a.willChangeTransformationMatrix()) {
                        this.mFlags |= AnimationSet.PROPERTY_MORPH_MATRIX_MASK;
                    }
                    let changeBounds = (this.mFlags & AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK) == 0;
                    if (changeBounds && a.willChangeBounds()) {
                        this.mFlags |= AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK;
                    }
                    if ((this.mFlags & AnimationSet.PROPERTY_DURATION_MASK) == AnimationSet.PROPERTY_DURATION_MASK) {
                        this.mLastEnd = this.mStartOffset + this.mDuration;
                    }
                    else {
                        if (this.mAnimations.size() == 1) {
                            this.mDuration = a.getStartOffset() + a.getDuration();
                            this.mLastEnd = this.mStartOffset + this.mDuration;
                        }
                        else {
                            this.mLastEnd = Math.max(this.mLastEnd, a.getStartOffset() + a.getDuration());
                            this.mDuration = this.mLastEnd - this.mStartOffset;
                        }
                    }
                    this.mDirty = true;
                }
                setStartTime(startTimeMillis) {
                    super.setStartTime(startTimeMillis);
                    const count = this.mAnimations.size();
                    const animations = this.mAnimations;
                    for (let i = 0; i < count; i++) {
                        let a = animations.get(i);
                        a.setStartTime(startTimeMillis);
                    }
                }
                getStartTime() {
                    let startTime = Long.MAX_VALUE;
                    const count = this.mAnimations.size();
                    const animations = this.mAnimations;
                    for (let i = 0; i < count; i++) {
                        let a = animations.get(i);
                        startTime = Math.min(startTime, a.getStartTime());
                    }
                    return startTime;
                }
                restrictDuration(durationMillis) {
                    super.restrictDuration(durationMillis);
                    const animations = this.mAnimations;
                    let count = animations.size();
                    for (let i = 0; i < count; i++) {
                        animations.get(i).restrictDuration(durationMillis);
                    }
                }
                getDuration() {
                    const animations = this.mAnimations;
                    const count = animations.size();
                    let duration = 0;
                    let durationSet = (this.mFlags & AnimationSet.PROPERTY_DURATION_MASK) == AnimationSet.PROPERTY_DURATION_MASK;
                    if (durationSet) {
                        duration = this.mDuration;
                    }
                    else {
                        for (let i = 0; i < count; i++) {
                            duration = Math.max(duration, animations.get(i).getDuration());
                        }
                    }
                    return duration;
                }
                computeDurationHint() {
                    let duration = 0;
                    const count = this.mAnimations.size();
                    const animations = this.mAnimations;
                    for (let i = count - 1; i >= 0; --i) {
                        const d = animations.get(i).computeDurationHint();
                        if (d > duration)
                            duration = d;
                    }
                    return duration;
                }
                initializeInvalidateRegion(left, top, right, bottom) {
                    const region = this.mPreviousRegion;
                    region.set(left, top, right, bottom);
                    region.inset(-1.0, -1.0);
                    if (this.mFillBefore) {
                        const count = this.mAnimations.size();
                        const animations = this.mAnimations;
                        const temp = this.mTempTransformation;
                        const previousTransformation = this.mPreviousTransformation;
                        for (let i = count - 1; i >= 0; --i) {
                            const a = animations.get(i);
                            if (!a.isFillEnabled() || a.getFillBefore() || a.getStartOffset() == 0) {
                                temp.clear();
                                const interpolator = a.mInterpolator;
                                a.applyTransformation(interpolator != null ? interpolator.getInterpolation(0.0) : 0.0, temp);
                                previousTransformation.compose(temp);
                            }
                        }
                    }
                }
                getTransformation(currentTime, t) {
                    const count = this.mAnimations.size();
                    const animations = this.mAnimations;
                    const temp = this.mTempTransformation;
                    let more = false;
                    let started = false;
                    let ended = true;
                    t.clear();
                    for (let i = count - 1; i >= 0; --i) {
                        const a = animations.get(i);
                        temp.clear();
                        more = a.getTransformation(currentTime, temp, this.getScaleFactor()) || more;
                        t.compose(temp);
                        started = started || a.hasStarted();
                        ended = a.hasEnded() && ended;
                    }
                    if (started && !this.mStarted) {
                        if (this.mListener != null) {
                            this.mListener.onAnimationStart(this);
                        }
                        this.mStarted = true;
                    }
                    if (ended != this.mEnded) {
                        if (this.mListener != null) {
                            this.mListener.onAnimationEnd(this);
                        }
                        this.mEnded = ended;
                    }
                    return more;
                }
                scaleCurrentDuration(scale) {
                    const animations = this.mAnimations;
                    let count = animations.size();
                    for (let i = 0; i < count; i++) {
                        animations.get(i).scaleCurrentDuration(scale);
                    }
                }
                initialize(width, height, parentWidth, parentHeight) {
                    super.initialize(width, height, parentWidth, parentHeight);
                    let durationSet = (this.mFlags & AnimationSet.PROPERTY_DURATION_MASK) == AnimationSet.PROPERTY_DURATION_MASK;
                    let fillAfterSet = (this.mFlags & AnimationSet.PROPERTY_FILL_AFTER_MASK) == AnimationSet.PROPERTY_FILL_AFTER_MASK;
                    let fillBeforeSet = (this.mFlags & AnimationSet.PROPERTY_FILL_BEFORE_MASK) == AnimationSet.PROPERTY_FILL_BEFORE_MASK;
                    let repeatModeSet = (this.mFlags & AnimationSet.PROPERTY_REPEAT_MODE_MASK) == AnimationSet.PROPERTY_REPEAT_MODE_MASK;
                    let shareInterpolator = (this.mFlags & AnimationSet.PROPERTY_SHARE_INTERPOLATOR_MASK) == AnimationSet.PROPERTY_SHARE_INTERPOLATOR_MASK;
                    let startOffsetSet = (this.mFlags & AnimationSet.PROPERTY_START_OFFSET_MASK) == AnimationSet.PROPERTY_START_OFFSET_MASK;
                    if (shareInterpolator) {
                        this.ensureInterpolator();
                    }
                    const children = this.mAnimations;
                    const count = children.size();
                    const duration = this.mDuration;
                    const fillAfter = this.mFillAfter;
                    const fillBefore = this.mFillBefore;
                    const repeatMode = this.mRepeatMode;
                    const interpolator = this.mInterpolator;
                    const startOffset = this.mStartOffset;
                    let storedOffsets = this.mStoredOffsets;
                    if (startOffsetSet) {
                        if (storedOffsets == null || storedOffsets.length != count) {
                            storedOffsets = this.mStoredOffsets = new Array(count);
                        }
                    }
                    else if (storedOffsets != null) {
                        storedOffsets = this.mStoredOffsets = null;
                    }
                    for (let i = 0; i < count; i++) {
                        let a = children.get(i);
                        if (durationSet) {
                            a.setDuration(duration);
                        }
                        if (fillAfterSet) {
                            a.setFillAfter(fillAfter);
                        }
                        if (fillBeforeSet) {
                            a.setFillBefore(fillBefore);
                        }
                        if (repeatModeSet) {
                            a.setRepeatMode(repeatMode);
                        }
                        if (shareInterpolator) {
                            a.setInterpolator(interpolator);
                        }
                        if (startOffsetSet) {
                            let offset = a.getStartOffset();
                            a.setStartOffset(offset + startOffset);
                            storedOffsets[i] = offset;
                        }
                        a.initialize(width, height, parentWidth, parentHeight);
                    }
                }
                reset() {
                    super.reset();
                    this.restoreChildrenStartOffset();
                }
                restoreChildrenStartOffset() {
                    const offsets = this.mStoredOffsets;
                    if (offsets == null)
                        return;
                    const children = this.mAnimations;
                    const count = children.size();
                    for (let i = 0; i < count; i++) {
                        children.get(i).setStartOffset(offsets[i]);
                    }
                }
                getAnimations() {
                    return this.mAnimations;
                }
                willChangeTransformationMatrix() {
                    return (this.mFlags & AnimationSet.PROPERTY_MORPH_MATRIX_MASK) == AnimationSet.PROPERTY_MORPH_MATRIX_MASK;
                }
                willChangeBounds() {
                    return (this.mFlags & AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK) == AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK;
                }
            }
            AnimationSet.PROPERTY_FILL_AFTER_MASK = 0x1;
            AnimationSet.PROPERTY_FILL_BEFORE_MASK = 0x2;
            AnimationSet.PROPERTY_REPEAT_MODE_MASK = 0x4;
            AnimationSet.PROPERTY_START_OFFSET_MASK = 0x8;
            AnimationSet.PROPERTY_SHARE_INTERPOLATOR_MASK = 0x10;
            AnimationSet.PROPERTY_DURATION_MASK = 0x20;
            AnimationSet.PROPERTY_MORPH_MATRIX_MASK = 0x40;
            AnimationSet.PROPERTY_CHANGE_BOUNDS_MASK = 0x80;
            animation.AnimationSet = AnimationSet;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class AccelerateInterpolator {
                constructor(factor = 1) {
                    this.mFactor = factor;
                    this.mDoubleFactor = factor * 2;
                }
                getInterpolation(input) {
                    if (this.mFactor == 1.0) {
                        return input * input;
                    }
                    else {
                        return Math.pow(input, this.mDoubleFactor);
                    }
                }
            }
            animation.AccelerateInterpolator = AccelerateInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class AnticipateInterpolator {
                constructor(tension = 2) {
                    this.mTension = tension;
                }
                getInterpolation(t) {
                    return t * t * ((this.mTension + 1) * t - this.mTension);
                }
            }
            animation.AnticipateInterpolator = AnticipateInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class AnticipateOvershootInterpolator {
                constructor(tension = 2, extraTension = 1.5) {
                    this.mTension = tension * extraTension;
                }
                static a(t, s) {
                    return t * t * ((s + 1) * t - s);
                }
                static o(t, s) {
                    return t * t * ((s + 1) * t + s);
                }
                getInterpolation(t) {
                    if (t < 0.5)
                        return 0.5 * AnticipateOvershootInterpolator.a(t * 2.0, this.mTension);
                    else
                        return 0.5 * (AnticipateOvershootInterpolator.o(t * 2.0 - 2.0, this.mTension) + 2.0);
                }
            }
            animation.AnticipateOvershootInterpolator = AnticipateOvershootInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class BounceInterpolator {
                static bounce(t) {
                    return t * t * 8.0;
                }
                getInterpolation(t) {
                    t *= 1.1226;
                    if (t < 0.3535)
                        return BounceInterpolator.bounce(t);
                    else if (t < 0.7408)
                        return BounceInterpolator.bounce(t - 0.54719) + 0.7;
                    else if (t < 0.9644)
                        return BounceInterpolator.bounce(t - 0.8526) + 0.9;
                    else
                        return BounceInterpolator.bounce(t - 1.0435) + 0.95;
                }
            }
            animation.BounceInterpolator = BounceInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class CycleInterpolator {
                constructor(mCycles) {
                    this.mCycles = mCycles;
                }
                getInterpolation(input) {
                    return (Math.sin(2 * this.mCycles * Math.PI * input));
                }
            }
            animation.CycleInterpolator = CycleInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class OvershootInterpolator {
                constructor(tension = 2) {
                    this.mTension = tension;
                }
                getInterpolation(t) {
                    t -= 1.0;
                    return t * t * ((this.mTension + 1) * t + this.mTension) + 1.0;
                }
            }
            animation.OvershootInterpolator = OvershootInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 16/1/10.
 */
///<reference path="../view/animation/Interpolator"/>
///<reference path="../view/animation/AccelerateDecelerateInterpolator"/>
///<reference path="../view/animation/AccelerateInterpolator"/>
///<reference path="../view/animation/AnticipateInterpolator"/>
///<reference path="../view/animation/AnticipateOvershootInterpolator"/>
///<reference path="../view/animation/BounceInterpolator"/>
///<reference path="../view/animation/CycleInterpolator"/>
///<reference path="../view/animation/DecelerateInterpolator"/>
///<reference path="../view/animation/LinearInterpolator"/>
///<reference path="../view/animation/OvershootInterpolator"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var AccelerateDecelerateInterpolator = android.view.animation.AccelerateDecelerateInterpolator;
        var AccelerateInterpolator = android.view.animation.AccelerateInterpolator;
        var AnticipateInterpolator = android.view.animation.AnticipateInterpolator;
        var AnticipateOvershootInterpolator = android.view.animation.AnticipateOvershootInterpolator;
        var BounceInterpolator = android.view.animation.BounceInterpolator;
        var CycleInterpolator = android.view.animation.CycleInterpolator;
        var DecelerateInterpolator = android.view.animation.DecelerateInterpolator;
        var LinearInterpolator = android.view.animation.LinearInterpolator;
        var OvershootInterpolator = android.view.animation.OvershootInterpolator;
        class interpolator {
        }
        interpolator.accelerate_cubic = new AccelerateInterpolator(1.5);
        interpolator.accelerate_decelerate = new AccelerateDecelerateInterpolator();
        interpolator.accelerate_quad = new AccelerateInterpolator();
        interpolator.accelerate_quint = new AccelerateInterpolator(2.5);
        interpolator.anticipate_overshoot = new AnticipateOvershootInterpolator();
        interpolator.anticipate = new AnticipateInterpolator();
        interpolator.bounce = new BounceInterpolator();
        interpolator.cycle = new CycleInterpolator(1);
        interpolator.decelerate_cubic = new DecelerateInterpolator(1.5);
        interpolator.decelerate_quad = new DecelerateInterpolator();
        interpolator.decelerate_quint = new DecelerateInterpolator(2.5);
        interpolator.linear = new LinearInterpolator();
        interpolator.overshoot = new OvershootInterpolator();
        R.interpolator = interpolator;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 16/1/10.
 */
///<reference path="../view/animation/Animation.ts"/>
///<reference path="../view/animation/AlphaAnimation.ts"/>
///<reference path="../view/animation/TranslateAnimation.ts"/>
///<reference path="../view/animation/ScaleAnimation.ts"/>
///<reference path="../view/animation/AnimationSet.ts"/>
///<reference path="interpolator.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var Animation = android.view.animation.Animation;
        var AlphaAnimation = android.view.animation.AlphaAnimation;
        var TranslateAnimation = android.view.animation.TranslateAnimation;
        var ScaleAnimation = android.view.animation.ScaleAnimation;
        var AnimationSet = android.view.animation.AnimationSet;
        class anim {
            static get activity_close_enter() {
                let alpha = new AlphaAnimation(1, 1);
                alpha.setDuration(300);
                alpha.setFillBefore(true);
                alpha.setFillEnabled(true);
                alpha.setFillAfter(true);
                return alpha;
            }
            static get activity_close_exit() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(1, 0);
                alpha.setDuration(300);
                alpha.setFillBefore(true);
                alpha.setFillEnabled(true);
                alpha.setFillAfter(true);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(1, 0.8, 1, 0.8, Animation.RELATIVE_TO_PARENT, 0.5, Animation.RELATIVE_TO_PARENT, 0.5);
                scale.setDuration(300);
                scale.setFillBefore(true);
                scale.setFillEnabled(true);
                scale.setFillAfter(true);
                scale.setInterpolator(R.interpolator.decelerate_cubic);
                animSet.addAnimation(alpha);
                animSet.addAnimation(scale);
                return animSet;
            }
            static get activity_open_enter() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(0, 1);
                alpha.setDuration(300);
                alpha.setFillBefore(false);
                alpha.setFillEnabled(true);
                alpha.setFillAfter(true);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(0.8, 1, 0.8, 1, Animation.RELATIVE_TO_PARENT, 0.5, Animation.RELATIVE_TO_PARENT, 0.5);
                scale.setDuration(300);
                scale.setFillBefore(false);
                scale.setFillEnabled(true);
                scale.setFillAfter(true);
                scale.setInterpolator(R.interpolator.decelerate_cubic);
                animSet.addAnimation(alpha);
                animSet.addAnimation(scale);
                return animSet;
            }
            static get activity_open_exit() {
                let alpha = new AlphaAnimation(1, 0);
                alpha.setDuration(300);
                alpha.setFillBefore(false);
                alpha.setFillEnabled(true);
                alpha.setFillAfter(true);
                alpha.setInterpolator(R.interpolator.decelerate_quint);
                return alpha;
            }
            static get activity_close_enter_ios() {
                let anim = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, -0.25, Animation.RELATIVE_TO_PARENT, 0, 0, 0, 0, 0);
                anim.setDuration(300);
                return anim;
            }
            static get activity_close_exit_ios() {
                let anim = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, 0, Animation.RELATIVE_TO_PARENT, 1, 0, 0, 0, 0);
                anim.setDuration(300);
                return anim;
            }
            static get activity_open_enter_ios() {
                let anim = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, 1, Animation.RELATIVE_TO_PARENT, 0, 0, 0, 0, 0);
                anim.setDuration(300);
                return anim;
            }
            static get activity_open_exit_ios() {
                let anim = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, 0, Animation.RELATIVE_TO_PARENT, -0.25, 0, 0, 0, 0);
                anim.setDuration(300);
                return anim;
            }
            static get dialog_enter() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(0, 1);
                alpha.setDuration(150);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(0.9, 1, 0.9, 1, Animation.RELATIVE_TO_PARENT, 0.5, Animation.RELATIVE_TO_PARENT, 0.5);
                scale.setDuration(220);
                scale.setInterpolator(R.interpolator.decelerate_quint);
                animSet.addAnimation(scale);
                animSet.addAnimation(alpha);
                return animSet;
            }
            static get dialog_exit() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(1, 0);
                alpha.setDuration(150);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(1, 0.9, 1, 0.9, Animation.RELATIVE_TO_PARENT, 0.5, Animation.RELATIVE_TO_PARENT, 0.5);
                scale.setDuration(220);
                scale.setInterpolator(R.interpolator.decelerate_quint);
                animSet.addAnimation(scale);
                animSet.addAnimation(alpha);
                return animSet;
            }
            static get fade_in() {
                let alpha = new AlphaAnimation(0, 1);
                alpha.setDuration(500);
                alpha.setInterpolator(R.interpolator.decelerate_quad);
                return alpha;
            }
            static get fade_out() {
                let alpha = new AlphaAnimation(1, 0);
                alpha.setDuration(400);
                alpha.setInterpolator(R.interpolator.accelerate_quad);
                return alpha;
            }
            static get toast_enter() {
                let alpha = new AlphaAnimation(0, 1);
                alpha.setDuration(500);
                alpha.setInterpolator(R.interpolator.decelerate_quad);
                return alpha;
            }
            static get toast_exit() {
                let alpha = new AlphaAnimation(1, 0);
                alpha.setDuration(500);
                alpha.setInterpolator(R.interpolator.accelerate_quad);
                return alpha;
            }
            static get grow_fade_in() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(0, 1);
                alpha.setDuration(150);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(0.9, 1, 0.9, 1, Animation.RELATIVE_TO_SELF, 0.5, Animation.RELATIVE_TO_SELF, 0);
                scale.setDuration(220);
                scale.setInterpolator(R.interpolator.decelerate_quint);
                animSet.addAnimation(scale);
                animSet.addAnimation(alpha);
                return animSet;
            }
            static get grow_fade_in_center() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(0, 1);
                alpha.setDuration(150);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(0.9, 1, 0.9, 1, Animation.RELATIVE_TO_SELF, 0.5, Animation.RELATIVE_TO_SELF, 0.5);
                scale.setDuration(220);
                scale.setInterpolator(R.interpolator.decelerate_quint);
                animSet.addAnimation(scale);
                animSet.addAnimation(alpha);
                return animSet;
            }
            static get grow_fade_in_from_bottom() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(0, 1);
                alpha.setDuration(150);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(0.9, 1, 0.9, 1, Animation.RELATIVE_TO_SELF, 0.5, Animation.RELATIVE_TO_SELF, 1);
                scale.setDuration(220);
                scale.setInterpolator(R.interpolator.decelerate_quint);
                animSet.addAnimation(scale);
                animSet.addAnimation(alpha);
                return animSet;
            }
            static get shrink_fade_out() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(1, 0);
                alpha.setDuration(150);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(1, 0.9, 1, 0.9, Animation.RELATIVE_TO_SELF, 0.5, Animation.RELATIVE_TO_SELF, 0);
                scale.setDuration(220);
                scale.setInterpolator(R.interpolator.decelerate_quint);
                animSet.addAnimation(scale);
                animSet.addAnimation(alpha);
                return animSet;
            }
            static get shrink_fade_out_center() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(1, 0);
                alpha.setDuration(150);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(1, 0.9, 1, 0.9, Animation.RELATIVE_TO_SELF, 0.5, Animation.RELATIVE_TO_SELF, 0.5);
                scale.setDuration(220);
                scale.setInterpolator(R.interpolator.decelerate_quint);
                animSet.addAnimation(scale);
                animSet.addAnimation(alpha);
                return animSet;
            }
            static get shrink_fade_out_from_bottom() {
                let animSet = new AnimationSet();
                let alpha = new AlphaAnimation(1, 0);
                alpha.setDuration(150);
                alpha.setInterpolator(R.interpolator.decelerate_cubic);
                let scale = new ScaleAnimation(1, 0.9, 1, 0.9, Animation.RELATIVE_TO_SELF, 0.5, Animation.RELATIVE_TO_SELF, 1);
                scale.setDuration(220);
                scale.setInterpolator(R.interpolator.decelerate_quint);
                animSet.addAnimation(scale);
                animSet.addAnimation(alpha);
                return animSet;
            }
        }
        R.anim = anim;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/WindowManager.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/graphics/PixelFormat.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/LayoutInflater.ts"/>
///<reference path="../../android/view/Surface.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/animation/Animation.ts"/>
///<reference path="../../android/view/animation/TranslateAnimation.ts"/>
///<reference path="../../android/content/Context.ts"/>
///<reference path="../../android/os/SystemClock.ts"/>
///<reference path="../../android/R/anim.ts"/>
var android;
(function (android) {
    var view;
    (function (view_6) {
        var MotionEvent = android.view.MotionEvent;
        var View = android.view.View;
        var ViewConfiguration = android.view.ViewConfiguration;
        var WindowManager = android.view.WindowManager;
        var FrameLayout = android.widget.FrameLayout;
        class Window {
            constructor(context) {
                this.mIsActive = false;
                this.mCloseOnTouchOutside = false;
                this.mSetCloseOnTouchOutside = false;
                this.mWindowAttributes = new WindowManager.LayoutParams();
                this.mContext = context;
                this.initDecorView();
                this.initAttachInfo();
            }
            initDecorView() {
                this.mDecor = new DecorView(this);
                this.mContentParent = new FrameLayout(this.mContext);
                this.mContentParent.setId(android.R.id.content);
                this.mDecor.addView(this.mContentParent, -1, -1);
            }
            initAttachInfo() {
                let viewRootImpl = this.mContext.androidUI._viewRootImpl;
                this.mAttachInfo = new View.AttachInfo(viewRootImpl, viewRootImpl.mHandler);
                this.mAttachInfo.mRootView = this.mDecor;
                this.mAttachInfo.mHasWindowFocus = true;
            }
            getContext() {
                return this.mContext;
            }
            setContainer(container) {
                this.mContainer = container;
            }
            getContainer() {
                return this.mContainer;
            }
            destroy() {
                this.mDestroyed = true;
            }
            isDestroyed() {
                return this.mDestroyed;
            }
            setChildWindowManager(wm) {
                //this.mAppToken = appToken;
                //this.mAppName = appName;
                //this.mHardwareAccelerated = hardwareAccelerated;// || SystemProperties.getBoolean(Window.PROPERTY_HARDWARE_UI, false);
                //if (wm == null) {
                //    wm = <WindowManager> this.mContext.getSystemService(Context.WINDOW_SERVICE);
                //}
                //this.mWindowManager = (<WindowManagerImpl> wm).createLocalWindowManager(this);
                if (this.mChildWindowManager) {
                    this.mDecor.removeView(this.mChildWindowManager.getWindowsLayout());
                }
                this.mChildWindowManager = wm;
            }
            getChildWindowManager() {
                if (!this.mChildWindowManager) {
                    this.mChildWindowManager = new WindowManager(this.mContext);
                    this.mDecor.addView(this.mChildWindowManager.getWindowsLayout(), -1, -1);
                }
                return this.mChildWindowManager;
            }
            setCallback(callback) {
                this.mCallback = callback;
            }
            getCallback() {
                return this.mCallback;
            }
            setFloating(isFloating) {
                const attrs = this.getAttributes();
                if (isFloating === attrs.isFloating())
                    return;
                if (isFloating)
                    attrs.flags |= WindowManager.LayoutParams.FLAG_FLOATING;
                else
                    attrs.flags &= ~WindowManager.LayoutParams.FLAG_FLOATING;
                if (this.mCallback != null) {
                    this.mCallback.onWindowAttributesChanged(attrs);
                }
            }
            isFloating() {
                return this.mWindowAttributes.isFloating();
            }
            setLayout(width, height) {
                const attrs = this.getAttributes();
                attrs.width = width;
                attrs.height = height;
                if (this.mCallback != null) {
                    this.mCallback.onWindowAttributesChanged(attrs);
                }
            }
            setGravity(gravity) {
                const attrs = this.getAttributes();
                attrs.gravity = gravity;
                if (this.mCallback != null) {
                    this.mCallback.onWindowAttributesChanged(attrs);
                }
            }
            setType(type) {
                const attrs = this.getAttributes();
                attrs.type = type;
                if (this.mCallback != null) {
                    this.mCallback.onWindowAttributesChanged(attrs);
                }
            }
            setWindowAnimations(enterAnimation, exitAnimation, resumeAnimation = this.mWindowAttributes.resumeAnimation, hideAnimation = this.mWindowAttributes.hideAnimation) {
                const attrs = this.getAttributes();
                attrs.enterAnimation = enterAnimation;
                attrs.exitAnimation = exitAnimation;
                attrs.resumeAnimation = resumeAnimation;
                attrs.hideAnimation = hideAnimation;
                if (this.mCallback != null) {
                    this.mCallback.onWindowAttributesChanged(attrs);
                }
            }
            addFlags(flags) {
                this.setFlags(flags, flags);
            }
            clearFlags(flags) {
                this.setFlags(0, flags);
            }
            setFlags(flags, mask) {
                const attrs = this.getAttributes();
                attrs.flags = (attrs.flags & ~mask) | (flags & mask);
                if (this.mCallback != null) {
                    this.mCallback.onWindowAttributesChanged(attrs);
                }
            }
            setDimAmount(amount) {
                const attrs = this.getAttributes();
                attrs.dimAmount = amount;
                if (this.mCallback != null) {
                    this.mCallback.onWindowAttributesChanged(attrs);
                }
            }
            setAttributes(a) {
                this.mWindowAttributes.copyFrom(a);
                if (this.mCallback != null) {
                    this.mCallback.onWindowAttributesChanged(this.mWindowAttributes);
                }
            }
            getAttributes() {
                return this.mWindowAttributes;
            }
            setCloseOnTouchOutside(close) {
                this.mCloseOnTouchOutside = close;
                this.mSetCloseOnTouchOutside = true;
            }
            setCloseOnTouchOutsideIfNotSet(close) {
                if (!this.mSetCloseOnTouchOutside) {
                    this.mCloseOnTouchOutside = close;
                    this.mSetCloseOnTouchOutside = true;
                }
            }
            shouldCloseOnTouch(context, event) {
                if (this.mCloseOnTouchOutside && event.getAction() == MotionEvent.ACTION_DOWN && this.isOutOfBounds(context, event) && this.peekDecorView() != null) {
                    return true;
                }
                return false;
            }
            isOutOfBounds(context, event) {
                const x = Math.floor(event.getX());
                const y = Math.floor(event.getY());
                const slop = ViewConfiguration.get(context).getScaledWindowTouchSlop();
                const decorView = this.getDecorView();
                return (x < -slop) || (y < -slop) || (x > (decorView.getWidth() + slop)) || (y > (decorView.getHeight() + slop));
            }
            makeActive() {
                if (this.mContainer != null) {
                    if (this.mContainer.mActiveWindow != null) {
                        this.mContainer.mActiveWindow.mIsActive = false;
                    }
                    this.mContainer.mActiveWindow = this;
                }
                this.mIsActive = true;
                this.onActive();
            }
            isActive() {
                return this.mIsActive;
            }
            findViewById(id) {
                return this.getDecorView().findViewById(id);
            }
            setContentView(view, params) {
                this.mContentParent.removeAllViews();
                this.addContentView(view, params);
            }
            addContentView(view, params) {
                if (params) {
                    this.mContentParent.addView(view, params);
                }
                else {
                    this.mContentParent.addView(view);
                }
                let cb = this.getCallback();
                if (cb != null && !this.isDestroyed()) {
                    cb.onContentChanged();
                }
            }
            getContentParent() {
                return this.mContentParent;
            }
            getCurrentFocus() {
                return this.mDecor != null ? this.mDecor.findFocus() : null;
            }
            getLayoutInflater() {
                return this.mContext.getLayoutInflater();
            }
            setTitle(title) {
                this.mDecor.bindElement.setAttribute('title', title);
                this.getAttributes().setTitle(title);
            }
            setBackgroundDrawable(drawable) {
                if (this.mDecor != null) {
                    this.mDecor.setBackground(drawable);
                }
            }
            setBackgroundColor(color) {
                if (this.mDecor != null) {
                    this.mDecor.setBackgroundColor(color);
                }
            }
            takeKeyEvents(_get) {
                this.mDecor.setFocusable(_get);
            }
            superDispatchKeyEvent(event) {
                return this.mDecor.superDispatchKeyEvent(event);
            }
            superDispatchTouchEvent(event) {
                return this.mDecor.superDispatchTouchEvent(event);
            }
            superDispatchGenericMotionEvent(event) {
                return this.mDecor.superDispatchGenericMotionEvent(event);
            }
            getDecorView() {
                return this.mDecor;
            }
            peekDecorView() {
                return this.mDecor;
            }
            onActive() {
            }
        }
        view_6.Window = Window;
        class DecorView extends FrameLayout {
            constructor(window) {
                super(window.mContext);
                this.Window_this = window;
                this.bindElement.classList.add(window.mContext.constructor.name);
                this.setBackgroundColor(android.graphics.Color.WHITE);
            }
            drawFromParent(canvas, parent, drawingTime) {
                let windowAnimation = this.getAnimation();
                let wparams = this.getLayoutParams();
                let shadowAlpha = wparams.dimAmount * 255;
                if (windowAnimation != null && shadowAlpha) {
                    const duration = windowAnimation.getDuration();
                    let startTime = windowAnimation.getStartTime();
                    if (startTime < 0)
                        startTime = drawingTime;
                    let startOffset = windowAnimation.getStartOffset();
                    let normalizedTime;
                    if (duration != 0) {
                        normalizedTime = (drawingTime - (startTime + startOffset)) / duration;
                        normalizedTime = Math.max(Math.min(normalizedTime, 1.0), 0.0);
                    }
                    else {
                        normalizedTime = drawingTime < startTime ? 0.0 : 1.0;
                    }
                    const interpolatedTime = windowAnimation.getInterpolator().getInterpolation(normalizedTime);
                    if (windowAnimation === wparams.exitAnimation) {
                        shadowAlpha = shadowAlpha * (1 - interpolatedTime);
                        if (!windowAnimation.hasEnded())
                            parent.invalidate();
                    }
                    else if (windowAnimation === wparams.enterAnimation) {
                        shadowAlpha = shadowAlpha * interpolatedTime;
                        if (!windowAnimation.hasEnded())
                            parent.invalidate();
                    }
                }
                if ((windowAnimation != null || wparams.isFloating()) && shadowAlpha) {
                    canvas.drawColor(android.graphics.Color.argb(shadowAlpha, 0, 0, 0));
                }
                return super.drawFromParent(canvas, parent, drawingTime);
            }
            tagName() {
                return 'Window';
            }
            dispatchKeyEvent(event) {
                const count = this.getChildCount();
                for (let i = count - 1; i >= 0; i--) {
                    let child = this.getChildAt(i);
                    if (child instanceof WindowManager.Layout && child.dispatchKeyEvent(event)) {
                        return true;
                    }
                }
                const action = event.getAction();
                if (!this.Window_this.isDestroyed()) {
                    const cb = this.Window_this.getCallback();
                    const handled = cb != null ? cb.dispatchKeyEvent(event) : super.dispatchKeyEvent(event);
                    if (handled) {
                        return true;
                    }
                }
                return super.dispatchKeyEvent(event);
            }
            dispatchTouchEvent(ev) {
                let wparams = this.getLayoutParams();
                const cb = this.Window_this.getCallback();
                let outside = this.Window_this.isOutOfBounds(this.getContext(), ev);
                if (outside && !wparams.isTouchModal()) {
                    if (wparams.isWatchTouchOutside() && ev.getAction() == android.view.MotionEvent.ACTION_DOWN) {
                        let action = ev.getAction();
                        ev.setAction(android.view.MotionEvent.ACTION_OUTSIDE);
                        if (cb != null && !this.Window_this.isDestroyed()) {
                            cb.dispatchTouchEvent(ev);
                        }
                        else {
                            super.dispatchTouchEvent(ev);
                        }
                        ev.setAction(action);
                    }
                    return false;
                }
                cb != null && !this.Window_this.isDestroyed() ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);
                return true;
            }
            dispatchGenericMotionEvent(ev) {
                const cb = this.Window_this.getCallback();
                return cb != null && !this.Window_this.isDestroyed() ? cb.dispatchGenericMotionEvent(ev) : super.dispatchGenericMotionEvent(ev);
            }
            superDispatchKeyEvent(event) {
                return super.dispatchKeyEvent(event);
            }
            superDispatchTouchEvent(event) {
                return super.dispatchTouchEvent(event);
            }
            superDispatchGenericMotionEvent(event) {
                return super.dispatchGenericMotionEvent(event);
            }
            onTouchEvent(event) {
                return this.onInterceptTouchEvent(event);
            }
            onVisibilityChanged(changedView, visibility) {
                this.Window_this.mAttachInfo.mWindowVisibility = visibility;
                this.dispatchWindowVisibilityChanged(visibility);
                super.onVisibilityChanged(changedView, visibility);
            }
            onWindowFocusChanged(hasWindowFocus) {
                this.Window_this.mAttachInfo.mHasWindowFocus = hasWindowFocus;
                super.onWindowFocusChanged(hasWindowFocus);
                const cb = this.Window_this.getCallback();
                if (cb != null && !this.Window_this.isDestroyed()) {
                    cb.onWindowFocusChanged(hasWindowFocus);
                }
            }
            onAttachedToWindow() {
                this.Window_this.mAttachInfo.mWindowVisibility = this.getVisibility();
                super.onAttachedToWindow();
                const cb = this.Window_this.getCallback();
                if (cb != null && !this.Window_this.isDestroyed()) {
                    cb.onAttachedToWindow();
                }
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                const cb = this.Window_this.getCallback();
                if (cb != null && !this.Window_this.isDestroyed()) {
                    cb.onDetachedFromWindow();
                }
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/11.
 */
///<reference path="../view/Window.ts"/>
///<reference path="../view/WindowManager.ts"/>
///<reference path="../content/Context.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../view/ViewRootImpl.ts"/>
///<reference path="../view/KeyEvent.ts"/>
///<reference path="../view/animation/Animation.ts"/>
///<reference path="../widget/FrameLayout.ts"/>
///<reference path="../view/MotionEvent.ts"/>
///<reference path="../view/LayoutInflater.ts"/>
///<reference path="../os/Bundle.ts"/>
///<reference path="../os/Handler.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../content/Intent.ts"/>
///<reference path="../../androidui/AndroidUI.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
var android;
(function (android) {
    var app;
    (function (app) {
        var View = android.view.View;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var Window = android.view.Window;
        var WindowManager = android.view.WindowManager;
        var Log = android.util.Log;
        var Context = android.content.Context;
        var Intent = android.content.Intent;
        class Activity extends Context {
            constructor(androidUI) {
                super(androidUI);
                this.mWindowAdded = false;
                this.mVisibleFromClient = true;
                this.mResultCode = Activity.RESULT_CANCELED;
                this.mResultData = null;
                this.mWindow = new Window(this);
                this.mWindow.setWindowAnimations(android.R.anim.activity_open_enter_ios, android.R.anim.activity_close_exit_ios, android.R.anim.activity_close_enter_ios, android.R.anim.activity_open_exit_ios);
                this.mWindow.setDimAmount(0.7);
                this.mWindow.getAttributes().flags |= WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
                this.mWindow.setCallback(this);
            }
            getIntent() {
                return this.mIntent;
            }
            setIntent(newIntent) {
                this.mIntent = newIntent;
            }
            getApplication() {
                return this.getApplicationContext();
            }
            getWindowManager() {
                return this.mWindow.getChildWindowManager();
            }
            getGlobalWindowManager() {
                return this.getApplicationContext().getWindowManager();
            }
            getWindow() {
                return this.mWindow;
            }
            getCurrentFocus() {
                return this.mWindow != null ? this.mWindow.getCurrentFocus() : null;
            }
            onCreate(savedInstanceState) {
                if (Activity.DEBUG_LIFECYCLE)
                    Log.v(Activity.TAG, "onCreate " + this + ": " + savedInstanceState);
                this.getApplication().dispatchActivityCreated(this, savedInstanceState);
                this.mCalled = true;
            }
            performRestoreInstanceState(savedInstanceState) {
                this.onRestoreInstanceState(savedInstanceState);
            }
            onRestoreInstanceState(savedInstanceState) {
            }
            onPostCreate(savedInstanceState) {
                this.onTitleChanged(this.getTitle());
                this.mCalled = true;
            }
            onStart() {
                if (Activity.DEBUG_LIFECYCLE)
                    Log.v(Activity.TAG, "onStart " + this);
                this.mCalled = true;
                this.getApplication().dispatchActivityStarted(this);
            }
            onRestart() {
                this.mCalled = true;
            }
            onResume() {
                if (Activity.DEBUG_LIFECYCLE)
                    Log.v(Activity.TAG, "onResume " + this);
                this.getApplication().dispatchActivityResumed(this);
                this.mCalled = true;
            }
            onPostResume() {
                const win = this.getWindow();
                if (win != null)
                    win.makeActive();
                this.mCalled = true;
            }
            onNewIntent(intent) {
            }
            performSaveInstanceState(outState) {
                this.onSaveInstanceState(outState);
                if (Activity.DEBUG_LIFECYCLE)
                    Log.v(Activity.TAG, "onSaveInstanceState " + this + ": " + outState);
            }
            onSaveInstanceState(outState) {
                this.getApplication().dispatchActivitySaveInstanceState(this, outState);
            }
            onPause() {
                if (Activity.DEBUG_LIFECYCLE)
                    Log.v(Activity.TAG, "onPause " + this);
                this.getApplication().dispatchActivityPaused(this);
                this.mCalled = true;
            }
            onUserLeaveHint() {
            }
            onStop() {
                if (Activity.DEBUG_LIFECYCLE)
                    Log.v(Activity.TAG, "onStop " + this);
                this.getApplication().dispatchActivityStopped(this);
                this.mCalled = true;
            }
            onDestroy() {
                if (Activity.DEBUG_LIFECYCLE)
                    Log.v(Activity.TAG, "onDestroy " + this);
                this.mCalled = true;
                this.getApplication().dispatchActivityDestroyed(this);
            }
            findViewById(id) {
                return this.getWindow().findViewById(id);
            }
            setContentView(view, params) {
                if (!(view instanceof View)) {
                    view = this.getLayoutInflater().inflate(view);
                }
                this.getWindow().setContentView(view, params);
            }
            addContentView(view, params) {
                this.mWindow.addContentView(view, params);
            }
            setFinishOnTouchOutside(finish) {
                this.mWindow.setCloseOnTouchOutside(finish);
            }
            onKeyDown(keyCode, event) {
                if (keyCode == KeyEvent.KEYCODE_BACK) {
                    event.startTracking();
                    return true;
                }
                return false;
            }
            onKeyLongPress(keyCode, event) {
                return false;
            }
            onKeyUp(keyCode, event) {
                if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
                    this.onBackPressed();
                    return true;
                }
                return false;
            }
            onBackPressed() {
                this.finish();
            }
            onTouchEvent(event) {
                if (this.mWindow.shouldCloseOnTouch(this, event)) {
                    this.finish();
                    return true;
                }
                return false;
            }
            onGenericMotionEvent(event) {
                return false;
            }
            onUserInteraction() {
            }
            onWindowAttributesChanged(params) {
                let decor = this.getWindow().getDecorView();
                if (decor != null && decor.getParent() != null) {
                    this.getWindowManager().updateWindowLayout(this.getWindow(), params);
                }
            }
            onContentChanged() {
            }
            onWindowFocusChanged(hasFocus) {
            }
            onAttachedToWindow() {
            }
            onDetachedFromWindow() {
            }
            hasWindowFocus() {
                let w = this.getWindow();
                if (w != null) {
                    let d = w.getDecorView();
                    if (d != null) {
                        return d.hasWindowFocus();
                    }
                }
                return false;
            }
            dispatchKeyEvent(event) {
                this.onUserInteraction();
                let win = this.getWindow();
                if (win.superDispatchKeyEvent(event)) {
                    return true;
                }
                let decor = win.getDecorView();
                return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
            }
            dispatchTouchEvent(ev) {
                if (ev.getAction() == MotionEvent.ACTION_DOWN) {
                    this.onUserInteraction();
                }
                if (this.getWindow().superDispatchTouchEvent(ev)) {
                    return true;
                }
                return this.onTouchEvent(ev);
            }
            dispatchGenericMotionEvent(ev) {
                this.onUserInteraction();
                if (this.getWindow().superDispatchGenericMotionEvent(ev)) {
                    return true;
                }
                return this.onGenericMotionEvent(ev);
            }
            takeKeyEvents(_get) {
                this.getWindow().takeKeyEvents(_get);
            }
            startActivityForResult(intent, requestCode, options) {
                if (typeof intent === 'string')
                    intent = new Intent(intent);
                if (requestCode >= 0)
                    intent.mRequestCode = requestCode;
                this.androidUI.mActivityThread.scheduleLaunchActivity(this, intent, options);
                if (requestCode >= 0) {
                    this.mStartedActivity = true;
                }
                const decor = this.mWindow != null ? this.mWindow.peekDecorView() : null;
                if (decor != null) {
                    decor.cancelPendingInputEvents();
                }
            }
            startActivities(intents, options) {
                for (let intent of intents) {
                    this.startActivity(intent, options);
                }
            }
            startActivity(intent, options) {
                if (options != null) {
                    this.startActivityForResult(intent, -1, options);
                }
                else {
                    this.startActivityForResult(intent, -1);
                }
            }
            startActivityIfNeeded(intent, requestCode, options) {
                if (this.androidUI.mActivityThread.canBackTo(intent)) {
                    return false;
                }
                this.startActivityForResult(intent, requestCode, options);
                return true;
            }
            overrideNextTransition(enterAnimation, exitAnimation, resumeAnimation, hideAnimation) {
                this.androidUI.mActivityThread.overrideNextWindowAnimation(enterAnimation, exitAnimation, resumeAnimation, hideAnimation);
            }
            setResult(resultCode, data) {
                {
                    this.mResultCode = resultCode;
                    this.mResultData = data;
                }
            }
            getCallingActivity() {
                return null;
            }
            setVisible(visible) {
                if (this.mVisibleFromClient != visible) {
                    this.mVisibleFromClient = visible;
                }
            }
            makeVisible() {
                if (!this.mWindowAdded) {
                    let wm = this.getGlobalWindowManager();
                    wm.addWindow(this.getWindow());
                    this.mWindowAdded = true;
                }
                this.getWindow().getDecorView().setVisibility(View.VISIBLE);
            }
            isFinishing() {
                return this.mFinished;
            }
            isDestroyed() {
                return this.mDestroyed;
            }
            finish() {
                let resultCode = this.mResultCode;
                let resultData = this.mResultData;
                try {
                    this.androidUI.mActivityThread.scheduleDestroyActivity(this);
                }
                catch (e) {
                }
            }
            finishActivity(requestCode) {
                this.androidUI.mActivityThread.scheduleDestroyActivityByRequestCode(requestCode);
            }
            onActivityResult(requestCode, resultCode, data) {
            }
            setTitle(title) {
                this.getWindow().setTitle(title);
                this.onTitleChanged(title);
            }
            getTitle() {
                return this.getWindow().getAttributes().getTitle();
            }
            onTitleChanged(title, color) {
                const win = this.getWindow();
                if (win != null) {
                    win.setTitle(title);
                }
            }
            runOnUiThread(action) {
                action.run();
            }
            navigateUpTo(upIntent, upToRootIfNotFound = true) {
                if (this.androidUI.mActivityThread.scheduleBackTo(upIntent)) {
                    return true;
                }
                if (upToRootIfNotFound)
                    this.androidUI.mActivityThread.scheduleBackToRoot();
                return false;
            }
            performCreate(icicle) {
                this.onCreate(icicle);
            }
            performStart() {
                this.mCalled = false;
                this.onStart();
                if (!this.mCalled) {
                    throw Error(`new SuperNotCalledException("Activity " + this.mComponent.toShortString() + " did not call through to super.onStart()")`);
                }
            }
            performRestart() {
                if (this.mStopped) {
                    this.mStopped = false;
                    this.mCalled = false;
                    this.onRestart();
                    if (!this.mCalled) {
                        throw Error(`new SuperNotCalledException("Activity " + this.mComponent.toShortString() + " did not call through to super.onRestart()")`);
                    }
                    this.performStart();
                }
            }
            performResume() {
                this.performRestart();
                this.mCalled = false;
                this.mResumed = true;
                this.onResume();
                if (!this.mCalled) {
                    throw Error(`new SuperNotCalledException("Activity " + this.mComponent.toShortString() + " did not call through to super.onResume()")`);
                }
                this.mCalled = false;
                this.onPostResume();
                if (!this.mCalled) {
                    throw Error(`new SuperNotCalledException("Activity " + this.mComponent.toShortString() + " did not call through to super.onPostResume()")`);
                }
            }
            performPause() {
                this.mCalled = false;
                this.onPause();
                this.mResumed = false;
                if (!this.mCalled) {
                    throw Error(`new SuperNotCalledException("Activity " + this.mComponent.toShortString() + " did not call through to super.onPause()")`);
                }
                this.mResumed = false;
            }
            performUserLeaving() {
                this.onUserInteraction();
                this.onUserLeaveHint();
            }
            performStop() {
                if (!this.mStopped) {
                    this.mCalled = false;
                    this.onStop();
                    if (!this.mCalled) {
                        throw Error(`new SuperNotCalledException("Activity " + this.mComponent.toShortString() + " did not call through to super.onStop()")`);
                    }
                    this.mStopped = true;
                }
                this.mResumed = false;
            }
            performDestroy() {
                this.mDestroyed = true;
                this.mWindow.destroy();
                this.onDestroy();
            }
            isResumed() {
                return this.mResumed;
            }
            dispatchActivityResult(who, requestCode, resultCode, data) {
                if (false)
                    Log.v(Activity.TAG, "Dispatching result: who=" + who + ", reqCode=" + requestCode + ", resCode=" + resultCode + ", data=" + data);
                this.onActivityResult(requestCode, resultCode, data);
            }
        }
        Activity.TAG = "Activity";
        Activity.DEBUG_LIFECYCLE = false;
        Activity.RESULT_CANCELED = 0;
        Activity.RESULT_OK = -1;
        Activity.RESULT_FIRST_USER = 1;
        app.Activity = Activity;
    })(app = android.app || (android.app = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../android/os/Bundle.ts"/>
///<reference path="../../android/app/Activity.ts"/>
///<reference path="../../android/content/Context.ts"/>
var android;
(function (android) {
    var app;
    (function (app) {
        var ArrayList = java.util.ArrayList;
        var Context = android.content.Context;
        class Application extends Context {
            constructor(...args) {
                super(...args);
                this.mActivityLifecycleCallbacks = new ArrayList();
            }
            onCreate() {
            }
            getWindowManager() {
                if (!this.mWindowManager)
                    this.mWindowManager = new android.view.WindowManager(this);
                return this.mWindowManager;
            }
            registerActivityLifecycleCallbacks(callback) {
                {
                    this.mActivityLifecycleCallbacks.add(callback);
                }
            }
            unregisterActivityLifecycleCallbacks(callback) {
                {
                    this.mActivityLifecycleCallbacks.remove(callback);
                }
            }
            dispatchActivityCreated(activity, savedInstanceState) {
                let callbacks = this.collectActivityLifecycleCallbacks();
                if (callbacks != null) {
                    for (let i = 0; i < callbacks.length; i++) {
                        callbacks[i].onActivityCreated(activity, savedInstanceState);
                    }
                }
            }
            dispatchActivityStarted(activity) {
                let callbacks = this.collectActivityLifecycleCallbacks();
                if (callbacks != null) {
                    for (let i = 0; i < callbacks.length; i++) {
                        callbacks[i].onActivityStarted(activity);
                    }
                }
            }
            dispatchActivityResumed(activity) {
                let callbacks = this.collectActivityLifecycleCallbacks();
                if (callbacks != null) {
                    for (let i = 0; i < callbacks.length; i++) {
                        callbacks[i].onActivityResumed(activity);
                    }
                }
            }
            dispatchActivityPaused(activity) {
                let callbacks = this.collectActivityLifecycleCallbacks();
                if (callbacks != null) {
                    for (let i = 0; i < callbacks.length; i++) {
                        callbacks[i].onActivityPaused(activity);
                    }
                }
            }
            dispatchActivityStopped(activity) {
                let callbacks = this.collectActivityLifecycleCallbacks();
                if (callbacks != null) {
                    for (let i = 0; i < callbacks.length; i++) {
                        callbacks[i].onActivityStopped(activity);
                    }
                }
            }
            dispatchActivitySaveInstanceState(activity, outState) {
                let callbacks = this.collectActivityLifecycleCallbacks();
                if (callbacks != null) {
                    for (let i = 0; i < callbacks.length; i++) {
                        callbacks[i].onActivitySaveInstanceState(activity, outState);
                    }
                }
            }
            dispatchActivityDestroyed(activity) {
                let callbacks = this.collectActivityLifecycleCallbacks();
                if (callbacks != null) {
                    for (let i = 0; i < callbacks.length; i++) {
                        callbacks[i].onActivityDestroyed(activity);
                    }
                }
            }
            collectActivityLifecycleCallbacks() {
                let callbacks = null;
                {
                    if (this.mActivityLifecycleCallbacks.size() > 0) {
                        callbacks = this.mActivityLifecycleCallbacks.toArray();
                    }
                }
                return callbacks;
            }
        }
        app.Application = Application;
    })(app = android.app || (android.app = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/17.
 */
///<reference path="../util/Log.ts"/>
///<reference path="../util/Pools.ts"/>
///<reference path="MotionEvent.ts"/>
///<reference path="KeyEvent.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Log = android.util.Log;
        var Pools = android.util.Pools;
        class VelocityTracker {
            constructor() {
                this.mLastTouchIndex = 0;
                this.mGeneration = 0;
                this.clear();
            }
            static obtain() {
                let instance = VelocityTracker.sPool.acquire();
                return (instance != null) ? instance : new VelocityTracker();
            }
            recycle() {
                this.clear();
                VelocityTracker.sPool.release(this);
            }
            setNextPoolable(element) {
                this.mNext = element;
            }
            getNextPoolable() {
                return this.mNext;
            }
            clear() {
                VelocityTracker.releasePointerList(this.mPointerListHead);
                this.mPointerListHead = null;
                this.mLastTouchIndex = 0;
            }
            addMovement(ev) {
                let historySize = ev.getHistorySize();
                const pointerCount = ev.getPointerCount();
                const lastTouchIndex = this.mLastTouchIndex;
                const nextTouchIndex = (lastTouchIndex + 1) % VelocityTracker.NUM_PAST;
                const finalTouchIndex = (nextTouchIndex + historySize) % VelocityTracker.NUM_PAST;
                const generation = this.mGeneration++;
                this.mLastTouchIndex = finalTouchIndex;
                let previousPointer = null;
                for (let i = 0; i < pointerCount; i++) {
                    const pointerId = ev.getPointerId(i);
                    let nextPointer;
                    if (previousPointer == null || pointerId < previousPointer.id) {
                        previousPointer = null;
                        nextPointer = this.mPointerListHead;
                    }
                    else {
                        nextPointer = previousPointer.next;
                    }
                    let pointer;
                    for (;;) {
                        if (nextPointer != null) {
                            const nextPointerId = nextPointer.id;
                            if (nextPointerId == pointerId) {
                                pointer = nextPointer;
                                break;
                            }
                            if (nextPointerId < pointerId) {
                                nextPointer = nextPointer.next;
                                continue;
                            }
                        }
                        pointer = VelocityTracker.obtainPointer();
                        pointer.id = pointerId;
                        pointer.pastTime[lastTouchIndex] = Number.MIN_VALUE;
                        pointer.next = nextPointer;
                        if (previousPointer == null) {
                            this.mPointerListHead = pointer;
                        }
                        else {
                            previousPointer.next = pointer;
                        }
                        break;
                    }
                    pointer.generation = generation;
                    previousPointer = pointer;
                    const pastX = pointer.pastX;
                    const pastY = pointer.pastY;
                    const pastTime = pointer.pastTime;
                    historySize = ev.getHistorySize(pointerId);
                    for (let j = 0; j < historySize; j++) {
                        const touchIndex = (nextTouchIndex + j) % VelocityTracker.NUM_PAST;
                        pastX[touchIndex] = ev.getHistoricalX(i, j);
                        pastY[touchIndex] = ev.getHistoricalY(i, j);
                        pastTime[touchIndex] = ev.getHistoricalEventTime(i, j);
                    }
                    pastX[finalTouchIndex] = ev.getX(i);
                    pastY[finalTouchIndex] = ev.getY(i);
                    pastTime[finalTouchIndex] = ev.getEventTime();
                }
                previousPointer = null;
                for (let pointer = this.mPointerListHead; pointer != null;) {
                    const nextPointer = pointer.next;
                    if (pointer.generation != generation) {
                        if (previousPointer == null) {
                            this.mPointerListHead = nextPointer;
                        }
                        else {
                            previousPointer.next = nextPointer;
                        }
                        VelocityTracker.releasePointer(pointer);
                    }
                    else {
                        previousPointer = pointer;
                    }
                    pointer = nextPointer;
                }
            }
            computeCurrentVelocity(units, maxVelocity = Number.MAX_SAFE_INTEGER) {
                const lastTouchIndex = this.mLastTouchIndex;
                for (let pointer = this.mPointerListHead; pointer != null; pointer = pointer.next) {
                    const pastTime = pointer.pastTime;
                    let oldestTouchIndex = lastTouchIndex;
                    let numTouches = 1;
                    const minTime = pastTime[lastTouchIndex] - VelocityTracker.MAX_AGE_MILLISECONDS;
                    while (numTouches < VelocityTracker.NUM_PAST) {
                        const nextOldestTouchIndex = (oldestTouchIndex + VelocityTracker.NUM_PAST - 1) % VelocityTracker.NUM_PAST;
                        const nextOldestTime = pastTime[nextOldestTouchIndex];
                        if (nextOldestTime < minTime) {
                            break;
                        }
                        oldestTouchIndex = nextOldestTouchIndex;
                        numTouches += 1;
                    }
                    if (numTouches > 3) {
                        numTouches -= 1;
                    }
                    const pastX = pointer.pastX;
                    const pastY = pointer.pastY;
                    const oldestX = pastX[oldestTouchIndex];
                    const oldestY = pastY[oldestTouchIndex];
                    const oldestTime = pastTime[oldestTouchIndex];
                    let accumX = 0;
                    let accumY = 0;
                    for (let i = 1; i < numTouches; i++) {
                        const touchIndex = (oldestTouchIndex + i) % VelocityTracker.NUM_PAST;
                        const duration = (pastTime[touchIndex] - oldestTime);
                        if (duration == 0)
                            continue;
                        let delta = pastX[touchIndex] - oldestX;
                        let velocity = (delta / duration) * units;
                        accumX = (accumX == 0) ? velocity : (accumX + velocity) * .5;
                        delta = pastY[touchIndex] - oldestY;
                        velocity = (delta / duration) * units;
                        accumY = (accumY == 0) ? velocity : (accumY + velocity) * .5;
                    }
                    if (accumX < -maxVelocity) {
                        accumX = -maxVelocity;
                    }
                    else if (accumX > maxVelocity) {
                        accumX = maxVelocity;
                    }
                    if (accumY < -maxVelocity) {
                        accumY = -maxVelocity;
                    }
                    else if (accumY > maxVelocity) {
                        accumY = maxVelocity;
                    }
                    pointer.xVelocity = accumX;
                    pointer.yVelocity = accumY;
                    if (VelocityTracker.localLOGV) {
                        Log.v(VelocityTracker.TAG, "Pointer " + pointer.id
                            + ": Y velocity=" + accumX + " X velocity=" + accumY + " N=" + numTouches);
                    }
                }
            }
            getXVelocity(id = 0) {
                let pointer = this.getPointer(id);
                return pointer != null ? pointer.xVelocity : 0;
            }
            getYVelocity(id = 0) {
                let pointer = this.getPointer(id);
                return pointer != null ? pointer.yVelocity : 0;
            }
            getPointer(id) {
                for (let pointer = this.mPointerListHead; pointer != null; pointer = pointer.next) {
                    if (pointer.id == id) {
                        return pointer;
                    }
                }
                return null;
            }
            static obtainPointer() {
                if (VelocityTracker.sRecycledPointerCount != 0) {
                    let element = VelocityTracker.sRecycledPointerListHead;
                    VelocityTracker.sRecycledPointerCount -= 1;
                    VelocityTracker.sRecycledPointerListHead = element.next;
                    element.next = null;
                    return element;
                }
                return new Pointer();
            }
            static releasePointer(pointer) {
                if (VelocityTracker.sRecycledPointerCount < VelocityTracker.POINTER_POOL_CAPACITY) {
                    pointer.next = VelocityTracker.sRecycledPointerListHead;
                    VelocityTracker.sRecycledPointerCount += 1;
                    VelocityTracker.sRecycledPointerListHead = pointer;
                }
            }
            static releasePointerList(pointer) {
                if (pointer != null) {
                    let count = VelocityTracker.sRecycledPointerCount;
                    if (count >= VelocityTracker.POINTER_POOL_CAPACITY) {
                        return;
                    }
                    let tail = pointer;
                    for (;;) {
                        count += 1;
                        if (count >= VelocityTracker.POINTER_POOL_CAPACITY) {
                            break;
                        }
                        let next = tail.next;
                        if (next == null) {
                            break;
                        }
                        tail = next;
                    }
                    tail.next = VelocityTracker.sRecycledPointerListHead;
                    VelocityTracker.sRecycledPointerCount = count;
                    VelocityTracker.sRecycledPointerListHead = pointer;
                }
            }
        }
        VelocityTracker.TAG = "VelocityTracker";
        VelocityTracker.DEBUG = Log.VelocityTracker_DBG;
        VelocityTracker.localLOGV = VelocityTracker.DEBUG;
        VelocityTracker.NUM_PAST = 10;
        VelocityTracker.MAX_AGE_MILLISECONDS = 200;
        VelocityTracker.POINTER_POOL_CAPACITY = 20;
        VelocityTracker.sPool = new Pools.SynchronizedPool(2);
        VelocityTracker.sRecycledPointerCount = 0;
        view.VelocityTracker = VelocityTracker;
        class Pointer {
            constructor() {
                this.id = 0;
                this.xVelocity = 0;
                this.yVelocity = 0;
                this.pastX = new Array(VelocityTracker.NUM_PAST);
                this.pastY = new Array(VelocityTracker.NUM_PAST);
                this.pastTime = new Array(VelocityTracker.NUM_PAST);
                this.generation = 0;
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/os/SystemClock.ts"/>
///<reference path="../../java/lang/Float.ts"/>
///<reference path="../../android/view/GestureDetector.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var SystemClock = android.os.SystemClock;
        var MotionEvent = android.view.MotionEvent;
        var ViewConfiguration = android.view.ViewConfiguration;
        var TypedValue = android.util.TypedValue;
        class ScaleGestureDetector {
            constructor(listener, handler) {
                this.mFocusX = 0;
                this.mFocusY = 0;
                this.mCurrSpan = 0;
                this.mPrevSpan = 0;
                this.mInitialSpan = 0;
                this.mCurrSpanX = 0;
                this.mCurrSpanY = 0;
                this.mPrevSpanX = 0;
                this.mPrevSpanY = 0;
                this.mCurrTime = 0;
                this.mPrevTime = 0;
                this.mSpanSlop = 0;
                this.mMinSpan = 0;
                this.mTouchUpper = 0;
                this.mTouchLower = 0;
                this.mTouchHistoryLastAccepted = 0;
                this.mTouchHistoryDirection = 0;
                this.mTouchHistoryLastAcceptedTime = 0;
                this.mTouchMinMajor = 0;
                this.mDoubleTapMode = ScaleGestureDetector.DOUBLE_TAP_MODE_NONE;
                this.mListener = listener;
                this.mSpanSlop = ViewConfiguration.get().getScaledTouchSlop() * 2;
                this.mTouchMinMajor = TypedValue.complexToDimensionPixelSize('48dp');
                this.mMinSpan = TypedValue.complexToDimensionPixelSize('27mm');
                this.mHandler = handler;
                this.setQuickScaleEnabled(true);
            }
            addTouchHistory(ev) {
                const currentTime = SystemClock.uptimeMillis();
                const count = ev.getPointerCount();
                let accept = currentTime - this.mTouchHistoryLastAcceptedTime >= ScaleGestureDetector.TOUCH_STABILIZE_TIME;
                let total = 0;
                let sampleCount = 0;
                for (let i = 0; i < count; i++) {
                    const hasLastAccepted = !Number.isNaN(this.mTouchHistoryLastAccepted);
                    const historySize = ev.getHistorySize();
                    const pointerSampleCount = historySize + 1;
                    for (let h = 0; h < pointerSampleCount; h++) {
                        let major;
                        if (h < historySize) {
                            major = ev.getHistoricalTouchMajor(i, h);
                        }
                        else {
                            major = ev.getTouchMajor(i);
                        }
                        if (major < this.mTouchMinMajor)
                            major = this.mTouchMinMajor;
                        total += major;
                        if (Number.isNaN(this.mTouchUpper) || major > this.mTouchUpper) {
                            this.mTouchUpper = major;
                        }
                        if (Number.isNaN(this.mTouchLower) || major < this.mTouchLower) {
                            this.mTouchLower = major;
                        }
                        if (hasLastAccepted) {
                            function Math_signum(value) {
                                if (value === 0 || Number.isNaN(value))
                                    return value;
                                return Math.abs(value) === value ? 1 : -1;
                            }
                            const directionSig = Math.floor(Math_signum(major - this.mTouchHistoryLastAccepted));
                            if (directionSig != this.mTouchHistoryDirection || (directionSig == 0 && this.mTouchHistoryDirection == 0)) {
                                this.mTouchHistoryDirection = directionSig;
                                const time = h < historySize ? ev.getHistoricalEventTime(h) : ev.getEventTime();
                                this.mTouchHistoryLastAcceptedTime = time;
                                accept = false;
                            }
                        }
                    }
                    sampleCount += pointerSampleCount;
                }
                const avg = total / sampleCount;
                if (accept) {
                    let newAccepted = (this.mTouchUpper + this.mTouchLower + avg) / 3;
                    this.mTouchUpper = (this.mTouchUpper + newAccepted) / 2;
                    this.mTouchLower = (this.mTouchLower + newAccepted) / 2;
                    this.mTouchHistoryLastAccepted = newAccepted;
                    this.mTouchHistoryDirection = 0;
                    this.mTouchHistoryLastAcceptedTime = ev.getEventTime();
                }
            }
            clearTouchHistory() {
                this.mTouchUpper = Number.NaN;
                this.mTouchLower = Number.NaN;
                this.mTouchHistoryLastAccepted = Number.NaN;
                this.mTouchHistoryDirection = 0;
                this.mTouchHistoryLastAcceptedTime = 0;
            }
            onTouchEvent(event) {
                this.mCurrTime = event.getEventTime();
                const action = event.getActionMasked();
                if (this.mQuickScaleEnabled) {
                    this.mGestureDetector.onTouchEvent(event);
                }
                const streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
                if (action == MotionEvent.ACTION_DOWN || streamComplete) {
                    if (this.mInProgress) {
                        this.mListener.onScaleEnd(this);
                        this.mInProgress = false;
                        this.mInitialSpan = 0;
                        this.mDoubleTapMode = ScaleGestureDetector.DOUBLE_TAP_MODE_NONE;
                    }
                    else if (this.mDoubleTapMode == ScaleGestureDetector.DOUBLE_TAP_MODE_IN_PROGRESS && streamComplete) {
                        this.mInProgress = false;
                        this.mInitialSpan = 0;
                        this.mDoubleTapMode = ScaleGestureDetector.DOUBLE_TAP_MODE_NONE;
                    }
                    if (streamComplete) {
                        this.clearTouchHistory();
                        return true;
                    }
                }
                const configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
                const pointerUp = action == MotionEvent.ACTION_POINTER_UP;
                const skipIndex = pointerUp ? event.getActionIndex() : -1;
                let sumX = 0, sumY = 0;
                const count = event.getPointerCount();
                const div = pointerUp ? count - 1 : count;
                let focusX;
                let focusY;
                if (this.mDoubleTapMode == ScaleGestureDetector.DOUBLE_TAP_MODE_IN_PROGRESS) {
                    focusX = this.mDoubleTapEvent.getX();
                    focusY = this.mDoubleTapEvent.getY();
                    if (event.getY() < focusY) {
                        this.mEventBeforeOrAboveStartingGestureEvent = true;
                    }
                    else {
                        this.mEventBeforeOrAboveStartingGestureEvent = false;
                    }
                }
                else {
                    for (let i = 0; i < count; i++) {
                        if (skipIndex == i)
                            continue;
                        sumX += event.getX(i);
                        sumY += event.getY(i);
                    }
                    focusX = sumX / div;
                    focusY = sumY / div;
                }
                this.addTouchHistory(event);
                let devSumX = 0, devSumY = 0;
                for (let i = 0; i < count; i++) {
                    if (skipIndex == i)
                        continue;
                    const touchSize = this.mTouchHistoryLastAccepted / 2;
                    devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
                    devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
                }
                const devX = devSumX / div;
                const devY = devSumY / div;
                const spanX = devX * 2;
                const spanY = devY * 2;
                let span;
                if (this.inDoubleTapMode()) {
                    span = spanY;
                }
                else {
                    span = Math.sqrt(spanX * spanX + spanY * spanY);
                }
                const wasInProgress = this.mInProgress;
                this.mFocusX = focusX;
                this.mFocusY = focusY;
                if (!this.inDoubleTapMode() && this.mInProgress && (span < this.mMinSpan || configChanged)) {
                    this.mListener.onScaleEnd(this);
                    this.mInProgress = false;
                    this.mInitialSpan = span;
                    this.mDoubleTapMode = ScaleGestureDetector.DOUBLE_TAP_MODE_NONE;
                }
                if (configChanged) {
                    this.mPrevSpanX = this.mCurrSpanX = spanX;
                    this.mPrevSpanY = this.mCurrSpanY = spanY;
                    this.mInitialSpan = this.mPrevSpan = this.mCurrSpan = span;
                }
                const minSpan = this.inDoubleTapMode() ? this.mSpanSlop : this.mMinSpan;
                if (!this.mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - this.mInitialSpan) > this.mSpanSlop)) {
                    this.mPrevSpanX = this.mCurrSpanX = spanX;
                    this.mPrevSpanY = this.mCurrSpanY = spanY;
                    this.mPrevSpan = this.mCurrSpan = span;
                    this.mPrevTime = this.mCurrTime;
                    this.mInProgress = this.mListener.onScaleBegin(this);
                }
                if (action == MotionEvent.ACTION_MOVE) {
                    this.mCurrSpanX = spanX;
                    this.mCurrSpanY = spanY;
                    this.mCurrSpan = span;
                    let updatePrev = true;
                    if (this.mInProgress) {
                        updatePrev = this.mListener.onScale(this);
                    }
                    if (updatePrev) {
                        this.mPrevSpanX = this.mCurrSpanX;
                        this.mPrevSpanY = this.mCurrSpanY;
                        this.mPrevSpan = this.mCurrSpan;
                        this.mPrevTime = this.mCurrTime;
                    }
                }
                return true;
            }
            inDoubleTapMode() {
                return this.mDoubleTapMode == ScaleGestureDetector.DOUBLE_TAP_MODE_IN_PROGRESS;
            }
            setQuickScaleEnabled(scales) {
                this.mQuickScaleEnabled = scales;
                if (this.mQuickScaleEnabled && this.mGestureDetector == null) {
                    let gestureListener = (() => {
                        const _this = this;
                        class _Inner extends view.GestureDetector.SimpleOnGestureListener {
                            onDoubleTap(e) {
                                _this.mDoubleTapEvent = e;
                                _this.mDoubleTapMode = ScaleGestureDetector.DOUBLE_TAP_MODE_IN_PROGRESS;
                                return true;
                            }
                        }
                        return new _Inner();
                    })();
                    this.mGestureDetector = new view.GestureDetector(gestureListener, this.mHandler);
                }
            }
            isQuickScaleEnabled() {
                return this.mQuickScaleEnabled;
            }
            isInProgress() {
                return this.mInProgress;
            }
            getFocusX() {
                return this.mFocusX;
            }
            getFocusY() {
                return this.mFocusY;
            }
            getCurrentSpan() {
                return this.mCurrSpan;
            }
            getCurrentSpanX() {
                return this.mCurrSpanX;
            }
            getCurrentSpanY() {
                return this.mCurrSpanY;
            }
            getPreviousSpan() {
                return this.mPrevSpan;
            }
            getPreviousSpanX() {
                return this.mPrevSpanX;
            }
            getPreviousSpanY() {
                return this.mPrevSpanY;
            }
            getScaleFactor() {
                if (this.inDoubleTapMode()) {
                    const scaleUp = (this.mEventBeforeOrAboveStartingGestureEvent && (this.mCurrSpan < this.mPrevSpan)) || (!this.mEventBeforeOrAboveStartingGestureEvent && (this.mCurrSpan > this.mPrevSpan));
                    const spanDiff = (Math.abs(1 - (this.mCurrSpan / this.mPrevSpan)) * ScaleGestureDetector.SCALE_FACTOR);
                    return this.mPrevSpan <= 0 ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
                }
                return this.mPrevSpan > 0 ? this.mCurrSpan / this.mPrevSpan : 1;
            }
            getTimeDelta() {
                return this.mCurrTime - this.mPrevTime;
            }
            getEventTime() {
                return this.mCurrTime;
            }
        }
        ScaleGestureDetector.TAG = "ScaleGestureDetector";
        ScaleGestureDetector.TOUCH_STABILIZE_TIME = 128;
        ScaleGestureDetector.DOUBLE_TAP_MODE_NONE = 0;
        ScaleGestureDetector.DOUBLE_TAP_MODE_IN_PROGRESS = 1;
        ScaleGestureDetector.SCALE_FACTOR = .5;
        view.ScaleGestureDetector = ScaleGestureDetector;
        (function (ScaleGestureDetector) {
            class SimpleOnScaleGestureListener {
                onScale(detector) {
                    return false;
                }
                onScaleBegin(detector) {
                    return true;
                }
                onScaleEnd(detector) {
                }
            }
            ScaleGestureDetector.SimpleOnScaleGestureListener = SimpleOnScaleGestureListener;
        })(ScaleGestureDetector = view.ScaleGestureDetector || (view.ScaleGestureDetector = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/os/Message.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="ScaleGestureDetector.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Handler = android.os.Handler;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var ViewConfiguration = android.view.ViewConfiguration;
        class GestureDetector {
            constructor(listener, handler) {
                this.mTouchSlopSquare = 0;
                this.mDoubleTapTouchSlopSquare = 0;
                this.mDoubleTapSlopSquare = 0;
                this.mMinimumFlingVelocity = 0;
                this.mMaximumFlingVelocity = 0;
                this.mLastFocusX = 0;
                this.mLastFocusY = 0;
                this.mDownFocusX = 0;
                this.mDownFocusY = 0;
                this.mHandler = new GestureDetector.GestureHandler(this);
                this.mListener = listener;
                if (listener['setOnDoubleTapListener']) {
                    this.setOnDoubleTapListener(listener);
                }
                this.init();
            }
            init() {
                if (this.mListener == null) {
                    throw Error(`new NullPointerException("OnGestureListener must not be null")`);
                }
                this.mIsLongpressEnabled = true;
                let touchSlop, doubleTapSlop, doubleTapTouchSlop;
                const configuration = ViewConfiguration.get();
                touchSlop = configuration.getScaledTouchSlop();
                doubleTapTouchSlop = configuration.getScaledDoubleTapTouchSlop();
                doubleTapSlop = configuration.getScaledDoubleTapSlop();
                this.mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mTouchSlopSquare = touchSlop * touchSlop;
                this.mDoubleTapTouchSlopSquare = doubleTapTouchSlop * doubleTapTouchSlop;
                this.mDoubleTapSlopSquare = doubleTapSlop * doubleTapSlop;
            }
            setOnDoubleTapListener(onDoubleTapListener) {
                this.mDoubleTapListener = onDoubleTapListener;
            }
            setIsLongpressEnabled(isLongpressEnabled) {
                this.mIsLongpressEnabled = isLongpressEnabled;
            }
            isLongpressEnabled() {
                return this.mIsLongpressEnabled;
            }
            onTouchEvent(ev) {
                const action = ev.getAction();
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                this.mVelocityTracker.addMovement(ev);
                const pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
                const skipIndex = pointerUp ? ev.getActionIndex() : -1;
                let sumX = 0, sumY = 0;
                const count = ev.getPointerCount();
                for (let i = 0; i < count; i++) {
                    if (skipIndex == i)
                        continue;
                    sumX += ev.getX(i);
                    sumY += ev.getY(i);
                }
                const div = pointerUp ? count - 1 : count;
                const focusX = sumX / div;
                const focusY = sumY / div;
                let handled = false;
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_POINTER_DOWN:
                        this.mDownFocusX = this.mLastFocusX = focusX;
                        this.mDownFocusY = this.mLastFocusY = focusY;
                        this.cancelTaps();
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        this.mDownFocusX = this.mLastFocusX = focusX;
                        this.mDownFocusY = this.mLastFocusY = focusY;
                        this.mVelocityTracker.computeCurrentVelocity(1000, this.mMaximumFlingVelocity);
                        const upIndex = ev.getActionIndex();
                        const id1 = ev.getPointerId(upIndex);
                        const x1 = this.mVelocityTracker.getXVelocity(id1);
                        const y1 = this.mVelocityTracker.getYVelocity(id1);
                        for (let i = 0; i < count; i++) {
                            if (i == upIndex)
                                continue;
                            const id2 = ev.getPointerId(i);
                            const x = x1 * this.mVelocityTracker.getXVelocity(id2);
                            const y = y1 * this.mVelocityTracker.getYVelocity(id2);
                            const dot = x + y;
                            if (dot < 0) {
                                this.mVelocityTracker.clear();
                                break;
                            }
                        }
                        break;
                    case MotionEvent.ACTION_DOWN:
                        if (this.mDoubleTapListener != null) {
                            let hadTapMessage = this.mHandler.hasMessages(GestureDetector.TAP);
                            if (hadTapMessage)
                                this.mHandler.removeMessages(GestureDetector.TAP);
                            if ((this.mCurrentDownEvent != null) && (this.mPreviousUpEvent != null) && hadTapMessage && this.isConsideredDoubleTap(this.mCurrentDownEvent, this.mPreviousUpEvent, ev)) {
                                this.mIsDoubleTapping = true;
                                handled = this.mDoubleTapListener.onDoubleTap(this.mCurrentDownEvent) || handled;
                                handled = this.mDoubleTapListener.onDoubleTapEvent(ev) || handled;
                            }
                            else {
                                this.mHandler.sendEmptyMessageDelayed(GestureDetector.TAP, GestureDetector.DOUBLE_TAP_TIMEOUT);
                            }
                        }
                        this.mDownFocusX = this.mLastFocusX = focusX;
                        this.mDownFocusY = this.mLastFocusY = focusY;
                        if (this.mCurrentDownEvent != null) {
                            this.mCurrentDownEvent.recycle();
                        }
                        this.mCurrentDownEvent = MotionEvent.obtain(ev);
                        this.mAlwaysInTapRegion = true;
                        this.mAlwaysInBiggerTapRegion = true;
                        this.mStillDown = true;
                        this.mInLongPress = false;
                        this.mDeferConfirmSingleTap = false;
                        if (this.mIsLongpressEnabled) {
                            this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                            this.mHandler.sendEmptyMessageAtTime(GestureDetector.LONG_PRESS, this.mCurrentDownEvent.getDownTime() + GestureDetector.TAP_TIMEOUT + GestureDetector.LONGPRESS_TIMEOUT);
                        }
                        this.mHandler.sendEmptyMessageAtTime(GestureDetector.SHOW_PRESS, this.mCurrentDownEvent.getDownTime() + GestureDetector.TAP_TIMEOUT);
                        handled = this.mListener.onDown(ev) || handled;
                        break;
                    case MotionEvent.ACTION_MOVE:
                        if (this.mInLongPress) {
                            break;
                        }
                        const scrollX = this.mLastFocusX - focusX;
                        const scrollY = this.mLastFocusY - focusY;
                        if (this.mIsDoubleTapping) {
                            handled = this.mDoubleTapListener.onDoubleTapEvent(ev) || handled;
                        }
                        else if (this.mAlwaysInTapRegion) {
                            const deltaX = Math.floor((focusX - this.mDownFocusX));
                            const deltaY = Math.floor((focusY - this.mDownFocusY));
                            let distance = (deltaX * deltaX) + (deltaY * deltaY);
                            if (distance > this.mTouchSlopSquare) {
                                handled = this.mListener.onScroll(this.mCurrentDownEvent, ev, scrollX, scrollY);
                                this.mLastFocusX = focusX;
                                this.mLastFocusY = focusY;
                                this.mAlwaysInTapRegion = false;
                                this.mHandler.removeMessages(GestureDetector.TAP);
                                this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                                this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                            }
                            if (distance > this.mDoubleTapTouchSlopSquare) {
                                this.mAlwaysInBiggerTapRegion = false;
                            }
                        }
                        else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                            handled = this.mListener.onScroll(this.mCurrentDownEvent, ev, scrollX, scrollY);
                            this.mLastFocusX = focusX;
                            this.mLastFocusY = focusY;
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        this.mStillDown = false;
                        let currentUpEvent = MotionEvent.obtain(ev);
                        if (this.mIsDoubleTapping) {
                            handled = this.mDoubleTapListener.onDoubleTapEvent(ev) || handled;
                        }
                        else if (this.mInLongPress) {
                            this.mHandler.removeMessages(GestureDetector.TAP);
                            this.mInLongPress = false;
                        }
                        else if (this.mAlwaysInTapRegion) {
                            handled = this.mListener.onSingleTapUp(ev);
                            if (this.mDeferConfirmSingleTap && this.mDoubleTapListener != null) {
                                this.mDoubleTapListener.onSingleTapConfirmed(ev);
                            }
                        }
                        else {
                            const velocityTracker = this.mVelocityTracker;
                            const pointerId = ev.getPointerId(0);
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumFlingVelocity);
                            const velocityY = velocityTracker.getYVelocity(pointerId);
                            const velocityX = velocityTracker.getXVelocity(pointerId);
                            if ((Math.abs(velocityY) > this.mMinimumFlingVelocity) || (Math.abs(velocityX) > this.mMinimumFlingVelocity)) {
                                handled = this.mListener.onFling(this.mCurrentDownEvent, ev, velocityX, velocityY);
                            }
                        }
                        if (this.mPreviousUpEvent != null) {
                            this.mPreviousUpEvent.recycle();
                        }
                        this.mPreviousUpEvent = currentUpEvent;
                        if (this.mVelocityTracker != null) {
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                        this.mIsDoubleTapping = false;
                        this.mDeferConfirmSingleTap = false;
                        this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                        this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        this.cancel();
                        break;
                }
                return handled;
            }
            cancel() {
                this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                this.mHandler.removeMessages(GestureDetector.TAP);
                this.mVelocityTracker.recycle();
                this.mVelocityTracker = null;
                this.mIsDoubleTapping = false;
                this.mStillDown = false;
                this.mAlwaysInTapRegion = false;
                this.mAlwaysInBiggerTapRegion = false;
                this.mDeferConfirmSingleTap = false;
                if (this.mInLongPress) {
                    this.mInLongPress = false;
                }
            }
            cancelTaps() {
                this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                this.mHandler.removeMessages(GestureDetector.TAP);
                this.mIsDoubleTapping = false;
                this.mAlwaysInTapRegion = false;
                this.mAlwaysInBiggerTapRegion = false;
                this.mDeferConfirmSingleTap = false;
                if (this.mInLongPress) {
                    this.mInLongPress = false;
                }
            }
            isConsideredDoubleTap(firstDown, firstUp, secondDown) {
                if (!this.mAlwaysInBiggerTapRegion) {
                    return false;
                }
                const deltaTime = secondDown.getEventTime() - firstUp.getEventTime();
                if (deltaTime > GestureDetector.DOUBLE_TAP_TIMEOUT || deltaTime < GestureDetector.DOUBLE_TAP_MIN_TIME) {
                    return false;
                }
                let deltaX = Math.floor(firstDown.getX()) - Math.floor(secondDown.getX());
                let deltaY = Math.floor(firstDown.getY()) - Math.floor(secondDown.getY());
                return (deltaX * deltaX + deltaY * deltaY < this.mDoubleTapSlopSquare);
            }
            dispatchLongPress() {
                this.mHandler.removeMessages(GestureDetector.TAP);
                this.mDeferConfirmSingleTap = false;
                this.mInLongPress = true;
                this.mListener.onLongPress(this.mCurrentDownEvent);
            }
        }
        GestureDetector.LONGPRESS_TIMEOUT = ViewConfiguration.getLongPressTimeout();
        GestureDetector.TAP_TIMEOUT = ViewConfiguration.getTapTimeout();
        GestureDetector.DOUBLE_TAP_TIMEOUT = ViewConfiguration.getDoubleTapTimeout();
        GestureDetector.DOUBLE_TAP_MIN_TIME = ViewConfiguration.getDoubleTapMinTime();
        GestureDetector.SHOW_PRESS = 1;
        GestureDetector.LONG_PRESS = 2;
        GestureDetector.TAP = 3;
        view.GestureDetector = GestureDetector;
        (function (GestureDetector) {
            class SimpleOnGestureListener {
                onSingleTapUp(e) {
                    return false;
                }
                onLongPress(e) {
                }
                onScroll(e1, e2, distanceX, distanceY) {
                    return false;
                }
                onFling(e1, e2, velocityX, velocityY) {
                    return false;
                }
                onShowPress(e) {
                }
                onDown(e) {
                    return false;
                }
                onDoubleTap(e) {
                    return false;
                }
                onDoubleTapEvent(e) {
                    return false;
                }
                onSingleTapConfirmed(e) {
                    return false;
                }
            }
            GestureDetector.SimpleOnGestureListener = SimpleOnGestureListener;
            class GestureHandler extends Handler {
                constructor(arg) {
                    super();
                    this._GestureDetector_this = arg;
                }
                handleMessage(msg) {
                    switch (msg.what) {
                        case GestureDetector.SHOW_PRESS:
                            this._GestureDetector_this.mListener.onShowPress(this._GestureDetector_this.mCurrentDownEvent);
                            break;
                        case GestureDetector.LONG_PRESS:
                            this._GestureDetector_this.dispatchLongPress();
                            break;
                        case GestureDetector.TAP:
                            if (this._GestureDetector_this.mDoubleTapListener != null) {
                                if (!this._GestureDetector_this.mStillDown) {
                                    this._GestureDetector_this.mDoubleTapListener.onSingleTapConfirmed(this._GestureDetector_this.mCurrentDownEvent);
                                }
                                else {
                                    this._GestureDetector_this.mDeferConfirmSingleTap = true;
                                }
                            }
                            break;
                        default:
                            throw Error(`new RuntimeException("Unknown message " + msg)`);
                    }
                }
            }
            GestureDetector.GestureHandler = GestureHandler;
        })(GestureDetector = view.GestureDetector || (view.GestureDetector = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var androidui;
(function (androidui) {
    var util;
    (function (util) {
        class NumberChecker {
            static warnNotNumber(...n) {
                try {
                    this.assetNotNumber(...n);
                }
                catch (e) {
                    console.error(e);
                    return true;
                }
                return false;
            }
            static assetNotNumber(...ns) {
                if (!this.checkIsNumber()) {
                    throw Error('assetNotNumber : ' + ns);
                }
            }
            static checkIsNumber(...ns) {
                if (ns == null)
                    return false;
                for (let n of ns) {
                    if (n == null || Number.isNaN(n))
                        return false;
                }
                return true;
            }
        }
        util.NumberChecker = NumberChecker;
    })(util = androidui.util || (androidui.util = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/10/17.
 */
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../view/animation/Interpolator.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../../androidui/util/NumberChecker.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ViewConfiguration = android.view.ViewConfiguration;
        var Resources = android.content.res.Resources;
        var SystemClock = android.os.SystemClock;
        var Log = android.util.Log;
        var NumberChecker = androidui.util.NumberChecker;
        class OverScroller {
            constructor(interpolator, flywheel = true) {
                this.mMode = 0;
                this.mFlywheel = true;
                this.mInterpolator = interpolator;
                this.mFlywheel = flywheel;
                this.mScrollerX = new SplineOverScroller();
                this.mScrollerY = new SplineOverScroller();
            }
            setInterpolator(interpolator) {
                this.mInterpolator = interpolator;
            }
            setFriction(friction) {
                NumberChecker.warnNotNumber(friction);
                this.mScrollerX.setFriction(friction);
                this.mScrollerY.setFriction(friction);
            }
            isFinished() {
                return this.mScrollerX.mFinished && this.mScrollerY.mFinished;
            }
            forceFinished(finished) {
                this.mScrollerX.mFinished = this.mScrollerY.mFinished = finished;
            }
            getCurrX() {
                return this.mScrollerX.mCurrentPosition;
            }
            getCurrY() {
                return this.mScrollerY.mCurrentPosition;
            }
            getCurrVelocity() {
                let squaredNorm = this.mScrollerX.mCurrVelocity * this.mScrollerX.mCurrVelocity;
                squaredNorm += this.mScrollerY.mCurrVelocity * this.mScrollerY.mCurrVelocity;
                return Math.sqrt(squaredNorm);
            }
            getStartX() {
                return this.mScrollerX.mStart;
            }
            getStartY() {
                return this.mScrollerY.mStart;
            }
            getFinalX() {
                return this.mScrollerX.mFinal;
            }
            getFinalY() {
                return this.mScrollerY.mFinal;
            }
            getDuration() {
                return Math.max(this.mScrollerX.mDuration, this.mScrollerY.mDuration);
            }
            computeScrollOffset() {
                if (this.isFinished()) {
                    return false;
                }
                switch (this.mMode) {
                    case OverScroller.SCROLL_MODE:
                        let time = SystemClock.uptimeMillis();
                        const elapsedTime = time - this.mScrollerX.mStartTime;
                        const duration = this.mScrollerX.mDuration;
                        if (elapsedTime < duration) {
                            let q = (elapsedTime) / duration;
                            if (this.mInterpolator == null) {
                                q = Scroller_viscousFluid(q);
                            }
                            else {
                                q = this.mInterpolator.getInterpolation(q);
                            }
                            this.mScrollerX.updateScroll(q);
                            this.mScrollerY.updateScroll(q);
                        }
                        else {
                            this.abortAnimation();
                        }
                        break;
                    case OverScroller.FLING_MODE:
                        if (!this.mScrollerX.mFinished) {
                            if (!this.mScrollerX.update()) {
                                if (!this.mScrollerX.continueWhenFinished()) {
                                    this.mScrollerX.finish();
                                }
                            }
                        }
                        if (!this.mScrollerY.mFinished) {
                            if (!this.mScrollerY.update()) {
                                if (!this.mScrollerY.continueWhenFinished()) {
                                    this.mScrollerY.finish();
                                }
                            }
                        }
                        break;
                }
                return true;
            }
            startScroll(startX, startY, dx, dy, duration = OverScroller.DEFAULT_DURATION) {
                NumberChecker.warnNotNumber(startX, startY, dx, dy, duration);
                this.mMode = OverScroller.SCROLL_MODE;
                this.mScrollerX.startScroll(startX, dx, duration);
                this.mScrollerY.startScroll(startY, dy, duration);
            }
            springBack(startX, startY, minX, maxX, minY, maxY) {
                NumberChecker.warnNotNumber(startX, startY, minX, maxX, minY, maxY);
                this.mMode = OverScroller.FLING_MODE;
                const spingbackX = this.mScrollerX.springback(startX, minX, maxX);
                const spingbackY = this.mScrollerY.springback(startY, minY, maxY);
                return spingbackX || spingbackY;
            }
            fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX = 0, overY = 0) {
                NumberChecker.warnNotNumber(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX, overY);
                if (this.mFlywheel && !this.isFinished()) {
                    let oldVelocityX = this.mScrollerX.mCurrVelocity;
                    let oldVelocityY = this.mScrollerY.mCurrVelocity;
                    if (Math_signum(velocityX) == Math_signum(oldVelocityX) &&
                        Math_signum(velocityY) == Math_signum(oldVelocityY)) {
                        velocityX += oldVelocityX;
                        velocityY += oldVelocityY;
                    }
                }
                this.mMode = OverScroller.FLING_MODE;
                this.mScrollerX.fling(startX, velocityX, minX, maxX, overX);
                this.mScrollerY.fling(startY, velocityY, minY, maxY, overY);
            }
            notifyHorizontalEdgeReached(startX, finalX, overX) {
                NumberChecker.warnNotNumber(startX, finalX, overX);
                this.mScrollerX.notifyEdgeReached(startX, finalX, overX);
            }
            notifyVerticalEdgeReached(startY, finalY, overY) {
                NumberChecker.warnNotNumber(startY, finalY, overY);
                this.mScrollerY.notifyEdgeReached(startY, finalY, overY);
            }
            isOverScrolled() {
                return ((!this.mScrollerX.mFinished &&
                    this.mScrollerX.mState != SplineOverScroller.SPLINE) ||
                    (!this.mScrollerY.mFinished &&
                        this.mScrollerY.mState != SplineOverScroller.SPLINE));
            }
            abortAnimation() {
                this.mScrollerX.finish();
                this.mScrollerY.finish();
            }
            timePassed() {
                const time = SystemClock.uptimeMillis();
                const startTime = Math.min(this.mScrollerX.mStartTime, this.mScrollerY.mStartTime);
                return (time - startTime);
            }
            isScrollingInDirection(xvel, yvel) {
                const dx = this.mScrollerX.mFinal - this.mScrollerX.mStart;
                const dy = this.mScrollerY.mFinal - this.mScrollerY.mStart;
                return !this.isFinished() && Math_signum(xvel) == Math_signum(dx) &&
                    Math_signum(yvel) == Math_signum(dy);
            }
        }
        OverScroller.DEFAULT_DURATION = 250;
        OverScroller.SCROLL_MODE = 0;
        OverScroller.FLING_MODE = 1;
        widget.OverScroller = OverScroller;
        class SplineOverScroller {
            constructor() {
                this.mStart = 0;
                this.mCurrentPosition = 0;
                this.mFinal = 0;
                this.mVelocity = 0;
                this._mCurrVelocity = 0;
                this.mDeceleration = 0;
                this.mStartTime = 0;
                this.mDuration = 0;
                this.mSplineDuration = 0;
                this.mSplineDistance = 0;
                this.mFinished = false;
                this.mOver = 0;
                this.mFlingFriction = ViewConfiguration.getScrollFriction();
                this.mState = SplineOverScroller.SPLINE;
                this.mPhysicalCoeff = 0;
                this.mFinished = true;
                let ppi = Resources.getDisplayMetrics().density * 160;
                this.mPhysicalCoeff = 9.80665
                    * 39.37
                    * ppi
                    * 0.84;
            }
            get mCurrVelocity() {
                return this._mCurrVelocity;
            }
            set mCurrVelocity(value) {
                if (!NumberChecker.checkIsNumber(value)) {
                    value = 0;
                }
                this._mCurrVelocity = value;
            }
            setFriction(friction) {
                this.mFlingFriction = friction;
            }
            updateScroll(q) {
                this.mCurrentPosition = this.mStart + Math.round(q * (this.mFinal - this.mStart));
            }
            static getDeceleration(velocity) {
                return velocity > 0 ? -SplineOverScroller.GRAVITY : SplineOverScroller.GRAVITY;
            }
            adjustDuration(start, oldFinal, newFinal) {
                let oldDistance = oldFinal - start;
                let newDistance = newFinal - start;
                let x = Math.abs(newDistance / oldDistance);
                let index = Math.floor(SplineOverScroller.NB_SAMPLES * x);
                if (index < SplineOverScroller.NB_SAMPLES) {
                    let x_inf = index / SplineOverScroller.NB_SAMPLES;
                    let x_sup = (index + 1) / SplineOverScroller.NB_SAMPLES;
                    let t_inf = SplineOverScroller.SPLINE_TIME[index];
                    let t_sup = SplineOverScroller.SPLINE_TIME[index + 1];
                    let timeCoef = t_inf + (x - x_inf) / (x_sup - x_inf) * (t_sup - t_inf);
                    this.mDuration *= timeCoef;
                }
            }
            startScroll(start, distance, duration) {
                this.mFinished = false;
                this.mStart = start;
                this.mFinal = start + distance;
                this.mStartTime = SystemClock.uptimeMillis();
                this.mDuration = duration;
                this.mDeceleration = 0;
                this.mVelocity = 0;
            }
            finish() {
                this.mCurrentPosition = this.mFinal;
                this.mFinished = true;
            }
            setFinalPosition(position) {
                this.mFinal = position;
                this.mFinished = false;
            }
            extendDuration(extend) {
                let time = SystemClock.uptimeMillis();
                let elapsedTime = (time - this.mStartTime);
                this.mDuration = elapsedTime + extend;
                this.mFinished = false;
            }
            springback(start, min, max) {
                this.mFinished = true;
                this.mStart = this.mFinal = start;
                this.mVelocity = 0;
                this.mStartTime = SystemClock.uptimeMillis();
                this.mDuration = 0;
                if (start < min) {
                    this.startSpringback(start, min, 0);
                }
                else if (start > max) {
                    this.startSpringback(start, max, 0);
                }
                return !this.mFinished;
            }
            startSpringback(start, end, velocity) {
                this.mFinished = false;
                this.mState = SplineOverScroller.CUBIC;
                this.mStart = start;
                this.mFinal = end;
                const delta = start - end;
                this.mDeceleration = SplineOverScroller.getDeceleration(delta);
                this.mVelocity = -delta;
                this.mOver = Math.abs(delta);
                const density = android.content.res.Resources.getDisplayMetrics().density;
                this.mDuration = Math.floor(1000.0 * Math.sqrt(-2.0 * (delta / density) / this.mDeceleration));
            }
            fling(start, velocity, min, max, over) {
                this.mOver = over;
                this.mFinished = false;
                this.mCurrVelocity = this.mVelocity = velocity;
                this.mDuration = this.mSplineDuration = 0;
                this.mStartTime = SystemClock.uptimeMillis();
                this.mCurrentPosition = this.mStart = start;
                if (start > max || start < min) {
                    this.startAfterEdge(start, min, max, velocity);
                    return;
                }
                this.mState = SplineOverScroller.SPLINE;
                let totalDistance = 0.0;
                if (velocity != 0) {
                    this.mDuration = this.mSplineDuration = this.getSplineFlingDuration(velocity);
                    totalDistance = this.getSplineFlingDistance(velocity);
                }
                this.mSplineDistance = (totalDistance * Math_signum(velocity));
                this.mFinal = start + this.mSplineDistance;
                if (this.mFinal < min) {
                    this.adjustDuration(this.mStart, this.mFinal, min);
                    this.mFinal = min;
                }
                if (this.mFinal > max) {
                    this.adjustDuration(this.mStart, this.mFinal, max);
                    this.mFinal = max;
                }
            }
            getSplineDeceleration(velocity) {
                return Math.log(SplineOverScroller.INFLEXION * Math.abs(velocity) / (this.mFlingFriction * this.mPhysicalCoeff));
            }
            getSplineFlingDistance(velocity) {
                let l = this.getSplineDeceleration(velocity);
                let decelMinusOne = SplineOverScroller.DECELERATION_RATE - 1.0;
                return this.mFlingFriction * this.mPhysicalCoeff * Math.exp(SplineOverScroller.DECELERATION_RATE / decelMinusOne * l);
            }
            getSplineFlingDuration(velocity) {
                let l = this.getSplineDeceleration(velocity);
                let decelMinusOne = SplineOverScroller.DECELERATION_RATE - 1.0;
                return (1000.0 * Math.exp(l / decelMinusOne));
            }
            fitOnBounceCurve(start, end, velocity) {
                let durationToApex = -velocity / this.mDeceleration;
                let distanceToApex = velocity * velocity / 2.0 / Math.abs(this.mDeceleration);
                let distanceToEdge = Math.abs(end - start);
                let totalDuration = Math.sqrt(2.0 * (distanceToApex + distanceToEdge) / Math.abs(this.mDeceleration));
                this.mStartTime -= (1000 * (totalDuration - durationToApex));
                this.mStart = end;
                this.mVelocity = (-this.mDeceleration * totalDuration);
            }
            startBounceAfterEdge(start, end, velocity) {
                this.mDeceleration = SplineOverScroller.getDeceleration(velocity == 0 ? start - end : velocity);
                this.fitOnBounceCurve(start, end, velocity);
                this.onEdgeReached();
            }
            startAfterEdge(start, min, max, velocity) {
                if (start > min && start < max) {
                    Log.e("OverScroller", "startAfterEdge called from a valid position");
                    this.mFinished = true;
                    return;
                }
                const positive = start > max;
                const edge = positive ? max : min;
                const overDistance = start - edge;
                let keepIncreasing = overDistance * velocity >= 0;
                if (keepIncreasing) {
                    this.startBounceAfterEdge(start, edge, velocity);
                }
                else {
                    const totalDistance = this.getSplineFlingDistance(velocity);
                    if (totalDistance > Math.abs(overDistance)) {
                        this.fling(start, velocity, positive ? min : start, positive ? start : max, this.mOver);
                    }
                    else {
                        this.startSpringback(start, edge, velocity);
                    }
                }
            }
            notifyEdgeReached(start, end, over) {
                if (this.mState == SplineOverScroller.SPLINE) {
                    this.mOver = over;
                    this.mStartTime = SystemClock.uptimeMillis();
                    this.startAfterEdge(start, end, end, this.mCurrVelocity);
                }
            }
            onEdgeReached() {
                let distance = this.mVelocity * this.mVelocity / (2 * Math.abs(this.mDeceleration));
                const sign = Math_signum(this.mVelocity);
                if (distance > this.mOver) {
                    this.mDeceleration = -sign * this.mVelocity * this.mVelocity / (2.0 * this.mOver);
                    distance = this.mOver;
                }
                this.mOver = distance;
                this.mState = SplineOverScroller.BALLISTIC;
                this.mFinal = this.mStart + (this.mVelocity > 0 ? distance : -distance);
                this.mDuration = -(1000 * this.mVelocity / this.mDeceleration);
            }
            continueWhenFinished() {
                switch (this.mState) {
                    case SplineOverScroller.SPLINE:
                        if (this.mDuration < this.mSplineDuration) {
                            this.mStart = this.mFinal;
                            this.mVelocity = this.mCurrVelocity;
                            this.mDeceleration = SplineOverScroller.getDeceleration(this.mVelocity);
                            this.mStartTime += this.mDuration;
                            this.onEdgeReached();
                        }
                        else {
                            return false;
                        }
                        break;
                    case SplineOverScroller.BALLISTIC:
                        this.mStartTime += this.mDuration;
                        this.startSpringback(this.mFinal, this.mStart, 0);
                        break;
                    case SplineOverScroller.CUBIC:
                        return false;
                }
                this.update();
                return true;
            }
            update() {
                const time = SystemClock.uptimeMillis();
                const currentTime = time - this.mStartTime;
                if (currentTime > this.mDuration) {
                    return false;
                }
                let distance = 0;
                switch (this.mState) {
                    case SplineOverScroller.SPLINE: {
                        const t = currentTime / this.mSplineDuration;
                        const index = Math.floor(SplineOverScroller.NB_SAMPLES * t);
                        let distanceCoef = 1;
                        let velocityCoef = 0;
                        if (index < SplineOverScroller.NB_SAMPLES) {
                            const t_inf = index / SplineOverScroller.NB_SAMPLES;
                            const t_sup = (index + 1) / SplineOverScroller.NB_SAMPLES;
                            const d_inf = SplineOverScroller.SPLINE_POSITION[index];
                            const d_sup = SplineOverScroller.SPLINE_POSITION[index + 1];
                            velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                            distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                        }
                        distance = distanceCoef * this.mSplineDistance;
                        this.mCurrVelocity = velocityCoef * this.mSplineDistance / this.mSplineDuration * 1000;
                        break;
                    }
                    case SplineOverScroller.BALLISTIC: {
                        const t = currentTime / 1000;
                        this.mCurrVelocity = this.mVelocity + this.mDeceleration * t;
                        distance = this.mVelocity * t + this.mDeceleration * t * t / 2;
                        break;
                    }
                    case SplineOverScroller.CUBIC: {
                        const t = (currentTime) / this.mDuration;
                        const t2 = t * t;
                        const sign = Math_signum(this.mVelocity);
                        distance = sign * this.mOver * (3 * t2 - 2 * t * t2);
                        this.mCurrVelocity = sign * this.mOver * 6 * (-t + t2);
                        break;
                    }
                }
                this.mCurrentPosition = this.mStart + Math.round(distance);
                return true;
            }
        }
        SplineOverScroller.DECELERATION_RATE = (Math.log(0.78) / Math.log(0.9));
        SplineOverScroller.INFLEXION = 0.35;
        SplineOverScroller.START_TENSION = 0.5;
        SplineOverScroller.END_TENSION = 1.0;
        SplineOverScroller.P1 = SplineOverScroller.START_TENSION * SplineOverScroller.INFLEXION;
        SplineOverScroller.P2 = 1.0 - SplineOverScroller.END_TENSION * (1 - SplineOverScroller.INFLEXION);
        SplineOverScroller.NB_SAMPLES = 100;
        SplineOverScroller.SPLINE_POSITION = new Array(SplineOverScroller.NB_SAMPLES + 1);
        SplineOverScroller.SPLINE_TIME = new Array(SplineOverScroller.NB_SAMPLES + 1);
        SplineOverScroller.SPLINE = 0;
        SplineOverScroller.CUBIC = 1;
        SplineOverScroller.BALLISTIC = 2;
        SplineOverScroller.GRAVITY = 2000;
        SplineOverScroller._staticFunc = function () {
            let x_min = 0.0;
            let y_min = 0.0;
            for (let i = 0; i < SplineOverScroller.NB_SAMPLES; i++) {
                const alpha = i / SplineOverScroller.NB_SAMPLES;
                let x_max = 1.0;
                let x, tx, coef;
                while (true) {
                    x = x_min + (x_max - x_min) / 2.0;
                    coef = 3.0 * x * (1.0 - x);
                    tx = coef * ((1.0 - x) * SplineOverScroller.P1 + x * SplineOverScroller.P2) + x * x * x;
                    if (Math.abs(tx - alpha) < 1E-5)
                        break;
                    if (tx > alpha)
                        x_max = x;
                    else
                        x_min = x;
                }
                SplineOverScroller.SPLINE_POSITION[i] = coef * ((1.0 - x) * SplineOverScroller.START_TENSION + x) + x * x * x;
                let y_max = 1.0;
                let y, dy;
                while (true) {
                    y = y_min + (y_max - y_min) / 2.0;
                    coef = 3.0 * y * (1.0 - y);
                    dy = coef * ((1.0 - y) * SplineOverScroller.START_TENSION + y) + y * y * y;
                    if (Math.abs(dy - alpha) < 1E-5)
                        break;
                    if (dy > alpha)
                        y_max = y;
                    else
                        y_min = y;
                }
                SplineOverScroller.SPLINE_TIME[i] = coef * ((1.0 - y) * SplineOverScroller.P1 + y * SplineOverScroller.P2) + y * y * y;
            }
            SplineOverScroller.SPLINE_POSITION[SplineOverScroller.NB_SAMPLES] = SplineOverScroller.SPLINE_TIME[SplineOverScroller.NB_SAMPLES] = 1.0;
        }();
        function Math_signum(value) {
            if (value === 0 || Number.isNaN(value))
                return value;
            return Math.abs(value) === value ? 1 : -1;
        }
        let sViscousFluidScale = 8;
        let sViscousFluidNormalize = 1;
        function Scroller_viscousFluid(x) {
            x *= sViscousFluidScale;
            if (x < 1) {
                x -= (1 - Math.exp(-x));
            }
            else {
                let start = 0.36787944117;
                x = 1 - Math.exp(1 - x);
                x = start + x * (1 - start);
            }
            x *= sViscousFluidNormalize;
            return x;
        }
        sViscousFluidNormalize = 1 / Scroller_viscousFluid(1);
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/17.
 */
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../view/MotionEvent.ts"/>
///<reference path="FrameLayout.ts"/>
///<reference path="OverScroller.ts"/>
///<reference path="../view/VelocityTracker.ts"/>
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../view/FocusFinder.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../graphics/Rect.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var MeasureSpec = View.MeasureSpec;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var ViewConfiguration = android.view.ViewConfiguration;
        var Rect = android.graphics.Rect;
        var OverScroller = android.widget.OverScroller;
        var Log = android.util.Log;
        var SystemClock = android.os.SystemClock;
        var KeyEvent = android.view.KeyEvent;
        var FocusFinder = android.view.FocusFinder;
        class ScrollView extends widget.FrameLayout {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mLastScroll = 0;
                this.mTempRect = new Rect();
                this.mLastMotionY = 0;
                this.mIsLayoutDirty = true;
                this.mIsBeingDragged = false;
                this.mFillViewport = false;
                this.mSmoothScrollingEnabled = true;
                this.mMinimumVelocity = 0;
                this.mMaximumVelocity = 0;
                this.mOverscrollDistance = 0;
                this._mOverflingDistance = 0;
                this.mActivePointerId = ScrollView.INVALID_POINTER;
                this.initScrollView();
                this._attrBinder.addAttr('fillViewport', (value) => {
                    this.setFillViewport(this._attrBinder.parseBoolean(value));
                });
            }
            get mOverflingDistance() {
                let height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                let bottom = this.getChildAt(0).getHeight();
                let minOverY = this.mScrollY < 0 ? -this.mScrollY : this.mScrollY - (bottom - height);
                return Math.max(this._mOverflingDistance, minOverY + this._mOverflingDistance);
            }
            set mOverflingDistance(value) {
                this._mOverflingDistance = value;
            }
            shouldDelayChildPressedState() {
                return true;
            }
            getMaxScrollAmount() {
                return (ScrollView.MAX_SCROLL_FACTOR * (this.mBottom - this.mTop));
            }
            initScrollView() {
                this.mScroller = new OverScroller();
                this.setFocusable(true);
                this.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
                this.setWillNotDraw(false);
                const configuration = ViewConfiguration.get();
                this.mTouchSlop = configuration.getScaledTouchSlop();
                this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mOverscrollDistance = configuration.getScaledOverscrollDistance();
                this.mOverflingDistance = configuration.getScaledOverflingDistance();
                this.initScrollCache();
                this.setVerticalScrollBarEnabled(true);
            }
            addView(...args) {
                if (this.getChildCount() > 0) {
                    throw new Error("ScrollView can host only one direct child");
                }
                return super.addView(...args);
            }
            canScroll() {
                let child = this.getChildAt(0);
                if (child != null) {
                    let childHeight = child.getHeight();
                    return this.getHeight() < childHeight + this.mPaddingTop + this.mPaddingBottom;
                }
                return false;
            }
            isFillViewport() {
                return this.mFillViewport;
            }
            setFillViewport(fillViewport) {
                if (fillViewport != this.mFillViewport) {
                    this.mFillViewport = fillViewport;
                    this.requestLayout();
                }
            }
            isSmoothScrollingEnabled() {
                return this.mSmoothScrollingEnabled;
            }
            setSmoothScrollingEnabled(smoothScrollingEnabled) {
                this.mSmoothScrollingEnabled = smoothScrollingEnabled;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                if (!this.mFillViewport) {
                    return;
                }
                const heightMode = MeasureSpec.getMode(heightMeasureSpec);
                if (heightMode == MeasureSpec.UNSPECIFIED) {
                    return;
                }
                if (this.getChildCount() > 0) {
                    const child = this.getChildAt(0);
                    let height = this.getMeasuredHeight();
                    if (child.getMeasuredHeight() < height) {
                        const lp = child.getLayoutParams();
                        let childWidthMeasureSpec = widget.FrameLayout.getChildMeasureSpec(widthMeasureSpec, this.mPaddingLeft + this.mPaddingRight, lp.width);
                        height -= this.mPaddingTop;
                        height -= this.mPaddingBottom;
                        let childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            dispatchKeyEvent(event) {
                return super.dispatchKeyEvent(event) || this.executeKeyEvent(event);
            }
            executeKeyEvent(event) {
                this.mTempRect.setEmpty();
                if (!this.canScroll()) {
                    if (this.isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
                        let currentFocused = this.findFocus();
                        if (currentFocused == this)
                            currentFocused = null;
                        let nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_DOWN);
                        return nextFocused != null
                            && nextFocused != this
                            && nextFocused.requestFocus(View.FOCUS_DOWN);
                    }
                    return false;
                }
                let handled = false;
                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    switch (event.getKeyCode()) {
                        case KeyEvent.KEYCODE_DPAD_UP:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_UP);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_DOWN:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_DOWN);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            this.pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
                            break;
                    }
                }
                return handled;
            }
            inChild(x, y) {
                if (this.getChildCount() > 0) {
                    const scrollY = this.mScrollY;
                    const child = this.getChildAt(0);
                    return !(y < child.getTop() - scrollY
                        || y >= child.getBottom() - scrollY
                        || x < child.getLeft()
                        || x >= child.getRight());
                }
                return false;
            }
            initOrResetVelocityTracker() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    this.mVelocityTracker.clear();
                }
            }
            initVelocityTrackerIfNotExists() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
            }
            recycleVelocityTracker() {
                if (this.mVelocityTracker != null) {
                    this.mVelocityTracker.recycle();
                    this.mVelocityTracker = null;
                }
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept) {
                    this.recycleVelocityTracker();
                }
                super.requestDisallowInterceptTouchEvent(disallowIntercept);
            }
            onInterceptTouchEvent(ev) {
                /*
                 * This method JUST determines whether we want to intercept the motion.
                 * If we return true, onMotionEvent will be called and we do the actual
                 * scrolling there.
                 */
                const action = ev.getAction();
                if ((action == MotionEvent.ACTION_MOVE) && (this.mIsBeingDragged)) {
                    return true;
                }
                if (this.getScrollY() == 0 && !this.canScrollVertically(1)) {
                    return false;
                }
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_MOVE:
                        {
                            const activePointerId = this.mActivePointerId;
                            if (activePointerId == ScrollView.INVALID_POINTER) {
                                break;
                            }
                            const pointerIndex = ev.findPointerIndex(activePointerId);
                            if (pointerIndex == -1) {
                                Log.e(ScrollView.TAG, "Invalid pointerId=" + activePointerId
                                    + " in onInterceptTouchEvent");
                                break;
                            }
                            const y = ev.getY(pointerIndex);
                            const yDiff = Math.abs(y - this.mLastMotionY);
                            if (yDiff > this.mTouchSlop) {
                                this.mIsBeingDragged = true;
                                this.mLastMotionY = y;
                                this.initVelocityTrackerIfNotExists();
                                this.mVelocityTracker.addMovement(ev);
                                const parent = this.getParent();
                                if (parent != null) {
                                    parent.requestDisallowInterceptTouchEvent(true);
                                }
                            }
                            break;
                        }
                    case MotionEvent.ACTION_DOWN:
                        {
                            const y = ev.getY();
                            if (!this.inChild(ev.getX(), y)) {
                                this.mIsBeingDragged = false;
                                this.recycleVelocityTracker();
                                break;
                            }
                            this.mLastMotionY = y;
                            this.mActivePointerId = ev.getPointerId(0);
                            this.initOrResetVelocityTracker();
                            this.mVelocityTracker.addMovement(ev);
                            this.mIsBeingDragged = !this.mScroller.isFinished();
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        this.mIsBeingDragged = false;
                        this.mActivePointerId = ScrollView.INVALID_POINTER;
                        this.recycleVelocityTracker();
                        if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, 0, 0, this.getScrollRange())) {
                            this.postInvalidateOnAnimation();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        break;
                }
                return this.mIsBeingDragged;
            }
            onTouchEvent(ev) {
                this.initVelocityTrackerIfNotExists();
                this.mVelocityTracker.addMovement(ev);
                const action = ev.getAction();
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            if (this.getChildCount() == 0) {
                                return false;
                            }
                            if ((this.mIsBeingDragged = !this.mScroller.isFinished())) {
                                const parent = this.getParent();
                                if (parent != null) {
                                    parent.requestDisallowInterceptTouchEvent(true);
                                }
                            }
                            if (!this.mScroller.isFinished()) {
                                this.mScroller.abortAnimation();
                            }
                            this.mLastMotionY = ev.getY();
                            this.mActivePointerId = ev.getPointerId(0);
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                        if (activePointerIndex == -1) {
                            Log.e(ScrollView.TAG, "Invalid pointerId=" + this.mActivePointerId + " in onTouchEvent");
                            break;
                        }
                        const y = ev.getY(activePointerIndex);
                        let deltaY = this.mLastMotionY - y;
                        if (!this.mIsBeingDragged && Math.abs(deltaY) > this.mTouchSlop) {
                            const parent = this.getParent();
                            if (parent != null) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                            this.mIsBeingDragged = true;
                            if (deltaY > 0) {
                                deltaY -= this.mTouchSlop;
                            }
                            else {
                                deltaY += this.mTouchSlop;
                            }
                        }
                        if (this.mIsBeingDragged) {
                            this.mLastMotionY = y;
                            const oldX = this.mScrollX;
                            const oldY = this.mScrollY;
                            const range = this.getScrollRange();
                            const overscrollMode = this.getOverScrollMode();
                            const canOverscroll = overscrollMode == ScrollView.OVER_SCROLL_ALWAYS ||
                                (overscrollMode == ScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                            if (this.overScrollBy(0, deltaY, 0, this.mScrollY, 0, range, 0, this.mOverscrollDistance, true)) {
                                this.mVelocityTracker.clear();
                            }
                            if (canOverscroll) {
                                const pulledToY = oldY + deltaY;
                                if (pulledToY < 0) {
                                }
                                else if (pulledToY > range) {
                                }
                            }
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        if (this.mIsBeingDragged) {
                            let velocityTracker = this.mVelocityTracker;
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                            let initialVelocity = velocityTracker.getYVelocity(this.mActivePointerId);
                            if (this.getChildCount() > 0) {
                                let forceSpringBack = (this.mScrollY < -this._mOverflingDistance && initialVelocity > 0)
                                    || (this.mScrollY > (this.getScrollRange() + this._mOverflingDistance) && initialVelocity < 0);
                                if (!forceSpringBack && (Math.abs(initialVelocity) > this.mMinimumVelocity)) {
                                    this.fling(-initialVelocity);
                                }
                                else {
                                    if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, 0, 0, this.getScrollRange())) {
                                        this.postInvalidateOnAnimation();
                                    }
                                }
                            }
                            this.mActivePointerId = ScrollView.INVALID_POINTER;
                            this.endDrag();
                        }
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        if (this.mIsBeingDragged && this.getChildCount() > 0) {
                            if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, 0, 0, this.getScrollRange())) {
                                this.postInvalidateOnAnimation();
                            }
                            this.mActivePointerId = ScrollView.INVALID_POINTER;
                            this.endDrag();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_DOWN:
                        {
                            const index = ev.getActionIndex();
                            this.mLastMotionY = ev.getY(index);
                            this.mActivePointerId = ev.getPointerId(index);
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        this.mLastMotionY = ev.getY(ev.findPointerIndex(this.mActivePointerId));
                        break;
                }
                return true;
            }
            onSecondaryPointerUp(ev) {
                const pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>
                    MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                const pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == this.mActivePointerId) {
                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    this.mLastMotionY = ev.getY(newPointerIndex);
                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                    if (this.mVelocityTracker != null) {
                        this.mVelocityTracker.clear();
                    }
                }
            }
            onGenericMotionEvent(event) {
                switch (event.getAction()) {
                    case MotionEvent.ACTION_SCROLL: {
                        if (!this.mIsBeingDragged) {
                            const vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                            if (vscroll != 0) {
                                const delta = Math.floor(vscroll * this.getVerticalScrollFactor());
                                const range = this.getScrollRange();
                                let oldScrollY = this.mScrollY;
                                let newScrollY = oldScrollY - delta;
                                if (newScrollY < 0) {
                                    newScrollY = 0;
                                }
                                else if (newScrollY > range) {
                                    newScrollY = range;
                                }
                                if (newScrollY != oldScrollY) {
                                    super.scrollTo(this.mScrollX, newScrollY);
                                    return true;
                                }
                            }
                        }
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
                if (!this.mScroller.isFinished()) {
                    const oldX = this.mScrollX;
                    const oldY = this.mScrollY;
                    this.mScrollX = scrollX;
                    this.mScrollY = scrollY;
                    this.invalidateParentIfNeeded();
                    this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                }
                else {
                    super.scrollTo(scrollX, scrollY);
                }
                if (!this.awakenScrollBars()) {
                    this.postInvalidateOnAnimation();
                }
            }
            getScrollRange() {
                let scrollRange = 0;
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    scrollRange = Math.max(0, child.getHeight() - (this.getHeight() - this.mPaddingBottom - this.mPaddingTop));
                }
                return scrollRange;
            }
            findFocusableViewInBounds(topFocus, top, bottom) {
                let focusables = this.getFocusables(View.FOCUS_FORWARD);
                let focusCandidate = null;
                let foundFullyContainedFocusable = false;
                let count = focusables.size();
                for (let i = 0; i < count; i++) {
                    let view = focusables.get(i);
                    let viewTop = view.getTop();
                    let viewBottom = view.getBottom();
                    if (top < viewBottom && viewTop < bottom) {
                        const viewIsFullyContained = (top < viewTop) && (viewBottom < bottom);
                        if (focusCandidate == null) {
                            focusCandidate = view;
                            foundFullyContainedFocusable = viewIsFullyContained;
                        }
                        else {
                            const viewIsCloserToBoundary = (topFocus && viewTop < focusCandidate.getTop()) || (!topFocus && viewBottom > focusCandidate.getBottom());
                            if (foundFullyContainedFocusable) {
                                if (viewIsFullyContained && viewIsCloserToBoundary) {
                                    focusCandidate = view;
                                }
                            }
                            else {
                                if (viewIsFullyContained) {
                                    focusCandidate = view;
                                    foundFullyContainedFocusable = true;
                                }
                                else if (viewIsCloserToBoundary) {
                                    focusCandidate = view;
                                }
                            }
                        }
                    }
                }
                return focusCandidate;
            }
            pageScroll(direction) {
                let down = direction == View.FOCUS_DOWN;
                let height = this.getHeight();
                if (down) {
                    this.mTempRect.top = this.getScrollY() + height;
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(count - 1);
                        if (this.mTempRect.top + height > view.getBottom()) {
                            this.mTempRect.top = view.getBottom() - height;
                        }
                    }
                }
                else {
                    this.mTempRect.top = this.getScrollY() - height;
                    if (this.mTempRect.top < 0) {
                        this.mTempRect.top = 0;
                    }
                }
                this.mTempRect.bottom = this.mTempRect.top + height;
                return this.scrollAndFocus(direction, this.mTempRect.top, this.mTempRect.bottom);
            }
            fullScroll(direction) {
                let down = direction == View.FOCUS_DOWN;
                let height = this.getHeight();
                this.mTempRect.top = 0;
                this.mTempRect.bottom = height;
                if (down) {
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(count - 1);
                        this.mTempRect.bottom = view.getBottom() + this.mPaddingBottom;
                        this.mTempRect.top = this.mTempRect.bottom - height;
                    }
                }
                return this.scrollAndFocus(direction, this.mTempRect.top, this.mTempRect.bottom);
            }
            scrollAndFocus(direction, top, bottom) {
                let handled = true;
                let height = this.getHeight();
                let containerTop = this.getScrollY();
                let containerBottom = containerTop + height;
                let up = direction == View.FOCUS_UP;
                let newFocused = this.findFocusableViewInBounds(up, top, bottom);
                if (newFocused == null) {
                    newFocused = this;
                }
                if (top >= containerTop && bottom <= containerBottom) {
                    handled = false;
                }
                else {
                    let delta = up ? (top - containerTop) : (bottom - containerBottom);
                    this.doScrollY(delta);
                }
                if (newFocused != this.findFocus())
                    newFocused.requestFocus(direction);
                return handled;
            }
            arrowScroll(direction) {
                let currentFocused = this.findFocus();
                if (currentFocused == this)
                    currentFocused = null;
                let nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
                const maxJump = this.getMaxScrollAmount();
                if (nextFocused != null && this.isWithinDeltaOfScreen(nextFocused, maxJump, this.getHeight())) {
                    nextFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(nextFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollY(scrollDelta);
                    nextFocused.requestFocus(direction);
                }
                else {
                    let scrollDelta = maxJump;
                    if (direction == View.FOCUS_UP && this.getScrollY() < scrollDelta) {
                        scrollDelta = this.getScrollY();
                    }
                    else if (direction == View.FOCUS_DOWN) {
                        if (this.getChildCount() > 0) {
                            let daBottom = this.getChildAt(0).getBottom();
                            let screenBottom = this.getScrollY() + this.getHeight() - this.mPaddingBottom;
                            if (daBottom - screenBottom < maxJump) {
                                scrollDelta = daBottom - screenBottom;
                            }
                        }
                    }
                    if (scrollDelta == 0) {
                        return false;
                    }
                    this.doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
                }
                if (currentFocused != null && currentFocused.isFocused() && this.isOffScreen(currentFocused)) {
                    const descendantFocusability = this.getDescendantFocusability();
                    this.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
                    this.requestFocus();
                    this.setDescendantFocusability(descendantFocusability);
                }
                return true;
            }
            isOffScreen(descendant) {
                return !this.isWithinDeltaOfScreen(descendant, 0, this.getHeight());
            }
            isWithinDeltaOfScreen(descendant, delta, height) {
                descendant.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(descendant, this.mTempRect);
                return (this.mTempRect.bottom + delta) >= this.getScrollY()
                    && (this.mTempRect.top - delta) <= (this.getScrollY() + height);
            }
            doScrollY(delta) {
                if (delta != 0) {
                    if (this.mSmoothScrollingEnabled) {
                        this.smoothScrollBy(0, delta);
                    }
                    else {
                        this.scrollBy(0, delta);
                    }
                }
            }
            smoothScrollBy(dx, dy) {
                if (this.getChildCount() == 0) {
                    return;
                }
                let duration = SystemClock.uptimeMillis() - this.mLastScroll;
                if (duration > ScrollView.ANIMATED_SCROLL_GAP) {
                    const height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                    const bottom = this.getChildAt(0).getHeight();
                    const maxY = Math.max(0, bottom - height);
                    const scrollY = this.mScrollY;
                    dy = Math.max(0, Math.min(scrollY + dy, maxY)) - scrollY;
                    this.mScroller.startScroll(this.mScrollX, scrollY, 0, dy);
                    this.postInvalidateOnAnimation();
                }
                else {
                    if (!this.mScroller.isFinished()) {
                        this.mScroller.abortAnimation();
                    }
                    this.scrollBy(dx, dy);
                }
                this.mLastScroll = SystemClock.uptimeMillis();
            }
            smoothScrollTo(x, y) {
                this.smoothScrollBy(x - this.mScrollX, y - this.mScrollY);
            }
            computeVerticalScrollRange() {
                const count = this.getChildCount();
                const contentHeight = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                if (count == 0) {
                    return contentHeight;
                }
                let scrollRange = this.getChildAt(0).getBottom();
                const scrollY = this.mScrollY;
                const overscrollBottom = Math.max(0, scrollRange - contentHeight);
                if (scrollY < 0) {
                    scrollRange -= scrollY;
                }
                else if (scrollY > overscrollBottom) {
                    scrollRange += scrollY - overscrollBottom;
                }
                return scrollRange;
            }
            computeVerticalScrollOffset() {
                return Math.max(0, super.computeVerticalScrollOffset());
            }
            measureChild(child, parentWidthMeasureSpec, parentHeightMeasureSpec) {
                let lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                let childWidthMeasureSpec;
                let childHeightMeasureSpec;
                childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft
                    + this.mPaddingRight, lp.width);
                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed) {
                const lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                const childWidthMeasureSpec = ScrollView.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft + this.mPaddingRight + lp.leftMargin + lp.rightMargin
                    + widthUsed, lp.width);
                const childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(lp.topMargin + lp.bottomMargin, MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            computeScroll() {
                if (this.mScroller.computeScrollOffset()) {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    let x = this.mScroller.getCurrX();
                    let y = this.mScroller.getCurrY();
                    if (oldX != x || oldY != y) {
                        const range = this.getScrollRange();
                        const overscrollMode = this.getOverScrollMode();
                        const canOverscroll = overscrollMode == ScrollView.OVER_SCROLL_ALWAYS ||
                            (overscrollMode == ScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                        this.overScrollBy(x - oldX, y - oldY, oldX, oldY, 0, range, 0, this.mOverflingDistance, false);
                        this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                        if (canOverscroll) {
                            if (y < 0 && oldY >= 0) {
                            }
                            else if (y > range && oldY <= range) {
                            }
                        }
                    }
                    if (!this.awakenScrollBars()) {
                        this.postInvalidateOnAnimation();
                    }
                }
                else {
                }
            }
            scrollToChild(child) {
                child.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(child, this.mTempRect);
                let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                if (scrollDelta != 0) {
                    this.scrollBy(0, scrollDelta);
                }
            }
            scrollToChildRect(rect, immediate) {
                const delta = this.computeScrollDeltaToGetChildRectOnScreen(rect);
                const scroll = delta != 0;
                if (scroll) {
                    if (immediate) {
                        this.scrollBy(0, delta);
                    }
                    else {
                        this.smoothScrollBy(0, delta);
                    }
                }
                return scroll;
            }
            computeScrollDeltaToGetChildRectOnScreen(rect) {
                if (this.getChildCount() == 0)
                    return 0;
                let height = this.getHeight();
                let screenTop = this.getScrollY();
                let screenBottom = screenTop + height;
                let fadingEdge = this.getVerticalFadingEdgeLength();
                if (rect.top > 0) {
                    screenTop += fadingEdge;
                }
                if (rect.bottom < this.getChildAt(0).getHeight()) {
                    screenBottom -= fadingEdge;
                }
                let scrollYDelta = 0;
                if (rect.bottom > screenBottom && rect.top > screenTop) {
                    if (rect.height() > height) {
                        scrollYDelta += (rect.top - screenTop);
                    }
                    else {
                        scrollYDelta += (rect.bottom - screenBottom);
                    }
                    let bottom = this.getChildAt(0).getBottom();
                    let distanceToBottom = bottom - screenBottom;
                    scrollYDelta = Math.min(scrollYDelta, distanceToBottom);
                }
                else if (rect.top < screenTop && rect.bottom < screenBottom) {
                    if (rect.height() > height) {
                        scrollYDelta -= (screenBottom - rect.bottom);
                    }
                    else {
                        scrollYDelta -= (screenTop - rect.top);
                    }
                    scrollYDelta = Math.max(scrollYDelta, -this.getScrollY());
                }
                return scrollYDelta;
            }
            requestChildFocus(child, focused) {
                if (!this.mIsLayoutDirty) {
                    this.scrollToChild(focused);
                }
                else {
                    this.mChildToScrollTo = focused;
                }
                super.requestChildFocus(child, focused);
            }
            onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                if (direction == View.FOCUS_FORWARD) {
                    direction = View.FOCUS_DOWN;
                }
                else if (direction == View.FOCUS_BACKWARD) {
                    direction = View.FOCUS_UP;
                }
                const nextFocus = previouslyFocusedRect == null ? FocusFinder.getInstance().findNextFocus(this, null, direction) : FocusFinder.getInstance().findNextFocusFromRect(this, previouslyFocusedRect, direction);
                if (nextFocus == null) {
                    return false;
                }
                if (this.isOffScreen(nextFocus)) {
                    return false;
                }
                return nextFocus.requestFocus(direction, previouslyFocusedRect);
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                rectangle.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
                return this.scrollToChildRect(rectangle, immediate);
            }
            requestLayout() {
                this.mIsLayoutDirty = true;
                super.requestLayout();
            }
            onLayout(changed, l, t, r, b) {
                super.onLayout(changed, l, t, r, b);
                this.mIsLayoutDirty = false;
                if (this.mChildToScrollTo != null && ScrollView.isViewDescendantOf(this.mChildToScrollTo, this)) {
                    this.scrollToChild(this.mChildToScrollTo);
                }
                this.mChildToScrollTo = null;
                if (!this.isLaidOut()) {
                    const childHeight = (this.getChildCount() > 0) ? this.getChildAt(0).getMeasuredHeight() : 0;
                    const scrollRange = Math.max(0, childHeight - (b - t - this.mPaddingBottom - this.mPaddingTop));
                    if (this.mScrollY > scrollRange) {
                        this.mScrollY = scrollRange;
                    }
                    else if (this.mScrollY < 0) {
                        this.mScrollY = 0;
                    }
                }
                this.scrollTo(this.mScrollX, this.mScrollY);
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                let currentFocused = this.findFocus();
                if (null == currentFocused || this == currentFocused)
                    return;
                if (this.isWithinDeltaOfScreen(currentFocused, 0, oldh)) {
                    currentFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(currentFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollY(scrollDelta);
                }
            }
            static isViewDescendantOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof ViewGroup) && ScrollView.isViewDescendantOf(theParent, parent);
            }
            fling(velocityY) {
                if (this.getChildCount() > 0) {
                    let height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                    let bottom = this.getChildAt(0).getHeight();
                    this.mScroller.fling(this.mScrollX, this.mScrollY, 0, velocityY, 0, 0, 0, Math.max(0, bottom - height), 0, this.mOverflingDistance);
                    this.postInvalidateOnAnimation();
                }
            }
            endDrag() {
                this.mIsBeingDragged = false;
                this.recycleVelocityTracker();
            }
            scrollTo(x, y) {
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    x = ScrollView.clamp(x, this.getWidth() - this.mPaddingRight - this.mPaddingLeft, child.getWidth());
                    y = ScrollView.clamp(y, this.getHeight() - this.mPaddingBottom - this.mPaddingTop, child.getHeight());
                    if (x != this.mScrollX || y != this.mScrollY) {
                        super.scrollTo(x, y);
                    }
                }
            }
            static clamp(n, my, child) {
                if (my >= child || n < 0) {
                    return 0;
                }
                if ((my + n) > child) {
                    return child - my;
                }
                return n;
            }
            canScrollVertically(direction) {
                if (this.getOverScrollMode() === View.OVER_SCROLL_ALWAYS)
                    return true;
                return super.canScrollVertically(direction);
            }
        }
        ScrollView.ANIMATED_SCROLL_GAP = 250;
        ScrollView.MAX_SCROLL_FACTOR = 0.5;
        ScrollView.TAG = "ScrollView";
        ScrollView.INVALID_POINTER = -1;
        widget.ScrollView = ScrollView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
///<reference path="../view/Gravity.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/Rect.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var MeasureSpec = View.MeasureSpec;
        var ViewGroup = android.view.ViewGroup;
        class LinearLayout extends ViewGroup {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mBaselineAligned = true;
                this.mBaselineAlignedChildIndex = -1;
                this.mBaselineChildTop = 0;
                this.mOrientation = 0;
                this.mGravity = Gravity.LEFT | Gravity.TOP;
                this.mTotalLength = 0;
                this.mWeightSum = -1;
                this.mUseLargestChild = false;
                this.mDividerWidth = 0;
                this.mDividerHeight = 0;
                this.mShowDividers = LinearLayout.SHOW_DIVIDER_NONE;
                this.mDividerPadding = 0;
                this._attrBinder.addAttr('orientation', (value) => {
                    if ((value + "").toUpperCase() === 'VERTICAL' || LinearLayout.VERTICAL == value) {
                        this.setOrientation(LinearLayout.VERTICAL);
                    }
                    else if ((value + "").toUpperCase() === 'HORIZONTAL' || LinearLayout.HORIZONTAL == value) {
                        this.setOrientation(LinearLayout.HORIZONTAL);
                    }
                }, () => {
                    return this.mOrientation;
                });
                this._attrBinder.addAttr('gravity', (value) => {
                    this.setGravity(this._attrBinder.parseGravity(value, this.mGravity));
                }, () => {
                    return this.mGravity;
                });
                this._attrBinder.addAttr('baselineAligned', (value) => {
                    if (!this._attrBinder.parseBoolean(value))
                        this.setBaselineAligned(false);
                });
                this._attrBinder.addAttr('weightSum', (value) => {
                    let weightSum = Number.parseFloat(value);
                    if (!Number.isNaN(weightSum) && weightSum != null) {
                        this.setWeightSum(weightSum);
                    }
                }, () => {
                    return this.mWeightSum;
                });
                this._attrBinder.addAttr('baselineAlignedChildIndex', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isSafeInteger(value)) {
                        this.mBaselineAlignedChildIndex = value;
                    }
                });
                this._attrBinder.addAttr('measureWithLargestChild', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isSafeInteger(value)) {
                        this.mUseLargestChild = this._attrBinder.parseBoolean(value, this.mUseLargestChild);
                    }
                });
                this._attrBinder.addAttr('divider', (value) => {
                    this.setDividerDrawable(this._attrBinder.parseDrawable(value));
                });
                this._attrBinder.addAttr('showDividers', (value) => {
                    let fieldName = ('SHOW_DIVIDER_' + value).toUpperCase();
                    if (Number.isInteger(LinearLayout[fieldName])) {
                        this.setShowDividers(LinearLayout[fieldName]);
                    }
                });
                this._attrBinder.addAttr('dividerPadding', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value)) {
                        this.setDividerPadding(value);
                    }
                });
            }
            setShowDividers(showDividers) {
                if (showDividers != this.mShowDividers) {
                    this.requestLayout();
                }
                this.mShowDividers = showDividers;
            }
            shouldDelayChildPressedState() {
                return false;
            }
            getShowDividers() {
                return this.mShowDividers;
            }
            getDividerDrawable() {
                return this.mDivider;
            }
            setDividerDrawable(divider) {
                if (divider == this.mDivider) {
                    return;
                }
                this.mDivider = divider;
                if (divider != null) {
                    this.mDividerWidth = divider.getIntrinsicWidth();
                    this.mDividerHeight = divider.getIntrinsicHeight();
                }
                else {
                    this.mDividerWidth = 0;
                    this.mDividerHeight = 0;
                }
                this.setWillNotDraw(divider == null);
                this.requestLayout();
            }
            setDividerPadding(padding) {
                this.mDividerPadding = padding;
            }
            getDividerPadding() {
                return this.mDividerPadding;
            }
            getDividerWidth() {
                return this.mDividerWidth;
            }
            onDraw(canvas) {
                if (this.mDivider == null) {
                    return;
                }
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    this.drawDividersVertical(canvas);
                }
                else {
                    this.drawDividersHorizontal(canvas);
                }
            }
            drawDividersVertical(canvas) {
                const count = this.getVirtualChildCount();
                for (let i = 0; i < count; i++) {
                    const child = this.getVirtualChildAt(i);
                    if (child != null && child.getVisibility() != View.GONE) {
                        if (this.hasDividerBeforeChildAt(i)) {
                            const lp = child.getLayoutParams();
                            const top = child.getTop() - lp.topMargin - this.mDividerHeight;
                            this.drawHorizontalDivider(canvas, top);
                        }
                    }
                }
                if (this.hasDividerBeforeChildAt(count)) {
                    const child = this.getVirtualChildAt(count - 1);
                    let bottom = 0;
                    if (child == null) {
                        bottom = this.getHeight() - this.getPaddingBottom() - this.mDividerHeight;
                    }
                    else {
                        const lp = child.getLayoutParams();
                        bottom = child.getBottom() + lp.bottomMargin;
                    }
                    this.drawHorizontalDivider(canvas, bottom);
                }
            }
            drawDividersHorizontal(canvas) {
                const count = this.getVirtualChildCount();
                const isLayoutRtl = this.isLayoutRtl();
                for (let i = 0; i < count; i++) {
                    const child = this.getVirtualChildAt(i);
                    if (child != null && child.getVisibility() != View.GONE) {
                        if (this.hasDividerBeforeChildAt(i)) {
                            const lp = child.getLayoutParams();
                            let position;
                            if (isLayoutRtl) {
                                position = child.getRight() + lp.rightMargin;
                            }
                            else {
                                position = child.getLeft() - lp.leftMargin - this.mDividerWidth;
                            }
                            this.drawVerticalDivider(canvas, position);
                        }
                    }
                }
                if (this.hasDividerBeforeChildAt(count)) {
                    const child = this.getVirtualChildAt(count - 1);
                    let position;
                    if (child == null) {
                        if (isLayoutRtl) {
                            position = this.getPaddingLeft();
                        }
                        else {
                            position = this.getWidth() - this.getPaddingRight() - this.mDividerWidth;
                        }
                    }
                    else {
                        const lp = child.getLayoutParams();
                        if (isLayoutRtl) {
                            position = child.getLeft() - lp.leftMargin - this.mDividerWidth;
                        }
                        else {
                            position = child.getRight() + lp.rightMargin;
                        }
                    }
                    this.drawVerticalDivider(canvas, position);
                }
            }
            drawHorizontalDivider(canvas, top) {
                this.mDivider.setBounds(this.getPaddingLeft() + this.mDividerPadding, top, this.getWidth() - this.getPaddingRight() - this.mDividerPadding, top + this.mDividerHeight);
                this.mDivider.draw(canvas);
            }
            drawVerticalDivider(canvas, left) {
                this.mDivider.setBounds(left, this.getPaddingTop() + this.mDividerPadding, left + this.mDividerWidth, this.getHeight() - this.getPaddingBottom() - this.mDividerPadding);
                this.mDivider.draw(canvas);
            }
            isBaselineAligned() {
                return this.mBaselineAligned;
            }
            setBaselineAligned(baselineAligned) {
                this.mBaselineAligned = baselineAligned;
            }
            isMeasureWithLargestChildEnabled() {
                return this.mUseLargestChild;
            }
            setMeasureWithLargestChildEnabled(enabled) {
                this.mUseLargestChild = enabled;
            }
            getBaseline() {
                if (this.mBaselineAlignedChildIndex < 0) {
                    return super.getBaseline();
                }
                if (this.getChildCount() <= this.mBaselineAlignedChildIndex) {
                    throw new Error("mBaselineAlignedChildIndex of LinearLayout "
                        + "set to an index that is out of bounds.");
                }
                const child = this.getChildAt(this.mBaselineAlignedChildIndex);
                const childBaseline = child.getBaseline();
                if (childBaseline == -1) {
                    if (this.mBaselineAlignedChildIndex == 0) {
                        return -1;
                    }
                    throw new Error("mBaselineAlignedChildIndex of LinearLayout "
                        + "points to a View that doesn't know how to get its baseline.");
                }
                let childTop = this.mBaselineChildTop;
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    const majorGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                    if (majorGravity != Gravity.TOP) {
                        switch (majorGravity) {
                            case Gravity.BOTTOM:
                                childTop = this.mBottom - this.mTop - this.mPaddingBottom - this.mTotalLength;
                                break;
                            case Gravity.CENTER_VERTICAL:
                                childTop += ((this.mBottom - this.mTop - this.mPaddingTop - this.mPaddingBottom) -
                                    this.mTotalLength) / 2;
                                break;
                        }
                    }
                }
                let lp = child.getLayoutParams();
                return childTop + lp.topMargin + childBaseline;
            }
            getBaselineAlignedChildIndex() {
                return this.mBaselineAlignedChildIndex;
            }
            setBaselineAlignedChildIndex(i) {
                if ((i < 0) || (i >= this.getChildCount())) {
                    throw new Error("base aligned child index out "
                        + "of range (0, " + this.getChildCount() + ")");
                }
                this.mBaselineAlignedChildIndex = i;
            }
            getVirtualChildAt(index) {
                return this.getChildAt(index);
            }
            getVirtualChildCount() {
                return this.getChildCount();
            }
            getWeightSum() {
                return this.mWeightSum;
            }
            setWeightSum(weightSum) {
                this.mWeightSum = Math.max(0, weightSum);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    this.measureVertical(widthMeasureSpec, heightMeasureSpec);
                }
                else {
                    this.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
                }
            }
            hasDividerBeforeChildAt(childIndex) {
                if (childIndex == 0) {
                    return (this.mShowDividers & LinearLayout.SHOW_DIVIDER_BEGINNING) != 0;
                }
                else if (childIndex == this.getChildCount()) {
                    return (this.mShowDividers & LinearLayout.SHOW_DIVIDER_END) != 0;
                }
                else if ((this.mShowDividers & LinearLayout.SHOW_DIVIDER_MIDDLE) != 0) {
                    let hasVisibleViewBefore = false;
                    for (let i = childIndex - 1; i >= 0; i--) {
                        if (this.getChildAt(i).getVisibility() != LinearLayout.GONE) {
                            hasVisibleViewBefore = true;
                            break;
                        }
                    }
                    return hasVisibleViewBefore;
                }
                return false;
            }
            measureVertical(widthMeasureSpec, heightMeasureSpec) {
                this.mTotalLength = 0;
                let maxWidth = 0;
                let childState = 0;
                let alternativeMaxWidth = 0;
                let weightedMaxWidth = 0;
                let allFillParent = true;
                let totalWeight = 0;
                const count = this.getVirtualChildCount();
                const widthMode = MeasureSpec.getMode(widthMeasureSpec);
                const heightMode = MeasureSpec.getMode(heightMeasureSpec);
                let matchWidth = false;
                const baselineChildIndex = this.mBaselineAlignedChildIndex;
                const useLargestChild = this.mUseLargestChild;
                let largestChildHeight = Number.MIN_SAFE_INTEGER;
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child == null) {
                        this.mTotalLength += this.measureNullChild(i);
                        continue;
                    }
                    if (child.getVisibility() == View.GONE) {
                        i += this.getChildrenSkipCount(child, i);
                        continue;
                    }
                    if (this.hasDividerBeforeChildAt(i)) {
                        this.mTotalLength += this.mDividerHeight;
                    }
                    let lp = child.getLayoutParams();
                    totalWeight += lp.weight;
                    if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
                    }
                    else {
                        let oldHeight = Number.MIN_SAFE_INTEGER;
                        if (lp.height == 0 && lp.weight > 0) {
                            oldHeight = 0;
                            lp.height = LinearLayout.LayoutParams.WRAP_CONTENT;
                        }
                        this.measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? this.mTotalLength : 0);
                        if (oldHeight != Number.MIN_SAFE_INTEGER) {
                            lp.height = oldHeight;
                        }
                        const childHeight = child.getMeasuredHeight();
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +
                            lp.bottomMargin + this.getNextLocationOffset(child));
                        if (useLargestChild) {
                            largestChildHeight = Math.max(childHeight, largestChildHeight);
                        }
                    }
                    if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
                        this.mBaselineChildTop = this.mTotalLength;
                    }
                    if (i < baselineChildIndex && lp.weight > 0) {
                        throw new Error("A child of LinearLayout with index "
                            + "less than mBaselineAlignedChildIndex has weight > 0, which "
                            + "won't work.  Either remove the weight, or don't set "
                            + "mBaselineAlignedChildIndex.");
                    }
                    let matchWidthLocally = false;
                    if (widthMode != MeasureSpec.EXACTLY && lp.width == LinearLayout.LayoutParams.MATCH_PARENT) {
                        matchWidth = true;
                        matchWidthLocally = true;
                    }
                    const margin = lp.leftMargin + lp.rightMargin;
                    const measuredWidth = child.getMeasuredWidth() + margin;
                    maxWidth = Math.max(maxWidth, measuredWidth);
                    childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState());
                    allFillParent = allFillParent && lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
                    if (lp.weight > 0) {
                        weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
                    }
                    else {
                        alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
                    }
                    i += this.getChildrenSkipCount(child, i);
                }
                if (this.mTotalLength > 0 && this.hasDividerBeforeChildAt(count)) {
                    this.mTotalLength += this.mDividerHeight;
                }
                if (useLargestChild &&
                    (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child == null) {
                            this.mTotalLength += this.measureNullChild(i);
                            continue;
                        }
                        if (child.getVisibility() == View.GONE) {
                            i += this.getChildrenSkipCount(child, i);
                            continue;
                        }
                        const lp = child.getLayoutParams();
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                            lp.topMargin + lp.bottomMargin + this.getNextLocationOffset(child));
                    }
                }
                this.mTotalLength += this.mPaddingTop + this.mPaddingBottom;
                let heightSize = this.mTotalLength;
                heightSize = Math.max(heightSize, this.getSuggestedMinimumHeight());
                let heightSizeAndState = LinearLayout.resolveSizeAndState(heightSize, heightMeasureSpec, 0);
                heightSize = heightSizeAndState & View.MEASURED_SIZE_MASK;
                let delta = heightSize - this.mTotalLength;
                if (delta != 0 && totalWeight > 0) {
                    let weightSum = this.mWeightSum > 0 ? this.mWeightSum : totalWeight;
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child.getVisibility() == View.GONE) {
                            continue;
                        }
                        let lp = child.getLayoutParams();
                        let childExtra = lp.weight;
                        if (childExtra > 0) {
                            let share = (childExtra * delta / weightSum);
                            weightSum -= childExtra;
                            delta -= share;
                            const childWidthMeasureSpec = LinearLayout.getChildMeasureSpec(widthMeasureSpec, this.mPaddingLeft + this.mPaddingRight +
                                lp.leftMargin + lp.rightMargin, lp.width);
                            if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                                let childHeight = child.getMeasuredHeight() + share;
                                if (childHeight < 0) {
                                    childHeight = 0;
                                }
                                child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                            }
                            else {
                                child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                            }
                            childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState()
                                & (View.MEASURED_STATE_MASK >> View.MEASURED_HEIGHT_STATE_SHIFT));
                        }
                        const margin = lp.leftMargin + lp.rightMargin;
                        const measuredWidth = child.getMeasuredWidth() + margin;
                        maxWidth = Math.max(maxWidth, measuredWidth);
                        let matchWidthLocally = widthMode != MeasureSpec.EXACTLY &&
                            lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
                        alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
                        allFillParent = allFillParent && lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +
                            lp.topMargin + lp.bottomMargin + this.getNextLocationOffset(child));
                    }
                    this.mTotalLength += this.mPaddingTop + this.mPaddingBottom;
                }
                else {
                    alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
                    if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
                        for (let i = 0; i < count; i++) {
                            const child = this.getVirtualChildAt(i);
                            if (child == null || child.getVisibility() == View.GONE) {
                                continue;
                            }
                            const lp = child.getLayoutParams();
                            let childExtra = lp.weight;
                            if (childExtra > 0) {
                                child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                            }
                        }
                    }
                }
                if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
                    maxWidth = alternativeMaxWidth;
                }
                maxWidth += this.mPaddingLeft + this.mPaddingRight;
                maxWidth = Math.max(maxWidth, this.getSuggestedMinimumWidth());
                this.setMeasuredDimension(LinearLayout.resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
                if (matchWidth) {
                    this.forceUniformWidth(count, heightMeasureSpec);
                }
            }
            forceUniformWidth(count, heightMeasureSpec) {
                let uniformMeasureSpec = MeasureSpec.makeMeasureSpec(this.getMeasuredWidth(), MeasureSpec.EXACTLY);
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child.getVisibility() != View.GONE) {
                        let lp = child.getLayoutParams();
                        if (lp.width == LinearLayout.LayoutParams.MATCH_PARENT) {
                            let oldHeight = lp.height;
                            lp.height = child.getMeasuredHeight();
                            this.measureChildWithMargins(child, uniformMeasureSpec, 0, heightMeasureSpec, 0);
                            lp.height = oldHeight;
                        }
                    }
                }
            }
            measureHorizontal(widthMeasureSpec, heightMeasureSpec) {
                this.mTotalLength = 0;
                let maxHeight = 0;
                let childState = 0;
                let alternativeMaxHeight = 0;
                let weightedMaxHeight = 0;
                let allFillParent = true;
                let totalWeight = 0;
                const count = this.getVirtualChildCount();
                const widthMode = MeasureSpec.getMode(widthMeasureSpec);
                const heightMode = MeasureSpec.getMode(heightMeasureSpec);
                let matchHeight = false;
                if (this.mMaxAscent == null || this.mMaxDescent == null) {
                    this.mMaxAscent = new Array(LinearLayout.VERTICAL_GRAVITY_COUNT);
                    this.mMaxDescent = new Array(LinearLayout.VERTICAL_GRAVITY_COUNT);
                }
                let maxAscent = this.mMaxAscent;
                let maxDescent = this.mMaxDescent;
                maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
                maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
                const baselineAligned = this.mBaselineAligned;
                const useLargestChild = this.mUseLargestChild;
                const isExactly = widthMode == MeasureSpec.EXACTLY;
                let largestChildWidth = Number.MAX_SAFE_INTEGER;
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child == null) {
                        this.mTotalLength += this.measureNullChild(i);
                        continue;
                    }
                    if (child.getVisibility() == View.GONE) {
                        i += this.getChildrenSkipCount(child, i);
                        continue;
                    }
                    if (this.hasDividerBeforeChildAt(i)) {
                        this.mTotalLength += this.mDividerWidth;
                    }
                    const lp = child.getLayoutParams();
                    totalWeight += lp.weight;
                    if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
                        if (isExactly) {
                            this.mTotalLength += lp.leftMargin + lp.rightMargin;
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength +
                                lp.leftMargin + lp.rightMargin);
                        }
                        if (baselineAligned) {
                            const freeSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                            child.measure(freeSpec, freeSpec);
                        }
                    }
                    else {
                        let oldWidth = Number.MIN_SAFE_INTEGER;
                        if (lp.width == 0 && lp.weight > 0) {
                            oldWidth = 0;
                            lp.width = LinearLayout.LayoutParams.WRAP_CONTENT;
                        }
                        this.measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? this.mTotalLength : 0, heightMeasureSpec, 0);
                        if (oldWidth != Number.MIN_SAFE_INTEGER) {
                            lp.width = oldWidth;
                        }
                        const childWidth = child.getMeasuredWidth();
                        if (isExactly) {
                            this.mTotalLength += childWidth + lp.leftMargin + lp.rightMargin +
                                this.getNextLocationOffset(child);
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin +
                                lp.rightMargin + this.getNextLocationOffset(child));
                        }
                        if (useLargestChild) {
                            largestChildWidth = Math.max(childWidth, largestChildWidth);
                        }
                    }
                    let matchHeightLocally = false;
                    if (heightMode != MeasureSpec.EXACTLY && lp.height == LinearLayout.LayoutParams.MATCH_PARENT) {
                        matchHeight = true;
                        matchHeightLocally = true;
                    }
                    const margin = lp.topMargin + lp.bottomMargin;
                    const childHeight = child.getMeasuredHeight() + margin;
                    childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState());
                    if (baselineAligned) {
                        const childBaseline = child.getBaseline();
                        if (childBaseline != -1) {
                            const gravity = (lp.gravity < 0 ? this.mGravity : lp.gravity)
                                & Gravity.VERTICAL_GRAVITY_MASK;
                            const index = ((gravity >> Gravity.AXIS_Y_SHIFT)
                                & ~Gravity.AXIS_SPECIFIED) >> 1;
                            maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                            maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                        }
                    }
                    maxHeight = Math.max(maxHeight, childHeight);
                    allFillParent = allFillParent && lp.height == LinearLayout.LayoutParams.MATCH_PARENT;
                    if (lp.weight > 0) {
                        weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
                    }
                    else {
                        alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
                    }
                    i += this.getChildrenSkipCount(child, i);
                }
                if (this.mTotalLength > 0 && this.hasDividerBeforeChildAt(count)) {
                    this.mTotalLength += this.mDividerWidth;
                }
                if (maxAscent[LinearLayout.INDEX_TOP] != -1 ||
                    maxAscent[LinearLayout.INDEX_CENTER_VERTICAL] != -1 ||
                    maxAscent[LinearLayout.INDEX_BOTTOM] != -1 ||
                    maxAscent[LinearLayout.INDEX_FILL] != -1) {
                    const ascent = Math.max(maxAscent[LinearLayout.INDEX_FILL], Math.max(maxAscent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxAscent[LinearLayout.INDEX_TOP], maxAscent[LinearLayout.INDEX_BOTTOM])));
                    const descent = Math.max(maxDescent[LinearLayout.INDEX_FILL], Math.max(maxDescent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxDescent[LinearLayout.INDEX_TOP], maxDescent[LinearLayout.INDEX_BOTTOM])));
                    maxHeight = Math.max(maxHeight, ascent + descent);
                }
                if (useLargestChild &&
                    (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child == null) {
                            this.mTotalLength += this.measureNullChild(i);
                            continue;
                        }
                        if (child.getVisibility() == View.GONE) {
                            i += this.getChildrenSkipCount(child, i);
                            continue;
                        }
                        const lp = child.getLayoutParams();
                        if (isExactly) {
                            this.mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin +
                                this.getNextLocationOffset(child);
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength + largestChildWidth +
                                lp.leftMargin + lp.rightMargin + this.getNextLocationOffset(child));
                        }
                    }
                }
                this.mTotalLength += this.mPaddingLeft + this.mPaddingRight;
                let widthSize = this.mTotalLength;
                widthSize = Math.max(widthSize, this.getSuggestedMinimumWidth());
                let widthSizeAndState = LinearLayout.resolveSizeAndState(widthSize, widthMeasureSpec, 0);
                widthSize = widthSizeAndState & View.MEASURED_SIZE_MASK;
                let delta = widthSize - this.mTotalLength;
                if (delta != 0 && totalWeight > 0) {
                    let weightSum = this.mWeightSum > 0 ? this.mWeightSum : totalWeight;
                    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
                    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
                    maxHeight = -1;
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child == null || child.getVisibility() == View.GONE) {
                            continue;
                        }
                        const lp = child.getLayoutParams();
                        let childExtra = lp.weight;
                        if (childExtra > 0) {
                            let share = (childExtra * delta / weightSum);
                            weightSum -= childExtra;
                            delta -= share;
                            const childHeightMeasureSpec = LinearLayout.getChildMeasureSpec(heightMeasureSpec, this.mPaddingTop + this.mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                            if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                                let childWidth = child.getMeasuredWidth() + share;
                                if (childWidth < 0) {
                                    childWidth = 0;
                                }
                                child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                            }
                            else {
                                child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                            }
                            childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState() & View.MEASURED_STATE_MASK);
                        }
                        if (isExactly) {
                            this.mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin +
                                this.getNextLocationOffset(child);
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() +
                                lp.leftMargin + lp.rightMargin + this.getNextLocationOffset(child));
                        }
                        let matchHeightLocally = heightMode != MeasureSpec.EXACTLY &&
                            lp.height == LinearLayout.LayoutParams.MATCH_PARENT;
                        const margin = lp.topMargin + lp.bottomMargin;
                        let childHeight = child.getMeasuredHeight() + margin;
                        maxHeight = Math.max(maxHeight, childHeight);
                        alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
                        allFillParent = allFillParent && lp.height == LinearLayout.LayoutParams.MATCH_PARENT;
                        if (baselineAligned) {
                            const childBaseline = child.getBaseline();
                            if (childBaseline != -1) {
                                const gravity = (lp.gravity < 0 ? this.mGravity : lp.gravity)
                                    & Gravity.VERTICAL_GRAVITY_MASK;
                                const index = ((gravity >> Gravity.AXIS_Y_SHIFT)
                                    & ~Gravity.AXIS_SPECIFIED) >> 1;
                                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                            }
                        }
                    }
                    this.mTotalLength += this.mPaddingLeft + this.mPaddingRight;
                    if (maxAscent[LinearLayout.INDEX_TOP] != -1 ||
                        maxAscent[LinearLayout.INDEX_CENTER_VERTICAL] != -1 ||
                        maxAscent[LinearLayout.INDEX_BOTTOM] != -1 ||
                        maxAscent[LinearLayout.INDEX_FILL] != -1) {
                        const ascent = Math.max(maxAscent[LinearLayout.INDEX_FILL], Math.max(maxAscent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxAscent[LinearLayout.INDEX_TOP], maxAscent[LinearLayout.INDEX_BOTTOM])));
                        const descent = Math.max(maxDescent[LinearLayout.INDEX_FILL], Math.max(maxDescent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxDescent[LinearLayout.INDEX_TOP], maxDescent[LinearLayout.INDEX_BOTTOM])));
                        maxHeight = Math.max(maxHeight, ascent + descent);
                    }
                }
                else {
                    alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
                    if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
                        for (let i = 0; i < count; i++) {
                            const child = this.getVirtualChildAt(i);
                            if (child == null || child.getVisibility() == View.GONE) {
                                continue;
                            }
                            const lp = child.getLayoutParams();
                            let childExtra = lp.weight;
                            if (childExtra > 0) {
                                child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                            }
                        }
                    }
                }
                if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
                    maxHeight = alternativeMaxHeight;
                }
                maxHeight += this.mPaddingTop + this.mPaddingBottom;
                maxHeight = Math.max(maxHeight, this.getSuggestedMinimumHeight());
                this.setMeasuredDimension(widthSizeAndState | (childState & View.MEASURED_STATE_MASK), LinearLayout.resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << View.MEASURED_HEIGHT_STATE_SHIFT)));
                if (matchHeight) {
                    this.forceUniformHeight(count, widthMeasureSpec);
                }
            }
            forceUniformHeight(count, widthMeasureSpec) {
                let uniformMeasureSpec = MeasureSpec.makeMeasureSpec(this.getMeasuredHeight(), MeasureSpec.EXACTLY);
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child.getVisibility() != View.GONE) {
                        let lp = child.getLayoutParams();
                        if (lp.height == LinearLayout.LayoutParams.MATCH_PARENT) {
                            let oldWidth = lp.width;
                            lp.width = child.getMeasuredWidth();
                            this.measureChildWithMargins(child, widthMeasureSpec, 0, uniformMeasureSpec, 0);
                            lp.width = oldWidth;
                        }
                    }
                }
            }
            getChildrenSkipCount(child, index) {
                return 0;
            }
            measureNullChild(childIndex) {
                return 0;
            }
            measureChildBeforeLayout(child, childIndex, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight) {
                this.measureChildWithMargins(child, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight);
            }
            getLocationOffset(child) {
                return 0;
            }
            getNextLocationOffset(child) {
                return 0;
            }
            onLayout(changed, l, t, r, b) {
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    this.layoutVertical(l, t, r, b);
                }
                else {
                    this.layoutHorizontal(l, t, r, b);
                }
            }
            layoutVertical(left, top, right, bottom) {
                const paddingLeft = this.mPaddingLeft;
                let childTop;
                let childLeft;
                const width = right - left;
                let childRight = width - this.mPaddingRight;
                let childSpace = width - paddingLeft - this.mPaddingRight;
                const count = this.getVirtualChildCount();
                const majorGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                const minorGravity = this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                switch (majorGravity) {
                    case Gravity.BOTTOM:
                        childTop = this.mPaddingTop + bottom - top - this.mTotalLength;
                        break;
                    case Gravity.CENTER_VERTICAL:
                        childTop = this.mPaddingTop + (bottom - top - this.mTotalLength) / 2;
                        break;
                    case Gravity.TOP:
                    default:
                        childTop = this.mPaddingTop;
                        break;
                }
                for (let i = 0; i < count; i++) {
                    const child = this.getVirtualChildAt(i);
                    if (child == null) {
                        childTop += this.measureNullChild(i);
                    }
                    else if (child.getVisibility() != View.GONE) {
                        const childWidth = child.getMeasuredWidth();
                        const childHeight = child.getMeasuredHeight();
                        const lp = child.getLayoutParams();
                        let gravity = lp.gravity;
                        if (gravity < 0) {
                            gravity = minorGravity;
                        }
                        const absoluteGravity = gravity;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.CENTER_HORIZONTAL:
                                childLeft = paddingLeft + ((childSpace - childWidth) / 2)
                                    + lp.leftMargin - lp.rightMargin;
                                break;
                            case Gravity.RIGHT:
                                childLeft = childRight - childWidth - lp.rightMargin;
                                break;
                            case Gravity.LEFT:
                            default:
                                childLeft = paddingLeft + lp.leftMargin;
                                break;
                        }
                        if (this.hasDividerBeforeChildAt(i)) {
                            childTop += this.mDividerHeight;
                        }
                        childTop += lp.topMargin;
                        this.setChildFrame(child, childLeft, childTop + this.getLocationOffset(child), childWidth, childHeight);
                        childTop += childHeight + lp.bottomMargin + this.getNextLocationOffset(child);
                        i += this.getChildrenSkipCount(child, i);
                    }
                }
            }
            layoutHorizontal(left, top, right, bottom) {
                const isLayoutRtl = this.isLayoutRtl();
                const paddingTop = this.mPaddingTop;
                let childTop;
                let childLeft;
                const height = bottom - top;
                let childBottom = height - this.mPaddingBottom;
                let childSpace = height - paddingTop - this.mPaddingBottom;
                const count = this.getVirtualChildCount();
                const majorGravity = this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                const minorGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                const baselineAligned = this.mBaselineAligned;
                const maxAscent = this.mMaxAscent;
                const maxDescent = this.mMaxDescent;
                let absoluteGravity = majorGravity;
                switch (absoluteGravity) {
                    case Gravity.RIGHT:
                        childLeft = this.mPaddingLeft + right - left - this.mTotalLength;
                        break;
                    case Gravity.CENTER_HORIZONTAL:
                        childLeft = this.mPaddingLeft + (right - left - this.mTotalLength) / 2;
                        break;
                    case Gravity.LEFT:
                    default:
                        childLeft = this.mPaddingLeft;
                        break;
                }
                let start = 0;
                let dir = 1;
                if (isLayoutRtl) {
                    start = count - 1;
                    dir = -1;
                }
                for (let i = 0; i < count; i++) {
                    let childIndex = start + dir * i;
                    const child = this.getVirtualChildAt(childIndex);
                    if (child == null) {
                        childLeft += this.measureNullChild(childIndex);
                    }
                    else if (child.getVisibility() != View.GONE) {
                        const childWidth = child.getMeasuredWidth();
                        const childHeight = child.getMeasuredHeight();
                        let childBaseline = -1;
                        const lp = child.getLayoutParams();
                        if (baselineAligned && lp.height != LinearLayout.LayoutParams.MATCH_PARENT) {
                            childBaseline = child.getBaseline();
                        }
                        let gravity = lp.gravity;
                        if (gravity < 0) {
                            gravity = minorGravity;
                        }
                        switch (gravity & Gravity.VERTICAL_GRAVITY_MASK) {
                            case Gravity.TOP:
                                childTop = paddingTop + lp.topMargin;
                                if (childBaseline != -1) {
                                    childTop += maxAscent[LinearLayout.INDEX_TOP] - childBaseline;
                                }
                                break;
                            case Gravity.CENTER_VERTICAL:
                                childTop = paddingTop + ((childSpace - childHeight) / 2)
                                    + lp.topMargin - lp.bottomMargin;
                                break;
                            case Gravity.BOTTOM:
                                childTop = childBottom - childHeight - lp.bottomMargin;
                                if (childBaseline != -1) {
                                    let descent = child.getMeasuredHeight() - childBaseline;
                                    childTop -= (maxDescent[LinearLayout.INDEX_BOTTOM] - descent);
                                }
                                break;
                            default:
                                childTop = paddingTop;
                                break;
                        }
                        if (this.hasDividerBeforeChildAt(childIndex)) {
                            childLeft += this.mDividerWidth;
                        }
                        childLeft += lp.leftMargin;
                        this.setChildFrame(child, childLeft + this.getLocationOffset(child), childTop, childWidth, childHeight);
                        childLeft += childWidth + lp.rightMargin +
                            this.getNextLocationOffset(child);
                        i += this.getChildrenSkipCount(child, childIndex);
                    }
                }
            }
            setChildFrame(child, left, top, width, height) {
                child.layout(left, top, left + width, top + height);
            }
            setOrientation(orientation) {
                if (typeof orientation === 'string') {
                    if ('VERTICAL' === (orientation + '').toUpperCase())
                        orientation = LinearLayout.VERTICAL;
                    else if ('HORIZONTAL' === (orientation + '').toUpperCase())
                        orientation = LinearLayout.HORIZONTAL;
                }
                if (this.mOrientation != orientation) {
                    this.mOrientation = orientation;
                    this.requestLayout();
                }
            }
            getOrientation() {
                return this.mOrientation;
            }
            setGravity(gravity) {
                if (this.mGravity != gravity) {
                    if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == 0) {
                        gravity |= Gravity.LEFT;
                    }
                    if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
                        gravity |= Gravity.TOP;
                    }
                    this.mGravity = gravity;
                    this.requestLayout();
                }
            }
            setHorizontalGravity(horizontalGravity) {
                const gravity = horizontalGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                if ((this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) != gravity) {
                    this.mGravity = (this.mGravity & ~Gravity.HORIZONTAL_GRAVITY_MASK) | gravity;
                    this.requestLayout();
                }
            }
            setVerticalGravity(verticalGravity) {
                const gravity = verticalGravity & Gravity.VERTICAL_GRAVITY_MASK;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != gravity) {
                    this.mGravity = (this.mGravity & ~Gravity.VERTICAL_GRAVITY_MASK) | gravity;
                    this.requestLayout();
                }
            }
            generateDefaultLayoutParams() {
                let LayoutParams = LinearLayout.LayoutParams;
                if (this.mOrientation == LinearLayout.HORIZONTAL) {
                    return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
                }
                else if (this.mOrientation == LinearLayout.VERTICAL) {
                    return new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
                }
                return super.generateDefaultLayoutParams();
            }
            generateLayoutParams(p) {
                return new LinearLayout.LayoutParams(p);
            }
            checkLayoutParams(p) {
                return p instanceof LinearLayout.LayoutParams;
            }
        }
        LinearLayout.HORIZONTAL = 0;
        LinearLayout.VERTICAL = 1;
        LinearLayout.SHOW_DIVIDER_NONE = 0;
        LinearLayout.SHOW_DIVIDER_BEGINNING = 1;
        LinearLayout.SHOW_DIVIDER_MIDDLE = 2;
        LinearLayout.SHOW_DIVIDER_END = 4;
        LinearLayout.VERTICAL_GRAVITY_COUNT = 4;
        LinearLayout.INDEX_CENTER_VERTICAL = 0;
        LinearLayout.INDEX_TOP = 1;
        LinearLayout.INDEX_BOTTOM = 2;
        LinearLayout.INDEX_FILL = 3;
        widget.LinearLayout = LinearLayout;
        (function (LinearLayout) {
            class LayoutParams extends android.view.ViewGroup.MarginLayoutParams {
                constructor(...args) {
                    super();
                    this.weight = 0;
                    this.gravity = -1;
                    if (args.length === 1) {
                        if (args[0] instanceof LayoutParams) {
                            this.gravity = args[0].gravity;
                        }
                        super(args[0]);
                    }
                    else {
                        let [width, height, weight = 0] = args;
                        super(width, height);
                        this.weight = weight;
                    }
                    this._attrBinder.addAttr('gravity', (value) => {
                        this.gravity = this._attrBinder.parseGravity(value, this.gravity);
                    }, () => {
                        return this.gravity;
                    });
                    this._attrBinder.addAttr('weight', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            this.weight = value;
                    }, () => {
                        return this.weight;
                    });
                }
            }
            LinearLayout.LayoutParams = LayoutParams;
        })(LinearLayout = widget.LinearLayout || (widget.LinearLayout = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class ArrayMap {
            constructor(capacity) {
                this.map = new Map();
            }
            clear() {
                this.map.clear();
            }
            erase() {
                this.map.clear();
            }
            ensureCapacity(minimumCapacity) {
            }
            containsKey(key) {
                return this.map.has(key);
            }
            indexOfValue(value) {
                return [...this.map.values()].indexOf(value);
            }
            containsValue(value) {
                return this.indexOfValue(value) >= 0;
            }
            get(key) {
                return this.map.get(key);
            }
            keyAt(index) {
                return [...this.map.keys()][index];
            }
            valueAt(index) {
                return [...this.map.values()][index];
            }
            setValueAt(index, value) {
                let key = this.keyAt(index);
                if (key == null)
                    throw Error('index error');
                let oldV = this.get(key);
                this.map.set(key, value);
                return oldV;
            }
            isEmpty() {
                return this.map.size <= 0;
            }
            put(key, value) {
                let oldV = this.get(key);
                this.map.set(key, value);
                return oldV;
            }
            append(key, value) {
                this.map.set(key, value);
            }
            remove(key) {
                let oldV = this.get(key);
                this.map.delete(key);
                return oldV;
            }
            removeAt(index) {
                let key = this.keyAt(index);
                if (key == null)
                    throw Error('index error');
                let oldV = this.get(key);
                this.map.delete(key);
                return oldV;
            }
            keySet() {
                return new Set(this.map.keys());
            }
            size() {
                return this.map.size;
            }
        }
        util.ArrayMap = ArrayMap;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/12/12.
 */
///<reference path="ArrayList.ts"/>
var java;
(function (java) {
    var util;
    (function (util) {
        class ArrayDeque extends util.ArrayList {
            addFirst(e) {
                this.add(0, e);
            }
            addLast(e) {
                this.add(e);
            }
            offerFirst(e) {
                this.addFirst(e);
                return true;
            }
            offerLast(e) {
                this.addLast(e);
                return true;
            }
            removeFirst() {
                let x = this.pollFirst();
                if (x == null)
                    throw Error('NoSuchElementException');
                return x;
            }
            removeLast() {
                let x = this.pollLast();
                if (x == null)
                    throw Error('NoSuchElementException');
                return x;
            }
            pollFirst() {
                return this.array.shift();
            }
            pollLast() {
                return this.array.splice(this.array.length - 1)[0];
            }
            getFirst() {
                let x = this.peekFirst();
                if (x == null)
                    throw Error('NoSuchElementException');
                return x;
            }
            getLast() {
                let x = this.peekLast();
                if (x == null)
                    throw Error('NoSuchElementException');
                return x;
            }
            peekFirst() {
                return this.array[0];
            }
            peekLast() {
                return this.array[this.array.length - 1];
            }
            removeFirstOccurrence(o) {
                if (o == null)
                    return false;
                for (let i = 0, count = this.size(); i < count; i++) {
                    if (this.array[i] == o) {
                        this.delete(i);
                        return true;
                    }
                }
                return false;
            }
            removeLastOccurrence(o) {
                if (o == null)
                    return false;
                for (let i = this.size(); i >= 0; i--) {
                    if (this.array[i] == o) {
                        this.delete(i);
                        return true;
                    }
                }
                return false;
            }
            offer(e) {
                return this.offerLast(e);
            }
            remove() {
                return this.removeFirst();
            }
            poll() {
                return this.pollFirst();
            }
            element() {
                return this.getFirst();
            }
            peek() {
                return this.peekFirst();
            }
            push(e) {
                this.addFirst(e);
            }
            pop() {
                return this.removeFirst();
            }
            delete(i) {
                if (i >= this.array.length)
                    return false;
                this.array.splice(i, 1);
                return true;
            }
        }
        util.ArrayDeque = ArrayDeque;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var util;
    (function (util) {
        class MathUtils {
            constructor() {
            }
            static abs(v) {
                return v > 0 ? v : -v;
            }
            static constrain(amount, low, high) {
                return amount < low ? low : (amount > high ? high : amount);
            }
            static log(a) {
                return Math.log(a);
            }
            static exp(a) {
                return Math.exp(a);
            }
            static pow(a, b) {
                return Math.pow(a, b);
            }
            static max(a, b, c) {
                if (c == null)
                    return a > b ? a : b;
                return a > b ? (a > c ? a : c) : (b > c ? b : c);
            }
            static min(a, b, c) {
                if (c == null)
                    return a < b ? a : b;
                return a < b ? (a < c ? a : c) : (b < c ? b : c);
            }
            static dist(x1, y1, x2, y2) {
                const x = (x2 - x1);
                const y = (y2 - y1);
                return Math.sqrt(x * x + y * y);
            }
            static dist3(x1, y1, z1, x2, y2, z2) {
                const x = (x2 - x1);
                const y = (y2 - y1);
                const z = (z2 - z1);
                return Math.sqrt(x * x + y * y + z * z);
            }
            static mag(a, b, c) {
                if (c == null)
                    return Math.sqrt(a * a + b * b);
                return Math.sqrt(a * a + b * b + c * c);
            }
            static sq(v) {
                return v * v;
            }
            static radians(degrees) {
                return degrees * MathUtils.DEG_TO_RAD;
            }
            static degrees(radians) {
                return radians * MathUtils.RAD_TO_DEG;
            }
            static acos(value) {
                return Math.acos(value);
            }
            static asin(value) {
                return Math.asin(value);
            }
            static atan(value) {
                return Math.atan(value);
            }
            static atan2(a, b) {
                return Math.atan2(a, b);
            }
            static tan(angle) {
                return Math.tan(angle);
            }
            static lerp(start, stop, amount) {
                return start + (stop - start) * amount;
            }
            static norm(start, stop, value) {
                return (value - start) / (stop - start);
            }
            static map(minStart, minStop, maxStart, maxStop, value) {
                return maxStart + (maxStart - maxStop) * ((value - minStart) / (minStop - minStart));
            }
            static random(...args) {
                if (args.length == 1)
                    return Math.random() * args[0];
                let [howsmall, howbig] = args;
                if (howsmall >= howbig)
                    return howsmall;
                return Math.random() * (howbig - howsmall) + howsmall;
            }
        }
        MathUtils.DEG_TO_RAD = 3.1415926 / 180.0;
        MathUtils.RAD_TO_DEG = 180.0 / 3.1415926;
        util.MathUtils = MathUtils;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="SparseArray.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        class SparseBooleanArray extends util.SparseArray {
        }
        util.SparseBooleanArray = SparseBooleanArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="View.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class SoundEffectConstants {
            static getContantForFocusDirection(direction) {
                switch (direction) {
                    case view.View.FOCUS_RIGHT:
                        return SoundEffectConstants.NAVIGATION_RIGHT;
                    case view.View.FOCUS_FORWARD:
                    case view.View.FOCUS_DOWN:
                        return SoundEffectConstants.NAVIGATION_DOWN;
                    case view.View.FOCUS_LEFT:
                        return SoundEffectConstants.NAVIGATION_LEFT;
                    case view.View.FOCUS_BACKWARD:
                    case view.View.FOCUS_UP:
                        return SoundEffectConstants.NAVIGATION_UP;
                }
                throw Error(`new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD, FOCUS_BACKWARD}.")`);
            }
        }
        SoundEffectConstants.CLICK = 0;
        SoundEffectConstants.NAVIGATION_LEFT = 1;
        SoundEffectConstants.NAVIGATION_UP = 2;
        SoundEffectConstants.NAVIGATION_RIGHT = 3;
        SoundEffectConstants.NAVIGATION_DOWN = 4;
        view.SoundEffectConstants = SoundEffectConstants;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/util/Log.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        class Trace {
            static nativeGetEnabledTags() {
                return Trace.TRACE_TAG_ALWAYS;
            }
            static nativeTraceCounter(tag, name, value) {
            }
            static nativeTraceBegin(tag, name) { }
            static nativeTraceEnd(tag) { }
            static nativeAsyncTraceBegin(tag, name, cookie) { }
            static nativeAsyncTraceEnd(tag, name, cookie) { }
            static nativeSetAppTracingAllowed(allowed) { }
            static nativeSetTracingEnabled(allowed) { }
            static cacheEnabledTags() {
                let tags = Trace.nativeGetEnabledTags();
                Trace.sEnabledTags = tags;
                return tags;
            }
            static isTagEnabled(traceTag) {
                let tags = Trace.sEnabledTags;
                if (tags == Trace.TRACE_TAG_NOT_READY) {
                    tags = Trace.cacheEnabledTags();
                }
                return (tags & traceTag) != 0;
            }
            static traceCounter(traceTag, counterName, counterValue) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeTraceCounter(traceTag, counterName, counterValue);
                }
            }
            static setAppTracingAllowed(allowed) {
                Trace.nativeSetAppTracingAllowed(allowed);
                Trace.cacheEnabledTags();
            }
            static setTracingEnabled(enabled) {
                Trace.nativeSetTracingEnabled(enabled);
                Trace.cacheEnabledTags();
            }
            static traceBegin(traceTag, methodName) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeTraceBegin(traceTag, methodName);
                }
            }
            static traceEnd(traceTag) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeTraceEnd(traceTag);
                }
            }
            static asyncTraceBegin(traceTag, methodName, cookie) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeAsyncTraceBegin(traceTag, methodName, cookie);
                }
            }
            static asyncTraceEnd(traceTag, methodName, cookie) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeAsyncTraceEnd(traceTag, methodName, cookie);
                }
            }
            static beginSection(sectionName) {
                if (Trace.isTagEnabled(Trace.TRACE_TAG_APP)) {
                    if (sectionName.length > Trace.MAX_SECTION_NAME_LEN) {
                        throw Error(`new IllegalArgumentException("sectionName is too long")`);
                    }
                    Trace.nativeTraceBegin(Trace.TRACE_TAG_APP, sectionName);
                }
            }
            static endSection() {
                if (Trace.isTagEnabled(Trace.TRACE_TAG_APP)) {
                    Trace.nativeTraceEnd(Trace.TRACE_TAG_APP);
                }
            }
        }
        Trace.TAG = "Trace";
        Trace.TRACE_TAG_NEVER = 0;
        Trace.TRACE_TAG_ALWAYS = 1 << 0;
        Trace.TRACE_TAG_GRAPHICS = 1 << 1;
        Trace.TRACE_TAG_INPUT = 1 << 2;
        Trace.TRACE_TAG_VIEW = 1 << 3;
        Trace.TRACE_TAG_WEBVIEW = 1 << 4;
        Trace.TRACE_TAG_WINDOW_MANAGER = 1 << 5;
        Trace.TRACE_TAG_ACTIVITY_MANAGER = 1 << 6;
        Trace.TRACE_TAG_SYNC_MANAGER = 1 << 7;
        Trace.TRACE_TAG_AUDIO = 1 << 8;
        Trace.TRACE_TAG_VIDEO = 1 << 9;
        Trace.TRACE_TAG_CAMERA = 1 << 10;
        Trace.TRACE_TAG_HAL = 1 << 11;
        Trace.TRACE_TAG_APP = 1 << 12;
        Trace.TRACE_TAG_RESOURCES = 1 << 13;
        Trace.TRACE_TAG_DALVIK = 1 << 14;
        Trace.TRACE_TAG_RS = 1 << 15;
        Trace.TRACE_TAG_NOT_READY = 1 << 63;
        Trace.MAX_SECTION_NAME_LEN = 127;
        Trace.sEnabledTags = Trace.TRACE_TAG_NOT_READY;
        os.Trace = Trace;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var text;
    (function (text) {
        class InputType {
        }
        InputType.TYPE_MASK_CLASS = 0x0000000f;
        InputType.TYPE_MASK_VARIATION = 0x00000ff0;
        InputType.TYPE_MASK_FLAGS = 0x00fff000;
        InputType.TYPE_NULL = 0x00000000;
        InputType.TYPE_CLASS_TEXT = 0x00000001;
        InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS = 0x00001000;
        InputType.TYPE_TEXT_FLAG_CAP_WORDS = 0x00002000;
        InputType.TYPE_TEXT_FLAG_CAP_SENTENCES = 0x00004000;
        InputType.TYPE_TEXT_FLAG_AUTO_CORRECT = 0x00008000;
        InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE = 0x00010000;
        InputType.TYPE_TEXT_FLAG_MULTI_LINE = 0x00020000;
        InputType.TYPE_TEXT_FLAG_IME_MULTI_LINE = 0x00040000;
        InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS = 0x00080000;
        InputType.TYPE_TEXT_VARIATION_NORMAL = 0x00000000;
        InputType.TYPE_TEXT_VARIATION_URI = 0x00000010;
        InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS = 0x00000020;
        InputType.TYPE_TEXT_VARIATION_EMAIL_SUBJECT = 0x00000030;
        InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE = 0x00000040;
        InputType.TYPE_TEXT_VARIATION_LONG_MESSAGE = 0x00000050;
        InputType.TYPE_TEXT_VARIATION_PERSON_NAME = 0x00000060;
        InputType.TYPE_TEXT_VARIATION_POSTAL_ADDRESS = 0x00000070;
        InputType.TYPE_TEXT_VARIATION_PASSWORD = 0x00000080;
        InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD = 0x00000090;
        InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT = 0x000000a0;
        InputType.TYPE_TEXT_VARIATION_FILTER = 0x000000b0;
        InputType.TYPE_TEXT_VARIATION_PHONETIC = 0x000000c0;
        InputType.TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS = 0x000000d0;
        InputType.TYPE_TEXT_VARIATION_WEB_PASSWORD = 0x000000e0;
        InputType.TYPE_CLASS_NUMBER = 0x00000002;
        InputType.TYPE_NUMBER_FLAG_SIGNED = 0x00001000;
        InputType.TYPE_NUMBER_FLAG_DECIMAL = 0x00002000;
        InputType.TYPE_NUMBER_VARIATION_NORMAL = 0x00000000;
        InputType.TYPE_NUMBER_VARIATION_PASSWORD = 0x00000010;
        InputType.TYPE_CLASS_PHONE = 0x00000003;
        InputType.TYPE_CLASS_DATETIME = 0x00000004;
        InputType.TYPE_DATETIME_VARIATION_NORMAL = 0x00000000;
        InputType.TYPE_DATETIME_VARIATION_DATE = 0x00000010;
        InputType.TYPE_DATETIME_VARIATION_TIME = 0x00000020;
        text.InputType = InputType;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="SparseArray.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        class LongSparseArray extends util.SparseArray {
        }
        util.LongSparseArray = LongSparseArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class HapticFeedbackConstants {
        }
        HapticFeedbackConstants.LONG_PRESS = 0;
        HapticFeedbackConstants.VIRTUAL_KEY = 1;
        HapticFeedbackConstants.KEYBOARD_TAP = 3;
        HapticFeedbackConstants.SAFE_MODE_DISABLED = 10000;
        HapticFeedbackConstants.SAFE_MODE_ENABLED = 10001;
        HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING = 0x0001;
        HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING = 0x0002;
        view.HapticFeedbackConstants = HapticFeedbackConstants;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
var android;
(function (android) {
    var database;
    (function (database) {
        class DataSetObserver {
            onChanged() { }
            onInvalidated() { }
        }
        database.DataSetObserver = DataSetObserver;
    })(database = android.database || (android.database = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/os/SystemClock.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Long.ts"/>
///<reference path="Adapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var DataSetObserver = android.database.DataSetObserver;
        var SystemClock = android.os.SystemClock;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Long = java.lang.Long;
        class AdapterView extends ViewGroup {
            constructor(...args) {
                super(...args);
                this.mFirstPosition = 0;
                this.mSpecificTop = 0;
                this.mSyncPosition = 0;
                this.mSyncRowId = AdapterView.INVALID_ROW_ID;
                this.mSyncHeight = 0;
                this.mNeedSync = false;
                this.mSyncMode = 0;
                this.mLayoutHeight = 0;
                this.mInLayout = false;
                this.mNextSelectedPosition = AdapterView.INVALID_POSITION;
                this.mNextSelectedRowId = AdapterView.INVALID_ROW_ID;
                this.mSelectedPosition = AdapterView.INVALID_POSITION;
                this.mSelectedRowId = AdapterView.INVALID_ROW_ID;
                this.mItemCount = 0;
                this.mOldItemCount = 0;
                this.mOldSelectedPosition = AdapterView.INVALID_POSITION;
                this.mOldSelectedRowId = AdapterView.INVALID_ROW_ID;
                this.mBlockLayoutRequests = false;
            }
            setOnItemClickListener(listener) {
                this.mOnItemClickListener = listener;
            }
            getOnItemClickListener() {
                return this.mOnItemClickListener;
            }
            performItemClick(view, position, id) {
                if (this.mOnItemClickListener != null) {
                    this.playSoundEffect(SoundEffectConstants.CLICK);
                    this.mOnItemClickListener.onItemClick(this, view, position, id);
                    return true;
                }
                return false;
            }
            setOnItemLongClickListener(listener) {
                if (!this.isLongClickable()) {
                    this.setLongClickable(true);
                }
                this.mOnItemLongClickListener = listener;
            }
            getOnItemLongClickListener() {
                return this.mOnItemLongClickListener;
            }
            setOnItemSelectedListener(listener) {
                this.mOnItemSelectedListener = listener;
            }
            getOnItemSelectedListener() {
                return this.mOnItemSelectedListener;
            }
            addView(...args) {
                throw Error(`new UnsupportedOperationException("addView() is not supported in AdapterView")`);
            }
            removeView(child) {
                throw Error(`new UnsupportedOperationException("removeView(View) is not supported in AdapterView")`);
            }
            removeViewAt(index) {
                throw Error(`new UnsupportedOperationException("removeViewAt(int) is not supported in AdapterView")`);
            }
            removeAllViews() {
                throw Error(`new UnsupportedOperationException("removeAllViews() is not supported in AdapterView")`);
            }
            onLayout(changed, left, top, right, bottom) {
                this.mLayoutHeight = this.getHeight();
            }
            getSelectedItemPosition() {
                return this.mNextSelectedPosition;
            }
            getSelectedItemId() {
                return this.mNextSelectedRowId;
            }
            getSelectedItem() {
                let adapter = this.getAdapter();
                let selection = this.getSelectedItemPosition();
                if (adapter != null && adapter.getCount() > 0 && selection >= 0) {
                    return adapter.getItem(selection);
                }
                else {
                    return null;
                }
            }
            getCount() {
                return this.mItemCount;
            }
            getPositionForView(view) {
                let listItem = view;
                try {
                    let v;
                    while (!((v = listItem.getParent()) == (this))) {
                        listItem = v;
                    }
                }
                catch (e) {
                    return AdapterView.INVALID_POSITION;
                }
                const childCount = this.getChildCount();
                for (let i = 0; i < childCount; i++) {
                    if (this.getChildAt(i) == (listItem)) {
                        return this.mFirstPosition + i;
                    }
                }
                return AdapterView.INVALID_POSITION;
            }
            getFirstVisiblePosition() {
                return this.mFirstPosition;
            }
            getLastVisiblePosition() {
                return this.mFirstPosition + this.getChildCount() - 1;
            }
            setEmptyView(emptyView) {
                this.mEmptyView = emptyView;
                const adapter = this.getAdapter();
                const empty = ((adapter == null) || adapter.isEmpty());
                this.updateEmptyStatus(empty);
            }
            getEmptyView() {
                return this.mEmptyView;
            }
            isInFilterMode() {
                return false;
            }
            setFocusable(focusable) {
                const adapter = this.getAdapter();
                const empty = adapter == null || adapter.getCount() == 0;
                this.mDesiredFocusableState = focusable;
                if (!focusable) {
                    this.mDesiredFocusableInTouchModeState = false;
                }
                super.setFocusable(focusable && (!empty || this.isInFilterMode()));
            }
            setFocusableInTouchMode(focusable) {
                const adapter = this.getAdapter();
                const empty = adapter == null || adapter.getCount() == 0;
                this.mDesiredFocusableInTouchModeState = focusable;
                if (focusable) {
                    this.mDesiredFocusableState = true;
                }
                super.setFocusableInTouchMode(focusable && (!empty || this.isInFilterMode()));
            }
            checkFocus() {
                const adapter = this.getAdapter();
                const empty = adapter == null || adapter.getCount() == 0;
                const focusable = !empty || this.isInFilterMode();
                super.setFocusableInTouchMode(focusable && this.mDesiredFocusableInTouchModeState);
                super.setFocusable(focusable && this.mDesiredFocusableState);
                if (this.mEmptyView != null) {
                    this.updateEmptyStatus((adapter == null) || adapter.isEmpty());
                }
            }
            updateEmptyStatus(empty) {
                if (this.isInFilterMode()) {
                    empty = false;
                }
                if (empty) {
                    if (this.mEmptyView != null) {
                        this.mEmptyView.setVisibility(View.VISIBLE);
                        this.setVisibility(View.GONE);
                    }
                    else {
                        this.setVisibility(View.VISIBLE);
                    }
                    if (this.mDataChanged) {
                        this.onLayout(false, this.mLeft, this.mTop, this.mRight, this.mBottom);
                    }
                }
                else {
                    if (this.mEmptyView != null)
                        this.mEmptyView.setVisibility(View.GONE);
                    this.setVisibility(View.VISIBLE);
                }
            }
            getItemAtPosition(position) {
                let adapter = this.getAdapter();
                return (adapter == null || position < 0) ? null : adapter.getItem(position);
            }
            getItemIdAtPosition(position) {
                let adapter = this.getAdapter();
                return (adapter == null || position < 0) ? AdapterView.INVALID_ROW_ID : adapter.getItemId(position);
            }
            setOnClickListener(l) {
                throw Error(`new RuntimeException("Don't call setOnClickListener for an AdapterView. " + "You probably want setOnItemClickListener instead")`);
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.removeCallbacks(this.mSelectionNotifier);
            }
            selectionChanged() {
                if (this.mOnItemSelectedListener != null) {
                    if (this.mInLayout || this.mBlockLayoutRequests) {
                        if (this.mSelectionNotifier == null) {
                            this.mSelectionNotifier = new SelectionNotifier(this);
                        }
                        this.post(this.mSelectionNotifier);
                    }
                    else {
                        this.fireOnSelected();
                        this.performAccessibilityActionsOnSelected();
                    }
                }
            }
            fireOnSelected() {
                if (this.mOnItemSelectedListener == null) {
                    return;
                }
                const selection = this.getSelectedItemPosition();
                if (selection >= 0) {
                    let v = this.getSelectedView();
                    this.mOnItemSelectedListener.onItemSelected(this, v, selection, this.getAdapter().getItemId(selection));
                }
                else {
                    this.mOnItemSelectedListener.onNothingSelected(this);
                }
            }
            performAccessibilityActionsOnSelected() {
            }
            isScrollableForAccessibility() {
                let adapter = this.getAdapter();
                if (adapter != null) {
                    const itemCount = adapter.getCount();
                    return itemCount > 0 && (this.getFirstVisiblePosition() > 0 || this.getLastVisiblePosition() < itemCount - 1);
                }
                return false;
            }
            canAnimate() {
                return super.canAnimate() && this.mItemCount > 0;
            }
            handleDataChanged() {
                const count = this.mItemCount;
                let found = false;
                if (count > 0) {
                    let newPos;
                    if (this.mNeedSync) {
                        this.mNeedSync = false;
                        newPos = this.findSyncPosition();
                        if (newPos >= 0) {
                            let selectablePos = this.lookForSelectablePosition(newPos, true);
                            if (selectablePos == newPos) {
                                this.setNextSelectedPositionInt(newPos);
                                found = true;
                            }
                        }
                    }
                    if (!found) {
                        newPos = this.getSelectedItemPosition();
                        if (newPos >= count) {
                            newPos = count - 1;
                        }
                        if (newPos < 0) {
                            newPos = 0;
                        }
                        let selectablePos = this.lookForSelectablePosition(newPos, true);
                        if (selectablePos < 0) {
                            selectablePos = this.lookForSelectablePosition(newPos, false);
                        }
                        if (selectablePos >= 0) {
                            this.setNextSelectedPositionInt(selectablePos);
                            this.checkSelectionChanged();
                            found = true;
                        }
                    }
                }
                if (!found) {
                    this.mSelectedPosition = AdapterView.INVALID_POSITION;
                    this.mSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.mNextSelectedPosition = AdapterView.INVALID_POSITION;
                    this.mNextSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.mNeedSync = false;
                    this.checkSelectionChanged();
                }
            }
            checkSelectionChanged() {
                if ((this.mSelectedPosition != this.mOldSelectedPosition) || (this.mSelectedRowId != this.mOldSelectedRowId)) {
                    this.selectionChanged();
                    this.mOldSelectedPosition = this.mSelectedPosition;
                    this.mOldSelectedRowId = this.mSelectedRowId;
                }
            }
            findSyncPosition() {
                let count = this.mItemCount;
                if (count == 0) {
                    return AdapterView.INVALID_POSITION;
                }
                let idToMatch = this.mSyncRowId;
                let seed = this.mSyncPosition;
                if (idToMatch == AdapterView.INVALID_ROW_ID) {
                    return AdapterView.INVALID_POSITION;
                }
                seed = Math.max(0, seed);
                seed = Math.min(count - 1, seed);
                let endTime = SystemClock.uptimeMillis() + AdapterView.SYNC_MAX_DURATION_MILLIS;
                let rowId;
                let first = seed;
                let last = seed;
                let next = false;
                let hitFirst;
                let hitLast;
                let adapter = this.getAdapter();
                if (adapter == null) {
                    return AdapterView.INVALID_POSITION;
                }
                while (SystemClock.uptimeMillis() <= endTime) {
                    rowId = adapter.getItemId(seed);
                    if (rowId == idToMatch) {
                        return seed;
                    }
                    hitLast = last == count - 1;
                    hitFirst = first == 0;
                    if (hitLast && hitFirst) {
                        break;
                    }
                    if (hitFirst || (next && !hitLast)) {
                        last++;
                        seed = last;
                        next = false;
                    }
                    else if (hitLast || (!next && !hitFirst)) {
                        first--;
                        seed = first;
                        next = true;
                    }
                }
                return AdapterView.INVALID_POSITION;
            }
            lookForSelectablePosition(position, lookDown) {
                return position;
            }
            setSelectedPositionInt(position) {
                this.mSelectedPosition = position;
                this.mSelectedRowId = this.getItemIdAtPosition(position);
            }
            setNextSelectedPositionInt(position) {
                this.mNextSelectedPosition = position;
                this.mNextSelectedRowId = this.getItemIdAtPosition(position);
                if (this.mNeedSync && this.mSyncMode == AdapterView.SYNC_SELECTED_POSITION && position >= 0) {
                    this.mSyncPosition = position;
                    this.mSyncRowId = this.mNextSelectedRowId;
                }
            }
            rememberSyncState() {
                if (this.getChildCount() > 0) {
                    this.mNeedSync = true;
                    this.mSyncHeight = this.mLayoutHeight;
                    if (this.mSelectedPosition >= 0) {
                        let v = this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                        this.mSyncRowId = this.mNextSelectedRowId;
                        this.mSyncPosition = this.mNextSelectedPosition;
                        if (v != null) {
                            this.mSpecificTop = v.getTop();
                        }
                        this.mSyncMode = AdapterView.SYNC_SELECTED_POSITION;
                    }
                    else {
                        let v = this.getChildAt(0);
                        let adapter = this.getAdapter();
                        if (this.mFirstPosition >= 0 && this.mFirstPosition < adapter.getCount()) {
                            this.mSyncRowId = adapter.getItemId(this.mFirstPosition);
                        }
                        else {
                            this.mSyncRowId = AdapterView.NO_ID;
                        }
                        this.mSyncPosition = this.mFirstPosition;
                        if (v != null) {
                            this.mSpecificTop = v.getTop();
                        }
                        this.mSyncMode = AdapterView.SYNC_FIRST_POSITION;
                    }
                }
            }
        }
        AdapterView.ITEM_VIEW_TYPE_IGNORE = -1;
        AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER = -2;
        AdapterView.SYNC_SELECTED_POSITION = 0;
        AdapterView.SYNC_FIRST_POSITION = 1;
        AdapterView.SYNC_MAX_DURATION_MILLIS = 100;
        AdapterView.INVALID_POSITION = -1;
        AdapterView.INVALID_ROW_ID = Long.MIN_VALUE;
        widget.AdapterView = AdapterView;
        (function (AdapterView) {
            class AdapterDataSetObserver extends DataSetObserver {
                constructor(AdapterView_this) {
                    super();
                    this.AdapterView_this = AdapterView_this;
                }
                onChanged() {
                    this.AdapterView_this.mDataChanged = true;
                    this.AdapterView_this.mOldItemCount = this.AdapterView_this.mItemCount;
                    this.AdapterView_this.mItemCount = this.AdapterView_this.getAdapter().getCount();
                    this.AdapterView_this.rememberSyncState();
                    this.AdapterView_this.checkFocus();
                    this.AdapterView_this.requestLayout();
                }
                onInvalidated() {
                    this.AdapterView_this.mDataChanged = true;
                    this.AdapterView_this.mOldItemCount = this.AdapterView_this.mItemCount;
                    this.AdapterView_this.mItemCount = 0;
                    this.AdapterView_this.mSelectedPosition = AdapterView.INVALID_POSITION;
                    this.AdapterView_this.mSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.AdapterView_this.mNextSelectedPosition = AdapterView.INVALID_POSITION;
                    this.AdapterView_this.mNextSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.AdapterView_this.mNeedSync = false;
                    this.AdapterView_this.checkFocus();
                    this.AdapterView_this.requestLayout();
                }
                clearSavedState() {
                }
            }
            AdapterView.AdapterDataSetObserver = AdapterDataSetObserver;
        })(AdapterView = widget.AdapterView || (widget.AdapterView = {}));
        class SelectionNotifier {
            constructor(AdapterView_this) {
                this.AdapterView_this = AdapterView_this;
            }
            run() {
                if (this.AdapterView_this.mDataChanged) {
                    if (this.AdapterView_this.getAdapter() != null) {
                        this.AdapterView_this.post(this);
                    }
                }
                else {
                    this.AdapterView_this.fireOnSelected();
                    this.AdapterView_this.performAccessibilityActionsOnSelected();
                }
            }
        }
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="AdapterView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Integer = java.lang.Integer;
        var Adapter;
        (function (Adapter) {
            Adapter.IGNORE_ITEM_VIEW_TYPE = widget.AdapterView.ITEM_VIEW_TYPE_IGNORE;
            Adapter.NO_SELECTION = Integer.MIN_VALUE;
        })(Adapter = widget.Adapter || (widget.Adapter = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Path.ts"/>
///<reference path="../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextLine.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text_8) {
        var Paint = android.graphics.Paint;
        var ParagraphStyle = android.text.style.ParagraphStyle;
        var Layout = android.text.Layout;
        var Spanned = android.text.Spanned;
        var TextDirectionHeuristics = android.text.TextDirectionHeuristics;
        var TextLine = android.text.TextLine;
        var TextPaint = android.text.TextPaint;
        var TextUtils = android.text.TextUtils;
        class BoringLayout extends Layout {
            constructor(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, ellipsize = null, ellipsizedWidth = outerwidth) {
                super(source, paint, outerwidth, align, TextDirectionHeuristics.FIRSTSTRONG_LTR, spacingmult, spacingadd);
                this.mBottom = 0;
                this.mDesc = 0;
                this.mTopPadding = 0;
                this.mBottomPadding = 0;
                this.mMax = 0;
                this.mEllipsizedWidth = 0;
                this.mEllipsizedStart = 0;
                this.mEllipsizedCount = 0;
                let trust;
                if (ellipsize == null || ellipsize == TextUtils.TruncateAt.MARQUEE) {
                    this.mEllipsizedWidth = outerwidth;
                    this.mEllipsizedStart = 0;
                    this.mEllipsizedCount = 0;
                    trust = true;
                }
                else {
                    this.replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerwidth, align, spacingmult, spacingadd);
                    this.mEllipsizedWidth = ellipsizedWidth;
                    trust = false;
                }
                this.init(this.getText(), paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, trust);
            }
            static make(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, ellipsize = null, ellipsizedWidth = outerwidth) {
                return new BoringLayout(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, ellipsize, ellipsizedWidth);
            }
            replaceOrMake(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, ellipsize = null, ellipsizedWidth = outerwidth) {
                let trust;
                if (ellipsize == null || ellipsize == TextUtils.TruncateAt.MARQUEE) {
                    this.replaceWith(source, paint, outerwidth, align, spacingmult, spacingadd);
                    this.mEllipsizedWidth = outerwidth;
                    this.mEllipsizedStart = 0;
                    this.mEllipsizedCount = 0;
                    trust = true;
                }
                else {
                    this.replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerwidth, align, spacingmult, spacingadd);
                    this.mEllipsizedWidth = ellipsizedWidth;
                    trust = false;
                }
                this.init(this.getText(), paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, trust);
                return this;
            }
            init(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, trustWidth) {
                let spacing;
                if (Object.getPrototypeOf(source) === String.prototype && align == Layout.Alignment.ALIGN_NORMAL) {
                    this.mDirect = source.toString();
                }
                else {
                    this.mDirect = null;
                }
                this.mPaint = paint;
                if (includepad) {
                    spacing = metrics.bottom - metrics.top;
                }
                else {
                    spacing = metrics.descent - metrics.ascent;
                }
                if (spacingmult != 1 || spacingadd != 0) {
                    spacing = Math.floor((spacing * spacingmult + spacingadd + 0.5));
                }
                this.mBottom = spacing;
                if (includepad) {
                    this.mDesc = spacing + metrics.top;
                }
                else {
                    this.mDesc = spacing + metrics.ascent;
                }
                if (trustWidth) {
                    this.mMax = metrics.width;
                }
                else {
                    let line = TextLine.obtain();
                    line.set(paint, source, 0, source.length, Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
                    this.mMax = Math.floor(Math.ceil(line.metrics(null)));
                    TextLine.recycle(line);
                }
                if (includepad) {
                    this.mTopPadding = metrics.top - metrics.ascent;
                    this.mBottomPadding = metrics.bottom - metrics.descent;
                }
            }
            static isBoring(text, paint, textDir = TextDirectionHeuristics.FIRSTSTRONG_LTR, metrics = null) {
                let temp;
                let length = text.length;
                let boring = true;
                outer: for (let i = 0; i < length; i += 500) {
                    let j = i + 500;
                    if (j > length)
                        j = length;
                    temp = text.substring(i, j);
                    let n = j - i;
                    for (let a = 0; a < n; a++) {
                        let c = temp[a];
                        if (c == '\n' || c == '\t') {
                            boring = false;
                            break outer;
                        }
                    }
                    if (textDir != null && textDir.isRtl(temp, 0, n)) {
                        boring = false;
                        break outer;
                    }
                }
                if (boring && Spanned.isImplements(text)) {
                    let sp = text;
                    let styles = sp.getSpans(0, length, ParagraphStyle.type);
                    if (styles.length > 0) {
                        boring = false;
                    }
                }
                if (boring) {
                    let fm = metrics;
                    if (fm == null) {
                        fm = new BoringLayout.Metrics();
                    }
                    let line = TextLine.obtain();
                    line.set(paint, text, 0, length, Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
                    fm.width = Math.floor(Math.ceil(line.metrics(fm)));
                    TextLine.recycle(line);
                    return fm;
                }
                else {
                    return null;
                }
            }
            getHeight() {
                return this.mBottom;
            }
            getLineCount() {
                return 1;
            }
            getLineTop(line) {
                if (line == 0)
                    return 0;
                else
                    return this.mBottom;
            }
            getLineDescent(line) {
                return this.mDesc;
            }
            getLineStart(line) {
                if (line == 0)
                    return 0;
                else
                    return this.getText().length;
            }
            getParagraphDirection(line) {
                return BoringLayout.DIR_LEFT_TO_RIGHT;
            }
            getLineContainsTab(line) {
                return false;
            }
            getLineMax(line) {
                return this.mMax;
            }
            getLineDirections(line) {
                return Layout.DIRS_ALL_LEFT_TO_RIGHT;
            }
            getTopPadding() {
                return this.mTopPadding;
            }
            getBottomPadding() {
                return this.mBottomPadding;
            }
            getEllipsisCount(line) {
                return this.mEllipsizedCount;
            }
            getEllipsisStart(line) {
                return this.mEllipsizedStart;
            }
            getEllipsizedWidth() {
                return this.mEllipsizedWidth;
            }
            draw(c, highlight, highlightpaint, cursorOffset) {
                if (this.mDirect != null && highlight == null) {
                    c.drawText(this.mDirect, 0, this.mBottom - this.mDesc, this.mPaint);
                }
                else {
                    super.draw(c, highlight, highlightpaint, cursorOffset);
                }
            }
            ellipsized(start, end) {
                this.mEllipsizedStart = start;
                this.mEllipsizedCount = end - start;
            }
        }
        BoringLayout.FIRST_RIGHT_TO_LEFT = ''.codePointAt(0);
        BoringLayout.sTemp = new TextPaint();
        text_8.BoringLayout = BoringLayout;
        (function (BoringLayout) {
            class Metrics extends Paint.FontMetricsInt {
                constructor(...args) {
                    super(...args);
                    this.width = 0;
                }
                toString() {
                    return super.toString() + " width=" + this.width;
                }
            }
            BoringLayout.Metrics = Metrics;
        })(BoringLayout = text_8.BoringLayout || (text_8.BoringLayout = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../java/lang/System.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var System = java.lang.System;
        class PackedIntVector {
            constructor(columns) {
                this.mColumns = 0;
                this.mRows = 0;
                this.mRowGapStart = 0;
                this.mRowGapLength = 0;
                this.mColumns = columns;
                this.mRows = 0;
                this.mRowGapStart = 0;
                this.mRowGapLength = this.mRows;
                this.mValues = null;
                this.mValueGap = new Array(2 * columns);
            }
            getValue(row, column) {
                const columns = this.mColumns;
                if (((row | column) < 0) || (row >= this.size()) || (column >= columns)) {
                    throw Error(`new IndexOutOfBoundsException(row + ", " + column)`);
                }
                if (row >= this.mRowGapStart) {
                    row += this.mRowGapLength;
                }
                let value = this.mValues[row * columns + column];
                let valuegap = this.mValueGap;
                if (row >= valuegap[column]) {
                    value += valuegap[column + columns];
                }
                return value;
            }
            setValue(row, column, value) {
                if (((row | column) < 0) || (row >= this.size()) || (column >= this.mColumns)) {
                    throw Error(`new IndexOutOfBoundsException(row + ", " + column)`);
                }
                if (row >= this.mRowGapStart) {
                    row += this.mRowGapLength;
                }
                let valuegap = this.mValueGap;
                if (row >= valuegap[column]) {
                    value -= valuegap[column + this.mColumns];
                }
                this.mValues[row * this.mColumns + column] = value;
            }
            setValueInternal(row, column, value) {
                if (row >= this.mRowGapStart) {
                    row += this.mRowGapLength;
                }
                let valuegap = this.mValueGap;
                if (row >= valuegap[column]) {
                    value -= valuegap[column + this.mColumns];
                }
                this.mValues[row * this.mColumns + column] = value;
            }
            adjustValuesBelow(startRow, column, delta) {
                if (((startRow | column) < 0) || (startRow > this.size()) || (column >= this.width())) {
                    throw Error(`new IndexOutOfBoundsException(startRow + ", " + column)`);
                }
                if (startRow >= this.mRowGapStart) {
                    startRow += this.mRowGapLength;
                }
                this.moveValueGapTo(column, startRow);
                this.mValueGap[column + this.mColumns] += delta;
            }
            insertAt(row, values) {
                if ((row < 0) || (row > this.size())) {
                    throw Error(`new IndexOutOfBoundsException("row " + row)`);
                }
                if ((values != null) && (values.length < this.width())) {
                    throw Error(`new IndexOutOfBoundsException("value count " + values.length)`);
                }
                this.moveRowGapTo(row);
                if (this.mRowGapLength == 0) {
                    this.growBuffer();
                }
                this.mRowGapStart++;
                this.mRowGapLength--;
                if (values == null) {
                    for (let i = this.mColumns - 1; i >= 0; i--) {
                        this.setValueInternal(row, i, 0);
                    }
                }
                else {
                    for (let i = this.mColumns - 1; i >= 0; i--) {
                        this.setValueInternal(row, i, values[i]);
                    }
                }
            }
            deleteAt(row, count) {
                if (((row | count) < 0) || (row + count > this.size())) {
                    throw Error(`new IndexOutOfBoundsException(row + ", " + count)`);
                }
                this.moveRowGapTo(row + count);
                this.mRowGapStart -= count;
                this.mRowGapLength += count;
            }
            size() {
                return this.mRows - this.mRowGapLength;
            }
            width() {
                return this.mColumns;
            }
            growBuffer() {
                const columns = this.mColumns;
                let newsize = this.size() + 1;
                newsize = (newsize * columns) / columns;
                let newvalues = new Array(newsize * columns);
                const valuegap = this.mValueGap;
                const rowgapstart = this.mRowGapStart;
                let after = this.mRows - (rowgapstart + this.mRowGapLength);
                if (this.mValues != null) {
                    System.arraycopy(this.mValues, 0, newvalues, 0, columns * rowgapstart);
                    System.arraycopy(this.mValues, (this.mRows - after) * columns, newvalues, (newsize - after) * columns, after * columns);
                }
                for (let i = 0; i < columns; i++) {
                    if (valuegap[i] >= rowgapstart) {
                        valuegap[i] += newsize - this.mRows;
                        if (valuegap[i] < rowgapstart) {
                            valuegap[i] = rowgapstart;
                        }
                    }
                }
                this.mRowGapLength += newsize - this.mRows;
                this.mRows = newsize;
                this.mValues = newvalues;
            }
            moveValueGapTo(column, where) {
                const valuegap = this.mValueGap;
                const values = this.mValues;
                const columns = this.mColumns;
                if (where == valuegap[column]) {
                    return;
                }
                else if (where > valuegap[column]) {
                    for (let i = valuegap[column]; i < where; i++) {
                        values[i * columns + column] += valuegap[column + columns];
                    }
                }
                else {
                    for (let i = where; i < valuegap[column]; i++) {
                        values[i * columns + column] -= valuegap[column + columns];
                    }
                }
                valuegap[column] = where;
            }
            moveRowGapTo(where) {
                if (where == this.mRowGapStart) {
                    return;
                }
                else if (where > this.mRowGapStart) {
                    let moving = where + this.mRowGapLength - (this.mRowGapStart + this.mRowGapLength);
                    const columns = this.mColumns;
                    const valuegap = this.mValueGap;
                    const values = this.mValues;
                    const gapend = this.mRowGapStart + this.mRowGapLength;
                    for (let i = gapend; i < gapend + moving; i++) {
                        let destrow = i - gapend + this.mRowGapStart;
                        for (let j = 0; j < columns; j++) {
                            let val = values[i * columns + j];
                            if (i >= valuegap[j]) {
                                val += valuegap[j + columns];
                            }
                            if (destrow >= valuegap[j]) {
                                val -= valuegap[j + columns];
                            }
                            values[destrow * columns + j] = val;
                        }
                    }
                }
                else {
                    let moving = this.mRowGapStart - where;
                    const columns = this.mColumns;
                    const valuegap = this.mValueGap;
                    const values = this.mValues;
                    const gapend = this.mRowGapStart + this.mRowGapLength;
                    for (let i = where + moving - 1; i >= where; i--) {
                        let destrow = i - where + gapend - moving;
                        for (let j = 0; j < columns; j++) {
                            let val = values[i * columns + j];
                            if (i >= valuegap[j]) {
                                val += valuegap[j + columns];
                            }
                            if (destrow >= valuegap[j]) {
                                val -= valuegap[j + columns];
                            }
                            values[destrow * columns + j] = val;
                        }
                    }
                }
                this.mRowGapStart = where;
            }
        }
        text.PackedIntVector = PackedIntVector;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../java/lang/System.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var System = java.lang.System;
        class PackedObjectVector {
            constructor(columns) {
                this.mColumns = 0;
                this.mRows = 0;
                this.mRowGapStart = 0;
                this.mRowGapLength = 0;
                this.mColumns = columns;
                this.mRows = 1;
                this.mRowGapStart = 0;
                this.mRowGapLength = this.mRows;
                this.mValues = new Array(this.mRows * this.mColumns);
            }
            getValue(row, column) {
                if (row >= this.mRowGapStart)
                    row += this.mRowGapLength;
                let value = this.mValues[row * this.mColumns + column];
                return value;
            }
            setValue(row, column, value) {
                if (row >= this.mRowGapStart)
                    row += this.mRowGapLength;
                this.mValues[row * this.mColumns + column] = value;
            }
            insertAt(row, values) {
                this.moveRowGapTo(row);
                if (this.mRowGapLength == 0)
                    this.growBuffer();
                this.mRowGapStart++;
                this.mRowGapLength--;
                if (values == null)
                    for (let i = 0; i < this.mColumns; i++)
                        this.setValue(row, i, null);
                else
                    for (let i = 0; i < this.mColumns; i++)
                        this.setValue(row, i, values[i]);
            }
            deleteAt(row, count) {
                this.moveRowGapTo(row + count);
                this.mRowGapStart -= count;
                this.mRowGapLength += count;
                if (this.mRowGapLength > this.size() * 2) {
                }
            }
            size() {
                return this.mRows - this.mRowGapLength;
            }
            width() {
                return this.mColumns;
            }
            growBuffer() {
                let newsize = this.size() + 1;
                newsize = (newsize * this.mColumns) / this.mColumns;
                let newvalues = new Array(newsize * this.mColumns);
                let after = this.mRows - (this.mRowGapStart + this.mRowGapLength);
                System.arraycopy(this.mValues, 0, newvalues, 0, this.mColumns * this.mRowGapStart);
                System.arraycopy(this.mValues, (this.mRows - after) * this.mColumns, newvalues, (newsize - after) * this.mColumns, after * this.mColumns);
                this.mRowGapLength += newsize - this.mRows;
                this.mRows = newsize;
                this.mValues = newvalues;
            }
            moveRowGapTo(where) {
                if (where == this.mRowGapStart)
                    return;
                if (where > this.mRowGapStart) {
                    let moving = where + this.mRowGapLength - (this.mRowGapStart + this.mRowGapLength);
                    for (let i = this.mRowGapStart + this.mRowGapLength; i < this.mRowGapStart + this.mRowGapLength + moving; i++) {
                        let destrow = i - (this.mRowGapStart + this.mRowGapLength) + this.mRowGapStart;
                        for (let j = 0; j < this.mColumns; j++) {
                            let val = this.mValues[i * this.mColumns + j];
                            this.mValues[destrow * this.mColumns + j] = val;
                        }
                    }
                }
                else {
                    let moving = this.mRowGapStart - where;
                    for (let i = where + moving - 1; i >= where; i--) {
                        let destrow = i - where + this.mRowGapStart + this.mRowGapLength - moving;
                        for (let j = 0; j < this.mColumns; j++) {
                            let val = this.mValues[i * this.mColumns + j];
                            this.mValues[destrow * this.mColumns + j] = val;
                        }
                    }
                }
                this.mRowGapStart = where;
            }
            dump() {
                for (let i = 0; i < this.mRows; i++) {
                    for (let j = 0; j < this.mColumns; j++) {
                        let val = this.mValues[i * this.mColumns + j];
                        if (i < this.mRowGapStart || i >= this.mRowGapStart + this.mRowGapLength)
                            System.out.print(val + " ");
                        else
                            System.out.print("(" + val + ") ");
                    }
                    System.out.print(" << \n");
                }
                System.out.print("-----\n\n");
            }
        }
        text.PackedObjectVector = PackedObjectVector;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/TextWatcher.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var Spannable;
        (function (Spannable) {
            function isImpl(obj) {
                return obj && obj['setSpan'] && obj['removeSpan'];
            }
            Spannable.isImpl = isImpl;
            class Factory {
                static getInstance() {
                    return Factory.sInstance;
                }
                newSpannable(source) {
                    return source;
                }
            }
            Factory.sInstance = new Factory();
            Spannable.Factory = Factory;
        })(Spannable = text.Spannable || (text.Spannable = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/text/Layout.ts"/>
///<reference path="../../../android/text/TextPaint.ts"/>
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../../android/text/style/WrapTogetherSpan.ts"/>
var android;
(function (android) {
    var text;
    (function (text_9) {
        var style;
        (function (style) {
            var LineHeightSpan;
            (function (LineHeightSpan) {
                LineHeightSpan.type = Symbol();
            })(LineHeightSpan = style.LineHeightSpan || (style.LineHeightSpan = {}));
        })(style = text_9.style || (text_9.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/text/style/LeadingMarginSpan.ts"/>
///<reference path="../../android/text/style/LineHeightSpan.ts"/>
///<reference path="../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../android/text/style/TabStopSpan.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/MeasuredText.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text_10) {
        var Paint = android.graphics.Paint;
        var LeadingMarginSpan = android.text.style.LeadingMarginSpan;
        var LeadingMarginSpan2 = android.text.style.LeadingMarginSpan.LeadingMarginSpan2;
        var LineHeightSpan = android.text.style.LineHeightSpan;
        var MetricAffectingSpan = android.text.style.MetricAffectingSpan;
        var TabStopSpan = android.text.style.TabStopSpan;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        var Layout = android.text.Layout;
        var MeasuredText = android.text.MeasuredText;
        var Spanned = android.text.Spanned;
        var TextUtils = android.text.TextUtils;
        class StaticLayout extends Layout {
            constructor(source, bufstart, bufend, paint, outerwidth, align, textDir, spacingmult, spacingadd, includepad, ellipsize = null, ellipsizedWidth = 0, maxLines = Integer.MAX_VALUE) {
                super((ellipsize == null) ? source : (Spanned.isImplements(source)) ? new Layout.SpannedEllipsizer(source) : new Layout.Ellipsizer(source), paint, outerwidth, align, textDir, spacingmult, spacingadd);
                this.mLineCount = 0;
                this.mTopPadding = 0;
                this.mBottomPadding = 0;
                this.mColumns = 0;
                this.mEllipsizedWidth = 0;
                this.mMaximumVisibleLineCount = Integer.MAX_VALUE;
                this.mFontMetricsInt = new Paint.FontMetricsInt();
                if (source == null) {
                    this.mColumns = StaticLayout.COLUMNS_ELLIPSIZE;
                    this.mLines = new Array((2 * this.mColumns));
                    this.mLineDirections = new Array((2 * this.mColumns));
                    this.mMeasured = MeasuredText.obtain();
                    return;
                }
                if (ellipsize != null) {
                    let e = this.getText();
                    e.mLayout = this;
                    e.mWidth = ellipsizedWidth;
                    e.mMethod = ellipsize;
                    this.mEllipsizedWidth = ellipsizedWidth;
                    this.mColumns = StaticLayout.COLUMNS_ELLIPSIZE;
                }
                else {
                    this.mColumns = StaticLayout.COLUMNS_NORMAL;
                    this.mEllipsizedWidth = outerwidth;
                }
                this.mLines = new Array(2 * this.mColumns);
                this.mLineDirections = new Array(2 * this.mColumns);
                this.mMaximumVisibleLineCount = maxLines;
                this.mMeasured = MeasuredText.obtain();
                this.generate(source, bufstart, bufend, paint, outerwidth, textDir, spacingmult, spacingadd, includepad, includepad, ellipsizedWidth, ellipsize);
                this.mMeasured = MeasuredText.recycle(this.mMeasured);
                this.mFontMetricsInt = null;
            }
            generate(source, bufStart, bufEnd, paint, outerWidth, textDir, spacingmult, spacingadd, includepad, trackpad, ellipsizedWidth, ellipsize) {
                this.mLineCount = 0;
                let v = 0;
                let needMultiply = (spacingmult != 1 || spacingadd != 0);
                let fm = this.mFontMetricsInt;
                let chooseHtv = null;
                let measured = this.mMeasured;
                let spanned = null;
                if (Spanned.isImplements(source))
                    spanned = source;
                let DEFAULT_DIR = StaticLayout.DIR_LEFT_TO_RIGHT;
                let paraEnd;
                for (let paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
                    paraEnd = source.substring(0, bufEnd).indexOf(StaticLayout.CHAR_NEW_LINE, paraStart);
                    if (paraEnd < 0)
                        paraEnd = bufEnd;
                    else
                        paraEnd++;
                    let firstWidthLineLimit = this.mLineCount + 1;
                    let firstWidth = outerWidth;
                    let restWidth = outerWidth;
                    let chooseHt = null;
                    if (spanned != null) {
                        let sp = StaticLayout.getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.type);
                        for (let i = 0; i < sp.length; i++) {
                            let lms = sp[i];
                            firstWidth -= sp[i].getLeadingMargin(true);
                            restWidth -= sp[i].getLeadingMargin(false);
                            if (LeadingMarginSpan2.isImpl(lms)) {
                                let lms2 = lms;
                                let lmsFirstLine = this.getLineForOffset(spanned.getSpanStart(lms2));
                                firstWidthLineLimit = lmsFirstLine + lms2.getLeadingMarginLineCount();
                            }
                        }
                        chooseHt = StaticLayout.getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.type);
                        if (chooseHt.length != 0) {
                            if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                                chooseHtv = new Array(chooseHt.length);
                            }
                            for (let i = 0; i < chooseHt.length; i++) {
                                let o = spanned.getSpanStart(chooseHt[i]);
                                if (o < paraStart) {
                                    chooseHtv[i] = this.getLineTop(this.getLineForOffset(o));
                                }
                                else {
                                    chooseHtv[i] = v;
                                }
                            }
                        }
                    }
                    measured.setPara(source, paraStart, paraEnd, textDir);
                    let chs = measured.mChars;
                    let widths = measured.mWidths;
                    let chdirs = measured.mLevels;
                    let dir = measured.mDir;
                    let easy = measured.mEasy;
                    let width = firstWidth;
                    let w = 0;
                    let here = paraStart;
                    let ok = paraStart;
                    let okWidth = w;
                    let okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
                    let fit = paraStart;
                    let fitWidth = w;
                    let fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
                    let hasTabOrEmoji = false;
                    let hasTab = false;
                    let tabStops = null;
                    for (let spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
                        if (spanned == null) {
                            spanEnd = paraEnd;
                            let spanLen = spanEnd - spanStart;
                            measured.addStyleRun(paint, spanLen, fm);
                        }
                        else {
                            spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.type);
                            let spanLen = spanEnd - spanStart;
                            let spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.type);
                            spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.type);
                            measured.addStyleRun(paint, spans, spanLen, fm);
                        }
                        let fmTop = fm.top;
                        let fmBottom = fm.bottom;
                        let fmAscent = fm.ascent;
                        let fmDescent = fm.descent;
                        for (let j = spanStart; j < spanEnd; j++) {
                            let c = chs[j - paraStart];
                            if (c == StaticLayout.CHAR_NEW_LINE) {
                            }
                            else if (c == StaticLayout.CHAR_TAB) {
                                if (hasTab == false) {
                                    hasTab = true;
                                    hasTabOrEmoji = true;
                                    if (spanned != null) {
                                        let spans = StaticLayout.getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.type);
                                        if (spans.length > 0) {
                                            tabStops = new Layout.TabStops(StaticLayout.TAB_INCREMENT, spans);
                                        }
                                    }
                                }
                                if (tabStops != null) {
                                    w = tabStops.nextTab(w);
                                }
                                else {
                                    w = StaticLayout.TabStops.nextDefaultStop(w, StaticLayout.TAB_INCREMENT);
                                }
                            }
                            else if (c.codePointAt(0) >= StaticLayout.CHAR_FIRST_HIGH_SURROGATE
                                && c.codePointAt(0) <= StaticLayout.CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                                let emoji = chs.codePointAt(j - paraStart);
                                w += widths[j - paraStart];
                            }
                            else {
                                w += widths[j - paraStart];
                            }
                            let isSpaceOrTab = c == StaticLayout.CHAR_SPACE || c == StaticLayout.CHAR_TAB || c == StaticLayout.CHAR_ZWSP;
                            if (w <= width || isSpaceOrTab) {
                                fitWidth = w;
                                fit = j + 1;
                                if (fmTop < fitTop)
                                    fitTop = fmTop;
                                if (fmAscent < fitAscent)
                                    fitAscent = fmAscent;
                                if (fmDescent > fitDescent)
                                    fitDescent = fmDescent;
                                if (fmBottom > fitBottom)
                                    fitBottom = fmBottom;
                                let isLineBreak = isSpaceOrTab ||
                                    ((c == StaticLayout.CHAR_SLASH || c == StaticLayout.CHAR_HYPHEN) && (j + 1 >= spanEnd ||
                                        !Number.isInteger(Number.parseInt(chs[j + 1 - paraStart])))) ||
                                    (c.codePointAt(0) >= StaticLayout.CHAR_FIRST_CJK.codePointAt(0) && StaticLayout.isIdeographic(c, true) && j + 1 < spanEnd && StaticLayout.isIdeographic(chs[j + 1 - paraStart], false));
                                if (isLineBreak) {
                                    okWidth = w;
                                    ok = j + 1;
                                    if (fitTop < okTop)
                                        okTop = fitTop;
                                    if (fitAscent < okAscent)
                                        okAscent = fitAscent;
                                    if (fitDescent > okDescent)
                                        okDescent = fitDescent;
                                    if (fitBottom > okBottom)
                                        okBottom = fitBottom;
                                }
                            }
                            else {
                                const moreChars = (j + 1 < spanEnd);
                                let endPos;
                                let above, below, top, bottom;
                                let currentTextWidth;
                                if (ok != here) {
                                    endPos = ok;
                                    above = okAscent;
                                    below = okDescent;
                                    top = okTop;
                                    bottom = okBottom;
                                    currentTextWidth = okWidth;
                                }
                                else if (fit != here) {
                                    endPos = fit;
                                    above = fitAscent;
                                    below = fitDescent;
                                    top = fitTop;
                                    bottom = fitBottom;
                                    currentTextWidth = fitWidth;
                                }
                                else {
                                    endPos = here + 1;
                                    above = fm.ascent;
                                    below = fm.descent;
                                    top = fm.top;
                                    bottom = fm.bottom;
                                    currentTextWidth = widths[here - paraStart];
                                }
                                v = this.out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                                here = endPos;
                                j = here - 1;
                                ok = fit = here;
                                w = 0;
                                fitAscent = fitDescent = fitTop = fitBottom = 0;
                                okAscent = okDescent = okTop = okBottom = 0;
                                if (--firstWidthLineLimit <= 0) {
                                    width = restWidth;
                                }
                                if (here < spanStart) {
                                    measured.setPos(here);
                                    spanEnd = here;
                                    break;
                                }
                                if (this.mLineCount >= this.mMaximumVisibleLineCount) {
                                    break;
                                }
                            }
                        }
                    }
                    if (paraEnd != here && this.mLineCount < this.mMaximumVisibleLineCount) {
                        if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                            paint.getFontMetricsInt(fm);
                            fitTop = fm.top;
                            fitBottom = fm.bottom;
                            fitAscent = fm.ascent;
                            fitDescent = fm.descent;
                        }
                        v = this.out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
                    }
                    paraStart = paraEnd;
                    if (paraEnd == bufEnd)
                        break;
                }
                if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == StaticLayout.CHAR_NEW_LINE) && this.mLineCount < this.mMaximumVisibleLineCount) {
                    measured.setPara(source, bufStart, bufEnd, textDir);
                    paint.getFontMetricsInt(fm);
                    v = this.out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
                }
            }
            static isIdeographic(c, includeNonStarters) {
                let code = c.codePointAt(0);
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    return true;
                }
                if (c == '') {
                    return true;
                }
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    if (!includeNonStarters) {
                        switch (c) {
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                                return false;
                        }
                    }
                    return true;
                }
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    if (!includeNonStarters) {
                        switch (c) {
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                            case '':
                                return false;
                        }
                    }
                    return true;
                }
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    return true;
                }
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    return true;
                }
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    return true;
                }
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    return true;
                }
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    return true;
                }
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    return true;
                }
                if (code >= ''.codePointAt(0) && code <= ''.codePointAt(0)) {
                    return true;
                }
                return false;
            }
            out(text, start, end, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includePad, trackPad, chs, widths, widthStart, ellipsize, ellipsisWidth, textWidth, paint, moreChars) {
                let j = this.mLineCount;
                let off = j * this.mColumns;
                let want = off + this.mColumns + StaticLayout.TOP;
                let lines = this.mLines;
                if (want >= lines.length) {
                    let nlen = (want + 1);
                    let grow = new Array(nlen);
                    System.arraycopy(lines, 0, grow, 0, lines.length);
                    this.mLines = grow;
                    lines = grow;
                    let grow2 = new Array(nlen);
                    System.arraycopy(this.mLineDirections, 0, grow2, 0, this.mLineDirections.length);
                    this.mLineDirections = grow2;
                }
                if (chooseHt != null) {
                    fm.ascent = above;
                    fm.descent = below;
                    fm.top = top;
                    fm.bottom = bottom;
                    for (let i = 0; i < chooseHt.length; i++) {
                        chooseHt[i].chooseHeight(text, start, end, chooseHtv[i], v, fm, paint);
                    }
                    above = fm.ascent;
                    below = fm.descent;
                    top = fm.top;
                    bottom = fm.bottom;
                }
                if (j == 0) {
                    if (trackPad) {
                        this.mTopPadding = top - above;
                    }
                    if (includePad) {
                        above = top;
                    }
                }
                if (end == bufEnd) {
                    if (trackPad) {
                        this.mBottomPadding = bottom - below;
                    }
                    if (includePad) {
                        below = bottom;
                    }
                }
                let extra;
                if (needMultiply) {
                    let ex = (below - above) * (spacingmult - 1) + spacingadd;
                    if (ex >= 0) {
                        extra = Math.floor((ex + StaticLayout.EXTRA_ROUNDING));
                    }
                    else {
                        extra = -Math.floor((-ex + StaticLayout.EXTRA_ROUNDING));
                    }
                }
                else {
                    extra = 0;
                }
                lines[off + StaticLayout.START] = start;
                lines[off + StaticLayout.TOP] = v;
                lines[off + StaticLayout.DESCENT] = below + extra;
                v += (below - above) + extra;
                lines[off + this.mColumns + StaticLayout.START] = end;
                lines[off + this.mColumns + StaticLayout.TOP] = v;
                if (hasTabOrEmoji)
                    lines[off + StaticLayout.TAB] |= StaticLayout.TAB_MASK;
                lines[off + StaticLayout.DIR] |= dir << StaticLayout.DIR_SHIFT;
                let linedirs = StaticLayout.DIRS_ALL_LEFT_TO_RIGHT;
                this.mLineDirections[j] = linedirs;
                if (ellipsize != null) {
                    let firstLine = (j == 0);
                    let currentLineIsTheLastVisibleOne = (j + 1 == this.mMaximumVisibleLineCount);
                    let forceEllipsis = moreChars && (this.mLineCount + 1 == this.mMaximumVisibleLineCount);
                    let doEllipsis = (((this.mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
                    if (doEllipsis) {
                        this.calculateEllipsis(start, end, widths, widthStart, ellipsisWidth, ellipsize, j, textWidth, paint, forceEllipsis);
                    }
                }
                this.mLineCount++;
                return v;
            }
            calculateEllipsis(lineStart, lineEnd, widths, widthStart, avail, where, line, textWidth, paint, forceEllipsis) {
                if (textWidth <= avail && !forceEllipsis) {
                    this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_START] = 0;
                    this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_COUNT] = 0;
                    return;
                }
                let ellipsisWidth = paint.measureText((where == TextUtils.TruncateAt.END_SMALL) ? StaticLayout.ELLIPSIS_TWO_DOTS[0] : StaticLayout.ELLIPSIS_NORMAL[0], 0, 1);
                let ellipsisStart = 0;
                let ellipsisCount = 0;
                let len = lineEnd - lineStart;
                if (where == TextUtils.TruncateAt.START) {
                    if (this.mMaximumVisibleLineCount == 1) {
                        let sum = 0;
                        let i;
                        for (i = len; i >= 0; i--) {
                            let w = widths[i - 1 + lineStart - widthStart];
                            if (w + sum + ellipsisWidth > avail) {
                                break;
                            }
                            sum += w;
                        }
                        ellipsisStart = 0;
                        ellipsisCount = i;
                    }
                    else {
                    }
                }
                else if (where == TextUtils.TruncateAt.END || where == TextUtils.TruncateAt.MARQUEE || where == TextUtils.TruncateAt.END_SMALL) {
                    let sum = 0;
                    let i;
                    for (i = 0; i < len; i++) {
                        let w = widths[i + lineStart - widthStart];
                        if (w + sum + ellipsisWidth > avail) {
                            break;
                        }
                        sum += w;
                    }
                    ellipsisStart = i;
                    ellipsisCount = len - i;
                    if (forceEllipsis && ellipsisCount == 0 && len > 0) {
                        ellipsisStart = len - 1;
                        ellipsisCount = 1;
                    }
                }
                else {
                    if (this.mMaximumVisibleLineCount == 1) {
                        let lsum = 0, rsum = 0;
                        let left = 0, right = len;
                        let ravail = (avail - ellipsisWidth) / 2;
                        for (right = len; right >= 0; right--) {
                            let w = widths[right - 1 + lineStart - widthStart];
                            if (w + rsum > ravail) {
                                break;
                            }
                            rsum += w;
                        }
                        let lavail = avail - ellipsisWidth - rsum;
                        for (left = 0; left < right; left++) {
                            let w = widths[left + lineStart - widthStart];
                            if (w + lsum > lavail) {
                                break;
                            }
                            lsum += w;
                        }
                        ellipsisStart = left;
                        ellipsisCount = right - left;
                    }
                    else {
                    }
                }
                this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_START] = ellipsisStart;
                this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_COUNT] = ellipsisCount;
            }
            getLineForVertical(vertical) {
                let high = this.mLineCount;
                let low = -1;
                let guess;
                let lines = this.mLines;
                while (high - low > 1) {
                    guess = (high + low) >> 1;
                    if (lines[this.mColumns * guess + StaticLayout.TOP] > vertical) {
                        high = guess;
                    }
                    else {
                        low = guess;
                    }
                }
                if (low < 0) {
                    return 0;
                }
                else {
                    return low;
                }
            }
            getLineCount() {
                return this.mLineCount;
            }
            getLineTop(line) {
                let top = this.mLines[this.mColumns * line + StaticLayout.TOP];
                if (this.mMaximumVisibleLineCount > 0 && line >= this.mMaximumVisibleLineCount && line != this.mLineCount) {
                    top += this.getBottomPadding();
                }
                return top;
            }
            getLineDescent(line) {
                let descent = this.mLines[this.mColumns * line + StaticLayout.DESCENT];
                if (this.mMaximumVisibleLineCount > 0 && line >= this.mMaximumVisibleLineCount - 1 && line != this.mLineCount) {
                    descent += this.getBottomPadding();
                }
                return descent;
            }
            getLineStart(line) {
                return this.mLines[this.mColumns * line + StaticLayout.START] & StaticLayout.START_MASK;
            }
            getParagraphDirection(line) {
                return this.mLines[this.mColumns * line + StaticLayout.DIR] >> StaticLayout.DIR_SHIFT;
            }
            getLineContainsTab(line) {
                return (this.mLines[this.mColumns * line + StaticLayout.TAB] & StaticLayout.TAB_MASK) != 0;
            }
            getLineDirections(line) {
                return this.mLineDirections[line];
            }
            getTopPadding() {
                return this.mTopPadding;
            }
            getBottomPadding() {
                return this.mBottomPadding;
            }
            getEllipsisCount(line) {
                if (this.mColumns < StaticLayout.COLUMNS_ELLIPSIZE) {
                    return 0;
                }
                return this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_COUNT];
            }
            getEllipsisStart(line) {
                if (this.mColumns < StaticLayout.COLUMNS_ELLIPSIZE) {
                    return 0;
                }
                return this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_START];
            }
            getEllipsizedWidth() {
                return this.mEllipsizedWidth;
            }
            prepare() {
                this.mMeasured = MeasuredText.obtain();
            }
            finish() {
                this.mMeasured = MeasuredText.recycle(this.mMeasured);
            }
        }
        StaticLayout.TAG = "StaticLayout";
        StaticLayout.COLUMNS_NORMAL = 3;
        StaticLayout.COLUMNS_ELLIPSIZE = 5;
        StaticLayout.START = 0;
        StaticLayout.DIR = StaticLayout.START;
        StaticLayout.TAB = StaticLayout.START;
        StaticLayout.TOP = 1;
        StaticLayout.DESCENT = 2;
        StaticLayout.ELLIPSIS_START = 3;
        StaticLayout.ELLIPSIS_COUNT = 4;
        StaticLayout.START_MASK = 0x1FFFFFFF;
        StaticLayout.DIR_SHIFT = 30;
        StaticLayout.TAB_MASK = 0x20000000;
        StaticLayout.CHAR_FIRST_CJK = '';
        StaticLayout.CHAR_NEW_LINE = '\n';
        StaticLayout.CHAR_TAB = '\t';
        StaticLayout.CHAR_SPACE = ' ';
        StaticLayout.CHAR_SLASH = '/';
        StaticLayout.CHAR_HYPHEN = '-';
        StaticLayout.CHAR_ZWSP = '';
        StaticLayout.EXTRA_ROUNDING = 0.5;
        StaticLayout.CHAR_FIRST_HIGH_SURROGATE = 0xD800;
        StaticLayout.CHAR_LAST_LOW_SURROGATE = 0xDFFF;
        text_10.StaticLayout = StaticLayout;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/text/style/UpdateLayout.ts"/>
///<reference path="../../android/text/style/WrapTogetherSpan.ts"/>
///<reference path="../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/PackedIntVector.ts"/>
///<reference path="../../android/text/PackedObjectVector.ts"/>
///<reference path="../../android/text/Spannable.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/StaticLayout.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/text/TextWatcher.ts"/>
var android;
(function (android) {
    var text;
    (function (text_11) {
        var Paint = android.graphics.Paint;
        var System = java.lang.System;
        var Layout = android.text.Layout;
        var PackedIntVector = android.text.PackedIntVector;
        var PackedObjectVector = android.text.PackedObjectVector;
        var Spanned = android.text.Spanned;
        var StaticLayout = android.text.StaticLayout;
        class DynamicLayout extends Layout {
            constructor(base, display, paint, width, align, textDir, spacingmult, spacingadd, includepad, ellipsize = null, ellipsizedWidth = 0) {
                super((ellipsize == null) ? display : (Spanned.isImplements(display)) ? new Layout.SpannedEllipsizer(display) : new Layout.Ellipsizer(display), paint, width, align, textDir, spacingmult, spacingadd);
                this.mEllipsizedWidth = 0;
                this.mNumberOfBlocks = 0;
                this.mIndexFirstChangedBlock = 0;
                this.mTopPadding = 0;
                this.mBottomPadding = 0;
                this.mBase = base;
                this.mDisplay = display;
                if (ellipsize != null) {
                    this.mInts = new PackedIntVector(DynamicLayout.COLUMNS_ELLIPSIZE);
                    this.mEllipsizedWidth = ellipsizedWidth;
                    this.mEllipsizeAt = ellipsize;
                }
                else {
                    this.mInts = new PackedIntVector(DynamicLayout.COLUMNS_NORMAL);
                    this.mEllipsizedWidth = width;
                    this.mEllipsizeAt = null;
                }
                this.mObjects = new PackedObjectVector(1);
                this.mIncludePad = includepad;
                if (ellipsize != null) {
                    let e = this.getText();
                    e.mLayout = this;
                    e.mWidth = ellipsizedWidth;
                    e.mMethod = ellipsize;
                    this.mEllipsize = true;
                }
                let start;
                if (ellipsize != null) {
                    start = new Array(DynamicLayout.COLUMNS_ELLIPSIZE);
                    start[DynamicLayout.ELLIPSIS_START] = DynamicLayout.ELLIPSIS_UNDEFINED;
                }
                else {
                    start = new Array(DynamicLayout.COLUMNS_NORMAL);
                }
                let dirs = [DynamicLayout.DIRS_ALL_LEFT_TO_RIGHT];
                let fm = new Paint.FontMetricsInt();
                paint.getFontMetricsInt(fm);
                let asc = fm.ascent;
                let desc = fm.descent;
                start[DynamicLayout.DIR] = DynamicLayout.DIR_LEFT_TO_RIGHT << DynamicLayout.DIR_SHIFT;
                start[DynamicLayout.TOP] = 0;
                start[DynamicLayout.DESCENT] = desc;
                this.mInts.insertAt(0, start);
                start[DynamicLayout.TOP] = desc - asc;
                this.mInts.insertAt(1, start);
                this.mObjects.insertAt(0, dirs);
                this.reflow(base, 0, 0, base.length);
            }
            reflow(s, where, before, after) {
                if (s != this.mBase)
                    return;
                let text = this.mDisplay;
                let len = text.length;
                let find = text.lastIndexOf('\n', where - 1);
                if (find < 0)
                    find = 0;
                else
                    find = find + 1;
                {
                    let diff = where - find;
                    before += diff;
                    after += diff;
                    where -= diff;
                }
                let look = text.indexOf('\n', where + after);
                if (look < 0)
                    look = len;
                else
                    look++;
                let change = look - (where + after);
                before += change;
                after += change;
                let startline = this.getLineForOffset(where);
                let startv = this.getLineTop(startline);
                let endline = this.getLineForOffset(where + before);
                if (where + after == len)
                    endline = this.getLineCount();
                let endv = this.getLineTop(endline);
                let islast = (endline == this.getLineCount());
                let reflowed;
                {
                    reflowed = DynamicLayout.sStaticLayout;
                    DynamicLayout.sStaticLayout = null;
                }
                if (reflowed == null) {
                    reflowed = new StaticLayout(null, 0, 0, null, 0, null, null, 0, 1, true);
                }
                else {
                    reflowed.prepare();
                }
                reflowed.generate(text, where, where + after, this.getPaint(), this.getWidth(), this.getTextDirectionHeuristic(), this.getSpacingMultiplier(), this.getSpacingAdd(), false, true, this.mEllipsizedWidth, this.mEllipsizeAt);
                let n = reflowed.getLineCount();
                if (where + after != len && reflowed.getLineStart(n - 1) == where + after)
                    n--;
                this.mInts.deleteAt(startline, endline - startline);
                this.mObjects.deleteAt(startline, endline - startline);
                let ht = reflowed.getLineTop(n);
                let toppad = 0, botpad = 0;
                if (this.mIncludePad && startline == 0) {
                    toppad = reflowed.getTopPadding();
                    this.mTopPadding = toppad;
                    ht -= toppad;
                }
                if (this.mIncludePad && islast) {
                    botpad = reflowed.getBottomPadding();
                    this.mBottomPadding = botpad;
                    ht += botpad;
                }
                this.mInts.adjustValuesBelow(startline, DynamicLayout.START, after - before);
                this.mInts.adjustValuesBelow(startline, DynamicLayout.TOP, startv - endv + ht);
                let ints;
                if (this.mEllipsize) {
                    ints = new Array(DynamicLayout.COLUMNS_ELLIPSIZE);
                    ints[DynamicLayout.ELLIPSIS_START] = DynamicLayout.ELLIPSIS_UNDEFINED;
                }
                else {
                    ints = new Array(DynamicLayout.COLUMNS_NORMAL);
                }
                let objects = new Array(1);
                for (let i = 0; i < n; i++) {
                    ints[DynamicLayout.START] = reflowed.getLineStart(i) | (reflowed.getParagraphDirection(i) << DynamicLayout.DIR_SHIFT) | (reflowed.getLineContainsTab(i) ? DynamicLayout.TAB_MASK : 0);
                    let top = reflowed.getLineTop(i) + startv;
                    if (i > 0)
                        top -= toppad;
                    ints[DynamicLayout.TOP] = top;
                    let desc = reflowed.getLineDescent(i);
                    if (i == n - 1)
                        desc += botpad;
                    ints[DynamicLayout.DESCENT] = desc;
                    objects[0] = reflowed.getLineDirections(i);
                    if (this.mEllipsize) {
                        ints[DynamicLayout.ELLIPSIS_START] = reflowed.getEllipsisStart(i);
                        ints[DynamicLayout.ELLIPSIS_COUNT] = reflowed.getEllipsisCount(i);
                    }
                    this.mInts.insertAt(startline + i, ints);
                    this.mObjects.insertAt(startline + i, objects);
                }
                this.updateBlocks(startline, endline - 1, n);
                {
                    DynamicLayout.sStaticLayout = reflowed;
                    reflowed.finish();
                }
            }
            createBlocks() {
                let offset = DynamicLayout.BLOCK_MINIMUM_CHARACTER_LENGTH;
                this.mNumberOfBlocks = 0;
                const text = this.mDisplay;
                while (true) {
                    offset = text.indexOf('\n', offset);
                    if (offset < 0) {
                        this.addBlockAtOffset(text.length);
                        break;
                    }
                    else {
                        this.addBlockAtOffset(offset);
                        offset += DynamicLayout.BLOCK_MINIMUM_CHARACTER_LENGTH;
                    }
                }
                this.mBlockIndices = new Array(this.mBlockEndLines.length);
                for (let i = 0; i < this.mBlockEndLines.length; i++) {
                    this.mBlockIndices[i] = DynamicLayout.INVALID_BLOCK_INDEX;
                }
            }
            addBlockAtOffset(offset) {
                const line = this.getLineForOffset(offset);
                if (this.mBlockEndLines == null) {
                    this.mBlockEndLines = new Array((1));
                    this.mBlockEndLines[this.mNumberOfBlocks] = line;
                    this.mNumberOfBlocks++;
                    return;
                }
                const previousBlockEndLine = this.mBlockEndLines[this.mNumberOfBlocks - 1];
                if (line > previousBlockEndLine) {
                    if (this.mNumberOfBlocks == this.mBlockEndLines.length) {
                        let blockEndLines = new Array((this.mNumberOfBlocks + 1));
                        System.arraycopy(this.mBlockEndLines, 0, blockEndLines, 0, this.mNumberOfBlocks);
                        this.mBlockEndLines = blockEndLines;
                    }
                    this.mBlockEndLines[this.mNumberOfBlocks] = line;
                    this.mNumberOfBlocks++;
                }
            }
            updateBlocks(startLine, endLine, newLineCount) {
                if (this.mBlockEndLines == null) {
                    this.createBlocks();
                    return;
                }
                let firstBlock = -1;
                let lastBlock = -1;
                for (let i = 0; i < this.mNumberOfBlocks; i++) {
                    if (this.mBlockEndLines[i] >= startLine) {
                        firstBlock = i;
                        break;
                    }
                }
                for (let i = firstBlock; i < this.mNumberOfBlocks; i++) {
                    if (this.mBlockEndLines[i] >= endLine) {
                        lastBlock = i;
                        break;
                    }
                }
                const lastBlockEndLine = this.mBlockEndLines[lastBlock];
                let createBlockBefore = startLine > (firstBlock == 0 ? 0 : this.mBlockEndLines[firstBlock - 1] + 1);
                let createBlock = newLineCount > 0;
                let createBlockAfter = endLine < this.mBlockEndLines[lastBlock];
                let numAddedBlocks = 0;
                if (createBlockBefore)
                    numAddedBlocks++;
                if (createBlock)
                    numAddedBlocks++;
                if (createBlockAfter)
                    numAddedBlocks++;
                const numRemovedBlocks = lastBlock - firstBlock + 1;
                const newNumberOfBlocks = this.mNumberOfBlocks + numAddedBlocks - numRemovedBlocks;
                if (newNumberOfBlocks == 0) {
                    this.mBlockEndLines[0] = 0;
                    this.mBlockIndices[0] = DynamicLayout.INVALID_BLOCK_INDEX;
                    this.mNumberOfBlocks = 1;
                    return;
                }
                if (newNumberOfBlocks > this.mBlockEndLines.length) {
                    const newSize = (newNumberOfBlocks);
                    let blockEndLines = new Array(newSize);
                    let blockIndices = new Array(newSize);
                    System.arraycopy(this.mBlockEndLines, 0, blockEndLines, 0, firstBlock);
                    System.arraycopy(this.mBlockIndices, 0, blockIndices, 0, firstBlock);
                    System.arraycopy(this.mBlockEndLines, lastBlock + 1, blockEndLines, firstBlock + numAddedBlocks, this.mNumberOfBlocks - lastBlock - 1);
                    System.arraycopy(this.mBlockIndices, lastBlock + 1, blockIndices, firstBlock + numAddedBlocks, this.mNumberOfBlocks - lastBlock - 1);
                    this.mBlockEndLines = blockEndLines;
                    this.mBlockIndices = blockIndices;
                }
                else {
                    System.arraycopy(this.mBlockEndLines, lastBlock + 1, this.mBlockEndLines, firstBlock + numAddedBlocks, this.mNumberOfBlocks - lastBlock - 1);
                    System.arraycopy(this.mBlockIndices, lastBlock + 1, this.mBlockIndices, firstBlock + numAddedBlocks, this.mNumberOfBlocks - lastBlock - 1);
                }
                this.mNumberOfBlocks = newNumberOfBlocks;
                let newFirstChangedBlock;
                const deltaLines = newLineCount - (endLine - startLine + 1);
                if (deltaLines != 0) {
                    newFirstChangedBlock = firstBlock + numAddedBlocks;
                    for (let i = newFirstChangedBlock; i < this.mNumberOfBlocks; i++) {
                        this.mBlockEndLines[i] += deltaLines;
                    }
                }
                else {
                    newFirstChangedBlock = this.mNumberOfBlocks;
                }
                this.mIndexFirstChangedBlock = Math.min(this.mIndexFirstChangedBlock, newFirstChangedBlock);
                let blockIndex = firstBlock;
                if (createBlockBefore) {
                    this.mBlockEndLines[blockIndex] = startLine - 1;
                    this.mBlockIndices[blockIndex] = DynamicLayout.INVALID_BLOCK_INDEX;
                    blockIndex++;
                }
                if (createBlock) {
                    this.mBlockEndLines[blockIndex] = startLine + newLineCount - 1;
                    this.mBlockIndices[blockIndex] = DynamicLayout.INVALID_BLOCK_INDEX;
                    blockIndex++;
                }
                if (createBlockAfter) {
                    this.mBlockEndLines[blockIndex] = lastBlockEndLine + deltaLines;
                    this.mBlockIndices[blockIndex] = DynamicLayout.INVALID_BLOCK_INDEX;
                }
            }
            setBlocksDataForTest(blockEndLines, blockIndices, numberOfBlocks) {
                this.mBlockEndLines = new Array(blockEndLines.length);
                this.mBlockIndices = new Array(blockIndices.length);
                System.arraycopy(blockEndLines, 0, this.mBlockEndLines, 0, blockEndLines.length);
                System.arraycopy(blockIndices, 0, this.mBlockIndices, 0, blockIndices.length);
                this.mNumberOfBlocks = numberOfBlocks;
            }
            getBlockEndLines() {
                return this.mBlockEndLines;
            }
            getBlockIndices() {
                return this.mBlockIndices;
            }
            getNumberOfBlocks() {
                return this.mNumberOfBlocks;
            }
            getIndexFirstChangedBlock() {
                return this.mIndexFirstChangedBlock;
            }
            setIndexFirstChangedBlock(i) {
                this.mIndexFirstChangedBlock = i;
            }
            getLineCount() {
                return this.mInts.size() - 1;
            }
            getLineTop(line) {
                return this.mInts.getValue(line, DynamicLayout.TOP);
            }
            getLineDescent(line) {
                return this.mInts.getValue(line, DynamicLayout.DESCENT);
            }
            getLineStart(line) {
                return this.mInts.getValue(line, DynamicLayout.START) & DynamicLayout.START_MASK;
            }
            getLineContainsTab(line) {
                return (this.mInts.getValue(line, DynamicLayout.TAB) & DynamicLayout.TAB_MASK) != 0;
            }
            getParagraphDirection(line) {
                return this.mInts.getValue(line, DynamicLayout.DIR) >> DynamicLayout.DIR_SHIFT;
            }
            getLineDirections(line) {
                return this.mObjects.getValue(line, 0);
            }
            getTopPadding() {
                return this.mTopPadding;
            }
            getBottomPadding() {
                return this.mBottomPadding;
            }
            getEllipsizedWidth() {
                return this.mEllipsizedWidth;
            }
            getEllipsisStart(line) {
                if (this.mEllipsizeAt == null) {
                    return 0;
                }
                return this.mInts.getValue(line, DynamicLayout.ELLIPSIS_START);
            }
            getEllipsisCount(line) {
                if (this.mEllipsizeAt == null) {
                    return 0;
                }
                return this.mInts.getValue(line, DynamicLayout.ELLIPSIS_COUNT);
            }
        }
        DynamicLayout.PRIORITY = 128;
        DynamicLayout.BLOCK_MINIMUM_CHARACTER_LENGTH = 400;
        DynamicLayout.INVALID_BLOCK_INDEX = -1;
        DynamicLayout.sStaticLayout = new StaticLayout(null, 0, 0, null, 0, null, null, 1, 0, true);
        DynamicLayout.sLock = new Array(0);
        DynamicLayout.START = 0;
        DynamicLayout.DIR = DynamicLayout.START;
        DynamicLayout.TAB = DynamicLayout.START;
        DynamicLayout.TOP = 1;
        DynamicLayout.DESCENT = 2;
        DynamicLayout.COLUMNS_NORMAL = 3;
        DynamicLayout.ELLIPSIS_START = 3;
        DynamicLayout.ELLIPSIS_COUNT = 4;
        DynamicLayout.COLUMNS_ELLIPSIZE = 5;
        DynamicLayout.START_MASK = 0x1FFFFFFF;
        DynamicLayout.DIR_SHIFT = 30;
        DynamicLayout.TAB_MASK = 0x20000000;
        DynamicLayout.ELLIPSIS_UNDEFINED = 0x80000000;
        text_11.DynamicLayout = DynamicLayout;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/text/Spannable.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/view/View.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            var TransformationMethod;
            (function (TransformationMethod) {
                function isImpl(obj) {
                    return obj['getTransformation'] && obj['onFocusChanged'];
                }
                TransformationMethod.isImpl = isImpl;
            })(TransformationMethod = method.TransformationMethod || (method.TransformationMethod = {}));
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/method/TransformationMethod.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            var TransformationMethod = android.text.method.TransformationMethod;
            var TransformationMethod2;
            (function (TransformationMethod2) {
                function isImpl(obj) {
                    return TransformationMethod.isImpl(obj) && obj['setLengthChangesAllowed'];
                }
                TransformationMethod2.isImpl = isImpl;
            })(TransformationMethod2 = method.TransformationMethod2 || (method.TransformationMethod2 = {}));
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/util/Log.ts"/>
///<reference path="../../../android/view/View.ts"/>
///<reference path="../../../android/text/method/TransformationMethod.ts"/>
///<reference path="../../../android/text/method/TransformationMethod2.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            var Log = android.util.Log;
            class AllCapsTransformationMethod {
                constructor(context) {
                }
                getTransformation(source, view) {
                    if (this.mEnabled) {
                        return source != null ? source.toLocaleUpperCase() : null;
                    }
                    Log.w(AllCapsTransformationMethod.TAG, "Caller did not enable length changes; not transforming text");
                    return source;
                }
                onFocusChanged(view, sourceText, focused, direction, previouslyFocusedRect) {
                }
                setLengthChangesAllowed(allowLengthChanges) {
                    this.mEnabled = allowLengthChanges;
                }
            }
            AllCapsTransformationMethod.TAG = "AllCapsTransformationMethod";
            method.AllCapsTransformationMethod = AllCapsTransformationMethod;
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/widget/TextView.ts"/>
///<reference path="../../../android/view/KeyEvent.ts"/>
///<reference path="../../../android/view/MotionEvent.ts"/>
///<reference path="../../../android/text/Spannable.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/text/Spannable.ts"/>
///<reference path="../../../android/text/Spanned.ts"/>
///<reference path="../../../android/text/TextUtils.ts"/>
///<reference path="../../../android/view/View.ts"/>
///<reference path="../../../android/text/method/TransformationMethod.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            class ReplacementTransformationMethod {
                getTransformation(source, v) {
                    let original = this.getOriginal();
                    let replacement = this.getReplacement();
                    let doNothing = true;
                    let n = original.length;
                    for (let i = 0; i < n; i++) {
                        if (source.indexOf(original[i]) >= 0) {
                            doNothing = false;
                            break;
                        }
                    }
                    if (doNothing) {
                        return source;
                    }
                    return new ReplacementTransformationMethod.ReplacementCharSequence(source, original, replacement).toString();
                    return new ReplacementTransformationMethod.ReplacementCharSequence(source, original, replacement);
                }
                onFocusChanged(view, sourceText, focused, direction, previouslyFocusedRect) {
                }
            }
            method.ReplacementTransformationMethod = ReplacementTransformationMethod;
            (function (ReplacementTransformationMethod) {
                class ReplacementCharSequence extends String {
                    constructor(source, original, replacement) {
                        super(source);
                        this.mSource = source;
                        this.mOriginal = original;
                        this.mReplacement = replacement;
                    }
                    charAt(i) {
                        let c = this.mSource.charAt(i);
                        let n = this.mOriginal.length;
                        for (let j = 0; j < n; j++) {
                            if (c == this.mOriginal[j]) {
                                c = this.mReplacement[j];
                            }
                        }
                        return c;
                    }
                    toString() {
                        return this.startReplace(0, this.length);
                    }
                    substr(from, length) {
                        return this.startReplace(from, from + length);
                    }
                    substring(start, end) {
                        return this.startReplace(start, end);
                    }
                    startReplace(start, end) {
                        let dest = this.mSource.substring(start, end).split('');
                        let offend = end - start;
                        let n = this.mOriginal.length;
                        for (let i = 0; i < offend; i++) {
                            let c = dest[i];
                            for (let j = 0; j < n; j++) {
                                if (c == this.mOriginal[j]) {
                                    dest[i] = this.mReplacement[j];
                                }
                            }
                        }
                        return dest.join('');
                    }
                }
                ReplacementTransformationMethod.ReplacementCharSequence = ReplacementCharSequence;
            })(ReplacementTransformationMethod = method.ReplacementTransformationMethod || (method.ReplacementTransformationMethod = {}));
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/text/Spannable.ts"/>
///<reference path="../../../android/text/Spanned.ts"/>
///<reference path="../../../android/text/TextUtils.ts"/>
///<reference path="../../../android/view/View.ts"/>
///<reference path="../../../android/text/method/ReplacementTransformationMethod.ts"/>
///<reference path="../../../android/text/method/TransformationMethod.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            var ReplacementTransformationMethod = android.text.method.ReplacementTransformationMethod;
            class SingleLineTransformationMethod extends ReplacementTransformationMethod {
                getOriginal() {
                    return SingleLineTransformationMethod.ORIGINAL;
                }
                getReplacement() {
                    return SingleLineTransformationMethod.REPLACEMENT;
                }
                static getInstance() {
                    if (SingleLineTransformationMethod.sInstance != null)
                        return SingleLineTransformationMethod.sInstance;
                    SingleLineTransformationMethod.sInstance = new SingleLineTransformationMethod();
                    return SingleLineTransformationMethod.sInstance;
                }
            }
            SingleLineTransformationMethod.ORIGINAL = ['\n', '\r'];
            SingleLineTransformationMethod.REPLACEMENT = [' ', ''];
            method.SingleLineTransformationMethod = SingleLineTransformationMethod;
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/R/attr.ts"/>
///<reference path="../../android/R/color.ts"/>
///<reference path="../../android/R/drawable.ts"/>
///<reference path="../../android/R/string.ts"/>
///<reference path="../../android/content/res/ColorStateList.ts"/>
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Path.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/RectF.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/os/Message.ts"/>
///<reference path="../../android/os/SystemClock.ts"/>
///<reference path="../../android/text/BoringLayout.ts"/>
///<reference path="../../android/text/DynamicLayout.ts"/>
///<reference path="../../android/text/InputType.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/SpanWatcher.ts"/>
///<reference path="../../android/text/Spannable.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/StaticLayout.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/text/TextWatcher.ts"/>
///<reference path="../../android/text/method/AllCapsTransformationMethod.ts"/>
///<reference path="../../android/text/method/MovementMethod.ts"/>
///<reference path="../../android/text/method/SingleLineTransformationMethod.ts"/>
///<reference path="../../android/text/method/TransformationMethod.ts"/>
///<reference path="../../android/text/method/TransformationMethod2.ts"/>
///<reference path="../../android/text/style/CharacterStyle.ts"/>
///<reference path="../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../android/text/style/UpdateAppearance.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/HapticFeedbackConstants.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewRootImpl.ts"/>
///<reference path="../../android/view/ViewTreeObserver.ts"/>
///<reference path="../../android/view/animation/AnimationUtils.ts"/>
///<reference path="../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../androidui/image/NetDrawable.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ColorStateList = android.content.res.ColorStateList;
        var Paint = android.graphics.Paint;
        var Path = android.graphics.Path;
        var Rect = android.graphics.Rect;
        var RectF = android.graphics.RectF;
        var Handler = android.os.Handler;
        var BoringLayout = android.text.BoringLayout;
        var DynamicLayout = android.text.DynamicLayout;
        var Layout = android.text.Layout;
        var Spannable = android.text.Spannable;
        var Spanned = android.text.Spanned;
        var StaticLayout = android.text.StaticLayout;
        var TextDirectionHeuristics = android.text.TextDirectionHeuristics;
        var TextPaint = android.text.TextPaint;
        var TextUtils = android.text.TextUtils;
        var TruncateAt = android.text.TextUtils.TruncateAt;
        var AllCapsTransformationMethod = android.text.method.AllCapsTransformationMethod;
        var SingleLineTransformationMethod = android.text.method.SingleLineTransformationMethod;
        var TransformationMethod2 = android.text.method.TransformationMethod2;
        var Log = android.util.Log;
        var TypedValue = android.util.TypedValue;
        var Gravity = android.view.Gravity;
        var HapticFeedbackConstants = android.view.HapticFeedbackConstants;
        var MotionEvent = android.view.MotionEvent;
        var View = android.view.View;
        var LayoutParams = android.view.ViewGroup.LayoutParams;
        var AnimationUtils = android.view.animation.AnimationUtils;
        var WeakReference = java.lang.ref.WeakReference;
        var ArrayList = java.util.ArrayList;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        var NetDrawable = androidui.image.NetDrawable;
        class TextView extends View {
            constructor(context, bindElement, defStyle = android.R.attr.textViewStyle) {
                super(context, bindElement, null);
                this.mCurTextColor = 0;
                this.mCurHintTextColor = 0;
                this.mSpannableFactory = Spannable.Factory.getInstance();
                this.mShadowRadius = 0;
                this.mShadowDx = 0;
                this.mShadowDy = 0;
                this.mMarqueeRepeatLimit = 3;
                this.mLastLayoutDirection = -1;
                this.mMarqueeFadeMode = TextView.MARQUEE_FADE_NORMAL;
                this.mBufferType = TextView.BufferType.NORMAL;
                this.mGravity = Gravity.TOP | Gravity.LEFT;
                this.mAutoLinkMask = 0;
                this.mLinksClickable = true;
                this.mSpacingMult = 1.0;
                this.mSpacingAdd = 0.0;
                this.mMaximum = Integer.MAX_VALUE;
                this.mMaxMode = TextView.LINES;
                this.mMinimum = 0;
                this.mMinMode = TextView.LINES;
                this.mOldMaximum = this.mMaximum;
                this.mOldMaxMode = this.mMaxMode;
                this.mMaxWidthValue = Integer.MAX_VALUE;
                this.mMaxWidthMode = TextView.PIXELS;
                this.mMinWidthValue = 0;
                this.mMinWidthMode = TextView.PIXELS;
                this.mDesiredHeightAtMeasure = -1;
                this.mIncludePad = true;
                this.mDeferScroll = -1;
                this.mLastScroll = 0;
                this.mFilters = TextView.NO_FILTERS;
                this.mHighlightColor = 0x6633B5E5;
                this.mHighlightPathBogus = true;
                this.mCursorDrawableRes = 0;
                this.mTextSelectHandleLeftRes = 0;
                this.mTextSelectHandleRightRes = 0;
                this.mTextSelectHandleRes = 0;
                this.mTextEditSuggestionItemLayout = 0;
                this.mText = "";
                const res = this.getResources();
                this.mTextPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
                this.mHighlightPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
                this.mMovement = this.getDefaultMovementMethod();
                this.mTransformation = null;
                this._attrBinder.addAttr('textColorHighlight', (value) => {
                    this.setHighlightColor(this._attrBinder.parseColor(value, this.mHighlightColor));
                });
                this._attrBinder.addAttr('textColor', (value) => {
                    let color = this._attrBinder.parseColorList(value);
                    if (color)
                        this.setTextColor(color);
                }, () => {
                    return this.mTextColor;
                });
                this._attrBinder.addAttr('textColorHint', (value) => {
                    let color = this._attrBinder.parseColorList(value);
                    if (color)
                        this.setHintTextColor(color);
                }, () => {
                    return this.mHintTextColor;
                });
                this._attrBinder.addAttr('textSize', (value) => {
                    let size = this._attrBinder.parseNumber(value, this.mTextPaint.getTextSize());
                    this.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
                }, () => {
                    return this.mTextPaint.getTextSize();
                });
                this._attrBinder.addAttr('textAllCaps', (value) => {
                    this.setAllCaps(this._attrBinder.parseBoolean(value, true));
                });
                this._attrBinder.addAttr('shadowColor', (value) => {
                    this.setShadowLayer(this.mShadowRadius, this.mShadowDx, this.mShadowDy, this._attrBinder.parseColor(value, this.mTextPaint.shadowColor));
                });
                this._attrBinder.addAttr('shadowDx', (value) => {
                    let dx = this._attrBinder.parseNumber(value, this.mShadowDx);
                    this.setShadowLayer(this.mShadowRadius, dx, this.mShadowDy, this.mTextPaint.shadowColor);
                });
                this._attrBinder.addAttr('shadowDy', (value) => {
                    let dy = this._attrBinder.parseNumber(value, this.mShadowDy);
                    this.setShadowLayer(this.mShadowRadius, this.mShadowDx, dy, this.mTextPaint.shadowColor);
                });
                this._attrBinder.addAttr('shadowRadius', (value) => {
                    let radius = this._attrBinder.parseNumber(value, this.mShadowRadius);
                    this.setShadowLayer(radius, this.mShadowDx, this.mShadowDy, this.mTextPaint.shadowColor);
                });
                this._attrBinder.addAttr('drawableLeft', (value) => {
                    let dr = this.mDrawables || {};
                    let drawable = this._attrBinder.parseDrawable(value);
                    this.setCompoundDrawablesWithIntrinsicBounds(drawable, dr.mDrawableTop, dr.mDrawableRight, dr.mDrawableBottom);
                });
                this._attrBinder.addAttr('drawableTop', (value) => {
                    let dr = this.mDrawables || {};
                    let drawable = this._attrBinder.parseDrawable(value);
                    this.setCompoundDrawablesWithIntrinsicBounds(dr.mDrawableLeft, drawable, dr.mDrawableRight, dr.mDrawableBottom);
                });
                this._attrBinder.addAttr('drawableRight', (value) => {
                    let dr = this.mDrawables || {};
                    let drawable = this._attrBinder.parseDrawable(value);
                    this.setCompoundDrawablesWithIntrinsicBounds(dr.mDrawableLeft, dr.mDrawableTop, drawable, dr.mDrawableBottom);
                });
                this._attrBinder.addAttr('drawableBottom', (value) => {
                    let dr = this.mDrawables || {};
                    let drawable = this._attrBinder.parseDrawable(value);
                    this.setCompoundDrawablesWithIntrinsicBounds(dr.mDrawableLeft, dr.mDrawableTop, dr.mDrawableRight, drawable);
                });
                this._attrBinder.addAttr('drawableLeftUri', (value) => {
                    let dr = this.mDrawables || {};
                    let drawable = value ? new NetDrawable(value) : null;
                    this.setCompoundDrawablesWithIntrinsicBounds(drawable, dr.mDrawableTop, dr.mDrawableRight, dr.mDrawableBottom);
                });
                this._attrBinder.addAttr('drawableTopUri', (value) => {
                    let dr = this.mDrawables || {};
                    let drawable = value ? new NetDrawable(value) : null;
                    this.setCompoundDrawablesWithIntrinsicBounds(dr.mDrawableLeft, drawable, dr.mDrawableRight, dr.mDrawableBottom);
                });
                this._attrBinder.addAttr('drawableRightUri', (value) => {
                    let dr = this.mDrawables || {};
                    let drawable = value ? new NetDrawable(value) : null;
                    this.setCompoundDrawablesWithIntrinsicBounds(dr.mDrawableLeft, dr.mDrawableTop, drawable, dr.mDrawableBottom);
                });
                this._attrBinder.addAttr('drawableBottomUri', (value) => {
                    let dr = this.mDrawables || {};
                    let drawable = value ? new NetDrawable(value) : null;
                    this.setCompoundDrawablesWithIntrinsicBounds(dr.mDrawableLeft, dr.mDrawableTop, dr.mDrawableRight, drawable);
                });
                this._attrBinder.addAttr('drawablePadding', (value) => {
                    this.setCompoundDrawablePadding(this._attrBinder.parseNumber(value));
                });
                this._attrBinder.addAttr('maxLines', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setMaxLines(value);
                }, () => {
                    return this.getMaxLines();
                });
                this._attrBinder.addAttr('maxHeight', (value) => {
                    this.setMaxHeight(this._attrBinder.parseNumber(value, this.getMaxHeight()));
                }, () => {
                    return this.getMaxHeight();
                });
                this._attrBinder.addAttr('lines', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setLines(value);
                }, () => {
                    if (this.getMaxLines() === this.getMinLines())
                        return this.getMaxLines();
                    return null;
                });
                this._attrBinder.addAttr('height', (value) => {
                    value = this._attrBinder.parseNumber(value, -1);
                    if (value >= 0)
                        this.setHeight(value);
                }, () => {
                    if (this.getMaxHeight() === this.getMinimumHeight())
                        return this.getMaxHeight();
                    return null;
                });
                this._attrBinder.addAttr('minLines', (value) => {
                    this.setMinLines(this._attrBinder.parseNumber(value, this.getMinLines()));
                }, () => {
                    return this.getMinLines();
                });
                this._attrBinder.addAttr('minHeight', (value) => {
                    this.setMinHeight(this._attrBinder.parseNumber(value, this.getMinHeight()));
                }, () => {
                    return this.getMinHeight();
                });
                this._attrBinder.addAttr('maxEms', (value) => {
                    this.setMaxEms(this._attrBinder.parseNumber(value, this.getMaxEms()));
                }, () => {
                    return this.getMaxEms();
                });
                this._attrBinder.addAttr('maxWidth', (value) => {
                    this.setMaxWidth(this._attrBinder.parseNumber(value, this.getMaxWidth()));
                }, () => {
                    return this.getMaxWidth();
                });
                this._attrBinder.addAttr('ems', (value) => {
                    let ems = this._attrBinder.parseNumber(value, null);
                    if (ems != null)
                        this.setEms(ems);
                }, () => {
                    if (this.getMinEms() === this.getMaxEms())
                        return this.getMaxEms();
                    return null;
                });
                this._attrBinder.addAttr('width', (value) => {
                    value = this._attrBinder.parseNumber(value, -1);
                    if (value >= 0)
                        this.setWidth(value);
                }, () => {
                    if (this.getMinWidth() === this.getMaxWidth())
                        return this.getMinWidth();
                    return null;
                });
                this._attrBinder.addAttr('minEms', (value) => {
                    this.setMinEms(this._attrBinder.parseNumber(value, this.getMinEms()));
                }, () => {
                    return this.getMinEms();
                });
                this._attrBinder.addAttr('minWidth', (value) => {
                    this.setMinWidth(this._attrBinder.parseNumber(value, this.getMinWidth()));
                }, () => {
                    return this.getMinWidth();
                });
                this._attrBinder.addAttr('gravity', (value) => {
                    this.setGravity(this._attrBinder.parseGravity(value, this.mGravity));
                }, () => {
                    return this.mGravity;
                });
                this._attrBinder.addAttr('hint', (value) => {
                    this.setHint(value);
                }, () => {
                    return this.getHint();
                });
                this._attrBinder.addAttr('text', (value) => {
                    this.setText(value);
                }, () => {
                    return this.getText();
                });
                this._attrBinder.addAttr('scrollHorizontally', (value) => {
                    this.setHorizontallyScrolling(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('singleLine', (value) => {
                    this.setSingleLine(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('ellipsize', (value) => {
                    let ellipsize = TextUtils.TruncateAt[(value + '').toUpperCase()];
                    if (ellipsize)
                        this.setEllipsize(ellipsize);
                });
                this._attrBinder.addAttr('marqueeRepeatLimit', (value) => {
                    let marqueeRepeatLimit = this._attrBinder.parseNumber(value, -1);
                    if (marqueeRepeatLimit >= 0)
                        this.setMarqueeRepeatLimit(marqueeRepeatLimit);
                });
                this._attrBinder.addAttr('includeFontPadding', (value) => {
                    this.setIncludeFontPadding(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('enabled', (value) => {
                    this.setEnabled(this._attrBinder.parseBoolean(value, this.isEnabled()));
                });
                this._attrBinder.addAttr('lineSpacingExtra', (value) => {
                    this.setLineSpacing(this._attrBinder.parseNumber(value, this.mSpacingAdd), this.mSpacingMult);
                }, () => {
                    return this.mSpacingAdd;
                });
                this._attrBinder.addAttr('lineSpacingMultiplier', (value) => {
                    this.setLineSpacing(this.mSpacingAdd, this._attrBinder.parseNumber(value, this.mSpacingMult));
                }, () => {
                    return this.mSpacingMult;
                });
                this.setTextSize(14);
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
                this.bindElement.innerHTML = this.bindElement.innerHTML.trim();
                let text = this.mText || this.bindElement.innerText;
                this.bindElement.innerHTML = '';
                this.setText(text, this.mBufferType);
            }
            setTypefaceFromAttrs(familyName, typefaceIndex, styleIndex) {
            }
            setRelativeDrawablesIfNeeded(start, end) {
                let hasRelativeDrawables = (start != null) || (end != null);
                if (hasRelativeDrawables) {
                    let dr = this.mDrawables;
                    if (dr == null) {
                        this.mDrawables = dr = new TextView.Drawables();
                    }
                    this.mDrawables.mOverride = true;
                    const compoundRect = dr.mCompoundRect;
                    let state = this.getDrawableState();
                    if (start != null) {
                        start.setBounds(0, 0, start.getIntrinsicWidth(), start.getIntrinsicHeight());
                        start.setState(state);
                        start.copyBounds(compoundRect);
                        start.setCallback(this);
                        dr.mDrawableStart = start;
                        dr.mDrawableSizeStart = compoundRect.width();
                        dr.mDrawableHeightStart = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                    }
                    if (end != null) {
                        end.setBounds(0, 0, end.getIntrinsicWidth(), end.getIntrinsicHeight());
                        end.setState(state);
                        end.copyBounds(compoundRect);
                        end.setCallback(this);
                        dr.mDrawableEnd = end;
                        dr.mDrawableSizeEnd = compoundRect.width();
                        dr.mDrawableHeightEnd = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                    }
                    this.resetResolvedDrawables();
                    this.resolveDrawables();
                }
            }
            setEnabled(enabled) {
                if (enabled == this.isEnabled()) {
                    return;
                }
                super.setEnabled(enabled);
            }
            setTypeface(tf, style) {
            }
            getDefaultEditable() {
                return false;
            }
            getDefaultMovementMethod() {
                return null;
            }
            getText() {
                return this.mText;
            }
            length() {
                return this.mText.length;
            }
            getEditableText() {
                return null;
            }
            getLineHeight() {
                return Math.round(this.mTextPaint.getFontMetricsInt(null) * this.mSpacingMult + this.mSpacingAdd);
            }
            getLayout() {
                return this.mLayout;
            }
            getHintLayout() {
                return this.mHintLayout;
            }
            getUndoManager() {
                return null;
            }
            setUndoManager(undoManager, tag) {
            }
            getKeyListener() {
                return null;
            }
            setKeyListener(input) {
            }
            setKeyListenerOnly(input) {
            }
            getMovementMethod() {
                return this.mMovement;
            }
            setMovementMethod(movement) {
                if (this.mMovement != movement) {
                    this.mMovement = movement;
                    if (movement != null && !Spannable.isImpl(this.mText)) {
                        this.setText(this.mText);
                    }
                    this.fixFocusableAndClickableSettings();
                }
            }
            fixFocusableAndClickableSettings() {
                if (this.mMovement != null) {
                    this.setFocusable(true);
                    this.setClickable(true);
                    this.setLongClickable(true);
                }
                else {
                    this.setFocusable(false);
                    this.setClickable(false);
                    this.setLongClickable(false);
                }
            }
            getTransformationMethod() {
                return this.mTransformation;
            }
            setTransformationMethod(method) {
                if (method == this.mTransformation) {
                    return;
                }
                if (this.mTransformation != null) {
                    if (Spannable.isImpl(this.mText)) {
                        this.mText.removeSpan(this.mTransformation);
                    }
                }
                this.mTransformation = method;
                if (TransformationMethod2.isImpl(method)) {
                    let method2 = method;
                    this.mAllowTransformationLengthChange = !this.isTextSelectable();
                    method2.setLengthChangesAllowed(this.mAllowTransformationLengthChange);
                }
                else {
                    this.mAllowTransformationLengthChange = false;
                }
                this.setText(this.mText);
            }
            getCompoundPaddingTop() {
                const dr = this.mDrawables;
                if (dr == null || dr.mDrawableTop == null) {
                    return this.mPaddingTop;
                }
                else {
                    return this.mPaddingTop + dr.mDrawablePadding + dr.mDrawableSizeTop;
                }
            }
            getCompoundPaddingBottom() {
                const dr = this.mDrawables;
                if (dr == null || dr.mDrawableBottom == null) {
                    return this.mPaddingBottom;
                }
                else {
                    return this.mPaddingBottom + dr.mDrawablePadding + dr.mDrawableSizeBottom;
                }
            }
            getCompoundPaddingLeft() {
                const dr = this.mDrawables;
                if (dr == null || dr.mDrawableLeft == null) {
                    return this.mPaddingLeft;
                }
                else {
                    return this.mPaddingLeft + dr.mDrawablePadding + dr.mDrawableSizeLeft;
                }
            }
            getCompoundPaddingRight() {
                const dr = this.mDrawables;
                if (dr == null || dr.mDrawableRight == null) {
                    return this.mPaddingRight;
                }
                else {
                    return this.mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight;
                }
            }
            getCompoundPaddingStart() {
                this.resolveDrawables();
                return this.getCompoundPaddingLeft();
            }
            getCompoundPaddingEnd() {
                this.resolveDrawables();
                return this.getCompoundPaddingRight();
            }
            getExtendedPaddingTop() {
                if (this.mMaxMode != TextView.LINES) {
                    return this.getCompoundPaddingTop();
                }
                if (this.mLayout.getLineCount() <= this.mMaximum) {
                    return this.getCompoundPaddingTop();
                }
                let top = this.getCompoundPaddingTop();
                let bottom = this.getCompoundPaddingBottom();
                let viewht = this.getHeight() - top - bottom;
                let layoutht = this.mLayout.getLineTop(this.mMaximum);
                if (layoutht >= viewht) {
                    return top;
                }
                const gravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                if (gravity == Gravity.TOP) {
                    return top;
                }
                else if (gravity == Gravity.BOTTOM) {
                    return top + viewht - layoutht;
                }
                else {
                    return top + (viewht - layoutht) / 2;
                }
            }
            getExtendedPaddingBottom() {
                if (this.mMaxMode != TextView.LINES) {
                    return this.getCompoundPaddingBottom();
                }
                if (this.mLayout.getLineCount() <= this.mMaximum) {
                    return this.getCompoundPaddingBottom();
                }
                let top = this.getCompoundPaddingTop();
                let bottom = this.getCompoundPaddingBottom();
                let viewht = this.getHeight() - top - bottom;
                let layoutht = this.mLayout.getLineTop(this.mMaximum);
                if (layoutht >= viewht) {
                    return bottom;
                }
                const gravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                if (gravity == Gravity.TOP) {
                    return bottom + viewht - layoutht;
                }
                else if (gravity == Gravity.BOTTOM) {
                    return bottom;
                }
                else {
                    return bottom + (viewht - layoutht) / 2;
                }
            }
            getTotalPaddingLeft() {
                return this.getCompoundPaddingLeft();
            }
            getTotalPaddingRight() {
                return this.getCompoundPaddingRight();
            }
            getTotalPaddingStart() {
                return this.getCompoundPaddingStart();
            }
            getTotalPaddingEnd() {
                return this.getCompoundPaddingEnd();
            }
            getTotalPaddingTop() {
                return this.getExtendedPaddingTop() + this.getVerticalOffset(true);
            }
            getTotalPaddingBottom() {
                return this.getExtendedPaddingBottom() + this.getBottomVerticalOffset(true);
            }
            setCompoundDrawables(left, top, right, bottom) {
                let dr = this.mDrawables;
                const drawables = left != null || top != null || right != null || bottom != null;
                if (!drawables) {
                    if (dr != null) {
                        if (dr.mDrawablePadding == 0) {
                            this.mDrawables = null;
                        }
                        else {
                            if (dr.mDrawableLeft != null) {
                                dr.mDrawableLeft.setCallback(null);
                            }
                            dr.mDrawableLeft = null;
                            if (dr.mDrawableTop != null) {
                                dr.mDrawableTop.setCallback(null);
                            }
                            dr.mDrawableTop = null;
                            if (dr.mDrawableRight != null) {
                                dr.mDrawableRight.setCallback(null);
                            }
                            dr.mDrawableRight = null;
                            if (dr.mDrawableBottom != null) {
                                dr.mDrawableBottom.setCallback(null);
                            }
                            dr.mDrawableBottom = null;
                            dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
                            dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
                            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
                        }
                    }
                }
                else {
                    if (dr == null) {
                        this.mDrawables = dr = new TextView.Drawables();
                    }
                    this.mDrawables.mOverride = false;
                    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
                        dr.mDrawableLeft.setCallback(null);
                    }
                    dr.mDrawableLeft = left;
                    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
                        dr.mDrawableTop.setCallback(null);
                    }
                    dr.mDrawableTop = top;
                    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
                        dr.mDrawableRight.setCallback(null);
                    }
                    dr.mDrawableRight = right;
                    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
                        dr.mDrawableBottom.setCallback(null);
                    }
                    dr.mDrawableBottom = bottom;
                    const compoundRect = dr.mCompoundRect;
                    let state;
                    state = this.getDrawableState();
                    if (left != null) {
                        left.setState(state);
                        left.copyBounds(compoundRect);
                        left.setCallback(this);
                        dr.mDrawableSizeLeft = compoundRect.width();
                        dr.mDrawableHeightLeft = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
                    }
                    if (right != null) {
                        right.setState(state);
                        right.copyBounds(compoundRect);
                        right.setCallback(this);
                        dr.mDrawableSizeRight = compoundRect.width();
                        dr.mDrawableHeightRight = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
                    }
                    if (top != null) {
                        top.setState(state);
                        top.copyBounds(compoundRect);
                        top.setCallback(this);
                        dr.mDrawableSizeTop = compoundRect.height();
                        dr.mDrawableWidthTop = compoundRect.width();
                    }
                    else {
                        dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                    }
                    if (bottom != null) {
                        bottom.setState(state);
                        bottom.copyBounds(compoundRect);
                        bottom.setCallback(this);
                        dr.mDrawableSizeBottom = compoundRect.height();
                        dr.mDrawableWidthBottom = compoundRect.width();
                    }
                    else {
                        dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
                    }
                }
                if (dr != null) {
                    dr.mDrawableLeftInitial = left;
                    dr.mDrawableRightInitial = right;
                }
                this.resetResolvedDrawables();
                this.resolveDrawables();
                this.invalidate();
                this.requestLayout();
            }
            setCompoundDrawablesWithIntrinsicBounds(left, top, right, bottom) {
                if (left != null) {
                    left.setBounds(0, 0, left.getIntrinsicWidth(), left.getIntrinsicHeight());
                }
                if (right != null) {
                    right.setBounds(0, 0, right.getIntrinsicWidth(), right.getIntrinsicHeight());
                }
                if (top != null) {
                    top.setBounds(0, 0, top.getIntrinsicWidth(), top.getIntrinsicHeight());
                }
                if (bottom != null) {
                    bottom.setBounds(0, 0, bottom.getIntrinsicWidth(), bottom.getIntrinsicHeight());
                }
                this.setCompoundDrawables(left, top, right, bottom);
            }
            setCompoundDrawablesRelative(start, top, end, bottom) {
                let dr = this.mDrawables;
                const drawables = start != null || top != null || end != null || bottom != null;
                if (!drawables) {
                    if (dr != null) {
                        if (dr.mDrawablePadding == 0) {
                            this.mDrawables = null;
                        }
                        else {
                            if (dr.mDrawableStart != null) {
                                dr.mDrawableStart.setCallback(null);
                            }
                            dr.mDrawableStart = null;
                            if (dr.mDrawableTop != null) {
                                dr.mDrawableTop.setCallback(null);
                            }
                            dr.mDrawableTop = null;
                            if (dr.mDrawableEnd != null) {
                                dr.mDrawableEnd.setCallback(null);
                            }
                            dr.mDrawableEnd = null;
                            if (dr.mDrawableBottom != null) {
                                dr.mDrawableBottom.setCallback(null);
                            }
                            dr.mDrawableBottom = null;
                            dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                            dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
                        }
                    }
                }
                else {
                    if (dr == null) {
                        this.mDrawables = dr = new TextView.Drawables();
                    }
                    this.mDrawables.mOverride = true;
                    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
                        dr.mDrawableStart.setCallback(null);
                    }
                    dr.mDrawableStart = start;
                    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
                        dr.mDrawableTop.setCallback(null);
                    }
                    dr.mDrawableTop = top;
                    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
                        dr.mDrawableEnd.setCallback(null);
                    }
                    dr.mDrawableEnd = end;
                    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
                        dr.mDrawableBottom.setCallback(null);
                    }
                    dr.mDrawableBottom = bottom;
                    const compoundRect = dr.mCompoundRect;
                    let state;
                    state = this.getDrawableState();
                    if (start != null) {
                        start.setState(state);
                        start.copyBounds(compoundRect);
                        start.setCallback(this);
                        dr.mDrawableSizeStart = compoundRect.width();
                        dr.mDrawableHeightStart = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                    }
                    if (end != null) {
                        end.setState(state);
                        end.copyBounds(compoundRect);
                        end.setCallback(this);
                        dr.mDrawableSizeEnd = compoundRect.width();
                        dr.mDrawableHeightEnd = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                    }
                    if (top != null) {
                        top.setState(state);
                        top.copyBounds(compoundRect);
                        top.setCallback(this);
                        dr.mDrawableSizeTop = compoundRect.height();
                        dr.mDrawableWidthTop = compoundRect.width();
                    }
                    else {
                        dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                    }
                    if (bottom != null) {
                        bottom.setState(state);
                        bottom.copyBounds(compoundRect);
                        bottom.setCallback(this);
                        dr.mDrawableSizeBottom = compoundRect.height();
                        dr.mDrawableWidthBottom = compoundRect.width();
                    }
                    else {
                        dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
                    }
                }
                this.resetResolvedDrawables();
                this.resolveDrawables();
                this.invalidate();
                this.requestLayout();
            }
            setCompoundDrawablesRelativeWithIntrinsicBounds(start, top, end, bottom) {
                if (start != null) {
                    start.setBounds(0, 0, start.getIntrinsicWidth(), start.getIntrinsicHeight());
                }
                if (end != null) {
                    end.setBounds(0, 0, end.getIntrinsicWidth(), end.getIntrinsicHeight());
                }
                if (top != null) {
                    top.setBounds(0, 0, top.getIntrinsicWidth(), top.getIntrinsicHeight());
                }
                if (bottom != null) {
                    bottom.setBounds(0, 0, bottom.getIntrinsicWidth(), bottom.getIntrinsicHeight());
                }
                this.setCompoundDrawablesRelative(start, top, end, bottom);
            }
            getCompoundDrawables() {
                const dr = this.mDrawables;
                if (dr != null) {
                    return [dr.mDrawableLeft, dr.mDrawableTop, dr.mDrawableRight, dr.mDrawableBottom];
                }
                else {
                    return [null, null, null, null];
                }
            }
            getCompoundDrawablesRelative() {
                const dr = this.mDrawables;
                if (dr != null) {
                    return [dr.mDrawableStart, dr.mDrawableTop, dr.mDrawableEnd, dr.mDrawableBottom];
                }
                else {
                    return [null, null, null, null];
                }
            }
            setCompoundDrawablePadding(pad) {
                let dr = this.mDrawables;
                if (pad == 0) {
                    if (dr != null) {
                        dr.mDrawablePadding = pad;
                    }
                }
                else {
                    if (dr == null) {
                        this.mDrawables = dr = new TextView.Drawables();
                    }
                    dr.mDrawablePadding = pad;
                }
                this.invalidate();
                this.requestLayout();
            }
            getCompoundDrawablePadding() {
                const dr = this.mDrawables;
                return dr != null ? dr.mDrawablePadding : 0;
            }
            setPadding(left, top, right, bottom) {
                if (left != this.mPaddingLeft || right != this.mPaddingRight || top != this.mPaddingTop || bottom != this.mPaddingBottom) {
                    this.nullLayouts();
                }
                super.setPadding(left, top, right, bottom);
                this.invalidate();
            }
            getAutoLinkMask() {
                return this.mAutoLinkMask;
            }
            getTextLocale() {
                return null;
            }
            setTextLocale(locale) {
            }
            getTextSize() {
                return this.mTextPaint.getTextSize();
            }
            setTextSize(...args) {
                if (args.length == 1) {
                    this.setTextSize(TypedValue.COMPLEX_UNIT_SP, args[0]);
                    return;
                }
                let [unit, size] = args;
                this.setRawTextSize(TypedValue.applyDimension(unit, size, this.getResources().getDisplayMetrics()));
            }
            setRawTextSize(size) {
                if (size != this.mTextPaint.getTextSize()) {
                    this.mTextPaint.setTextSize(size);
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            getTextScaleX() {
                return 1;
            }
            setTextScaleX(size) {
            }
            getTypeface() {
                return null;
            }
            setTextColor(colors) {
                if (typeof colors === 'number') {
                    colors = ColorStateList.valueOf(colors);
                }
                if (colors == null) {
                    throw Error(`new NullPointerException()`);
                }
                this.mTextColor = colors;
                this.updateTextColors();
            }
            getTextColors() {
                return this.mTextColor;
            }
            getCurrentTextColor() {
                return this.mCurTextColor;
            }
            setHighlightColor(color) {
                if (this.mHighlightColor != color) {
                    this.mHighlightColor = color;
                    this.invalidate();
                }
            }
            getHighlightColor() {
                return this.mHighlightColor;
            }
            setShowSoftInputOnFocus(show) {
                this.createEditorIfNeeded();
            }
            getShowSoftInputOnFocus() {
                return false;
            }
            setShadowLayer(radius, dx, dy, color) {
                this.mTextPaint.setShadowLayer(radius, dx, dy, color);
                this.mShadowRadius = radius;
                this.mShadowDx = dx;
                this.mShadowDy = dy;
                this.invalidate();
            }
            getShadowRadius() {
                return this.mShadowRadius;
            }
            getShadowDx() {
                return this.mShadowDx;
            }
            getShadowDy() {
                return this.mShadowDy;
            }
            getShadowColor() {
                return this.mTextPaint.shadowColor;
            }
            getPaint() {
                return this.mTextPaint;
            }
            setAutoLinkMask(mask) {
                this.mAutoLinkMask = mask;
            }
            setLinksClickable(whether) {
                this.mLinksClickable = whether;
            }
            getLinksClickable() {
                return this.mLinksClickable;
            }
            getUrls() {
                return new Array(0);
            }
            setHintTextColor(colors) {
                if (typeof colors === 'number') {
                    colors = ColorStateList.valueOf(colors);
                }
                this.mHintTextColor = colors;
                this.updateTextColors();
            }
            getHintTextColors() {
                return this.mHintTextColor;
            }
            getCurrentHintTextColor() {
                return this.mHintTextColor != null ? this.mCurHintTextColor : this.mCurTextColor;
            }
            setGravity(gravity) {
                if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == 0) {
                    gravity |= Gravity.LEFT;
                }
                if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
                    gravity |= Gravity.TOP;
                }
                let newLayout = false;
                if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) != (this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK)) {
                    newLayout = true;
                }
                if (gravity != this.mGravity) {
                    this.invalidate();
                }
                this.mGravity = gravity;
                if (this.mLayout != null && newLayout) {
                    let want = this.mLayout.getWidth();
                    let hintWant = this.mHintLayout == null ? 0 : this.mHintLayout.getWidth();
                    this.makeNewLayout(want, hintWant, TextView.UNKNOWN_BORING, TextView.UNKNOWN_BORING, this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight(), true);
                }
            }
            getGravity() {
                return this.mGravity;
            }
            getPaintFlags() {
                return this.mTextPaint.getFlags();
            }
            setPaintFlags(flags) {
                if (this.mTextPaint.getFlags() != flags) {
                    this.mTextPaint.setFlags(flags);
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            setHorizontallyScrolling(whether) {
                if (this.mHorizontallyScrolling != whether) {
                    this.mHorizontallyScrolling = whether;
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            getHorizontallyScrolling() {
                return this.mHorizontallyScrolling;
            }
            setMinLines(minlines) {
                this.mMinimum = minlines;
                this.mMinMode = TextView.LINES;
                this.requestLayout();
                this.invalidate();
            }
            getMinLines() {
                return this.mMinMode == TextView.LINES ? this.mMinimum : -1;
            }
            setMinHeight(minHeight) {
                this.mMinimum = minHeight;
                this.mMinMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            getMinHeight() {
                return this.mMinMode == TextView.PIXELS ? this.mMinimum : -1;
            }
            setMaxLines(maxlines) {
                this.mMaximum = maxlines;
                this.mMaxMode = TextView.LINES;
                this.requestLayout();
                this.invalidate();
            }
            getMaxLines() {
                return this.mMaxMode == TextView.LINES ? this.mMaximum : -1;
            }
            setMaxHeight(maxHeight) {
                this.mMaximum = maxHeight;
                this.mMaxMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            getMaxHeight() {
                return this.mMaxMode == TextView.PIXELS ? this.mMaximum : -1;
            }
            setLines(lines) {
                this.mMaximum = this.mMinimum = lines;
                this.mMaxMode = this.mMinMode = TextView.LINES;
                this.requestLayout();
                this.invalidate();
            }
            setHeight(pixels) {
                this.mMaximum = this.mMinimum = pixels;
                this.mMaxMode = this.mMinMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            setMinEms(minems) {
                this.mMinWidthValue = minems;
                this.mMinWidthMode = TextView.EMS;
                this.requestLayout();
                this.invalidate();
            }
            getMinEms() {
                return this.mMinWidthMode == TextView.EMS ? this.mMinWidthValue : -1;
            }
            setMinWidth(minpixels) {
                this.mMinWidthValue = minpixels;
                this.mMinWidthMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            getMinWidth() {
                return this.mMinWidthMode == TextView.PIXELS ? this.mMinWidthValue : -1;
            }
            setMaxEms(maxems) {
                this.mMaxWidthValue = maxems;
                this.mMaxWidthMode = TextView.EMS;
                this.requestLayout();
                this.invalidate();
            }
            getMaxEms() {
                return this.mMaxWidthMode == TextView.EMS ? this.mMaxWidthValue : -1;
            }
            setMaxWidth(maxpixels) {
                this.mMaxWidthValue = maxpixels;
                this.mMaxWidthMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            getMaxWidth() {
                return this.mMaxWidthMode == TextView.PIXELS ? this.mMaxWidthValue : -1;
            }
            setEms(ems) {
                this.mMaxWidthValue = this.mMinWidthValue = ems;
                this.mMaxWidthMode = this.mMinWidthMode = TextView.EMS;
                this.requestLayout();
                this.invalidate();
            }
            setWidth(pixels) {
                this.mMaxWidthValue = this.mMinWidthValue = pixels;
                this.mMaxWidthMode = this.mMinWidthMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            setLineSpacing(add, mult) {
                if (this.mSpacingAdd != add || this.mSpacingMult != mult) {
                    this.mSpacingAdd = add;
                    this.mSpacingMult = mult;
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            getLineSpacingMultiplier() {
                return this.mSpacingMult;
            }
            getLineSpacingExtra() {
                return this.mSpacingAdd;
            }
            updateTextColors() {
                let inval = false;
                let color = this.mTextColor.getColorForState(this.getDrawableState(), 0);
                if (color != this.mCurTextColor) {
                    this.mCurTextColor = color;
                    inval = true;
                }
                if (this.mLinkTextColor != null) {
                    color = this.mLinkTextColor.getColorForState(this.getDrawableState(), 0);
                    if (color != this.mTextPaint.linkColor) {
                        this.mTextPaint.linkColor = color;
                        inval = true;
                    }
                }
                if (this.mHintTextColor != null) {
                    color = this.mHintTextColor.getColorForState(this.getDrawableState(), 0);
                    if (color != this.mCurHintTextColor && this.mText.length == 0) {
                        this.mCurHintTextColor = color;
                        inval = true;
                    }
                }
                if (inval) {
                    this.invalidate();
                }
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if (this.mTextColor != null && this.mTextColor.isStateful() || (this.mHintTextColor != null && this.mHintTextColor.isStateful()) || (this.mLinkTextColor != null && this.mLinkTextColor.isStateful())) {
                    this.updateTextColors();
                }
                const dr = this.mDrawables;
                if (dr != null) {
                    let state = this.getDrawableState();
                    if (dr.mDrawableTop != null && dr.mDrawableTop.isStateful()) {
                        dr.mDrawableTop.setState(state);
                    }
                    if (dr.mDrawableBottom != null && dr.mDrawableBottom.isStateful()) {
                        dr.mDrawableBottom.setState(state);
                    }
                    if (dr.mDrawableLeft != null && dr.mDrawableLeft.isStateful()) {
                        dr.mDrawableLeft.setState(state);
                    }
                    if (dr.mDrawableRight != null && dr.mDrawableRight.isStateful()) {
                        dr.mDrawableRight.setState(state);
                    }
                    if (dr.mDrawableStart != null && dr.mDrawableStart.isStateful()) {
                        dr.mDrawableStart.setState(state);
                    }
                    if (dr.mDrawableEnd != null && dr.mDrawableEnd.isStateful()) {
                        dr.mDrawableEnd.setState(state);
                    }
                }
            }
            removeMisspelledSpans(spannable) {
            }
            setFreezesText(freezesText) {
                this.mFreezesText = freezesText;
            }
            getFreezesText() {
                return this.mFreezesText;
            }
            setSpannableFactory(factory) {
                this.mSpannableFactory = factory;
                this.setText(this.mText);
            }
            setText(text, type = this.mBufferType, notifyBefore = true, oldlen = 0) {
                if (text == null) {
                    text = "";
                }
                if (!this.isSuggestionsEnabled()) {
                    text = this.removeSuggestionSpans(text);
                }
                if (Spanned.isImplements(text) && text.getSpanStart(TextUtils.TruncateAt.MARQUEE) >= 0) {
                    this.setHorizontalFadingEdgeEnabled(true);
                    this.mMarqueeFadeMode = TextView.MARQUEE_FADE_NORMAL;
                    this.setEllipsize(TextUtils.TruncateAt.MARQUEE);
                }
                if (notifyBefore) {
                    if (this.mText != null) {
                        oldlen = this.mText.length;
                        this.sendBeforeTextChanged(this.mText, 0, oldlen, text.length);
                    }
                    else {
                        this.sendBeforeTextChanged("", 0, 0, text.length);
                    }
                }
                let needEditableForNotification = false;
                if (this.mListeners != null && this.mListeners.size() != 0) {
                    needEditableForNotification = true;
                }
                if (type == TextView.BufferType.SPANNABLE || this.mMovement != null) {
                    text = this.mSpannableFactory.newSpannable(text);
                }
                this.mBufferType = type;
                this.mText = text;
                if (this.mTransformation == null) {
                    this.mTransformed = text;
                }
                else {
                    this.mTransformed = this.mTransformation.getTransformation(text, this);
                }
                const textLength = text.length;
                if (this.mLayout != null) {
                    this.checkForRelayout();
                }
                this.sendOnTextChanged(text, 0, oldlen, textLength);
                this.onTextChanged(text, 0, oldlen, textLength);
            }
            setHint(hint) {
                this.mHint = hint;
                if (this.mLayout != null) {
                    this.checkForRelayout();
                }
                if (this.mText.length == 0) {
                    this.invalidate();
                }
            }
            getHint() {
                return this.mHint;
            }
            isSingleLine() {
                return this.mSingleLine;
            }
            static isMultilineInputType(type) {
                return true;
            }
            removeSuggestionSpans(text) {
                return text;
            }
            hasPasswordTransformationMethod() {
                return false;
            }
            static isPasswordInputType(inputType) {
                return false;
            }
            static isVisiblePasswordInputType(inputType) {
                return true;
            }
            setRawInputType(type) {
            }
            setInputType(type, direct = false) {
            }
            getInputType() {
                return 0;
            }
            setImeOptions(imeOptions) {
            }
            getImeOptions() {
                return -1;
            }
            setImeActionLabel(label, actionId) {
                this.createEditorIfNeeded();
            }
            getImeActionLabel() {
                return '';
            }
            getImeActionId() {
                return 0;
            }
            setOnEditorActionListener(l) {
                this.createEditorIfNeeded();
            }
            setFrame(l, t, r, b) {
                let result = super.setFrame(l, t, r, b);
                this.restartMarqueeIfNeeded();
                return result;
            }
            restartMarqueeIfNeeded() {
                if (this.mRestartMarquee && this.mEllipsize == TextUtils.TruncateAt.MARQUEE) {
                    this.mRestartMarquee = false;
                    this.startMarquee();
                }
            }
            setFilters(...args) {
            }
            getFilters() {
                return this.mFilters;
            }
            getBoxHeight(l) {
                let padding = (l == this.mHintLayout) ? this.getCompoundPaddingTop() + this.getCompoundPaddingBottom() : this.getExtendedPaddingTop() + this.getExtendedPaddingBottom();
                return this.getMeasuredHeight() - padding;
            }
            getVerticalOffset(forceNormal) {
                let voffset = 0;
                const gravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                let l = this.mLayout;
                if (!forceNormal && this.mText.length == 0 && this.mHintLayout != null) {
                    l = this.mHintLayout;
                }
                if (gravity != Gravity.TOP) {
                    let boxht = this.getBoxHeight(l);
                    let textht = l.getHeight();
                    if (textht < boxht) {
                        if (gravity == Gravity.BOTTOM)
                            voffset = boxht - textht;
                        else
                            voffset = (boxht - textht) >> 1;
                    }
                }
                return voffset;
            }
            getBottomVerticalOffset(forceNormal) {
                let voffset = 0;
                const gravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                let l = this.mLayout;
                if (!forceNormal && this.mText.length == 0 && this.mHintLayout != null) {
                    l = this.mHintLayout;
                }
                if (gravity != Gravity.BOTTOM) {
                    let boxht = this.getBoxHeight(l);
                    let textht = l.getHeight();
                    if (textht < boxht) {
                        if (gravity == Gravity.TOP)
                            voffset = boxht - textht;
                        else
                            voffset = (boxht - textht) >> 1;
                    }
                }
                return voffset;
            }
            invalidateRegion(start, end, invalidateCursor) {
                if (this.mLayout == null) {
                    this.invalidate();
                }
                else {
                    let lineStart = this.mLayout.getLineForOffset(start);
                    let top = this.mLayout.getLineTop(lineStart);
                    if (lineStart > 0) {
                        top -= this.mLayout.getLineDescent(lineStart - 1);
                    }
                    let lineEnd;
                    if (start == end)
                        lineEnd = lineStart;
                    else
                        lineEnd = this.mLayout.getLineForOffset(end);
                    let bottom = this.mLayout.getLineBottom(lineEnd);
                    const compoundPaddingLeft = this.getCompoundPaddingLeft();
                    const verticalPadding = this.getExtendedPaddingTop() + this.getVerticalOffset(true);
                    let left, right;
                    if (lineStart == lineEnd && !invalidateCursor) {
                        left = Math.floor(this.mLayout.getPrimaryHorizontal(start));
                        right = Math.floor((this.mLayout.getPrimaryHorizontal(end) + 1.0));
                        left += compoundPaddingLeft;
                        right += compoundPaddingLeft;
                    }
                    else {
                        left = compoundPaddingLeft;
                        right = this.getWidth() - this.getCompoundPaddingRight();
                    }
                    this.invalidate(this.mScrollX + left, verticalPadding + top, this.mScrollX + right, verticalPadding + bottom);
                }
            }
            registerForPreDraw() {
                if (!this.mPreDrawRegistered) {
                    this.getViewTreeObserver().addOnPreDrawListener(this);
                    this.mPreDrawRegistered = true;
                }
            }
            onPreDraw() {
                if (this.mLayout == null) {
                    this.assumeLayout();
                }
                if (this.mMovement != null) {
                    let curs = this.getSelectionEnd();
                    if (curs < 0 && (this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
                        curs = this.mText.length;
                    }
                    if (curs >= 0) {
                        this.bringPointIntoView(curs);
                    }
                }
                else {
                    this.bringTextIntoView();
                }
                this.getViewTreeObserver().removeOnPreDrawListener(this);
                this.mPreDrawRegistered = false;
                return true;
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                this.mTemporaryDetach = false;
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                if (this.mPreDrawRegistered) {
                    this.getViewTreeObserver().removeOnPreDrawListener(this);
                    this.mPreDrawRegistered = false;
                }
                this.resetResolvedDrawables();
            }
            isPaddingOffsetRequired() {
                return this.mShadowRadius != 0 || this.mDrawables != null;
            }
            getLeftPaddingOffset() {
                return this.getCompoundPaddingLeft() - this.mPaddingLeft + Math.floor(Math.min(0, this.mShadowDx - this.mShadowRadius));
            }
            getTopPaddingOffset() {
                return Math.floor(Math.min(0, this.mShadowDy - this.mShadowRadius));
            }
            getBottomPaddingOffset() {
                return Math.floor(Math.max(0, this.mShadowDy + this.mShadowRadius));
            }
            getRightPaddingOffset() {
                return -(this.getCompoundPaddingRight() - this.mPaddingRight) + Math.floor(Math.max(0, this.mShadowDx + this.mShadowRadius));
            }
            verifyDrawable(who) {
                const verified = super.verifyDrawable(who);
                if (!verified && this.mDrawables != null) {
                    return who == this.mDrawables.mDrawableLeft || who == this.mDrawables.mDrawableTop || who == this.mDrawables.mDrawableRight || who == this.mDrawables.mDrawableBottom || who == this.mDrawables.mDrawableStart || who == this.mDrawables.mDrawableEnd;
                }
                return verified;
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mDrawables != null) {
                    if (this.mDrawables.mDrawableLeft != null) {
                        this.mDrawables.mDrawableLeft.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableTop != null) {
                        this.mDrawables.mDrawableTop.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableRight != null) {
                        this.mDrawables.mDrawableRight.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableBottom != null) {
                        this.mDrawables.mDrawableBottom.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableStart != null) {
                        this.mDrawables.mDrawableStart.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableEnd != null) {
                        this.mDrawables.mDrawableEnd.jumpToCurrentState();
                    }
                }
            }
            drawableSizeChange(d) {
                const drawables = this.mDrawables;
                const isCompoundDrawable = drawables != null && (d == drawables.mDrawableLeft || d == drawables.mDrawableTop
                    || d == drawables.mDrawableRight || d == drawables.mDrawableBottom || d == drawables.mDrawableStart || d == drawables.mDrawableEnd);
                if (isCompoundDrawable) {
                    d.setBounds(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());
                    this.setCompoundDrawables(drawables.mDrawableLeft, drawables.mDrawableTop, drawables.mDrawableRight, drawables.mDrawableBottom);
                }
                else {
                    super.drawableSizeChange(d);
                }
            }
            invalidateDrawable(drawable) {
                if (this.verifyDrawable(drawable)) {
                    const dirty = drawable.getBounds();
                    let scrollX = this.mScrollX;
                    let scrollY = this.mScrollY;
                    const drawables = this.mDrawables;
                    if (drawables != null) {
                        if (drawable == drawables.mDrawableLeft) {
                            const compoundPaddingTop = this.getCompoundPaddingTop();
                            const compoundPaddingBottom = this.getCompoundPaddingBottom();
                            const vspace = this.mBottom - this.mTop - compoundPaddingBottom - compoundPaddingTop;
                            scrollX += this.mPaddingLeft;
                            scrollY += compoundPaddingTop + (vspace - drawables.mDrawableHeightLeft) / 2;
                        }
                        else if (drawable == drawables.mDrawableRight) {
                            const compoundPaddingTop = this.getCompoundPaddingTop();
                            const compoundPaddingBottom = this.getCompoundPaddingBottom();
                            const vspace = this.mBottom - this.mTop - compoundPaddingBottom - compoundPaddingTop;
                            scrollX += (this.mRight - this.mLeft - this.mPaddingRight - drawables.mDrawableSizeRight);
                            scrollY += compoundPaddingTop + (vspace - drawables.mDrawableHeightRight) / 2;
                        }
                        else if (drawable == drawables.mDrawableTop) {
                            const compoundPaddingLeft = this.getCompoundPaddingLeft();
                            const compoundPaddingRight = this.getCompoundPaddingRight();
                            const hspace = this.mRight - this.mLeft - compoundPaddingRight - compoundPaddingLeft;
                            scrollX += compoundPaddingLeft + (hspace - drawables.mDrawableWidthTop) / 2;
                            scrollY += this.mPaddingTop;
                        }
                        else if (drawable == drawables.mDrawableBottom) {
                            const compoundPaddingLeft = this.getCompoundPaddingLeft();
                            const compoundPaddingRight = this.getCompoundPaddingRight();
                            const hspace = this.mRight - this.mLeft - compoundPaddingRight - compoundPaddingLeft;
                            scrollX += compoundPaddingLeft + (hspace - drawables.mDrawableWidthBottom) / 2;
                            scrollY += (this.mBottom - this.mTop - this.mPaddingBottom - drawables.mDrawableSizeBottom);
                        }
                    }
                    this.invalidate(dirty.left + scrollX, dirty.top + scrollY, dirty.right + scrollX, dirty.bottom + scrollY);
                }
            }
            isTextSelectable() {
                return false;
            }
            setTextIsSelectable(selectable) {
            }
            onCreateDrawableState(extraSpace) {
                let drawableState;
                if (this.mSingleLine) {
                    drawableState = super.onCreateDrawableState(extraSpace);
                }
                else {
                    drawableState = super.onCreateDrawableState(extraSpace + 1);
                    TextView.mergeDrawableStates(drawableState, TextView.MULTILINE_STATE_SET);
                }
                if (this.isTextSelectable()) {
                    const length = drawableState.length;
                    for (let i = 0; i < length; i++) {
                        if (drawableState[i] == View.VIEW_STATE_PRESSED) {
                            const nonPressedState = new Array(length - 1);
                            System.arraycopy(drawableState, 0, nonPressedState, 0, i);
                            System.arraycopy(drawableState, i + 1, nonPressedState, i, length - i - 1);
                            return nonPressedState;
                        }
                    }
                }
                return drawableState;
            }
            getUpdatedHighlightPath() {
                let highlight = null;
                let highlightPaint = this.mHighlightPaint;
                const selStart = this.getSelectionStart();
                const selEnd = this.getSelectionEnd();
                if (this.mMovement != null && (this.isFocused() || this.isPressed()) && selStart >= 0) {
                    if (selStart == selEnd) {
                    }
                    else {
                        if (this.mHighlightPathBogus) {
                            if (this.mHighlightPath == null)
                                this.mHighlightPath = new Path();
                            this.mHighlightPath.reset();
                            this.mLayout.getSelectionPath(selStart, selEnd, this.mHighlightPath);
                            this.mHighlightPathBogus = false;
                        }
                        highlightPaint.setColor(this.mHighlightColor);
                        highlightPaint.setStyle(Paint.Style.FILL);
                        highlight = this.mHighlightPath;
                    }
                }
                return highlight;
            }
            getHorizontalOffsetForDrawables() {
                return 0;
            }
            onDraw(canvas) {
                this.restartMarqueeIfNeeded();
                super.onDraw(canvas);
                const compoundPaddingLeft = this.getCompoundPaddingLeft();
                const compoundPaddingTop = this.getCompoundPaddingTop();
                const compoundPaddingRight = this.getCompoundPaddingRight();
                const compoundPaddingBottom = this.getCompoundPaddingBottom();
                const scrollX = this.mScrollX;
                const scrollY = this.mScrollY;
                const right = this.mRight;
                const left = this.mLeft;
                const bottom = this.mBottom;
                const top = this.mTop;
                const isLayoutRtl = this.isLayoutRtl();
                const offset = this.getHorizontalOffsetForDrawables();
                const leftOffset = isLayoutRtl ? 0 : offset;
                const rightOffset = isLayoutRtl ? offset : 0;
                const dr = this.mDrawables;
                if (dr != null) {
                    let vspace = bottom - top - compoundPaddingBottom - compoundPaddingTop;
                    let hspace = right - left - compoundPaddingRight - compoundPaddingLeft;
                    if (dr.mDrawableLeft != null) {
                        canvas.save();
                        canvas.translate(scrollX + this.mPaddingLeft + leftOffset, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightLeft) / 2);
                        dr.mDrawableLeft.draw(canvas);
                        canvas.restore();
                    }
                    if (dr.mDrawableRight != null) {
                        canvas.save();
                        canvas.translate(scrollX + right - left - this.mPaddingRight - dr.mDrawableSizeRight - rightOffset, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightRight) / 2);
                        dr.mDrawableRight.draw(canvas);
                        canvas.restore();
                    }
                    if (dr.mDrawableTop != null) {
                        canvas.save();
                        canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthTop) / 2, scrollY + this.mPaddingTop);
                        dr.mDrawableTop.draw(canvas);
                        canvas.restore();
                    }
                    if (dr.mDrawableBottom != null) {
                        canvas.save();
                        canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthBottom) / 2, scrollY + bottom - top - this.mPaddingBottom - dr.mDrawableSizeBottom);
                        dr.mDrawableBottom.draw(canvas);
                        canvas.restore();
                    }
                }
                let color = this.mCurTextColor;
                if (this.mLayout == null) {
                    this.assumeLayout();
                }
                let layout = this.mLayout;
                if (this.mHint != null && this.mText.length == 0) {
                    if (this.mHintTextColor != null) {
                        color = this.mCurHintTextColor;
                    }
                    layout = this.mHintLayout;
                }
                this.mTextPaint.setColor(color);
                this.mTextPaint.drawableState = this.getDrawableState();
                canvas.save();
                let extendedPaddingTop = this.getExtendedPaddingTop();
                let extendedPaddingBottom = this.getExtendedPaddingBottom();
                const vspace = this.mBottom - this.mTop - compoundPaddingBottom - compoundPaddingTop;
                const maxScrollY = this.mLayout.getHeight() - vspace;
                let clipLeft = compoundPaddingLeft + scrollX;
                let clipTop = (scrollY == 0) ? 0 : extendedPaddingTop + scrollY;
                let clipRight = right - left - compoundPaddingRight + scrollX;
                let clipBottom = bottom - top + scrollY - ((scrollY == maxScrollY) ? 0 : extendedPaddingBottom);
                if (this.mShadowRadius != 0) {
                    clipLeft += Math.min(0, this.mShadowDx - this.mShadowRadius);
                    clipRight += Math.max(0, this.mShadowDx + this.mShadowRadius);
                    clipTop += Math.min(0, this.mShadowDy - this.mShadowRadius);
                    clipBottom += Math.max(0, this.mShadowDy + this.mShadowRadius);
                }
                canvas.clipRect(clipLeft, clipTop, clipRight, clipBottom);
                let voffsetText = 0;
                let voffsetCursor = 0;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                    voffsetText = this.getVerticalOffset(false);
                    voffsetCursor = this.getVerticalOffset(true);
                }
                canvas.translate(compoundPaddingLeft, extendedPaddingTop + voffsetText);
                const absoluteGravity = this.mGravity;
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE && this.mMarqueeFadeMode != TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                    if (!this.mSingleLine && this.getLineCount() == 1 && this.canMarquee() && (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) != Gravity.LEFT) {
                        const width = this.mRight - this.mLeft;
                        const padding = this.getCompoundPaddingLeft() + this.getCompoundPaddingRight();
                        const dx = this.mLayout.getLineRight(0) - (width - padding);
                        canvas.translate(isLayoutRtl ? -dx : +dx, 0.0);
                    }
                    if (this.mMarquee != null && this.mMarquee.isRunning()) {
                        const dx = -this.mMarquee.getScroll();
                        canvas.translate(isLayoutRtl ? -dx : +dx, 0.0);
                    }
                }
                const cursorOffsetVertical = voffsetCursor - voffsetText;
                let highlight = this.getUpdatedHighlightPath();
                layout.draw(canvas, highlight, this.mHighlightPaint, cursorOffsetVertical);
                if (this.mMarquee != null && this.mMarquee.shouldDrawGhost()) {
                    const dx = Math.floor(this.mMarquee.getGhostOffset());
                    canvas.translate(isLayoutRtl ? -dx : dx, 0.0);
                    layout.draw(canvas, highlight, this.mHighlightPaint, cursorOffsetVertical);
                }
                canvas.restore();
            }
            getFocusedRect(r) {
                if (this.mLayout == null) {
                    super.getFocusedRect(r);
                    return;
                }
                let selEnd = this.getSelectionEnd();
                if (selEnd < 0) {
                    super.getFocusedRect(r);
                    return;
                }
            }
            getLineCount() {
                return this.mLayout != null ? this.mLayout.getLineCount() : 0;
            }
            getLineBounds(line, bounds) {
                if (this.mLayout == null) {
                    if (bounds != null) {
                        bounds.set(0, 0, 0, 0);
                    }
                    return 0;
                }
                else {
                    let baseline = this.mLayout.getLineBounds(line, bounds);
                    let voffset = this.getExtendedPaddingTop();
                    if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                        voffset += this.getVerticalOffset(true);
                    }
                    if (bounds != null) {
                        bounds.offset(this.getCompoundPaddingLeft(), voffset);
                    }
                    return baseline + voffset;
                }
            }
            getBaseline() {
                if (this.mLayout == null) {
                    return super.getBaseline();
                }
                let voffset = 0;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                    voffset = this.getVerticalOffset(true);
                }
                return this.getExtendedPaddingTop() + voffset + this.mLayout.getLineBaseline(0);
            }
            getFadeTop(offsetRequired) {
                if (this.mLayout == null)
                    return 0;
                let voffset = 0;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                    voffset = this.getVerticalOffset(true);
                }
                if (offsetRequired)
                    voffset += this.getTopPaddingOffset();
                return this.getExtendedPaddingTop() + voffset;
            }
            getFadeHeight(offsetRequired) {
                return this.mLayout != null ? this.mLayout.getHeight() : 0;
            }
            onKeyDown(keyCode, event) {
                let which = this.doKeyDown(keyCode, event, null);
                if (which == 0) {
                    return super.onKeyDown(keyCode, event);
                }
                return true;
            }
            shouldAdvanceFocusOnEnter() {
                if (this.getKeyListener() == null) {
                    return false;
                }
                if (this.mSingleLine) {
                    return true;
                }
                return false;
            }
            shouldAdvanceFocusOnTab() {
                return true;
            }
            doKeyDown(keyCode, event, otherEvent) {
                return 0;
            }
            resetErrorChangedFlag() {
            }
            hideErrorIfUnchanged() {
            }
            onKeyUp(keyCode, event) {
                return super.onKeyUp(keyCode, event);
            }
            onCheckIsTextEditor() {
                return false;
            }
            nullLayouts() {
                if (this.mLayout instanceof BoringLayout && this.mSavedLayout == null) {
                    this.mSavedLayout = this.mLayout;
                }
                if (this.mHintLayout instanceof BoringLayout && this.mSavedHintLayout == null) {
                    this.mSavedHintLayout = this.mHintLayout;
                }
                this.mSavedMarqueeModeLayout = this.mLayout = this.mHintLayout = null;
                this.mBoring = this.mHintBoring = null;
            }
            assumeLayout() {
                let width = this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                if (width < 1) {
                    width = 0;
                }
                let physicalWidth = width;
                if (this.mHorizontallyScrolling) {
                    width = TextView.VERY_WIDE;
                }
                this.makeNewLayout(width, physicalWidth, TextView.UNKNOWN_BORING, TextView.UNKNOWN_BORING, physicalWidth, false);
            }
            getLayoutAlignment() {
                let alignment;
                switch (this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                    case Gravity.LEFT:
                        alignment = Layout.Alignment.ALIGN_LEFT;
                        break;
                    case Gravity.RIGHT:
                        alignment = Layout.Alignment.ALIGN_RIGHT;
                        break;
                    case Gravity.CENTER_HORIZONTAL:
                        alignment = Layout.Alignment.ALIGN_CENTER;
                        break;
                    default:
                        alignment = Layout.Alignment.ALIGN_NORMAL;
                        break;
                }
                return alignment;
            }
            makeNewLayout(wantWidth, hintWidth, boring, hintBoring, ellipsisWidth, bringIntoView) {
                this.stopMarquee();
                this.mOldMaximum = this.mMaximum;
                this.mOldMaxMode = this.mMaxMode;
                this.mHighlightPathBogus = true;
                if (wantWidth < 0) {
                    wantWidth = 0;
                }
                if (hintWidth < 0) {
                    hintWidth = 0;
                }
                let alignment = this.getLayoutAlignment();
                const testDirChange = this.mSingleLine && this.mLayout != null && (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE);
                let oldDir = 0;
                if (testDirChange)
                    oldDir = this.mLayout.getParagraphDirection(0);
                let shouldEllipsize = this.mEllipsize != null && this.getKeyListener() == null;
                const switchEllipsize = this.mEllipsize == TruncateAt.MARQUEE && this.mMarqueeFadeMode != TextView.MARQUEE_FADE_NORMAL;
                let effectiveEllipsize = this.mEllipsize;
                if (this.mEllipsize == TruncateAt.MARQUEE && this.mMarqueeFadeMode == TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                    effectiveEllipsize = TruncateAt.END_SMALL;
                }
                if (this.mTextDir == null) {
                    this.mTextDir = this.getTextDirectionHeuristic();
                }
                this.mLayout = this.makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, effectiveEllipsize, effectiveEllipsize == this.mEllipsize);
                if (switchEllipsize) {
                    let oppositeEllipsize = effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
                    this.mSavedMarqueeModeLayout = this.makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, oppositeEllipsize, effectiveEllipsize != this.mEllipsize);
                }
                shouldEllipsize = this.mEllipsize != null;
                this.mHintLayout = null;
                if (this.mHint != null) {
                    if (shouldEllipsize)
                        hintWidth = wantWidth;
                    if (hintBoring == TextView.UNKNOWN_BORING) {
                        hintBoring = BoringLayout.isBoring(this.mHint, this.mTextPaint, this.mTextDir, this.mHintBoring);
                        if (hintBoring != null) {
                            this.mHintBoring = hintBoring;
                        }
                    }
                    if (hintBoring != null) {
                        if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
                            if (this.mSavedHintLayout != null) {
                                this.mHintLayout = this.mSavedHintLayout.replaceOrMake(this.mHint, this.mTextPaint, hintWidth, alignment, this.mSpacingMult, this.mSpacingAdd, hintBoring, this.mIncludePad);
                            }
                            else {
                                this.mHintLayout = BoringLayout.make(this.mHint, this.mTextPaint, hintWidth, alignment, this.mSpacingMult, this.mSpacingAdd, hintBoring, this.mIncludePad);
                            }
                            this.mSavedHintLayout = this.mHintLayout;
                        }
                        else if (shouldEllipsize && hintBoring.width <= hintWidth) {
                            if (this.mSavedHintLayout != null) {
                                this.mHintLayout = this.mSavedHintLayout.replaceOrMake(this.mHint, this.mTextPaint, hintWidth, alignment, this.mSpacingMult, this.mSpacingAdd, hintBoring, this.mIncludePad, this.mEllipsize, ellipsisWidth);
                            }
                            else {
                                this.mHintLayout = BoringLayout.make(this.mHint, this.mTextPaint, hintWidth, alignment, this.mSpacingMult, this.mSpacingAdd, hintBoring, this.mIncludePad, this.mEllipsize, ellipsisWidth);
                            }
                        }
                        else if (shouldEllipsize) {
                            this.mHintLayout = new StaticLayout(this.mHint, 0, this.mHint.length, this.mTextPaint, hintWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, this.mEllipsize, ellipsisWidth, this.mMaxMode == TextView.LINES ? this.mMaximum : Integer.MAX_VALUE);
                        }
                        else {
                            this.mHintLayout = new StaticLayout(this.mHint, 0, this.mHint.length, this.mTextPaint, hintWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad);
                        }
                    }
                    else if (shouldEllipsize) {
                        this.mHintLayout = new StaticLayout(this.mHint, 0, this.mHint.length, this.mTextPaint, hintWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, this.mEllipsize, ellipsisWidth, this.mMaxMode == TextView.LINES ? this.mMaximum : Integer.MAX_VALUE);
                    }
                    else {
                        this.mHintLayout = new StaticLayout(this.mHint, 0, this.mHint.length, this.mTextPaint, hintWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad);
                    }
                }
                if (bringIntoView || (testDirChange && oldDir != this.mLayout.getParagraphDirection(0))) {
                    this.registerForPreDraw();
                }
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE) {
                    if (!this.compressText(ellipsisWidth)) {
                        const height = this.mLayoutParams.height;
                        if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
                            this.startMarquee();
                        }
                        else {
                            this.mRestartMarquee = true;
                        }
                    }
                }
            }
            makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, effectiveEllipsize, useSaved) {
                let result = null;
                if (Spannable.isImpl(this.mText)) {
                    result = new DynamicLayout(this.mText, this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, this.getKeyListener() == null ? effectiveEllipsize : null, ellipsisWidth);
                }
                else {
                    if (boring == TextView.UNKNOWN_BORING) {
                        boring = BoringLayout.isBoring(this.mTransformed, this.mTextPaint, this.mTextDir, this.mBoring);
                        if (boring != null) {
                            this.mBoring = boring;
                        }
                    }
                    if (boring != null) {
                        if (boring.width <= wantWidth && (effectiveEllipsize == null || boring.width <= ellipsisWidth)) {
                            if (useSaved && this.mSavedLayout != null) {
                                result = this.mSavedLayout.replaceOrMake(this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mSpacingMult, this.mSpacingAdd, boring, this.mIncludePad);
                            }
                            else {
                                result = BoringLayout.make(this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mSpacingMult, this.mSpacingAdd, boring, this.mIncludePad);
                            }
                            if (useSaved) {
                                this.mSavedLayout = result;
                            }
                        }
                        else if (shouldEllipsize && boring.width <= wantWidth) {
                            if (useSaved && this.mSavedLayout != null) {
                                result = this.mSavedLayout.replaceOrMake(this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mSpacingMult, this.mSpacingAdd, boring, this.mIncludePad, effectiveEllipsize, ellipsisWidth);
                            }
                            else {
                                result = BoringLayout.make(this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mSpacingMult, this.mSpacingAdd, boring, this.mIncludePad, effectiveEllipsize, ellipsisWidth);
                            }
                        }
                        else if (shouldEllipsize) {
                            result = new StaticLayout(this.mTransformed, 0, this.mTransformed.length, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, effectiveEllipsize, ellipsisWidth, this.mMaxMode == TextView.LINES ? this.mMaximum : Integer.MAX_VALUE);
                        }
                        else {
                            result = new StaticLayout(this.mTransformed, 0, this.mTransformed.length, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad);
                        }
                    }
                    else if (shouldEllipsize) {
                        result = new StaticLayout(this.mTransformed, 0, this.mTransformed.length, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, effectiveEllipsize, ellipsisWidth, this.mMaxMode == TextView.LINES ? this.mMaximum : Integer.MAX_VALUE);
                    }
                    else {
                        result = new StaticLayout(this.mTransformed, 0, this.mTransformed.length, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad);
                    }
                }
                return result;
            }
            compressText(width) {
                if (this.isHardwareAccelerated())
                    return false;
                if (width > 0.0 && this.mLayout != null && this.getLineCount() == 1 && !this.mUserSetTextScaleX && this.mTextPaint.getTextScaleX() == 1.0) {
                    const textWidth = this.mLayout.getLineWidth(0);
                    const overflow = (textWidth + 1.0 - width) / width;
                    if (overflow > 0.0 && overflow <= TextView.Marquee.MARQUEE_DELTA_MAX) {
                        this.mTextPaint.setTextScaleX(1.0 - overflow - 0.005);
                        this.post((() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.requestLayout();
                                }
                            }
                            return new _Inner();
                        })());
                        return true;
                    }
                }
                return false;
            }
            static desired(layout) {
                let n = layout.getLineCount();
                let text = layout.getText();
                let max = 0;
                for (let i = 0; i < n - 1; i++) {
                    if (text.charAt(layout.getLineEnd(i) - 1) != '\n')
                        return -1;
                }
                for (let i = 0; i < n; i++) {
                    max = Math.max(max, layout.getLineWidth(i));
                }
                return Math.floor(Math.ceil(max));
            }
            setIncludeFontPadding(includepad) {
                if (this.mIncludePad != includepad) {
                    this.mIncludePad = includepad;
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            getIncludeFontPadding() {
                return this.mIncludePad;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let widthMode = TextView.MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = TextView.MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = TextView.MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = TextView.MeasureSpec.getSize(heightMeasureSpec);
                let width;
                let height;
                let boring = TextView.UNKNOWN_BORING;
                let hintBoring = TextView.UNKNOWN_BORING;
                if (this.mTextDir == null) {
                    this.mTextDir = this.getTextDirectionHeuristic();
                }
                let des = -1;
                let fromexisting = false;
                if (widthMode == TextView.MeasureSpec.EXACTLY) {
                    width = widthSize;
                }
                else {
                    if (this.mLayout != null && this.mEllipsize == null) {
                        des = TextView.desired(this.mLayout);
                    }
                    if (des < 0) {
                        boring = BoringLayout.isBoring(this.mTransformed, this.mTextPaint, this.mTextDir, this.mBoring);
                        if (boring != null) {
                            this.mBoring = boring;
                        }
                    }
                    else {
                        fromexisting = true;
                    }
                    if (boring == null || boring == TextView.UNKNOWN_BORING) {
                        if (des < 0) {
                            des = Math.floor(Math.ceil(Layout.getDesiredWidth(this.mTransformed, this.mTextPaint)));
                        }
                        width = des;
                    }
                    else {
                        width = boring.width;
                    }
                    const dr = this.mDrawables;
                    if (dr != null) {
                        width = Math.max(width, dr.mDrawableWidthTop);
                        width = Math.max(width, dr.mDrawableWidthBottom);
                    }
                    if (this.mHint != null) {
                        let hintDes = -1;
                        let hintWidth;
                        if (this.mHintLayout != null && this.mEllipsize == null) {
                            hintDes = TextView.desired(this.mHintLayout);
                        }
                        if (hintDes < 0) {
                            hintBoring = BoringLayout.isBoring(this.mHint, this.mTextPaint, this.mTextDir, this.mHintBoring);
                            if (hintBoring != null) {
                                this.mHintBoring = hintBoring;
                            }
                        }
                        if (hintBoring == null || hintBoring == TextView.UNKNOWN_BORING) {
                            if (hintDes < 0) {
                                hintDes = Math.floor(Math.ceil(Layout.getDesiredWidth(this.mHint, this.mTextPaint)));
                            }
                            hintWidth = hintDes;
                        }
                        else {
                            hintWidth = hintBoring.width;
                        }
                        if (hintWidth > width) {
                            width = hintWidth;
                        }
                    }
                    width += this.getCompoundPaddingLeft() + this.getCompoundPaddingRight();
                    if (this.mMaxWidthMode == TextView.EMS) {
                        width = Math.min(width, this.mMaxWidthValue * this.getLineHeight());
                    }
                    else {
                        width = Math.min(width, this.mMaxWidthValue);
                    }
                    if (this.mMinWidthMode == TextView.EMS) {
                        width = Math.max(width, this.mMinWidthValue * this.getLineHeight());
                    }
                    else {
                        width = Math.max(width, this.mMinWidthValue);
                    }
                    width = Math.max(width, this.getSuggestedMinimumWidth());
                    if (widthMode == TextView.MeasureSpec.AT_MOST) {
                        width = Math.min(widthSize, width);
                    }
                }
                let want = width - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                let unpaddedWidth = want;
                if (this.mHorizontallyScrolling)
                    want = TextView.VERY_WIDE;
                let hintWant = want;
                let hintWidth = (this.mHintLayout == null) ? hintWant : this.mHintLayout.getWidth();
                if (this.mLayout == null) {
                    this.makeNewLayout(want, hintWant, boring, hintBoring, width - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight(), false);
                }
                else {
                    const layoutChanged = (this.mLayout.getWidth() != want) || (hintWidth != hintWant) || (this.mLayout.getEllipsizedWidth() != width - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight());
                    const widthChanged = (this.mHint == null) && (this.mEllipsize == null) && (want > this.mLayout.getWidth()) && (this.mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
                    const maximumChanged = (this.mMaxMode != this.mOldMaxMode) || (this.mMaximum != this.mOldMaximum);
                    if (layoutChanged || maximumChanged) {
                        if (!maximumChanged && widthChanged) {
                            this.mLayout.increaseWidthTo(want);
                        }
                        else {
                            this.makeNewLayout(want, hintWant, boring, hintBoring, width - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight(), false);
                        }
                    }
                    else {
                    }
                }
                if (heightMode == TextView.MeasureSpec.EXACTLY) {
                    height = heightSize;
                    this.mDesiredHeightAtMeasure = -1;
                }
                else {
                    let desired = this.getDesiredHeight();
                    height = desired;
                    this.mDesiredHeightAtMeasure = desired;
                    if (heightMode == TextView.MeasureSpec.AT_MOST) {
                        height = Math.min(desired, heightSize);
                    }
                }
                let unpaddedHeight = height - this.getCompoundPaddingTop() - this.getCompoundPaddingBottom();
                if (this.mMaxMode == TextView.LINES && this.mLayout.getLineCount() > this.mMaximum) {
                    unpaddedHeight = Math.min(unpaddedHeight, this.mLayout.getLineTop(this.mMaximum));
                }
                if (this.mMovement != null || this.mLayout.getWidth() > unpaddedWidth || this.mLayout.getHeight() > unpaddedHeight) {
                    this.registerForPreDraw();
                }
                else {
                    this.scrollTo(0, 0);
                }
                this.setMeasuredDimension(width, height);
            }
            getDesiredHeight(layout, cap = true) {
                if (arguments.length === 0) {
                    return Math.max(this.getDesiredHeight(this.mLayout, true), this.getDesiredHeight(this.mHintLayout, this.mEllipsize != null));
                }
                if (layout == null) {
                    return 0;
                }
                let linecount = layout.getLineCount();
                let pad = this.getCompoundPaddingTop() + this.getCompoundPaddingBottom();
                let desired = layout.getLineTop(linecount);
                const dr = this.mDrawables;
                if (dr != null) {
                    desired = Math.max(desired, dr.mDrawableHeightLeft);
                    desired = Math.max(desired, dr.mDrawableHeightRight);
                }
                desired += pad;
                if (this.mMaxMode == TextView.LINES) {
                    if (cap) {
                        if (linecount > this.mMaximum) {
                            desired = layout.getLineTop(this.mMaximum);
                            if (dr != null) {
                                desired = Math.max(desired, dr.mDrawableHeightLeft);
                                desired = Math.max(desired, dr.mDrawableHeightRight);
                            }
                            desired += pad;
                            linecount = this.mMaximum;
                        }
                    }
                }
                else {
                    desired = Math.min(desired, this.mMaximum);
                }
                if (this.mMinMode == TextView.LINES) {
                    if (linecount < this.mMinimum) {
                        desired += this.getLineHeight() * (this.mMinimum - linecount);
                    }
                }
                else {
                    desired = Math.max(desired, this.mMinimum);
                }
                desired = Math.max(desired, this.getSuggestedMinimumHeight());
                return desired;
            }
            checkForResize() {
                let sizeChanged = false;
                if (this.mLayout != null) {
                    if (this.mLayoutParams.width == LayoutParams.WRAP_CONTENT) {
                        sizeChanged = true;
                        this.invalidate();
                    }
                    if (this.mLayoutParams.height == LayoutParams.WRAP_CONTENT) {
                        let desiredHeight = this.getDesiredHeight();
                        if (desiredHeight != this.getHeight()) {
                            sizeChanged = true;
                        }
                    }
                    else if (this.mLayoutParams.height == LayoutParams.MATCH_PARENT) {
                        if (this.mDesiredHeightAtMeasure >= 0) {
                            let desiredHeight = this.getDesiredHeight();
                            if (desiredHeight != this.mDesiredHeightAtMeasure) {
                                sizeChanged = true;
                            }
                        }
                    }
                }
                if (sizeChanged) {
                    this.requestLayout();
                }
            }
            checkForRelayout() {
                if ((this.mLayoutParams.width != LayoutParams.WRAP_CONTENT || (this.mMaxWidthMode == this.mMinWidthMode && this.mMaxWidthValue == this.mMinWidthValue)) && (this.mHint == null || this.mHintLayout != null) && (this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight() > 0)) {
                    let oldht = this.mLayout.getHeight();
                    let want = this.mLayout.getWidth();
                    let hintWant = this.mHintLayout == null ? 0 : this.mHintLayout.getWidth();
                    this.makeNewLayout(want, hintWant, TextView.UNKNOWN_BORING, TextView.UNKNOWN_BORING, this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight(), false);
                    if (this.mEllipsize != TextUtils.TruncateAt.MARQUEE) {
                        if (this.mLayoutParams.height != LayoutParams.WRAP_CONTENT && this.mLayoutParams.height != LayoutParams.MATCH_PARENT) {
                            this.invalidate();
                            return;
                        }
                        if (this.mLayout.getHeight() == oldht && (this.mHintLayout == null || this.mHintLayout.getHeight() == oldht)) {
                            this.invalidate();
                            return;
                        }
                    }
                    this.requestLayout();
                    this.invalidate();
                }
                else {
                    this.nullLayouts();
                    this.requestLayout();
                    this.invalidate();
                }
            }
            onLayout(changed, left, top, right, bottom) {
                super.onLayout(changed, left, top, right, bottom);
                if (this.mDeferScroll >= 0) {
                    let curs = this.mDeferScroll;
                    this.mDeferScroll = -1;
                    this.bringPointIntoView(Math.min(curs, this.mText.length));
                }
            }
            isShowingHint() {
                return TextUtils.isEmpty(this.mText) && !TextUtils.isEmpty(this.mHint);
            }
            bringTextIntoView() {
                let layout = this.isShowingHint() ? this.mHintLayout : this.mLayout;
                let line = 0;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
                    line = layout.getLineCount() - 1;
                }
                let a = layout.getParagraphAlignment(line);
                let dir = layout.getParagraphDirection(line);
                let hspace = this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                let vspace = this.mBottom - this.mTop - this.getExtendedPaddingTop() - this.getExtendedPaddingBottom();
                let ht = layout.getHeight();
                let scrollx, scrolly;
                if (a == Layout.Alignment.ALIGN_NORMAL) {
                    a = dir == Layout.DIR_LEFT_TO_RIGHT ? Layout.Alignment.ALIGN_LEFT : Layout.Alignment.ALIGN_RIGHT;
                }
                else if (a == Layout.Alignment.ALIGN_OPPOSITE) {
                    a = dir == Layout.DIR_LEFT_TO_RIGHT ? Layout.Alignment.ALIGN_RIGHT : Layout.Alignment.ALIGN_LEFT;
                }
                if (a == Layout.Alignment.ALIGN_CENTER) {
                    let left = Math.floor(Math.floor(layout.getLineLeft(line)));
                    let right = Math.floor(Math.ceil(layout.getLineRight(line)));
                    if (right - left < hspace) {
                        scrollx = (right + left) / 2 - hspace / 2;
                    }
                    else {
                        if (dir < 0) {
                            scrollx = right - hspace;
                        }
                        else {
                            scrollx = left;
                        }
                    }
                }
                else if (a == Layout.Alignment.ALIGN_RIGHT) {
                    let right = Math.floor(Math.ceil(layout.getLineRight(line)));
                    scrollx = right - hspace;
                }
                else {
                    scrollx = Math.floor(Math.floor(layout.getLineLeft(line)));
                }
                if (ht < vspace) {
                    scrolly = 0;
                }
                else {
                    if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
                        scrolly = ht - vspace;
                    }
                    else {
                        scrolly = 0;
                    }
                }
                if (scrollx != this.mScrollX || scrolly != this.mScrollY) {
                    this.scrollTo(scrollx, scrolly);
                    return true;
                }
                else {
                    return false;
                }
            }
            bringPointIntoView(offset) {
                if (this.isLayoutRequested()) {
                    this.mDeferScroll = offset;
                    return false;
                }
                let changed = false;
                let layout = this.isShowingHint() ? this.mHintLayout : this.mLayout;
                if (layout == null)
                    return changed;
                let line = layout.getLineForOffset(offset);
                let grav;
                switch (layout.getParagraphAlignment(line)) {
                    case Layout.Alignment.ALIGN_LEFT:
                        grav = 1;
                        break;
                    case Layout.Alignment.ALIGN_RIGHT:
                        grav = -1;
                        break;
                    case Layout.Alignment.ALIGN_NORMAL:
                        grav = layout.getParagraphDirection(line);
                        break;
                    case Layout.Alignment.ALIGN_OPPOSITE:
                        grav = -layout.getParagraphDirection(line);
                        break;
                    case Layout.Alignment.ALIGN_CENTER:
                    default:
                        grav = 0;
                        break;
                }
                const clamped = grav > 0;
                const x = Math.floor(layout.getPrimaryHorizontal(offset, clamped));
                const top = layout.getLineTop(line);
                const bottom = layout.getLineTop(line + 1);
                let left = Math.floor(Math.floor(layout.getLineLeft(line)));
                let right = Math.floor(Math.ceil(layout.getLineRight(line)));
                let ht = layout.getHeight();
                let hspace = this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                let vspace = this.mBottom - this.mTop - this.getExtendedPaddingTop() - this.getExtendedPaddingBottom();
                if (!this.mHorizontallyScrolling && right - left > hspace && right > x) {
                    right = Math.max(x, left + hspace);
                }
                let hslack = (bottom - top) / 2;
                let vslack = hslack;
                if (vslack > vspace / 4)
                    vslack = vspace / 4;
                if (hslack > hspace / 4)
                    hslack = hspace / 4;
                let hs = this.mScrollX;
                let vs = this.mScrollY;
                if (top - vs < vslack)
                    vs = top - vslack;
                if (bottom - vs > vspace - vslack)
                    vs = bottom - (vspace - vslack);
                if (ht - vs < vspace)
                    vs = ht - vspace;
                if (0 - vs > 0)
                    vs = 0;
                if (grav != 0) {
                    if (x - hs < hslack) {
                        hs = x - hslack;
                    }
                    if (x - hs > hspace - hslack) {
                        hs = x - (hspace - hslack);
                    }
                }
                if (grav < 0) {
                    if (left - hs > 0)
                        hs = left;
                    if (right - hs < hspace)
                        hs = right - hspace;
                }
                else if (grav > 0) {
                    if (right - hs < hspace)
                        hs = right - hspace;
                    if (left - hs > 0)
                        hs = left;
                }
                else {
                    if (right - left <= hspace) {
                        hs = left - (hspace - (right - left)) / 2;
                    }
                    else if (x > right - hslack) {
                        hs = right - hspace;
                    }
                    else if (x < left + hslack) {
                        hs = left;
                    }
                    else if (left > hs) {
                        hs = left;
                    }
                    else if (right < hs + hspace) {
                        hs = right - hspace;
                    }
                    else {
                        if (x - hs < hslack) {
                            hs = x - hslack;
                        }
                        if (x - hs > hspace - hslack) {
                            hs = x - (hspace - hslack);
                        }
                    }
                }
                if (hs != this.mScrollX || vs != this.mScrollY) {
                    if (this.mScroller == null) {
                        this.scrollTo(hs, vs);
                    }
                    else {
                        let duration = AnimationUtils.currentAnimationTimeMillis() - this.mLastScroll;
                        let dx = hs - this.mScrollX;
                        let dy = vs - this.mScrollY;
                        if (duration > TextView.ANIMATED_SCROLL_GAP) {
                            this.mScroller.startScroll(this.mScrollX, this.mScrollY, dx, dy);
                            this.awakenScrollBars(this.mScroller.getDuration());
                            this.invalidate();
                        }
                        else {
                            if (!this.mScroller.isFinished()) {
                                this.mScroller.abortAnimation();
                            }
                            this.scrollBy(dx, dy);
                        }
                        this.mLastScroll = AnimationUtils.currentAnimationTimeMillis();
                    }
                    changed = true;
                }
                if (this.isFocused()) {
                    if (this.mTempRect == null)
                        this.mTempRect = new Rect();
                    this.mTempRect.set(x - 2, top, x + 2, bottom);
                    this.getInterestingRect(this.mTempRect, line);
                    this.mTempRect.offset(this.mScrollX, this.mScrollY);
                }
                return changed;
            }
            moveCursorToVisibleOffset() {
                return false;
            }
            computeScroll() {
                if (this.mScroller != null) {
                    if (this.mScroller.computeScrollOffset()) {
                        this.mScrollX = this.mScroller.getCurrX();
                        this.mScrollY = this.mScroller.getCurrY();
                        this.invalidateParentCaches();
                        this.postInvalidate();
                    }
                }
            }
            getInterestingRect(r, line) {
                this.convertFromViewportToContentCoordinates(r);
                if (line == 0)
                    r.top -= this.getExtendedPaddingTop();
                if (line == this.mLayout.getLineCount() - 1)
                    r.bottom += this.getExtendedPaddingBottom();
            }
            convertFromViewportToContentCoordinates(r) {
                const horizontalOffset = this.viewportToContentHorizontalOffset();
                r.left += horizontalOffset;
                r.right += horizontalOffset;
                const verticalOffset = this.viewportToContentVerticalOffset();
                r.top += verticalOffset;
                r.bottom += verticalOffset;
            }
            viewportToContentHorizontalOffset() {
                return this.getCompoundPaddingLeft() - this.mScrollX;
            }
            viewportToContentVerticalOffset() {
                let offset = this.getExtendedPaddingTop() - this.mScrollY;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                    offset += this.getVerticalOffset(false);
                }
                return offset;
            }
            getSelectionStart() {
                return -1;
            }
            getSelectionEnd() {
                return -1;
            }
            hasSelection() {
                const selectionStart = this.getSelectionStart();
                const selectionEnd = this.getSelectionEnd();
                return selectionStart >= 0 && selectionStart != selectionEnd;
            }
            setAllCaps(allCaps) {
                if (allCaps) {
                    this.setTransformationMethod(new AllCapsTransformationMethod());
                }
                else {
                    this.setTransformationMethod(null);
                }
            }
            setSingleLine(singleLine = true) {
                this.setInputTypeSingleLine(singleLine);
                this.applySingleLine(singleLine, true, true);
            }
            setInputTypeSingleLine(singleLine) {
            }
            applySingleLine(singleLine, applyTransformation, changeMaxLines) {
                this.mSingleLine = singleLine;
                if (singleLine) {
                    this.setLines(1);
                    this.setHorizontallyScrolling(true);
                    if (applyTransformation) {
                        this.setTransformationMethod(SingleLineTransformationMethod.getInstance());
                    }
                }
                else {
                    if (changeMaxLines) {
                        this.setMaxLines(Integer.MAX_VALUE);
                    }
                    this.setHorizontallyScrolling(false);
                    if (applyTransformation) {
                        this.setTransformationMethod(null);
                    }
                }
            }
            setEllipsize(where) {
                if (this.mEllipsize != where) {
                    this.mEllipsize = where;
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            setMarqueeRepeatLimit(marqueeLimit) {
                this.mMarqueeRepeatLimit = marqueeLimit;
            }
            getMarqueeRepeatLimit() {
                return this.mMarqueeRepeatLimit;
            }
            getEllipsize() {
                return this.mEllipsize;
            }
            setSelectAllOnFocus(selectAllOnFocus) {
                this.createEditorIfNeeded();
                this.mEditor.mSelectAllOnFocus = selectAllOnFocus;
                if (selectAllOnFocus && !Spannable.isImpl(this.mText)) {
                    this.setText(this.mText, TextView.BufferType.SPANNABLE);
                }
            }
            setCursorVisible(visible) {
            }
            isCursorVisible() {
                return null;
            }
            canMarquee() {
                let width = (this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight());
                return width > 0 && (this.mLayout.getLineWidth(0) > width || (this.mMarqueeFadeMode != TextView.MARQUEE_FADE_NORMAL && this.mSavedMarqueeModeLayout != null && this.mSavedMarqueeModeLayout.getLineWidth(0) > width));
            }
            startMarquee() {
                if (this.getKeyListener() != null)
                    return;
                if (this.compressText(this.getWidth() - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight())) {
                    return;
                }
                if ((this.mMarquee == null || this.mMarquee.isStopped()) && (this.isFocused() || this.isSelected()) && this.getLineCount() == 1 && this.canMarquee()) {
                    if (this.mMarqueeFadeMode == TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                        this.mMarqueeFadeMode = TextView.MARQUEE_FADE_SWITCH_SHOW_FADE;
                        const tmp = this.mLayout;
                        this.mLayout = this.mSavedMarqueeModeLayout;
                        this.mSavedMarqueeModeLayout = tmp;
                        this.setHorizontalFadingEdgeEnabled(true);
                        this.requestLayout();
                        this.invalidate();
                    }
                    if (this.mMarquee == null)
                        this.mMarquee = new TextView.Marquee(this);
                    this.mMarquee.start(this.mMarqueeRepeatLimit);
                }
            }
            stopMarquee() {
                if (this.mMarquee != null && !this.mMarquee.isStopped()) {
                    this.mMarquee.stop();
                }
                if (this.mMarqueeFadeMode == TextView.MARQUEE_FADE_SWITCH_SHOW_FADE) {
                    this.mMarqueeFadeMode = TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;
                    const tmp = this.mSavedMarqueeModeLayout;
                    this.mSavedMarqueeModeLayout = this.mLayout;
                    this.mLayout = tmp;
                    this.setHorizontalFadingEdgeEnabled(false);
                    this.requestLayout();
                    this.invalidate();
                }
            }
            startStopMarquee(start) {
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE) {
                    if (start) {
                        this.startMarquee();
                    }
                    else {
                        this.stopMarquee();
                    }
                }
            }
            onTextChanged(text, start, lengthBefore, lengthAfter) {
            }
            onSelectionChanged(selStart, selEnd) {
            }
            addTextChangedListener(watcher) {
                if (this.mListeners == null) {
                    this.mListeners = new ArrayList();
                }
                this.mListeners.add(watcher);
            }
            removeTextChangedListener(watcher) {
                if (this.mListeners != null) {
                    let i = this.mListeners.indexOf(watcher);
                    if (i >= 0) {
                        this.mListeners.remove(i);
                    }
                }
            }
            sendBeforeTextChanged(text, start, before, after) {
                if (this.mListeners != null) {
                    const list = this.mListeners;
                    const count = list.size();
                    for (let i = 0; i < count; i++) {
                        list.get(i).beforeTextChanged(text, start, before, after);
                    }
                }
            }
            removeAdjacentSuggestionSpans(pos) {
            }
            sendOnTextChanged(text, start, before, after) {
                if (this.mListeners != null) {
                    const list = this.mListeners;
                    const count = list.size();
                    for (let i = 0; i < count; i++) {
                        list.get(i).onTextChanged(text, start, before, after);
                    }
                }
            }
            sendAfterTextChanged(text) {
                if (this.mListeners != null) {
                    const list = this.mListeners;
                    const count = list.size();
                    for (let i = 0; i < count; i++) {
                        list.get(i).afterTextChanged(text + '');
                    }
                }
            }
            updateAfterEdit() {
                this.invalidate();
                let curs = this.getSelectionStart();
                if (curs >= 0 || (this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
                    this.registerForPreDraw();
                }
                this.checkForResize();
                if (curs >= 0) {
                    this.mHighlightPathBogus = true;
                    this.bringPointIntoView(curs);
                }
            }
            handleTextChanged(buffer, start, before, after) {
                this.updateAfterEdit();
                this.sendOnTextChanged(buffer, start, before, after);
                this.onTextChanged(buffer, start, before, after);
            }
            spanChange(buf, what, oldStart, newStart, oldEnd, newEnd) {
                let selChanged = false;
                let newSelStart = -1, newSelEnd = -1;
                this.invalidate();
                this.mHighlightPathBogus = true;
                this.checkForResize();
            }
            dispatchFinishTemporaryDetach() {
                this.mDispatchTemporaryDetach = true;
                super.dispatchFinishTemporaryDetach();
                this.mDispatchTemporaryDetach = false;
            }
            onStartTemporaryDetach() {
                super.onStartTemporaryDetach();
                if (!this.mDispatchTemporaryDetach)
                    this.mTemporaryDetach = true;
            }
            onFinishTemporaryDetach() {
                super.onFinishTemporaryDetach();
                if (!this.mDispatchTemporaryDetach)
                    this.mTemporaryDetach = false;
            }
            onFocusChanged(focused, direction, previouslyFocusedRect) {
                if (this.mTemporaryDetach) {
                    super.onFocusChanged(focused, direction, previouslyFocusedRect);
                    return;
                }
                this.startStopMarquee(focused);
                if (this.mTransformation != null) {
                    this.mTransformation.onFocusChanged(this, this.mText, focused, direction, previouslyFocusedRect);
                }
                super.onFocusChanged(focused, direction, previouslyFocusedRect);
            }
            onWindowFocusChanged(hasWindowFocus) {
                super.onWindowFocusChanged(hasWindowFocus);
                this.startStopMarquee(hasWindowFocus);
            }
            onVisibilityChanged(changedView, visibility) {
                super.onVisibilityChanged(changedView, visibility);
            }
            clearComposingText() {
            }
            setSelected(selected) {
                let wasSelected = this.isSelected();
                super.setSelected(selected);
                if (selected != wasSelected && this.mEllipsize == TextUtils.TruncateAt.MARQUEE) {
                    if (selected) {
                        this.startMarquee();
                    }
                    else {
                        this.stopMarquee();
                    }
                }
            }
            onTouchEvent(event) {
                const action = event.getActionMasked();
                const superResult = super.onTouchEvent(event);
                const touchIsFinished = (action == MotionEvent.ACTION_UP)
                    && this.isFocused();
                if ((this.mMovement != null || this.onCheckIsTextEditor()) && this.isEnabled() && Spannable.isImpl(this.mText) && this.mLayout != null) {
                    let handled = false;
                    if (this.mMovement != null) {
                        handled = this.mMovement.onTouchEvent(this, this.mText, event) || handled;
                    }
                    if (handled) {
                        return true;
                    }
                }
                return superResult;
            }
            onGenericMotionEvent(event) {
                if (this.mMovement != null && Spannable.isImpl(this.mText) && this.mLayout != null) {
                    try {
                        if (this.mMovement.onGenericMotionEvent(this, this.mText, event)) {
                            return true;
                        }
                    }
                    catch (e) {
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            isTextEditable() {
                return false;
            }
            didTouchFocusSelect() {
                return false;
            }
            cancelLongPress() {
                super.cancelLongPress();
            }
            setScroller(s) {
                this.mScroller = s;
            }
            getLeftFadingEdgeStrength() {
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE && this.mMarqueeFadeMode != TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                    if (this.mMarquee != null && !this.mMarquee.isStopped()) {
                        const marquee = this.mMarquee;
                        if (marquee.shouldDrawLeftFade()) {
                            const scroll = marquee.getScroll();
                            return scroll / this.getHorizontalFadingEdgeLength();
                        }
                        else {
                            return 0.0;
                        }
                    }
                    else if (this.getLineCount() == 1) {
                        const absoluteGravity = this.mGravity;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.LEFT:
                                return 0.0;
                            case Gravity.RIGHT:
                                return (this.mLayout.getLineRight(0) - (this.mRight - this.mLeft) - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight() - this.mLayout.getLineLeft(0)) / this.getHorizontalFadingEdgeLength();
                            case Gravity.CENTER_HORIZONTAL:
                            case Gravity.FILL_HORIZONTAL:
                                const textDirection = this.mLayout.getParagraphDirection(0);
                                if (textDirection == Layout.DIR_LEFT_TO_RIGHT) {
                                    return 0.0;
                                }
                                else {
                                    return (this.mLayout.getLineRight(0) - (this.mRight - this.mLeft) - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight() - this.mLayout.getLineLeft(0)) / this.getHorizontalFadingEdgeLength();
                                }
                        }
                    }
                }
                return super.getLeftFadingEdgeStrength();
            }
            getRightFadingEdgeStrength() {
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE && this.mMarqueeFadeMode != TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                    if (this.mMarquee != null && !this.mMarquee.isStopped()) {
                        const marquee = this.mMarquee;
                        const maxFadeScroll = marquee.getMaxFadeScroll();
                        const scroll = marquee.getScroll();
                        return (maxFadeScroll - scroll) / this.getHorizontalFadingEdgeLength();
                    }
                    else if (this.getLineCount() == 1) {
                        const absoluteGravity = this.mGravity;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.LEFT:
                                const textWidth = (this.mRight - this.mLeft) - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                                const lineWidth = this.mLayout.getLineWidth(0);
                                return (lineWidth - textWidth) / this.getHorizontalFadingEdgeLength();
                            case Gravity.RIGHT:
                                return 0.0;
                            case Gravity.CENTER_HORIZONTAL:
                            case Gravity.FILL_HORIZONTAL:
                                const textDirection = this.mLayout.getParagraphDirection(0);
                                if (textDirection == Layout.DIR_RIGHT_TO_LEFT) {
                                    return 0.0;
                                }
                                else {
                                    return (this.mLayout.getLineWidth(0) - ((this.mRight - this.mLeft) - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight())) / this.getHorizontalFadingEdgeLength();
                                }
                        }
                    }
                }
                return super.getRightFadingEdgeStrength();
            }
            computeHorizontalScrollRange() {
                if (this.mLayout != null) {
                    return this.mSingleLine && (this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.LEFT ? Math.floor(this.mLayout.getLineWidth(0)) : this.mLayout.getWidth();
                }
                return super.computeHorizontalScrollRange();
            }
            computeVerticalScrollRange() {
                if (this.mLayout != null)
                    return this.mLayout.getHeight();
                return super.computeVerticalScrollRange();
            }
            computeVerticalScrollExtent() {
                return this.getHeight() - this.getCompoundPaddingTop() - this.getCompoundPaddingBottom();
            }
            static getTextColors() {
                return android.R.attr.textViewStyle.textColor;
            }
            static getTextColor(def) {
                let colors = this.getTextColors();
                if (colors == null) {
                    return def;
                }
                else {
                    return colors.getDefaultColor();
                }
            }
            canSelectText() {
                return false;
            }
            textCanBeSelected() {
                return false;
            }
            getTransformedText(start, end) {
                return this.removeSuggestionSpans(this.mTransformed.substring(start, end));
            }
            performLongClick() {
                let handled = false;
                if (super.performLongClick()) {
                    handled = true;
                }
                if (handled) {
                    this.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
                }
                return handled;
            }
            isSuggestionsEnabled() {
                return false;
            }
            setCustomSelectionActionModeCallback(actionModeCallback) {
                this.createEditorIfNeeded();
            }
            getCustomSelectionActionModeCallback() {
                return null;
            }
            stopSelectionActionMode() {
            }
            canCut() {
                return false;
            }
            canCopy() {
                return true;
            }
            canPaste() {
                return false;
            }
            selectAllText() {
                return false;
            }
            getOffsetForPosition(x, y) {
                if (this.getLayout() == null)
                    return -1;
                const line = this.getLineAtCoordinate(y);
                const offset = this.getOffsetAtCoordinate(line, x);
                return offset;
            }
            convertToLocalHorizontalCoordinate(x) {
                x -= this.getTotalPaddingLeft();
                x = Math.max(0.0, x);
                x = Math.min(this.getWidth() - this.getTotalPaddingRight() - 1, x);
                x += this.getScrollX();
                return x;
            }
            getLineAtCoordinate(y) {
                y -= this.getTotalPaddingTop();
                y = Math.max(0.0, y);
                y = Math.min(this.getHeight() - this.getTotalPaddingBottom() - 1, y);
                y += this.getScrollY();
                return this.getLayout().getLineForVertical(Math.floor(y));
            }
            getOffsetAtCoordinate(line, x) {
                x = this.convertToLocalHorizontalCoordinate(x);
                return this.getLayout().getOffsetForHorizontal(line, x);
            }
            isInBatchEditMode() {
                return false;
            }
            getTextDirectionHeuristic() {
                return TextDirectionHeuristics.LTR;
            }
            onResolveDrawables(layoutDirection) {
                if (this.mLastLayoutDirection == layoutDirection) {
                    return;
                }
                this.mLastLayoutDirection = layoutDirection;
                if (this.mDrawables != null) {
                    this.mDrawables.resolveWithLayoutDirection(layoutDirection);
                }
            }
            resetResolvedDrawables() {
                this.mLastLayoutDirection = -1;
            }
            deleteText_internal(start, end) {
            }
            replaceText_internal(start, end, text) {
            }
            setSpan_internal(span, start, end, flags) {
            }
            setCursorPosition_internal(start, end) {
            }
            createEditorIfNeeded() {
            }
        }
        TextView.LOG_TAG = "TextView";
        TextView.DEBUG_EXTRACT = false;
        TextView.SANS = 1;
        TextView.SERIF = 2;
        TextView.MONOSPACE = 3;
        TextView.SIGNED = 2;
        TextView.DECIMAL = 4;
        TextView.MARQUEE_FADE_NORMAL = 0;
        TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS = 1;
        TextView.MARQUEE_FADE_SWITCH_SHOW_FADE = 2;
        TextView.LINES = 1;
        TextView.EMS = TextView.LINES;
        TextView.PIXELS = 2;
        TextView.TEMP_RECTF = new RectF();
        TextView.VERY_WIDE = 1024 * 1024;
        TextView.ANIMATED_SCROLL_GAP = 250;
        TextView.NO_FILTERS = new Array(0);
        TextView.CHANGE_WATCHER_PRIORITY = 100;
        TextView.MULTILINE_STATE_SET = [View.VIEW_STATE_MULTILINE];
        TextView.LAST_CUT_OR_COPY_TIME = 0;
        TextView.UNKNOWN_BORING = new BoringLayout.Metrics();
        widget.TextView = TextView;
        (function (TextView) {
            class Drawables {
                constructor(context) {
                    this.mCompoundRect = new Rect();
                    this.mDrawableSizeTop = 0;
                    this.mDrawableSizeBottom = 0;
                    this.mDrawableSizeLeft = 0;
                    this.mDrawableSizeRight = 0;
                    this.mDrawableSizeStart = 0;
                    this.mDrawableSizeEnd = 0;
                    this.mDrawableSizeError = 0;
                    this.mDrawableSizeTemp = 0;
                    this.mDrawableWidthTop = 0;
                    this.mDrawableWidthBottom = 0;
                    this.mDrawableHeightLeft = 0;
                    this.mDrawableHeightRight = 0;
                    this.mDrawableHeightStart = 0;
                    this.mDrawableHeightEnd = 0;
                    this.mDrawableHeightError = 0;
                    this.mDrawableHeightTemp = 0;
                    this.mDrawablePadding = 0;
                    this.mDrawableSaved = Drawables.DRAWABLE_NONE;
                    this.mIsRtlCompatibilityMode = false;
                    this.mOverride = false;
                }
                resolveWithLayoutDirection(layoutDirection) {
                    this.mDrawableLeft = this.mDrawableLeftInitial;
                    this.mDrawableRight = this.mDrawableRightInitial;
                    if (this.mOverride) {
                        this.mDrawableLeft = this.mDrawableStart;
                        this.mDrawableSizeLeft = this.mDrawableSizeStart;
                        this.mDrawableHeightLeft = this.mDrawableHeightStart;
                        this.mDrawableRight = this.mDrawableEnd;
                        this.mDrawableSizeRight = this.mDrawableSizeEnd;
                        this.mDrawableHeightRight = this.mDrawableHeightEnd;
                    }
                    this.applyErrorDrawableIfNeeded(layoutDirection);
                    this.updateDrawablesLayoutDirection(layoutDirection);
                }
                updateDrawablesLayoutDirection(layoutDirection) {
                }
                setErrorDrawable(dr, tv) {
                    if (this.mDrawableError != dr && this.mDrawableError != null) {
                        this.mDrawableError.setCallback(null);
                    }
                    this.mDrawableError = dr;
                    const compoundRect = this.mCompoundRect;
                    let state = tv.getDrawableState();
                    if (this.mDrawableError != null) {
                        this.mDrawableError.setState(state);
                        this.mDrawableError.copyBounds(compoundRect);
                        this.mDrawableError.setCallback(tv);
                        this.mDrawableSizeError = compoundRect.width();
                        this.mDrawableHeightError = compoundRect.height();
                    }
                    else {
                        this.mDrawableSizeError = this.mDrawableHeightError = 0;
                    }
                }
                applyErrorDrawableIfNeeded(layoutDirection) {
                    switch (this.mDrawableSaved) {
                        case Drawables.DRAWABLE_LEFT:
                            this.mDrawableLeft = this.mDrawableTemp;
                            this.mDrawableSizeLeft = this.mDrawableSizeTemp;
                            this.mDrawableHeightLeft = this.mDrawableHeightTemp;
                            break;
                        case Drawables.DRAWABLE_RIGHT:
                            this.mDrawableRight = this.mDrawableTemp;
                            this.mDrawableSizeRight = this.mDrawableSizeTemp;
                            this.mDrawableHeightRight = this.mDrawableHeightTemp;
                            break;
                        case Drawables.DRAWABLE_NONE:
                        default:
                    }
                    this.mDrawableSaved = Drawables.DRAWABLE_RIGHT;
                    this.mDrawableTemp = this.mDrawableRight;
                    this.mDrawableSizeTemp = this.mDrawableSizeRight;
                    this.mDrawableHeightTemp = this.mDrawableHeightRight;
                    this.mDrawableRight = this.mDrawableError;
                    this.mDrawableSizeRight = this.mDrawableSizeError;
                    this.mDrawableHeightRight = this.mDrawableHeightError;
                }
            }
            Drawables.DRAWABLE_NONE = -1;
            Drawables.DRAWABLE_RIGHT = 0;
            Drawables.DRAWABLE_LEFT = 1;
            TextView.Drawables = Drawables;
            class Marquee extends Handler {
                constructor(v) {
                    super();
                    this.mStatus = Marquee.MARQUEE_STOPPED;
                    this.mScrollUnit = 0;
                    this.mMaxScroll = 0;
                    this.mMaxFadeScroll = 0;
                    this.mGhostStart = 0;
                    this.mGhostOffset = 0;
                    this.mFadeStop = 0;
                    this.mRepeatLimit = 0;
                    this.mScroll = 0;
                    const density = v.getResources().getDisplayMetrics().density;
                    this.mScrollUnit = (Marquee.MARQUEE_PIXELS_PER_SECOND * density) / Marquee.MARQUEE_RESOLUTION;
                    this.mView = new WeakReference(v);
                }
                handleMessage(msg) {
                    switch (msg.what) {
                        case Marquee.MESSAGE_START:
                            this.mStatus = Marquee.MARQUEE_RUNNING;
                            this.tick();
                            break;
                        case Marquee.MESSAGE_TICK:
                            this.tick();
                            break;
                        case Marquee.MESSAGE_RESTART:
                            if (this.mStatus == Marquee.MARQUEE_RUNNING) {
                                if (this.mRepeatLimit >= 0) {
                                    this.mRepeatLimit--;
                                }
                                this.start(this.mRepeatLimit);
                            }
                            break;
                    }
                }
                tick() {
                    if (this.mStatus != Marquee.MARQUEE_RUNNING) {
                        return;
                    }
                    this.removeMessages(Marquee.MESSAGE_TICK);
                    const textView = this.mView.get();
                    if (textView != null && (textView.isFocused() || textView.isSelected())) {
                        this.mScroll += this.mScrollUnit;
                        if (this.mScroll > this.mMaxScroll) {
                            this.mScroll = this.mMaxScroll;
                            this.sendEmptyMessageDelayed(Marquee.MESSAGE_RESTART, Marquee.MARQUEE_RESTART_DELAY);
                        }
                        else {
                            this.sendEmptyMessageDelayed(Marquee.MESSAGE_TICK, Marquee.MARQUEE_RESOLUTION);
                        }
                        textView.invalidate();
                    }
                }
                stop() {
                    this.mStatus = Marquee.MARQUEE_STOPPED;
                    this.removeMessages(Marquee.MESSAGE_START);
                    this.removeMessages(Marquee.MESSAGE_RESTART);
                    this.removeMessages(Marquee.MESSAGE_TICK);
                    this.resetScroll();
                }
                resetScroll() {
                    this.mScroll = 0.0;
                    const textView = this.mView.get();
                    if (textView != null)
                        textView.invalidate();
                }
                start(repeatLimit) {
                    if (repeatLimit == 0) {
                        this.stop();
                        return;
                    }
                    this.mRepeatLimit = repeatLimit;
                    const textView = this.mView.get();
                    if (textView != null && textView.mLayout != null) {
                        this.mStatus = Marquee.MARQUEE_STARTING;
                        this.mScroll = 0.0;
                        const textWidth = textView.getWidth() - textView.getCompoundPaddingLeft() - textView.getCompoundPaddingRight();
                        const lineWidth = textView.mLayout.getLineWidth(0);
                        const gap = textWidth / 3.0;
                        this.mGhostStart = lineWidth - textWidth + gap;
                        this.mMaxScroll = this.mGhostStart + textWidth;
                        this.mGhostOffset = lineWidth + gap;
                        this.mFadeStop = lineWidth + textWidth / 6.0;
                        this.mMaxFadeScroll = this.mGhostStart + lineWidth + lineWidth;
                        textView.invalidate();
                        this.sendEmptyMessageDelayed(Marquee.MESSAGE_START, Marquee.MARQUEE_DELAY);
                    }
                }
                getGhostOffset() {
                    return this.mGhostOffset;
                }
                getScroll() {
                    return this.mScroll;
                }
                getMaxFadeScroll() {
                    return this.mMaxFadeScroll;
                }
                shouldDrawLeftFade() {
                    return this.mScroll <= this.mFadeStop;
                }
                shouldDrawGhost() {
                    return this.mStatus == Marquee.MARQUEE_RUNNING && this.mScroll > this.mGhostStart;
                }
                isRunning() {
                    return this.mStatus == Marquee.MARQUEE_RUNNING;
                }
                isStopped() {
                    return this.mStatus == Marquee.MARQUEE_STOPPED;
                }
            }
            Marquee.MARQUEE_DELTA_MAX = 0.07;
            Marquee.MARQUEE_DELAY = 1200;
            Marquee.MARQUEE_RESTART_DELAY = 1200;
            Marquee.MARQUEE_RESOLUTION = 1000 / 30;
            Marquee.MARQUEE_PIXELS_PER_SECOND = 30;
            Marquee.MARQUEE_STOPPED = 0x0;
            Marquee.MARQUEE_STARTING = 0x1;
            Marquee.MARQUEE_RUNNING = 0x2;
            Marquee.MESSAGE_START = 0x1;
            Marquee.MESSAGE_TICK = 0x2;
            Marquee.MESSAGE_RESTART = 0x3;
            TextView.Marquee = Marquee;
            class ChangeWatcher {
                constructor(arg) {
                    this._TextView_this = arg;
                }
                beforeTextChanged(buffer, start, before, after) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "beforeTextChanged start=" + start + " before=" + before + " after=" + after + ": " + buffer);
                    this._TextView_this.sendBeforeTextChanged(buffer, start, before, after);
                }
                onTextChanged(buffer, start, before, after) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "onTextChanged start=" + start + " before=" + before + " after=" + after + ": " + buffer);
                    this._TextView_this.handleTextChanged(buffer, start, before, after);
                }
                afterTextChanged(buffer) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "afterTextChanged: " + buffer);
                    this._TextView_this.sendAfterTextChanged(buffer);
                }
                onSpanChanged(buf, what, s, e, st, en) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "onSpanChanged s=" + s + " e=" + e + " st=" + st + " en=" + en + " what=" + what + ": " + buf);
                    this._TextView_this.spanChange(buf, what, s, st, e, en);
                }
                onSpanAdded(buf, what, s, e) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "onSpanAdded s=" + s + " e=" + e + " what=" + what + ": " + buf);
                    this._TextView_this.spanChange(buf, what, -1, s, -1, e);
                }
                onSpanRemoved(buf, what, s, e) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "onSpanRemoved s=" + s + " e=" + e + " what=" + what + ": " + buf);
                    this._TextView_this.spanChange(buf, what, s, -1, e, -1);
                }
            }
            TextView.ChangeWatcher = ChangeWatcher;
            (function (BufferType) {
                BufferType[BufferType["NORMAL"] = 0] = "NORMAL";
                BufferType[BufferType["SPANNABLE"] = 1] = "SPANNABLE";
                BufferType[BufferType["EDITABLE"] = 2] = "EDITABLE";
            })(TextView.BufferType || (TextView.BufferType = {}));
            var BufferType = TextView.BufferType;
        })(TextView = widget.TextView || (widget.TextView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="TextView.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        class Button extends widget.TextView {
            constructor(context, bindElement, defStyle = android.R.attr.buttonStyle) {
                super(context, bindElement, defStyle);
            }
        }
        widget.Button = Button;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/Adapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ListAdapter;
        (function (ListAdapter) {
            function isImpl(obj) {
                return obj && obj['areAllItemsEnabled'] && obj['isEnabled'];
            }
            ListAdapter.isImpl = isImpl;
        })(ListAdapter = widget.ListAdapter || (widget.ListAdapter = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/text/InputType.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/util/LongSparseArray.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/util/SparseBooleanArray.ts"/>
///<reference path="../../android/util/StateSet.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/HapticFeedbackConstants.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/ViewTreeObserver.ts"/>
///<reference path="../../android/view/animation/Interpolator.ts"/>
///<reference path="../../android/view/animation/LinearInterpolator.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/R/drawable.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var Log = android.util.Log;
        var LongSparseArray = android.util.LongSparseArray;
        var SparseArray = android.util.SparseArray;
        var SparseBooleanArray = android.util.SparseBooleanArray;
        var StateSet = android.util.StateSet;
        var HapticFeedbackConstants = android.view.HapticFeedbackConstants;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var View = android.view.View;
        var ViewConfiguration = android.view.ViewConfiguration;
        var ViewGroup = android.view.ViewGroup;
        var LinearInterpolator = android.view.animation.LinearInterpolator;
        var ArrayList = java.util.ArrayList;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        var AdapterView = android.widget.AdapterView;
        var OverScroller = android.widget.OverScroller;
        class AbsListView extends AdapterView {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mChoiceMode = AbsListView.CHOICE_MODE_NONE;
                this.mCheckedItemCount = 0;
                this.mDeferNotifyDataSetChanged = false;
                this.mDrawSelectorOnTop = false;
                this.mSelectorPosition = AbsListView.INVALID_POSITION;
                this.mSelectorRect = new Rect();
                this.mRecycler = new AbsListView.RecycleBin(this);
                this.mSelectionLeftPadding = 0;
                this.mSelectionTopPadding = 0;
                this.mSelectionRightPadding = 0;
                this.mSelectionBottomPadding = 0;
                this.mListPadding = new Rect();
                this.mWidthMeasureSpec = 0;
                this.mMotionPosition = 0;
                this.mMotionViewOriginalTop = 0;
                this.mMotionViewNewTop = 0;
                this.mMotionX = 0;
                this.mMotionY = 0;
                this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                this.mLastY = 0;
                this.mMotionCorrection = 0;
                this.mSelectedTop = 0;
                this.mSmoothScrollbarEnabled = true;
                this.mResurrectToPosition = AbsListView.INVALID_POSITION;
                this.mOverscrollMax = 0;
                this.mLastTouchMode = AbsListView.TOUCH_MODE_UNKNOWN;
                this.mScrollProfilingStarted = false;
                this.mFlingProfilingStarted = false;
                this.mTranscriptMode = 0;
                this.mCacheColorHint = 0;
                this.mLastScrollState = AbsListView.OnScrollListener.SCROLL_STATE_IDLE;
                this.mDensityScale = 0;
                this.mMinimumVelocity = 0;
                this.mMaximumVelocity = 0;
                this.mVelocityScale = 1.0;
                this.mIsScrap = new Array(1);
                this.mActivePointerId = AbsListView.INVALID_POINTER;
                this.mOverscrollDistance = 0;
                this._mOverflingDistance = 0;
                this.mFirstPositionDistanceGuess = 0;
                this.mLastPositionDistanceGuess = 0;
                this.mDirection = 0;
                this.mGlowPaddingLeft = 0;
                this.mGlowPaddingRight = 0;
                this.mLastHandledItemCount = 0;
                this.initAbsListView();
                this.setVerticalScrollBarEnabled(true);
                this.initializeScrollbars();
                this._attrBinder.addAttr('listSelector', (value) => {
                    let d = this._attrBinder.parseDrawable(value);
                    if (d)
                        this.setSelector(d);
                });
                this._attrBinder.addAttr('drawSelectorOnTop', (value) => {
                    this.mDrawSelectorOnTop = this._attrBinder.parseBoolean(value, false);
                });
                this._attrBinder.addAttr('stackFromBottom', (value) => {
                    this.setStackFromBottom(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('scrollingCache', (value) => {
                    this.setScrollingCacheEnabled(this._attrBinder.parseBoolean(value, true));
                });
                this._attrBinder.addAttr('transcriptMode', (value) => {
                    let transcriptMode = this._attrBinder.parseNumber(value, AbsListView.TRANSCRIPT_MODE_DISABLED);
                    this.setTranscriptMode(transcriptMode);
                });
                this._attrBinder.addAttr('cacheColorHint', (value) => {
                    let color = this._attrBinder.parseColor(value, 0);
                    this.setCacheColorHint(color);
                });
                this._attrBinder.addAttr('fastScrollEnabled', (value) => {
                    let enableFastScroll = this._attrBinder.parseBoolean(value, false);
                    this.setFastScrollEnabled(enableFastScroll);
                });
                this._attrBinder.addAttr('fastScrollAlwaysVisible', (value) => {
                    let fastScrollAlwaysVisible = this._attrBinder.parseBoolean(value, false);
                    this.setFastScrollAlwaysVisible(fastScrollAlwaysVisible);
                });
                this._attrBinder.addAttr('smoothScrollbar', (value) => {
                    let smoothScrollbar = this._attrBinder.parseBoolean(value, true);
                    this.setSmoothScrollbarEnabled(smoothScrollbar);
                });
                this._attrBinder.addAttr('choiceMode', (value) => {
                    this.setChoiceMode(this._attrBinder.parseNumber(value, AbsListView.CHOICE_MODE_NONE));
                });
            }
            get mOverflingDistance() {
                if (this.mScrollY <= 0) {
                    if (this.mScrollY < -this._mOverflingDistance)
                        return -this.mScrollY;
                    return this._mOverflingDistance;
                }
                let overDistance = this.mScrollY;
                if (overDistance > this._mOverflingDistance)
                    return overDistance;
                return this._mOverflingDistance;
            }
            set mOverflingDistance(value) {
                this._mOverflingDistance = value;
            }
            initAbsListView() {
                this.setClickable(true);
                this.setFocusableInTouchMode(true);
                this.setWillNotDraw(false);
                this.setAlwaysDrawnWithCacheEnabled(false);
                this.setScrollingCacheEnabled(true);
                const configuration = ViewConfiguration.get();
                this.mTouchSlop = configuration.getScaledTouchSlop();
                this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mOverscrollDistance = configuration.getScaledOverscrollDistance();
                this.mOverflingDistance = configuration.getScaledOverflingDistance();
                this.mDensityScale = android.content.res.Resources.getDisplayMetrics().density;
                this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
            }
            setOverScrollMode(mode) {
                if (mode != AbsListView.OVER_SCROLL_NEVER) {
                }
                else {
                }
                super.setOverScrollMode(mode);
            }
            setAdapter(adapter) {
                if (adapter != null) {
                    this.mAdapterHasStableIds = this.mAdapter.hasStableIds();
                    if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE && this.mAdapterHasStableIds && this.mCheckedIdStates == null) {
                        this.mCheckedIdStates = new LongSparseArray();
                    }
                }
                if (this.mCheckStates != null) {
                    this.mCheckStates.clear();
                }
                if (this.mCheckedIdStates != null) {
                    this.mCheckedIdStates.clear();
                }
            }
            getCheckedItemCount() {
                return this.mCheckedItemCount;
            }
            isItemChecked(position) {
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE && this.mCheckStates != null) {
                    return this.mCheckStates.get(position);
                }
                return false;
            }
            getCheckedItemPosition() {
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_SINGLE && this.mCheckStates != null && this.mCheckStates.size() == 1) {
                    return this.mCheckStates.keyAt(0);
                }
                return AbsListView.INVALID_POSITION;
            }
            getCheckedItemPositions() {
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE) {
                    return this.mCheckStates;
                }
                return null;
            }
            getCheckedItemIds() {
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_NONE || this.mCheckedIdStates == null || this.mAdapter == null) {
                    return [0];
                }
                const idStates = this.mCheckedIdStates;
                const count = idStates.size();
                const ids = [count];
                for (let i = 0; i < count; i++) {
                    ids[i] = idStates.keyAt(i);
                }
                return ids;
            }
            clearChoices() {
                if (this.mCheckStates != null) {
                    this.mCheckStates.clear();
                }
                if (this.mCheckedIdStates != null) {
                    this.mCheckedIdStates.clear();
                }
                this.mCheckedItemCount = 0;
            }
            setItemChecked(position, value) {
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_NONE) {
                    return;
                }
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE || this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE_MODAL) {
                    let oldValue = this.mCheckStates.get(position);
                    this.mCheckStates.put(position, value);
                    if (this.mCheckedIdStates != null && this.mAdapter.hasStableIds()) {
                        if (value) {
                            this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                        }
                        else {
                            this.mCheckedIdStates.delete(this.mAdapter.getItemId(position));
                        }
                    }
                    if (oldValue != value) {
                        if (value) {
                            this.mCheckedItemCount++;
                        }
                        else {
                            this.mCheckedItemCount--;
                        }
                    }
                }
                else {
                    let updateIds = this.mCheckedIdStates != null && this.mAdapter.hasStableIds();
                    if (value || this.isItemChecked(position)) {
                        this.mCheckStates.clear();
                        if (updateIds) {
                            this.mCheckedIdStates.clear();
                        }
                    }
                    if (value) {
                        this.mCheckStates.put(position, true);
                        if (updateIds) {
                            this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                        }
                        this.mCheckedItemCount = 1;
                    }
                    else if (this.mCheckStates.size() == 0 || !this.mCheckStates.valueAt(0)) {
                        this.mCheckedItemCount = 0;
                    }
                }
                if (!this.mInLayout && !this.mBlockLayoutRequests) {
                    this.mDataChanged = true;
                    this.rememberSyncState();
                    this.requestLayout();
                }
            }
            performItemClick(view, position, id) {
                let handled = false;
                let dispatchItemClick = true;
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE) {
                    handled = true;
                    let checkedStateChanged = false;
                    if (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE || (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE_MODAL && this.mChoiceActionMode != null)) {
                        let checked = !this.mCheckStates.get(position, false);
                        this.mCheckStates.put(position, checked);
                        if (this.mCheckedIdStates != null && this.mAdapter.hasStableIds()) {
                            if (checked) {
                                this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                            }
                            else {
                                this.mCheckedIdStates.delete(this.mAdapter.getItemId(position));
                            }
                        }
                        if (checked) {
                            this.mCheckedItemCount++;
                        }
                        else {
                            this.mCheckedItemCount--;
                        }
                        checkedStateChanged = true;
                    }
                    else if (this.mChoiceMode == AbsListView.CHOICE_MODE_SINGLE) {
                        let checked = !this.mCheckStates.get(position, false);
                        if (checked) {
                            this.mCheckStates.clear();
                            this.mCheckStates.put(position, true);
                            if (this.mCheckedIdStates != null && this.mAdapter.hasStableIds()) {
                                this.mCheckedIdStates.clear();
                                this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                            }
                            this.mCheckedItemCount = 1;
                        }
                        else if (this.mCheckStates.size() == 0 || !this.mCheckStates.valueAt(0)) {
                            this.mCheckedItemCount = 0;
                        }
                        checkedStateChanged = true;
                    }
                    if (checkedStateChanged) {
                        this.updateOnScreenCheckedViews();
                    }
                }
                if (dispatchItemClick) {
                    handled = super.performItemClick(view, position, id) || handled;
                }
                return handled;
            }
            updateOnScreenCheckedViews() {
                const firstPos = this.mFirstPosition;
                const count = this.getChildCount();
                const useActivated = true;
                for (let i = 0; i < count; i++) {
                    const child = this.getChildAt(i);
                    const position = firstPos + i;
                    if (child['setChecked']) {
                        child.setChecked(this.mCheckStates.get(position));
                    }
                    else if (useActivated) {
                        child.setActivated(this.mCheckStates.get(position));
                    }
                }
            }
            getChoiceMode() {
                return this.mChoiceMode;
            }
            setChoiceMode(choiceMode) {
                this.mChoiceMode = choiceMode;
                if (this.mChoiceActionMode != null) {
                    this.mChoiceActionMode.finish();
                    this.mChoiceActionMode = null;
                }
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE) {
                    if (this.mCheckStates == null) {
                        this.mCheckStates = new SparseBooleanArray(0);
                    }
                    if (this.mCheckedIdStates == null && this.mAdapter != null && this.mAdapter.hasStableIds()) {
                        this.mCheckedIdStates = new LongSparseArray(0);
                    }
                    if (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE_MODAL) {
                        this.clearChoices();
                        this.setLongClickable(true);
                    }
                }
            }
            contentFits() {
                const childCount = this.getChildCount();
                if (childCount == 0)
                    return true;
                if (childCount != this.mItemCount)
                    return false;
                return this.getChildAt(0).getTop() >= this.mListPadding.top && this.getChildAt(childCount - 1).getBottom() <= this.getHeight() - this.mListPadding.bottom;
            }
            setFastScrollEnabled(enabled) {
                if (this.mFastScrollEnabled != enabled) {
                    this.mFastScrollEnabled = enabled;
                    this.setFastScrollerEnabledUiThread(enabled);
                }
            }
            setFastScrollerEnabledUiThread(enabled) {
            }
            setFastScrollAlwaysVisible(alwaysShow) {
                if (this.mFastScrollAlwaysVisible != alwaysShow) {
                    if (alwaysShow && !this.mFastScrollEnabled) {
                        this.setFastScrollEnabled(true);
                    }
                    this.mFastScrollAlwaysVisible = alwaysShow;
                    this.setFastScrollerAlwaysVisibleUiThread(alwaysShow);
                }
            }
            setFastScrollerAlwaysVisibleUiThread(alwaysShow) {
            }
            isOwnerThread() {
                return true;
            }
            isFastScrollAlwaysVisible() {
                return false;
            }
            getVerticalScrollbarWidth() {
                return super.getVerticalScrollbarWidth();
            }
            isFastScrollEnabled() {
                return false;
            }
            setVerticalScrollbarPosition(position) {
                super.setVerticalScrollbarPosition(position);
            }
            setScrollBarStyle(style) {
                super.setScrollBarStyle(style);
            }
            isVerticalScrollBarHidden() {
                return this.isFastScrollEnabled();
            }
            setSmoothScrollbarEnabled(enabled) {
                this.mSmoothScrollbarEnabled = enabled;
            }
            isSmoothScrollbarEnabled() {
                return this.mSmoothScrollbarEnabled;
            }
            setOnScrollListener(l) {
                this.mOnScrollListener = l;
                this.invokeOnItemScrollListener();
            }
            invokeOnItemScrollListener() {
                if (this.mOnScrollListener != null) {
                    this.mOnScrollListener.onScroll(this, this.mFirstPosition, this.getChildCount(), this.mItemCount);
                }
                this.onScrollChanged(0, 0, 0, 0);
            }
            isScrollingCacheEnabled() {
                return this.mScrollingCacheEnabled;
            }
            setScrollingCacheEnabled(enabled) {
                if (this.mScrollingCacheEnabled && !enabled) {
                    this.clearScrollingCache();
                }
                this.mScrollingCacheEnabled = enabled;
            }
            setTextFilterEnabled(textFilterEnabled) {
                this.mTextFilterEnabled = textFilterEnabled;
            }
            isTextFilterEnabled() {
                return this.mTextFilterEnabled;
            }
            getFocusedRect(r) {
                let view = this.getSelectedView();
                if (view != null && view.getParent() == this) {
                    view.getFocusedRect(r);
                    this.offsetDescendantRectToMyCoords(view, r);
                }
                else {
                    super.getFocusedRect(r);
                }
            }
            useDefaultSelector() {
                this.setSelector(android.R.drawable.list_selector_background);
            }
            isStackFromBottom() {
                return this.mStackFromBottom;
            }
            setStackFromBottom(stackFromBottom) {
                if (this.mStackFromBottom != stackFromBottom) {
                    this.mStackFromBottom = stackFromBottom;
                    this.requestLayoutIfNecessary();
                }
            }
            requestLayoutIfNecessary() {
                if (this.getChildCount() > 0) {
                    this.resetList();
                    this.requestLayout();
                    this.invalidate();
                }
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
                if (gainFocus && this.mSelectedPosition < 0 && !this.isInTouchMode()) {
                    if (!this.isAttachedToWindow() && this.mAdapter != null) {
                        this.mDataChanged = true;
                        this.mOldItemCount = this.mItemCount;
                        this.mItemCount = this.mAdapter.getCount();
                    }
                    this.resurrectSelection();
                }
            }
            requestLayout() {
                if (!this.mBlockLayoutRequests && !this.mInLayout) {
                    super.requestLayout();
                }
            }
            resetList() {
                this.removeAllViewsInLayout();
                this.mFirstPosition = 0;
                this.mDataChanged = false;
                this.mPositionScrollAfterLayout = null;
                this.mNeedSync = false;
                this.mPendingSync = null;
                this.mOldSelectedPosition = AbsListView.INVALID_POSITION;
                this.mOldSelectedRowId = AbsListView.INVALID_ROW_ID;
                this.setSelectedPositionInt(AbsListView.INVALID_POSITION);
                this.setNextSelectedPositionInt(AbsListView.INVALID_POSITION);
                this.mSelectedTop = 0;
                this.mSelectorPosition = AbsListView.INVALID_POSITION;
                this.mSelectorRect.setEmpty();
                this.invalidate();
            }
            computeVerticalScrollExtent() {
                const count = this.getChildCount();
                if (count > 0) {
                    if (this.mSmoothScrollbarEnabled) {
                        let extent = count * 100;
                        let view = this.getChildAt(0);
                        const top = view.getTop();
                        let height = view.getHeight();
                        if (height > 0) {
                            extent += (top * 100) / height;
                        }
                        view = this.getChildAt(count - 1);
                        const bottom = view.getBottom();
                        height = view.getHeight();
                        if (height > 0) {
                            extent -= ((bottom - this.getHeight()) * 100) / height;
                        }
                        return extent;
                    }
                    else {
                        return 1;
                    }
                }
                return 0;
            }
            computeVerticalScrollOffset() {
                const firstPosition = this.mFirstPosition;
                const childCount = this.getChildCount();
                if (firstPosition >= 0 && childCount > 0) {
                    if (this.mSmoothScrollbarEnabled) {
                        const view = this.getChildAt(0);
                        const top = view.getTop();
                        let height = view.getHeight();
                        if (height > 0) {
                            return Math.max(firstPosition * 100 - (top * 100) / height + Math.floor((this.mScrollY / this.getHeight() * this.mItemCount * 100)), 0);
                        }
                    }
                    else {
                        let index;
                        const count = this.mItemCount;
                        if (firstPosition == 0) {
                            index = 0;
                        }
                        else if (firstPosition + childCount == count) {
                            index = count;
                        }
                        else {
                            index = firstPosition + childCount / 2;
                        }
                        return Math.floor((firstPosition + childCount * (index / count)));
                    }
                }
                return 0;
            }
            computeVerticalScrollRange() {
                let result;
                if (this.mSmoothScrollbarEnabled) {
                    result = Math.max(this.mItemCount * 100, 0);
                    if (this.mScrollY != 0) {
                        result += Math.abs(Math.floor((this.mScrollY / this.getHeight() * this.mItemCount * 100)));
                    }
                }
                else {
                    result = this.mItemCount;
                }
                return result;
            }
            getTopFadingEdgeStrength() {
                const count = this.getChildCount();
                const fadeEdge = super.getTopFadingEdgeStrength();
                if (count == 0) {
                    return fadeEdge;
                }
                else {
                    if (this.mFirstPosition > 0) {
                        return 1.0;
                    }
                    const top = this.getChildAt(0).getTop();
                    const fadeLength = this.getVerticalFadingEdgeLength();
                    return top < this.mPaddingTop ? -(top - this.mPaddingTop) / fadeLength : fadeEdge;
                }
            }
            getBottomFadingEdgeStrength() {
                const count = this.getChildCount();
                const fadeEdge = super.getBottomFadingEdgeStrength();
                if (count == 0) {
                    return fadeEdge;
                }
                else {
                    if (this.mFirstPosition + count - 1 < this.mItemCount - 1) {
                        return 1.0;
                    }
                    const bottom = this.getChildAt(count - 1).getBottom();
                    const height = this.getHeight();
                    const fadeLength = this.getVerticalFadingEdgeLength();
                    return bottom > height - this.mPaddingBottom ? (bottom - height + this.mPaddingBottom) / fadeLength : fadeEdge;
                }
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                if (this.mSelector == null) {
                    this.useDefaultSelector();
                }
                const listPadding = this.mListPadding;
                listPadding.left = this.mSelectionLeftPadding + this.mPaddingLeft;
                listPadding.top = this.mSelectionTopPadding + this.mPaddingTop;
                listPadding.right = this.mSelectionRightPadding + this.mPaddingRight;
                listPadding.bottom = this.mSelectionBottomPadding + this.mPaddingBottom;
                if (this.mTranscriptMode == AbsListView.TRANSCRIPT_MODE_NORMAL) {
                    const childCount = this.getChildCount();
                    const listBottom = this.getHeight() - this.getPaddingBottom();
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                    this.mForceTranscriptScroll = this.mFirstPosition + childCount >= this.mLastHandledItemCount && lastBottom <= listBottom;
                }
            }
            onLayout(changed, l, t, r, b) {
                super.onLayout(changed, l, t, r, b);
                this.mInLayout = true;
                if (changed) {
                    let childCount = this.getChildCount();
                    for (let i = 0; i < childCount; i++) {
                        this.getChildAt(i).forceLayout();
                    }
                    this.mRecycler.markChildrenDirty();
                }
                this.layoutChildren();
                this.mInLayout = false;
                this.mOverscrollMax = (b - t) / AbsListView.OVERSCROLL_LIMIT_DIVISOR;
            }
            setFrame(left, top, right, bottom) {
                const changed = super.setFrame(left, top, right, bottom);
                if (changed) {
                    const visible = this.getWindowVisibility() == View.VISIBLE;
                }
                return changed;
            }
            layoutChildren() {
            }
            updateScrollIndicators() {
                if (this.mScrollUp != null) {
                    let canScrollUp;
                    canScrollUp = this.mFirstPosition > 0;
                    if (!canScrollUp) {
                        if (this.getChildCount() > 0) {
                            let child = this.getChildAt(0);
                            canScrollUp = child.getTop() < this.mListPadding.top;
                        }
                    }
                    this.mScrollUp.setVisibility(canScrollUp ? View.VISIBLE : View.INVISIBLE);
                }
                if (this.mScrollDown != null) {
                    let canScrollDown;
                    let count = this.getChildCount();
                    canScrollDown = (this.mFirstPosition + count) < this.mItemCount;
                    if (!canScrollDown && count > 0) {
                        let child = this.getChildAt(count - 1);
                        canScrollDown = child.getBottom() > this.mBottom - this.mListPadding.bottom;
                    }
                    this.mScrollDown.setVisibility(canScrollDown ? View.VISIBLE : View.INVISIBLE);
                }
            }
            getSelectedView() {
                if (this.mItemCount > 0 && this.mSelectedPosition >= 0) {
                    return this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                }
                else {
                    return null;
                }
            }
            getListPaddingTop() {
                return this.mListPadding.top;
            }
            getListPaddingBottom() {
                return this.mListPadding.bottom;
            }
            getListPaddingLeft() {
                return this.mListPadding.left;
            }
            getListPaddingRight() {
                return this.mListPadding.right;
            }
            obtainView(position, isScrap) {
                isScrap[0] = false;
                let scrapView;
                scrapView = this.mRecycler.getTransientStateView(position);
                if (scrapView == null) {
                    scrapView = this.mRecycler.getScrapView(position);
                }
                let child;
                if (scrapView != null) {
                    child = this.mAdapter.getView(position, scrapView, this);
                    if (child != scrapView) {
                        this.mRecycler.addScrapView(scrapView, position);
                        if (this.mCacheColorHint != 0) {
                            child.setDrawingCacheBackgroundColor(this.mCacheColorHint);
                        }
                    }
                    else {
                        isScrap[0] = true;
                        child.dispatchFinishTemporaryDetach();
                    }
                }
                else {
                    child = this.mAdapter.getView(position, null, this);
                    if (this.mCacheColorHint != 0) {
                        child.setDrawingCacheBackgroundColor(this.mCacheColorHint);
                    }
                }
                if (this.mAdapterHasStableIds) {
                    const vlp = child.getLayoutParams();
                    let lp;
                    if (vlp == null) {
                        lp = this.generateDefaultLayoutParams();
                    }
                    else if (!this.checkLayoutParams(vlp)) {
                        lp = this.generateLayoutParams(vlp);
                    }
                    else {
                        lp = vlp;
                    }
                    lp.itemId = this.mAdapter.getItemId(position);
                    child.setLayoutParams(lp);
                }
                return child;
            }
            positionSelector(...args) {
                if (args.length === 4) {
                    let [l, t, r, b] = args;
                    this.mSelectorRect.set(l - this.mSelectionLeftPadding, t - this.mSelectionTopPadding, r + this.mSelectionRightPadding, b + this.mSelectionBottomPadding);
                }
                else {
                    let position = args[0];
                    let sel = args[1];
                    if (position != AbsListView.INVALID_POSITION) {
                        this.mSelectorPosition = position;
                    }
                    const selectorRect = this.mSelectorRect;
                    selectorRect.set(sel.getLeft(), sel.getTop(), sel.getRight(), sel.getBottom());
                    if (sel['adjustListItemSelectionBounds']) {
                        sel.adjustListItemSelectionBounds(selectorRect);
                    }
                    this.positionSelector(selectorRect.left, selectorRect.top, selectorRect.right, selectorRect.bottom);
                    const isChildViewEnabled = this.mIsChildViewEnabled;
                    if (sel.isEnabled() != isChildViewEnabled) {
                        this.mIsChildViewEnabled = !isChildViewEnabled;
                        if (this.getSelectedItemPosition() != AbsListView.INVALID_POSITION) {
                            this.refreshDrawableState();
                        }
                    }
                }
            }
            dispatchDraw(canvas) {
                let saveCount = 0;
                const clipToPadding = (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK;
                if (clipToPadding) {
                    saveCount = canvas.save();
                    const scrollX = this.mScrollX;
                    const scrollY = this.mScrollY;
                    canvas.clipRect(scrollX + this.mPaddingLeft, scrollY + this.mPaddingTop, scrollX + this.mRight - this.mLeft - this.mPaddingRight, scrollY + this.mBottom - this.mTop - this.mPaddingBottom);
                    this.mGroupFlags &= ~AbsListView.CLIP_TO_PADDING_MASK;
                }
                const drawSelectorOnTop = this.mDrawSelectorOnTop;
                if (!drawSelectorOnTop) {
                    this.drawSelector(canvas);
                }
                super.dispatchDraw(canvas);
                if (drawSelectorOnTop) {
                    this.drawSelector(canvas);
                }
                if (clipToPadding) {
                    canvas.restoreToCount(saveCount);
                    this.mGroupFlags |= AbsListView.CLIP_TO_PADDING_MASK;
                }
            }
            isPaddingOffsetRequired() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) != AbsListView.CLIP_TO_PADDING_MASK;
            }
            getLeftPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : -this.mPaddingLeft;
            }
            getTopPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : -this.mPaddingTop;
            }
            getRightPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : this.mPaddingRight;
            }
            getBottomPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : this.mPaddingBottom;
            }
            onSizeChanged(w, h, oldw, oldh) {
                if (this.getChildCount() > 0) {
                    this.mDataChanged = true;
                    this.rememberSyncState();
                }
            }
            touchModeDrawsInPressedState() {
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_TAP:
                    case AbsListView.TOUCH_MODE_DONE_WAITING:
                        return true;
                    default:
                        return false;
                }
            }
            shouldShowSelector() {
                return (!this.isInTouchMode()) || (this.touchModeDrawsInPressedState() && this.isPressed());
            }
            drawSelector(canvas) {
                if (!this.mSelectorRect.isEmpty()) {
                    const selector = this.mSelector;
                    selector.setBounds(this.mSelectorRect);
                    selector.draw(canvas);
                }
            }
            setDrawSelectorOnTop(onTop) {
                this.mDrawSelectorOnTop = onTop;
            }
            setSelector(sel) {
                if (this.mSelector != null) {
                    this.mSelector.setCallback(null);
                    this.unscheduleDrawable(this.mSelector);
                }
                this.mSelector = sel;
                let padding = new Rect();
                sel.getPadding(padding);
                this.mSelectionLeftPadding = padding.left;
                this.mSelectionTopPadding = padding.top;
                this.mSelectionRightPadding = padding.right;
                this.mSelectionBottomPadding = padding.bottom;
                sel.setCallback(this);
                this.updateSelectorState();
            }
            getSelector() {
                return this.mSelector;
            }
            keyPressed() {
                if (!this.isEnabled() || !this.isClickable()) {
                    return;
                }
                let selector = this.mSelector;
                let selectorRect = this.mSelectorRect;
                if (selector != null && (this.isFocused() || this.touchModeDrawsInPressedState()) && !selectorRect.isEmpty()) {
                    const v = this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                    if (v != null) {
                        if (v.hasFocusable())
                            return;
                        v.setPressed(true);
                    }
                    this.setPressed(true);
                    const longClickable = this.isLongClickable();
                    let d = selector.getCurrent();
                    if (longClickable && !this.mDataChanged) {
                        if (this.mPendingCheckForKeyLongPress == null) {
                            this.mPendingCheckForKeyLongPress = new AbsListView.CheckForKeyLongPress(this);
                        }
                        this.mPendingCheckForKeyLongPress.rememberWindowAttachCount();
                        this.postDelayed(this.mPendingCheckForKeyLongPress, ViewConfiguration.getLongPressTimeout());
                    }
                }
            }
            setScrollIndicators(up, down) {
                this.mScrollUp = up;
                this.mScrollDown = down;
            }
            updateSelectorState() {
                if (this.mSelector != null) {
                    if (this.shouldShowSelector()) {
                        this.mSelector.setState(this.getDrawableState());
                    }
                    else {
                        this.mSelector.setState(StateSet.NOTHING);
                    }
                }
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                this.updateSelectorState();
            }
            onCreateDrawableState(extraSpace) {
                if (this.mIsChildViewEnabled) {
                    return super.onCreateDrawableState(extraSpace);
                }
                const enabledState = AbsListView.ENABLED_STATE_SET[0];
                let state = super.onCreateDrawableState(extraSpace + 1);
                let enabledPos = -1;
                for (let i = state.length - 1; i >= 0; i--) {
                    if (state[i] == enabledState) {
                        enabledPos = i;
                        break;
                    }
                }
                if (enabledPos >= 0) {
                    System.arraycopy(state, enabledPos + 1, state, enabledPos, state.length - enabledPos - 1);
                }
                return state;
            }
            verifyDrawable(dr) {
                return this.mSelector == dr || super.verifyDrawable(dr);
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mSelector != null)
                    this.mSelector.jumpToCurrentState();
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                const treeObserver = this.getViewTreeObserver();
                treeObserver.addOnTouchModeChangeListener(this);
                if (this.mAdapter != null && this.mDataSetObserver == null) {
                    this.mDataSetObserver = new AbsListView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    this.mDataChanged = true;
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                }
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.dismissPopup();
                this.mRecycler.clear();
                const treeObserver = this.getViewTreeObserver();
                treeObserver.removeOnTouchModeChangeListener(this);
                if (this.mAdapter != null && this.mDataSetObserver != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                    this.mDataSetObserver = null;
                }
                if (this.mFlingRunnable != null) {
                    this.removeCallbacks(this.mFlingRunnable);
                }
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                if (this.mClearScrollingCache != null) {
                    this.removeCallbacks(this.mClearScrollingCache);
                }
                if (this.mPerformClick_ != null) {
                    this.removeCallbacks(this.mPerformClick_);
                }
                if (this.mTouchModeReset != null) {
                    this.removeCallbacks(this.mTouchModeReset);
                    this.mTouchModeReset.run();
                }
            }
            onWindowFocusChanged(hasWindowFocus) {
                super.onWindowFocusChanged(hasWindowFocus);
                const touchMode = this.isInTouchMode() ? AbsListView.TOUCH_MODE_ON : AbsListView.TOUCH_MODE_OFF;
                if (!hasWindowFocus) {
                    this.setChildrenDrawingCacheEnabled(false);
                    if (this.mFlingRunnable != null) {
                        this.removeCallbacks(this.mFlingRunnable);
                        this.mFlingRunnable.endFling();
                        if (this.mPositionScroller != null) {
                            this.mPositionScroller.stop();
                        }
                        if (this.mScrollY != 0) {
                            this.mScrollY = 0;
                            this.invalidateParentCaches();
                            this.finishGlows();
                            this.invalidate();
                        }
                    }
                    this.dismissPopup();
                    if (touchMode == AbsListView.TOUCH_MODE_OFF) {
                        this.mResurrectToPosition = this.mSelectedPosition;
                    }
                }
                else {
                    if (this.mFiltered && !this.mPopupHidden) {
                        this.showPopup();
                    }
                    if (touchMode != this.mLastTouchMode && this.mLastTouchMode != AbsListView.TOUCH_MODE_UNKNOWN) {
                        if (touchMode == AbsListView.TOUCH_MODE_OFF) {
                            this.resurrectSelection();
                        }
                        else {
                            this.hideSelector();
                            this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
                            this.layoutChildren();
                        }
                    }
                }
                this.mLastTouchMode = touchMode;
            }
            onCancelPendingInputEvents() {
                super.onCancelPendingInputEvents();
                if (this.mPerformClick_ != null) {
                    this.removeCallbacks(this.mPerformClick_);
                }
                if (this.mPendingCheckForTap_ != null) {
                    this.removeCallbacks(this.mPendingCheckForTap_);
                }
                if (this.mPendingCheckForLongPress_List != null) {
                    this.removeCallbacks(this.mPendingCheckForLongPress_List);
                }
                if (this.mPendingCheckForKeyLongPress != null) {
                    this.removeCallbacks(this.mPendingCheckForKeyLongPress);
                }
            }
            performLongPress(child, longPressPosition, longPressId) {
                let handled = false;
                if (this.mOnItemLongClickListener != null) {
                    handled = this.mOnItemLongClickListener.onItemLongClick(this, child, longPressPosition, longPressId);
                }
                if (handled) {
                    this.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
                }
                return handled;
            }
            onKeyDown(keyCode, event) {
                return false;
            }
            onKeyUp(keyCode, event) {
                if (KeyEvent.isConfirmKey(keyCode)) {
                    if (!this.isEnabled()) {
                        return true;
                    }
                    if (this.isClickable() && this.isPressed() && this.mSelectedPosition >= 0
                        && this.mAdapter != null && this.mSelectedPosition < this.mAdapter.getCount()) {
                        const view = this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                        if (view != null) {
                            this.performItemClick(view, this.mSelectedPosition, this.mSelectedRowId);
                            view.setPressed(false);
                        }
                        this.setPressed(false);
                        return true;
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            dispatchSetPressed(pressed) {
            }
            pointToPosition(x, y) {
                let frame = this.mTouchFrame;
                if (frame == null) {
                    this.mTouchFrame = new Rect();
                    frame = this.mTouchFrame;
                }
                const count = this.getChildCount();
                for (let i = count - 1; i >= 0; i--) {
                    const child = this.getChildAt(i);
                    if (child.getVisibility() == View.VISIBLE) {
                        child.getHitRect(frame);
                        if (frame.contains(x, y)) {
                            return this.mFirstPosition + i;
                        }
                    }
                }
                return AbsListView.INVALID_POSITION;
            }
            pointToRowId(x, y) {
                let position = this.pointToPosition(x, y);
                if (position >= 0) {
                    return this.mAdapter.getItemId(position);
                }
                return AbsListView.INVALID_ROW_ID;
            }
            checkOverScrollStartScrollIfNeeded() {
                return this.mScrollY != 0;
            }
            startScrollIfNeeded(y) {
                const deltaY = y - this.mMotionY;
                const distance = Math.abs(deltaY);
                const overscroll = this.checkOverScrollStartScrollIfNeeded();
                if (overscroll || distance > this.mTouchSlop) {
                    this.createScrollingCache();
                    if (this.mScrollY != 0) {
                        this.mTouchMode = AbsListView.TOUCH_MODE_OVERSCROLL;
                        this.mMotionCorrection = 0;
                    }
                    else {
                        this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                        this.mMotionCorrection = deltaY > 0 ? this.mTouchSlop : -this.mTouchSlop;
                    }
                    this.removeCallbacks(this.mPendingCheckForLongPress_List);
                    this.setPressed(false);
                    const motionView = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                    if (motionView != null) {
                        motionView.setPressed(false);
                    }
                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    const parent = this.getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                    this.scrollIfNeeded(y);
                    return true;
                }
                return false;
            }
            scrollIfNeeded(y) {
                const rawDeltaY = y - this.mMotionY;
                const deltaY = rawDeltaY - this.mMotionCorrection;
                let incrementalDeltaY = this.mLastY != Integer.MIN_VALUE ? y - this.mLastY : deltaY;
                if (this.mTouchMode == AbsListView.TOUCH_MODE_SCROLL) {
                    if (AbsListView.PROFILE_SCROLLING) {
                        if (!this.mScrollProfilingStarted) {
                            this.mScrollProfilingStarted = true;
                        }
                    }
                    if (y != this.mLastY) {
                        if ((this.mGroupFlags & AbsListView.FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > this.mTouchSlop) {
                            const parent = this.getParent();
                            if (parent != null) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                        }
                        let motionIndex;
                        if (this.mMotionPosition >= 0) {
                            motionIndex = this.mMotionPosition - this.mFirstPosition;
                        }
                        else {
                            motionIndex = this.getChildCount() / 2;
                        }
                        let motionViewPrevTop = 0;
                        let motionView = this.getChildAt(motionIndex);
                        if (motionView != null) {
                            motionViewPrevTop = motionView.getTop();
                        }
                        let atEdge = false;
                        if (incrementalDeltaY != 0) {
                            atEdge = this.trackMotionScroll(deltaY, incrementalDeltaY);
                        }
                        motionView = this.getChildAt(motionIndex);
                        if (motionView != null) {
                            const motionViewRealTop = motionView.getTop();
                            if (atEdge) {
                                let overscroll = -incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
                                this.overScrollBy(0, overscroll, 0, this.mScrollY, 0, 0, 0, this.mOverscrollDistance, true);
                                if (Math.abs(this.mOverscrollDistance) == Math.abs(this.mScrollY)) {
                                    if (this.mVelocityTracker != null) {
                                        this.mVelocityTracker.clear();
                                    }
                                }
                                const overscrollMode = this.getOverScrollMode();
                                if (overscrollMode == AbsListView.OVER_SCROLL_ALWAYS || (overscrollMode == AbsListView.OVER_SCROLL_IF_CONTENT_SCROLLS && !this.contentFits())) {
                                    this.mDirection = 0;
                                    this.mTouchMode = AbsListView.TOUCH_MODE_OVERSCROLL;
                                    if (rawDeltaY > 0) {
                                    }
                                    else if (rawDeltaY < 0) {
                                    }
                                }
                            }
                            this.mMotionY = y;
                        }
                        this.mLastY = y;
                    }
                }
                else if (this.mTouchMode == AbsListView.TOUCH_MODE_OVERSCROLL) {
                    if (y != this.mLastY) {
                        const oldScroll = this.mScrollY;
                        const newScroll = oldScroll - incrementalDeltaY;
                        let newDirection = y > this.mLastY ? 1 : -1;
                        if (this.mDirection == 0) {
                            this.mDirection = newDirection;
                        }
                        let overScrollDistance = -incrementalDeltaY;
                        if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
                            overScrollDistance = -oldScroll;
                            incrementalDeltaY += overScrollDistance;
                        }
                        else {
                            incrementalDeltaY = 0;
                        }
                        if (overScrollDistance != 0) {
                            this.overScrollBy(0, overScrollDistance, 0, this.mScrollY, 0, 0, 0, this.mOverscrollDistance, true);
                        }
                        if (incrementalDeltaY != 0) {
                            if (this.mScrollY != 0) {
                                this.mScrollY = 0;
                                this.invalidateParentIfNeeded();
                            }
                            this.trackMotionScroll(incrementalDeltaY, incrementalDeltaY);
                            this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                            const motionPosition = this.findClosestMotionRow(y);
                            this.mMotionCorrection = 0;
                            let motionView = this.getChildAt(motionPosition - this.mFirstPosition);
                            this.mMotionViewOriginalTop = motionView != null ? motionView.getTop() : 0;
                            this.mMotionY = y;
                            this.mMotionPosition = motionPosition;
                        }
                        this.mLastY = y;
                        this.mDirection = newDirection;
                    }
                }
            }
            onTouchModeChanged(isInTouchMode) {
                if (isInTouchMode) {
                    this.hideSelector();
                    if (this.getHeight() > 0 && this.getChildCount() > 0) {
                        this.layoutChildren();
                    }
                    this.updateSelectorState();
                }
                else {
                    let touchMode = this.mTouchMode;
                    if (touchMode == AbsListView.TOUCH_MODE_OVERSCROLL || touchMode == AbsListView.TOUCH_MODE_OVERFLING) {
                        if (this.mFlingRunnable != null) {
                            this.mFlingRunnable.endFling();
                        }
                        if (this.mPositionScroller != null) {
                            this.mPositionScroller.stop();
                        }
                        if (this.mScrollY != 0) {
                            this.mScrollY = 0;
                            this.invalidateParentCaches();
                            this.finishGlows();
                            this.invalidate();
                        }
                    }
                }
            }
            onTouchEvent(ev) {
                if (!this.isEnabled()) {
                    return this.isClickable() || this.isLongClickable();
                }
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                if (!this.isAttachedToWindow()) {
                    return false;
                }
                this.initVelocityTrackerIfNotExists();
                this.mVelocityTracker.addMovement(ev);
                const actionMasked = ev.getActionMasked();
                switch (actionMasked) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            this.onTouchDown(ev);
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        {
                            this.onTouchMove(ev);
                            break;
                        }
                    case MotionEvent.ACTION_UP:
                        {
                            this.onTouchUp(ev);
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                        {
                            this.onTouchCancel();
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        {
                            this.onSecondaryPointerUp(ev);
                            const x = this.mMotionX;
                            const y = this.mMotionY;
                            const motionPosition = this.pointToPosition(x, y);
                            if (motionPosition >= 0) {
                                const child = this.getChildAt(motionPosition - this.mFirstPosition);
                                this.mMotionViewOriginalTop = child.getTop();
                                this.mMotionPosition = motionPosition;
                            }
                            this.mLastY = y;
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_DOWN:
                        {
                            const index = ev.getActionIndex();
                            const id = ev.getPointerId(index);
                            const x = Math.floor(ev.getX(index));
                            const y = Math.floor(ev.getY(index));
                            this.mMotionCorrection = 0;
                            this.mActivePointerId = id;
                            this.mMotionX = x;
                            this.mMotionY = y;
                            const motionPosition = this.pointToPosition(x, y);
                            if (motionPosition >= 0) {
                                const child = this.getChildAt(motionPosition - this.mFirstPosition);
                                this.mMotionViewOriginalTop = child.getTop();
                                this.mMotionPosition = motionPosition;
                            }
                            this.mLastY = y;
                            break;
                        }
                }
                return true;
            }
            onTouchDown(ev) {
                this.mActivePointerId = ev.getPointerId(0);
                if (this.mTouchMode == AbsListView.TOUCH_MODE_OVERFLING) {
                    this.mFlingRunnable.endFling();
                    if (this.mPositionScroller != null) {
                        this.mPositionScroller.stop();
                    }
                    this.mTouchMode = AbsListView.TOUCH_MODE_OVERSCROLL;
                    this.mMotionX = Math.floor(ev.getX());
                    this.mMotionY = Math.floor(ev.getY());
                    this.mLastY = this.mMotionY;
                    this.mMotionCorrection = 0;
                    this.mDirection = 0;
                }
                else {
                    const x = Math.floor(ev.getX());
                    const y = Math.floor(ev.getY());
                    let motionPosition = this.pointToPosition(x, y);
                    if (!this.mDataChanged) {
                        if (this.mTouchMode == AbsListView.TOUCH_MODE_FLING) {
                            this.createScrollingCache();
                            this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                            this.mMotionCorrection = 0;
                            motionPosition = this.findMotionRow(y);
                            this.mFlingRunnable.flywheelTouch();
                        }
                        else if ((motionPosition >= 0) && this.getAdapter().isEnabled(motionPosition)) {
                            this.mTouchMode = AbsListView.TOUCH_MODE_DOWN;
                            if (this.mPendingCheckForTap_ == null) {
                                this.mPendingCheckForTap_ = new AbsListView.CheckForTap(this);
                            }
                            this.postDelayed(this.mPendingCheckForTap_, ViewConfiguration.getTapTimeout());
                        }
                        else if (motionPosition < 0) {
                            this.mTouchMode = AbsListView.TOUCH_MODE_DOWN;
                        }
                    }
                    if (motionPosition >= 0) {
                        const v = this.getChildAt(motionPosition - this.mFirstPosition);
                        this.mMotionViewOriginalTop = v.getTop();
                    }
                    this.mMotionX = x;
                    this.mMotionY = y;
                    this.mMotionPosition = motionPosition;
                    this.mLastY = Integer.MIN_VALUE;
                }
                if (this.mTouchMode == AbsListView.TOUCH_MODE_DOWN && this.mMotionPosition != AbsListView.INVALID_POSITION
                    && this.performButtonActionOnTouchDown(ev)) {
                    this.removeCallbacks(this.mPendingCheckForTap_);
                }
            }
            onTouchMove(ev) {
                let pointerIndex = ev.findPointerIndex(this.mActivePointerId);
                if (pointerIndex == -1) {
                    pointerIndex = 0;
                    this.mActivePointerId = ev.getPointerId(pointerIndex);
                }
                if (this.mDataChanged) {
                    this.layoutChildren();
                }
                const y = Math.floor(ev.getY(pointerIndex));
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_DOWN:
                    case AbsListView.TOUCH_MODE_TAP:
                    case AbsListView.TOUCH_MODE_DONE_WAITING:
                        if (this.startScrollIfNeeded(y)) {
                            break;
                        }
                        const x = ev.getX(pointerIndex);
                        if (!this.pointInView(x, y, this.mTouchSlop)) {
                            this.setPressed(false);
                            const motionView = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                            if (motionView != null) {
                                motionView.setPressed(false);
                            }
                            this.removeCallbacks(this.mTouchMode == AbsListView.TOUCH_MODE_DOWN ? this.mPendingCheckForTap_ : this.mPendingCheckForLongPress_List);
                            this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                            this.updateSelectorState();
                        }
                        break;
                    case AbsListView.TOUCH_MODE_SCROLL:
                    case AbsListView.TOUCH_MODE_OVERSCROLL:
                        this.scrollIfNeeded(y);
                        break;
                }
            }
            onTouchUp(ev) {
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_DOWN:
                    case AbsListView.TOUCH_MODE_TAP:
                    case AbsListView.TOUCH_MODE_DONE_WAITING:
                        const motionPosition = this.mMotionPosition;
                        const child = this.getChildAt(motionPosition - this.mFirstPosition);
                        if (child != null) {
                            if (this.mTouchMode != AbsListView.TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            const x = ev.getX();
                            const inList = x > this.mListPadding.left && x < this.getWidth() - this.mListPadding.right;
                            if (inList && !child.hasFocusable()) {
                                if (this.mPerformClick_ == null) {
                                    this.mPerformClick_ = new AbsListView.PerformClick(this);
                                }
                                const performClick = this.mPerformClick_;
                                performClick.mClickMotionPosition = motionPosition;
                                performClick.rememberWindowAttachCount();
                                this.mResurrectToPosition = motionPosition;
                                if (this.mTouchMode == AbsListView.TOUCH_MODE_DOWN || this.mTouchMode == AbsListView.TOUCH_MODE_TAP) {
                                    this.removeCallbacks(this.mTouchMode == AbsListView.TOUCH_MODE_DOWN ? this.mPendingCheckForTap_ : this.mPendingCheckForLongPress_List);
                                    this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
                                    if (!this.mDataChanged && this.mAdapter.isEnabled(motionPosition)) {
                                        this.mTouchMode = AbsListView.TOUCH_MODE_TAP;
                                        this.setSelectedPositionInt(this.mMotionPosition);
                                        this.layoutChildren();
                                        child.setPressed(true);
                                        this.positionSelector(this.mMotionPosition, child);
                                        this.setPressed(true);
                                        if (this.mSelector != null) {
                                            let d = this.mSelector.getCurrent();
                                        }
                                        if (this.mTouchModeReset != null) {
                                            this.removeCallbacks(this.mTouchModeReset);
                                        }
                                        this.mTouchModeReset = (() => {
                                            const _this = this;
                                            class _Inner {
                                                run() {
                                                    _this.mTouchModeReset = null;
                                                    _this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                                    child.setPressed(false);
                                                    _this.setPressed(false);
                                                    if (!_this.mDataChanged && _this.isAttachedToWindow()) {
                                                        performClick.run();
                                                    }
                                                }
                                            }
                                            return new _Inner();
                                        })();
                                        this.postDelayed(this.mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                    }
                                    else {
                                        this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                        this.updateSelectorState();
                                    }
                                    return;
                                }
                                else if (!this.mDataChanged && this.mAdapter.isEnabled(motionPosition)) {
                                    performClick.run();
                                }
                            }
                        }
                        this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        this.updateSelectorState();
                        break;
                    case AbsListView.TOUCH_MODE_SCROLL:
                        const childCount = this.getChildCount();
                        if (childCount > 0) {
                            const firstChildTop = this.getChildAt(0).getTop();
                            const lastChildBottom = this.getChildAt(childCount - 1).getBottom();
                            const contentTop = this.mListPadding.top;
                            const contentBottom = this.getHeight() - this.mListPadding.bottom;
                            if (this.mFirstPosition == 0 && firstChildTop >= contentTop && this.mFirstPosition + childCount < this.mItemCount
                                && lastChildBottom <= this.getHeight() - contentBottom) {
                                this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                            }
                            else {
                                const velocityTracker = this.mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                                const initialVelocity = Math.floor((velocityTracker.getYVelocity(this.mActivePointerId) * this.mVelocityScale));
                                if (Math.abs(initialVelocity) > this.mMinimumVelocity
                                    && !((this.mFirstPosition == 0 && firstChildTop == contentTop - this.mOverscrollDistance)
                                        || (this.mFirstPosition + childCount == this.mItemCount
                                            && lastChildBottom == contentBottom + this.mOverscrollDistance))) {
                                    if (this.mFlingRunnable == null) {
                                        this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                                    }
                                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                                    this.mFlingRunnable.start(-initialVelocity);
                                }
                                else {
                                    this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                                    if (this.mFlingRunnable != null) {
                                        this.mFlingRunnable.endFling();
                                    }
                                    if (this.mPositionScroller != null) {
                                        this.mPositionScroller.stop();
                                    }
                                }
                            }
                        }
                        else {
                            this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                            this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case AbsListView.TOUCH_MODE_OVERSCROLL:
                        if (this.mFlingRunnable == null) {
                            this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                        }
                        const velocityTracker = this.mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                        const initialVelocity = Math.floor(velocityTracker.getYVelocity(this.mActivePointerId));
                        this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > this.mMinimumVelocity) {
                            this.mFlingRunnable.startOverfling(-initialVelocity);
                        }
                        else {
                            this.mFlingRunnable.startSpringback();
                        }
                        break;
                }
                this.setPressed(false);
                this.invalidate();
                this.removeCallbacks(this.mPendingCheckForLongPress_List);
                this.recycleVelocityTracker();
                this.mActivePointerId = AbsListView.INVALID_POINTER;
                if (AbsListView.PROFILE_SCROLLING) {
                    if (this.mScrollProfilingStarted) {
                        this.mScrollProfilingStarted = false;
                    }
                }
            }
            onTouchCancel() {
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_OVERSCROLL:
                        if (this.mFlingRunnable == null) {
                            this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                        }
                        this.mFlingRunnable.startSpringback();
                        break;
                    case AbsListView.TOUCH_MODE_OVERFLING:
                        break;
                    default:
                        this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        this.setPressed(false);
                        const motionView = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        this.clearScrollingCache();
                        this.removeCallbacks(this.mPendingCheckForLongPress_List);
                        this.recycleVelocityTracker();
                }
                this.mActivePointerId = AbsListView.INVALID_POINTER;
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
                if (this.mScrollY != scrollY) {
                    this.onScrollChanged(this.mScrollX, scrollY, this.mScrollX, this.mScrollY);
                    this.mScrollY = scrollY;
                    this.invalidateParentIfNeeded();
                    this.awakenScrollBars();
                }
            }
            onGenericMotionEvent(event) {
                if (event.isPointerEvent()) {
                    switch (event.getAction()) {
                        case MotionEvent.ACTION_SCROLL:
                            {
                                if (this.mTouchMode == AbsListView.TOUCH_MODE_REST) {
                                    const vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                                    if (vscroll != 0) {
                                        const delta = Math.floor((vscroll * this.getVerticalScrollFactor()));
                                        if (!this.trackMotionScroll(delta, delta)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            draw(canvas) {
                super.draw(canvas);
            }
            setOverScrollEffectPadding(leftPadding, rightPadding) {
                this.mGlowPaddingLeft = leftPadding;
                this.mGlowPaddingRight = rightPadding;
            }
            initOrResetVelocityTracker() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    this.mVelocityTracker.clear();
                }
            }
            initVelocityTrackerIfNotExists() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
            }
            recycleVelocityTracker() {
                if (this.mVelocityTracker != null) {
                    this.mVelocityTracker.recycle();
                    this.mVelocityTracker = null;
                }
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept) {
                    this.recycleVelocityTracker();
                }
                super.requestDisallowInterceptTouchEvent(disallowIntercept);
            }
            onInterceptTouchEvent(ev) {
                let action = ev.getAction();
                let v;
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                if (!this.isAttachedToWindow()) {
                    return false;
                }
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            let touchMode = this.mTouchMode;
                            if (touchMode == AbsListView.TOUCH_MODE_OVERFLING || touchMode == AbsListView.TOUCH_MODE_OVERSCROLL) {
                                this.mMotionCorrection = 0;
                                return true;
                            }
                            const x = Math.floor(ev.getX());
                            const y = Math.floor(ev.getY());
                            this.mActivePointerId = ev.getPointerId(0);
                            let motionPosition = this.findMotionRow(y);
                            if (touchMode != AbsListView.TOUCH_MODE_FLING && motionPosition >= 0) {
                                v = this.getChildAt(motionPosition - this.mFirstPosition);
                                this.mMotionViewOriginalTop = v.getTop();
                                this.mMotionX = x;
                                this.mMotionY = y;
                                this.mMotionPosition = motionPosition;
                                this.mTouchMode = AbsListView.TOUCH_MODE_DOWN;
                                this.clearScrollingCache();
                            }
                            this.mLastY = Integer.MIN_VALUE;
                            this.initOrResetVelocityTracker();
                            this.mVelocityTracker.addMovement(ev);
                            if (touchMode == AbsListView.TOUCH_MODE_FLING) {
                                return true;
                            }
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        {
                            switch (this.mTouchMode) {
                                case AbsListView.TOUCH_MODE_DOWN:
                                    let pointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    if (pointerIndex == -1) {
                                        pointerIndex = 0;
                                        this.mActivePointerId = ev.getPointerId(pointerIndex);
                                    }
                                    const y = Math.floor(ev.getY(pointerIndex));
                                    this.initVelocityTrackerIfNotExists();
                                    this.mVelocityTracker.addMovement(ev);
                                    if (this.startScrollIfNeeded(y)) {
                                        return true;
                                    }
                                    break;
                            }
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        {
                            this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                            this.mActivePointerId = AbsListView.INVALID_POINTER;
                            this.recycleVelocityTracker();
                            this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        {
                            this.onSecondaryPointerUp(ev);
                            break;
                        }
                }
                return false;
            }
            onSecondaryPointerUp(ev) {
                const pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                const pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == this.mActivePointerId) {
                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    this.mMotionX = Math.floor(ev.getX(newPointerIndex));
                    this.mMotionY = Math.floor(ev.getY(newPointerIndex));
                    this.mMotionCorrection = 0;
                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                }
            }
            addTouchables(views) {
                const count = this.getChildCount();
                const firstPosition = this.mFirstPosition;
                const adapter = this.mAdapter;
                if (adapter == null) {
                    return;
                }
                for (let i = 0; i < count; i++) {
                    const child = this.getChildAt(i);
                    if (adapter.isEnabled(firstPosition + i)) {
                        views.add(child);
                    }
                    child.addTouchables(views);
                }
            }
            reportScrollStateChange(newState) {
                if (newState != this.mLastScrollState) {
                    if (this.mOnScrollListener != null) {
                        this.mLastScrollState = newState;
                        this.mOnScrollListener.onScrollStateChanged(this, newState);
                    }
                }
            }
            setFriction(friction) {
                if (this.mFlingRunnable == null) {
                    this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                }
                this.mFlingRunnable.mScroller.setFriction(friction);
            }
            setVelocityScale(scale) {
                this.mVelocityScale = scale;
            }
            smoothScrollToPositionFromTop(position, offset, duration) {
                if (this.mPositionScroller == null) {
                    this.mPositionScroller = new AbsListView.PositionScroller(this);
                }
                this.mPositionScroller.startWithOffset(position, offset, duration);
            }
            smoothScrollToPosition(position, boundPosition) {
                if (this.mPositionScroller == null) {
                    this.mPositionScroller = new AbsListView.PositionScroller(this);
                }
                this.mPositionScroller.start(position, boundPosition);
            }
            smoothScrollBy(distance, duration, linear = false) {
                if (this.mFlingRunnable == null) {
                    this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                }
                const firstPos = this.mFirstPosition;
                const childCount = this.getChildCount();
                const lastPos = firstPos + childCount;
                const topLimit = this.getPaddingTop();
                const bottomLimit = this.getHeight() - this.getPaddingBottom();
                if (distance == 0 || this.mItemCount == 0 || childCount == 0
                    || (firstPos == 0 && this.getChildAt(0).getTop() == topLimit && distance < 0)
                    || (lastPos == this.mItemCount && this.getChildAt(childCount - 1).getBottom() == bottomLimit && distance > 0)) {
                    this.mFlingRunnable.endFling();
                    if (this.mPositionScroller != null) {
                        this.mPositionScroller.stop();
                    }
                }
                else {
                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                    this.mFlingRunnable.startScroll(distance, duration, linear);
                }
            }
            smoothScrollByOffset(position) {
                let index = -1;
                if (position < 0) {
                    index = this.getFirstVisiblePosition();
                }
                else if (position > 0) {
                    index = this.getLastVisiblePosition();
                }
                if (index > -1) {
                    let child = this.getChildAt(index - this.getFirstVisiblePosition());
                    if (child != null) {
                        let visibleRect = new Rect();
                        if (child.getGlobalVisibleRect(visibleRect)) {
                            let childRectArea = child.getWidth() * child.getHeight();
                            let visibleRectArea = visibleRect.width() * visibleRect.height();
                            let visibleArea = (visibleRectArea / childRectArea);
                            const visibleThreshold = 0.75;
                            if ((position < 0) && (visibleArea < visibleThreshold)) {
                                ++index;
                            }
                            else if ((position > 0) && (visibleArea < visibleThreshold)) {
                                --index;
                            }
                        }
                        this.smoothScrollToPosition(Math.max(0, Math.min(this.getCount(), index + position)));
                    }
                }
            }
            createScrollingCache() {
                if (this.mScrollingCacheEnabled && !this.mCachingStarted && !this.isHardwareAccelerated()) {
                    this.setChildrenDrawnWithCacheEnabled(true);
                    this.setChildrenDrawingCacheEnabled(true);
                    this.mCachingStarted = this.mCachingActive = true;
                }
            }
            clearScrollingCache() {
                if (!this.isHardwareAccelerated()) {
                    if (this.mClearScrollingCache == null) {
                        this.mClearScrollingCache = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    if (_this.mCachingStarted) {
                                        _this.mCachingStarted = _this.mCachingActive = false;
                                        _this.setChildrenDrawnWithCacheEnabled(false);
                                        if ((_this.mPersistentDrawingCache & AbsListView.PERSISTENT_SCROLLING_CACHE) == 0) {
                                            _this.setChildrenDrawingCacheEnabled(false);
                                        }
                                        if (!_this.isAlwaysDrawnWithCacheEnabled()) {
                                            _this.invalidate();
                                        }
                                    }
                                }
                            }
                            return new _Inner();
                        })();
                    }
                    this.post(this.mClearScrollingCache);
                }
            }
            scrollListBy(y) {
                this.trackMotionScroll(-y, -y);
            }
            canScrollList(direction) {
                const childCount = this.getChildCount();
                if (childCount == 0) {
                    return false;
                }
                const firstPosition = this.mFirstPosition;
                const listPadding = this.mListPadding;
                if (direction > 0) {
                    const lastBottom = this.getChildAt(childCount - 1).getBottom();
                    const lastPosition = firstPosition + childCount;
                    return lastPosition < this.mItemCount || lastBottom > this.getHeight() - listPadding.bottom;
                }
                else {
                    const firstTop = this.getChildAt(0).getTop();
                    return firstPosition > 0 || firstTop < listPadding.top;
                }
            }
            trackMotionScroll(deltaY, incrementalDeltaY) {
                const childCount = this.getChildCount();
                if (childCount == 0) {
                    return true;
                }
                const firstTop = this.getChildAt(0).getTop();
                const lastBottom = this.getChildAt(childCount - 1).getBottom();
                const listPadding = this.mListPadding;
                let effectivePaddingTop = 0;
                let effectivePaddingBottom = 0;
                if ((this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK) {
                    effectivePaddingTop = listPadding.top;
                    effectivePaddingBottom = listPadding.bottom;
                }
                const spaceAbove = effectivePaddingTop - firstTop;
                const end = this.getHeight() - effectivePaddingBottom;
                const spaceBelow = lastBottom - end;
                const height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                if (deltaY < 0) {
                    deltaY = Math.max(-(height - 1), deltaY);
                }
                else {
                    deltaY = Math.min(height - 1, deltaY);
                }
                if (incrementalDeltaY < 0) {
                    incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
                }
                else {
                    incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
                }
                const firstPosition = this.mFirstPosition;
                if (firstPosition == 0) {
                    this.mFirstPositionDistanceGuess = firstTop - listPadding.top;
                }
                else {
                    this.mFirstPositionDistanceGuess += incrementalDeltaY;
                }
                if (firstPosition + childCount == this.mItemCount) {
                    this.mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
                }
                else {
                    this.mLastPositionDistanceGuess += incrementalDeltaY;
                }
                const cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
                const cannotScrollUp = (firstPosition + childCount == this.mItemCount && lastBottom <= this.getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
                if (cannotScrollDown || cannotScrollUp) {
                    return incrementalDeltaY != 0;
                }
                const down = incrementalDeltaY < 0;
                const inTouchMode = this.isInTouchMode();
                if (inTouchMode) {
                    this.hideSelector();
                }
                const headerViewsCount = this.getHeaderViewsCount();
                const footerViewsStart = this.mItemCount - this.getFooterViewsCount();
                let start = 0;
                let count = 0;
                if (down) {
                    let top = -incrementalDeltaY;
                    if ((this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK) {
                        top += listPadding.top;
                    }
                    for (let i = 0; i < childCount; i++) {
                        const child = this.getChildAt(i);
                        if (child.getBottom() >= top) {
                            break;
                        }
                        else {
                            count++;
                            let position = firstPosition + i;
                            if (position >= headerViewsCount && position < footerViewsStart) {
                                this.mRecycler.addScrapView(child, position);
                            }
                        }
                    }
                }
                else {
                    let bottom = this.getHeight() - incrementalDeltaY;
                    if ((this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK) {
                        bottom -= listPadding.bottom;
                    }
                    for (let i = childCount - 1; i >= 0; i--) {
                        const child = this.getChildAt(i);
                        if (child.getTop() <= bottom) {
                            break;
                        }
                        else {
                            start = i;
                            count++;
                            let position = firstPosition + i;
                            if (position >= headerViewsCount && position < footerViewsStart) {
                                this.mRecycler.addScrapView(child, position);
                            }
                        }
                    }
                }
                this.mMotionViewNewTop = this.mMotionViewOriginalTop + deltaY;
                this.mBlockLayoutRequests = true;
                if (count > 0) {
                    this.detachViewsFromParent(start, count);
                    this.mRecycler.removeSkippedScrap();
                }
                if (!this.awakenScrollBars()) {
                    this.invalidate();
                }
                this.offsetChildrenTopAndBottom(incrementalDeltaY);
                if (down) {
                    this.mFirstPosition += count;
                }
                const absIncrementalDeltaY = Math.abs(incrementalDeltaY);
                if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
                    this.fillGap(down);
                }
                if (!inTouchMode && this.mSelectedPosition != AbsListView.INVALID_POSITION) {
                    const childIndex = this.mSelectedPosition - this.mFirstPosition;
                    if (childIndex >= 0 && childIndex < this.getChildCount()) {
                        this.positionSelector(this.mSelectedPosition, this.getChildAt(childIndex));
                    }
                }
                else if (this.mSelectorPosition != AbsListView.INVALID_POSITION) {
                    const childIndex = this.mSelectorPosition - this.mFirstPosition;
                    if (childIndex >= 0 && childIndex < this.getChildCount()) {
                        this.positionSelector(AbsListView.INVALID_POSITION, this.getChildAt(childIndex));
                    }
                }
                else {
                    this.mSelectorRect.setEmpty();
                }
                this.mBlockLayoutRequests = false;
                this.invokeOnItemScrollListener();
                return false;
            }
            getHeaderViewsCount() {
                return 0;
            }
            getFooterViewsCount() {
                return 0;
            }
            hideSelector() {
                if (this.mSelectedPosition != AbsListView.INVALID_POSITION) {
                    if (this.mLayoutMode != AbsListView.LAYOUT_SPECIFIC) {
                        this.mResurrectToPosition = this.mSelectedPosition;
                    }
                    if (this.mNextSelectedPosition >= 0 && this.mNextSelectedPosition != this.mSelectedPosition) {
                        this.mResurrectToPosition = this.mNextSelectedPosition;
                    }
                    this.setSelectedPositionInt(AbsListView.INVALID_POSITION);
                    this.setNextSelectedPositionInt(AbsListView.INVALID_POSITION);
                    this.mSelectedTop = 0;
                }
            }
            reconcileSelectedPosition() {
                let position = this.mSelectedPosition;
                if (position < 0) {
                    position = this.mResurrectToPosition;
                }
                position = Math.max(0, position);
                position = Math.min(position, this.mItemCount - 1);
                return position;
            }
            findClosestMotionRow(y) {
                const childCount = this.getChildCount();
                if (childCount == 0) {
                    return AbsListView.INVALID_POSITION;
                }
                const motionRow = this.findMotionRow(y);
                return motionRow != AbsListView.INVALID_POSITION ? motionRow : this.mFirstPosition + childCount - 1;
            }
            invalidateViews() {
                this.mDataChanged = true;
                this.rememberSyncState();
                this.requestLayout();
                this.invalidate();
            }
            resurrectSelectionIfNeeded() {
                if (this.mSelectedPosition < 0 && this.resurrectSelection()) {
                    this.updateSelectorState();
                    return true;
                }
                return false;
            }
            resurrectSelection() {
                const childCount = this.getChildCount();
                if (childCount <= 0) {
                    return false;
                }
                let selectedTop = 0;
                let selectedPos;
                let childrenTop = this.mListPadding.top;
                let childrenBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                const firstPosition = this.mFirstPosition;
                const toPosition = this.mResurrectToPosition;
                let down = true;
                if (toPosition >= firstPosition && toPosition < firstPosition + childCount) {
                    selectedPos = toPosition;
                    const selected = this.getChildAt(selectedPos - this.mFirstPosition);
                    selectedTop = selected.getTop();
                    let selectedBottom = selected.getBottom();
                    if (selectedTop < childrenTop) {
                        selectedTop = childrenTop + this.getVerticalFadingEdgeLength();
                    }
                    else if (selectedBottom > childrenBottom) {
                        selectedTop = childrenBottom - selected.getMeasuredHeight() - this.getVerticalFadingEdgeLength();
                    }
                }
                else {
                    if (toPosition < firstPosition) {
                        selectedPos = firstPosition;
                        for (let i = 0; i < childCount; i++) {
                            const v = this.getChildAt(i);
                            const top = v.getTop();
                            if (i == 0) {
                                selectedTop = top;
                                if (firstPosition > 0 || top < childrenTop) {
                                    childrenTop += this.getVerticalFadingEdgeLength();
                                }
                            }
                            if (top >= childrenTop) {
                                selectedPos = firstPosition + i;
                                selectedTop = top;
                                break;
                            }
                        }
                    }
                    else {
                        const itemCount = this.mItemCount;
                        down = false;
                        selectedPos = firstPosition + childCount - 1;
                        for (let i = childCount - 1; i >= 0; i--) {
                            const v = this.getChildAt(i);
                            const top = v.getTop();
                            const bottom = v.getBottom();
                            if (i == childCount - 1) {
                                selectedTop = top;
                                if (firstPosition + childCount < itemCount || bottom > childrenBottom) {
                                    childrenBottom -= this.getVerticalFadingEdgeLength();
                                }
                            }
                            if (bottom <= childrenBottom) {
                                selectedPos = firstPosition + i;
                                selectedTop = top;
                                break;
                            }
                        }
                    }
                }
                this.mResurrectToPosition = AbsListView.INVALID_POSITION;
                this.removeCallbacks(this.mFlingRunnable);
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                this.clearScrollingCache();
                this.mSpecificTop = selectedTop;
                selectedPos = this.lookForSelectablePosition(selectedPos, down);
                if (selectedPos >= firstPosition && selectedPos <= this.getLastVisiblePosition()) {
                    this.mLayoutMode = AbsListView.LAYOUT_SPECIFIC;
                    this.updateSelectorState();
                    this.setSelectionInt(selectedPos);
                    this.invokeOnItemScrollListener();
                }
                else {
                    selectedPos = AbsListView.INVALID_POSITION;
                }
                this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                return selectedPos >= 0;
            }
            confirmCheckedPositionsById() {
                this.mCheckStates.clear();
                let checkedCountChanged = false;
                for (let checkedIndex = 0; checkedIndex < this.mCheckedIdStates.size(); checkedIndex++) {
                    const id = this.mCheckedIdStates.keyAt(checkedIndex);
                    const lastPos = this.mCheckedIdStates.valueAt(checkedIndex);
                    const lastPosId = this.mAdapter.getItemId(lastPos);
                    if (id != lastPosId) {
                        const start = Math.max(0, lastPos - AbsListView.CHECK_POSITION_SEARCH_DISTANCE);
                        const end = Math.min(lastPos + AbsListView.CHECK_POSITION_SEARCH_DISTANCE, this.mItemCount);
                        let found = false;
                        for (let searchPos = start; searchPos < end; searchPos++) {
                            const searchId = this.mAdapter.getItemId(searchPos);
                            if (id == searchId) {
                                found = true;
                                this.mCheckStates.put(searchPos, true);
                                this.mCheckedIdStates.setValueAt(checkedIndex, searchPos);
                                break;
                            }
                        }
                        if (!found) {
                            this.mCheckedIdStates.delete(id);
                            checkedIndex--;
                            this.mCheckedItemCount--;
                            checkedCountChanged = true;
                        }
                    }
                    else {
                        this.mCheckStates.put(lastPos, true);
                    }
                }
                if (checkedCountChanged && this.mChoiceActionMode != null) {
                    this.mChoiceActionMode.invalidate();
                }
            }
            handleDataChanged() {
                let count = this.mItemCount;
                let lastHandledItemCount = this.mLastHandledItemCount;
                this.mLastHandledItemCount = this.mItemCount;
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE && this.mAdapter != null && this.mAdapter.hasStableIds()) {
                    this.confirmCheckedPositionsById();
                }
                this.mRecycler.clearTransientStateViews();
                if (count > 0) {
                    let newPos;
                    let selectablePos;
                    if (this.mNeedSync) {
                        this.mNeedSync = false;
                        this.mPendingSync = null;
                        if (this.mTranscriptMode == AbsListView.TRANSCRIPT_MODE_ALWAYS_SCROLL) {
                            this.mLayoutMode = AbsListView.LAYOUT_FORCE_BOTTOM;
                            return;
                        }
                        else if (this.mTranscriptMode == AbsListView.TRANSCRIPT_MODE_NORMAL) {
                            if (this.mForceTranscriptScroll) {
                                this.mForceTranscriptScroll = false;
                                this.mLayoutMode = AbsListView.LAYOUT_FORCE_BOTTOM;
                                return;
                            }
                            const childCount = this.getChildCount();
                            const listBottom = this.getHeight() - this.getPaddingBottom();
                            const lastChild = this.getChildAt(childCount - 1);
                            const lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                            if (this.mFirstPosition + childCount >= lastHandledItemCount && lastBottom <= listBottom) {
                                this.mLayoutMode = AbsListView.LAYOUT_FORCE_BOTTOM;
                                return;
                            }
                            this.awakenScrollBars();
                        }
                        switch (this.mSyncMode) {
                            case AbsListView.SYNC_SELECTED_POSITION:
                                if (this.isInTouchMode()) {
                                    this.mLayoutMode = AbsListView.LAYOUT_SYNC;
                                    this.mSyncPosition = Math.min(Math.max(0, this.mSyncPosition), count - 1);
                                    return;
                                }
                                else {
                                    newPos = this.findSyncPosition();
                                    if (newPos >= 0) {
                                        selectablePos = this.lookForSelectablePosition(newPos, true);
                                        if (selectablePos == newPos) {
                                            this.mSyncPosition = newPos;
                                            if (this.mSyncHeight == this.getHeight()) {
                                                this.mLayoutMode = AbsListView.LAYOUT_SYNC;
                                            }
                                            else {
                                                this.mLayoutMode = AbsListView.LAYOUT_SET_SELECTION;
                                            }
                                            this.setNextSelectedPositionInt(newPos);
                                            return;
                                        }
                                    }
                                }
                                break;
                            case AbsListView.SYNC_FIRST_POSITION:
                                this.mLayoutMode = AbsListView.LAYOUT_SYNC;
                                this.mSyncPosition = Math.min(Math.max(0, this.mSyncPosition), count - 1);
                                return;
                        }
                    }
                    if (!this.isInTouchMode()) {
                        newPos = this.getSelectedItemPosition();
                        if (newPos >= count) {
                            newPos = count - 1;
                        }
                        if (newPos < 0) {
                            newPos = 0;
                        }
                        selectablePos = this.lookForSelectablePosition(newPos, true);
                        if (selectablePos >= 0) {
                            this.setNextSelectedPositionInt(selectablePos);
                            return;
                        }
                        else {
                            selectablePos = this.lookForSelectablePosition(newPos, false);
                            if (selectablePos >= 0) {
                                this.setNextSelectedPositionInt(selectablePos);
                                return;
                            }
                        }
                    }
                    else {
                        if (this.mResurrectToPosition >= 0) {
                            return;
                        }
                    }
                }
                this.mLayoutMode = this.mStackFromBottom ? AbsListView.LAYOUT_FORCE_BOTTOM : AbsListView.LAYOUT_FORCE_TOP;
                this.mSelectedPosition = AbsListView.INVALID_POSITION;
                this.mSelectedRowId = AbsListView.INVALID_ROW_ID;
                this.mNextSelectedPosition = AbsListView.INVALID_POSITION;
                this.mNextSelectedRowId = AbsListView.INVALID_ROW_ID;
                this.mNeedSync = false;
                this.mPendingSync = null;
                this.mSelectorPosition = AbsListView.INVALID_POSITION;
                this.checkSelectionChanged();
            }
            onDisplayHint(hint) {
                super.onDisplayHint(hint);
                this.mPopupHidden = hint == AbsListView.INVISIBLE;
            }
            dismissPopup() {
            }
            showPopup() {
            }
            positionPopup() {
            }
            static getDistance(source, dest, direction) {
                let sX, sY;
                let dX, dY;
                switch (direction) {
                    case View.FOCUS_RIGHT:
                        sX = source.right;
                        sY = source.top + source.height() / 2;
                        dX = dest.left;
                        dY = dest.top + dest.height() / 2;
                        break;
                    case View.FOCUS_DOWN:
                        sX = source.left + source.width() / 2;
                        sY = source.bottom;
                        dX = dest.left + dest.width() / 2;
                        dY = dest.top;
                        break;
                    case View.FOCUS_LEFT:
                        sX = source.left;
                        sY = source.top + source.height() / 2;
                        dX = dest.right;
                        dY = dest.top + dest.height() / 2;
                        break;
                    case View.FOCUS_UP:
                        sX = source.left + source.width() / 2;
                        sY = source.top;
                        dX = dest.left + dest.width() / 2;
                        dY = dest.bottom;
                        break;
                    case View.FOCUS_FORWARD:
                    case View.FOCUS_BACKWARD:
                        sX = source.right + source.width() / 2;
                        sY = source.top + source.height() / 2;
                        dX = dest.left + dest.width() / 2;
                        dY = dest.top + dest.height() / 2;
                        break;
                    default:
                        throw Error(`new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, " + "FOCUS_FORWARD, FOCUS_BACKWARD}.")`);
                }
                let deltaX = dX - sX;
                let deltaY = dY - sY;
                return deltaY * deltaY + deltaX * deltaX;
            }
            isInFilterMode() {
                return this.mFiltered;
            }
            hasTextFilter() {
                return this.mFiltered;
            }
            onGlobalLayout() {
                if (this.isShown()) {
                }
                else {
                }
            }
            generateDefaultLayoutParams() {
                return new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, 0);
            }
            generateLayoutParams(p) {
                return new AbsListView.LayoutParams(p);
            }
            checkLayoutParams(p) {
                return p instanceof AbsListView.LayoutParams;
            }
            setTranscriptMode(mode) {
                this.mTranscriptMode = mode;
            }
            getTranscriptMode() {
                return this.mTranscriptMode;
            }
            getSolidColor() {
                return this.mCacheColorHint;
            }
            setCacheColorHint(color) {
                if (color != this.mCacheColorHint) {
                    this.mCacheColorHint = color;
                    let count = this.getChildCount();
                    for (let i = 0; i < count; i++) {
                        this.getChildAt(i).setDrawingCacheBackgroundColor(color);
                    }
                    this.mRecycler.setCacheColorHint(color);
                }
            }
            getCacheColorHint() {
                return this.mCacheColorHint;
            }
            reclaimViews(views) {
                let childCount = this.getChildCount();
                let listener = this.mRecycler.mRecyclerListener;
                for (let i = 0; i < childCount; i++) {
                    let child = this.getChildAt(i);
                    let lp = child.getLayoutParams();
                    if (lp != null && this.mRecycler.shouldRecycleViewType(lp.viewType)) {
                        views.add(child);
                        if (listener != null) {
                            listener.onMovedToScrapHeap(child);
                        }
                    }
                }
                this.mRecycler.reclaimScrapViews(views);
                this.removeAllViewsInLayout();
            }
            finishGlows() {
            }
            setVisibleRangeHint(start, end) {
            }
            setRecyclerListener(listener) {
                this.mRecycler.mRecyclerListener = listener;
            }
            static retrieveFromScrap(scrapViews, position) {
                let size = scrapViews.size();
                if (size > 0) {
                    for (let i = 0; i < size; i++) {
                        let view = scrapViews.get(i);
                        if (view.getLayoutParams().scrappedFromPosition == position) {
                            scrapViews.remove(i);
                            return view;
                        }
                    }
                    return scrapViews.remove(size - 1);
                }
                else {
                    return null;
                }
            }
        }
        AbsListView.TAG_AbsListView = "AbsListView";
        AbsListView.TRANSCRIPT_MODE_DISABLED = 0;
        AbsListView.TRANSCRIPT_MODE_NORMAL = 1;
        AbsListView.TRANSCRIPT_MODE_ALWAYS_SCROLL = 2;
        AbsListView.TOUCH_MODE_REST = -1;
        AbsListView.TOUCH_MODE_DOWN = 0;
        AbsListView.TOUCH_MODE_TAP = 1;
        AbsListView.TOUCH_MODE_DONE_WAITING = 2;
        AbsListView.TOUCH_MODE_SCROLL = 3;
        AbsListView.TOUCH_MODE_FLING = 4;
        AbsListView.TOUCH_MODE_OVERSCROLL = 5;
        AbsListView.TOUCH_MODE_OVERFLING = 6;
        AbsListView.LAYOUT_NORMAL = 0;
        AbsListView.LAYOUT_FORCE_TOP = 1;
        AbsListView.LAYOUT_SET_SELECTION = 2;
        AbsListView.LAYOUT_FORCE_BOTTOM = 3;
        AbsListView.LAYOUT_SPECIFIC = 4;
        AbsListView.LAYOUT_SYNC = 5;
        AbsListView.LAYOUT_MOVE_SELECTION = 6;
        AbsListView.CHOICE_MODE_NONE = 0;
        AbsListView.CHOICE_MODE_SINGLE = 1;
        AbsListView.CHOICE_MODE_MULTIPLE = 2;
        AbsListView.CHOICE_MODE_MULTIPLE_MODAL = 3;
        AbsListView.OVERSCROLL_LIMIT_DIVISOR = 3;
        AbsListView.CHECK_POSITION_SEARCH_DISTANCE = 20;
        AbsListView.TOUCH_MODE_UNKNOWN = -1;
        AbsListView.TOUCH_MODE_ON = 0;
        AbsListView.TOUCH_MODE_OFF = 1;
        AbsListView.PROFILE_SCROLLING = false;
        AbsListView.PROFILE_FLINGING = false;
        AbsListView.INVALID_POINTER = -1;
        AbsListView.sLinearInterpolator = new LinearInterpolator();
        widget.AbsListView = AbsListView;
        (function (AbsListView) {
            var OnScrollListener;
            (function (OnScrollListener) {
                OnScrollListener.SCROLL_STATE_IDLE = 0;
                OnScrollListener.SCROLL_STATE_TOUCH_SCROLL = 1;
                OnScrollListener.SCROLL_STATE_FLING = 2;
            })(OnScrollListener = AbsListView.OnScrollListener || (AbsListView.OnScrollListener = {}));
            class WindowRunnnable {
                constructor(arg) {
                    this._AbsListView_this = arg;
                }
                rememberWindowAttachCount() {
                    this.mOriginalAttachCount = this._AbsListView_this.getWindowAttachCount();
                }
                sameWindow() {
                    return this._AbsListView_this.getWindowAttachCount() == this.mOriginalAttachCount;
                }
            }
            AbsListView.WindowRunnnable = WindowRunnnable;
            class PerformClick extends AbsListView.WindowRunnnable {
                constructor(arg) {
                    super(arg);
                    this.mClickMotionPosition = 0;
                    this._AbsListView_this = arg;
                }
                run() {
                    if (this._AbsListView_this.mDataChanged)
                        return;
                    const adapter = this._AbsListView_this.mAdapter;
                    const motionPosition = this.mClickMotionPosition;
                    if (adapter != null && this._AbsListView_this.mItemCount > 0 && motionPosition != AbsListView.INVALID_POSITION
                        && motionPosition < adapter.getCount() && this.sameWindow()) {
                        const view = this._AbsListView_this.getChildAt(motionPosition - this._AbsListView_this.mFirstPosition);
                        if (view != null) {
                            this._AbsListView_this.performItemClick(view, motionPosition, adapter.getItemId(motionPosition));
                        }
                    }
                }
            }
            AbsListView.PerformClick = PerformClick;
            class CheckForLongPress extends AbsListView.WindowRunnnable {
                constructor(arg) {
                    super(arg);
                    this._AbsListView_this = arg;
                }
                run() {
                    const motionPosition = this._AbsListView_this.mMotionPosition;
                    const child = this._AbsListView_this.getChildAt(motionPosition - this._AbsListView_this.mFirstPosition);
                    if (child != null) {
                        const longPressPosition = this._AbsListView_this.mMotionPosition;
                        const longPressId = this._AbsListView_this.mAdapter.getItemId(this._AbsListView_this.mMotionPosition);
                        let handled = false;
                        if (this.sameWindow() && !this._AbsListView_this.mDataChanged) {
                            handled = this._AbsListView_this.performLongPress(child, longPressPosition, longPressId);
                        }
                        if (handled) {
                            this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                            this._AbsListView_this.setPressed(false);
                            child.setPressed(false);
                        }
                        else {
                            this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                        }
                    }
                }
            }
            AbsListView.CheckForLongPress = CheckForLongPress;
            class CheckForKeyLongPress extends AbsListView.WindowRunnnable {
                constructor(arg) {
                    super(arg);
                    this._AbsListView_this = arg;
                }
                run() {
                    if (this._AbsListView_this.isPressed() && this._AbsListView_this.mSelectedPosition >= 0) {
                        let index = this._AbsListView_this.mSelectedPosition - this._AbsListView_this.mFirstPosition;
                        let v = this._AbsListView_this.getChildAt(index);
                        if (!this._AbsListView_this.mDataChanged) {
                            let handled = false;
                            if (this.sameWindow()) {
                                handled = this._AbsListView_this.performLongPress(v, this._AbsListView_this.mSelectedPosition, this._AbsListView_this.mSelectedRowId);
                            }
                            if (handled) {
                                this._AbsListView_this.setPressed(false);
                                v.setPressed(false);
                            }
                        }
                        else {
                            this._AbsListView_this.setPressed(false);
                            if (v != null)
                                v.setPressed(false);
                        }
                    }
                }
            }
            AbsListView.CheckForKeyLongPress = CheckForKeyLongPress;
            class CheckForTap {
                constructor(arg) {
                    this._AbsListView_this = arg;
                }
                run() {
                    if (this._AbsListView_this.mTouchMode == AbsListView.TOUCH_MODE_DOWN) {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_TAP;
                        const child = this._AbsListView_this.getChildAt(this._AbsListView_this.mMotionPosition - this._AbsListView_this.mFirstPosition);
                        if (child != null && !child.hasFocusable()) {
                            this._AbsListView_this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
                            if (!this._AbsListView_this.mDataChanged) {
                                child.setPressed(true);
                                this._AbsListView_this.setPressed(true);
                                this._AbsListView_this.layoutChildren();
                                this._AbsListView_this.positionSelector(this._AbsListView_this.mMotionPosition, child);
                                this._AbsListView_this.refreshDrawableState();
                                const longPressTimeout = ViewConfiguration.getLongPressTimeout();
                                const longClickable = this._AbsListView_this.isLongClickable();
                                if (this._AbsListView_this.mSelector != null) {
                                    let d = this._AbsListView_this.mSelector.getCurrent();
                                }
                                if (longClickable) {
                                    if (this._AbsListView_this.mPendingCheckForLongPress_List == null) {
                                        this._AbsListView_this.mPendingCheckForLongPress_List = new AbsListView.CheckForLongPress(this._AbsListView_this);
                                    }
                                    this._AbsListView_this.mPendingCheckForLongPress_List.rememberWindowAttachCount();
                                    this._AbsListView_this.postDelayed(this._AbsListView_this.mPendingCheckForLongPress_List, longPressTimeout);
                                }
                                else {
                                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                                }
                            }
                            else {
                                this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                            }
                        }
                    }
                }
            }
            AbsListView.CheckForTap = CheckForTap;
            class FlingRunnable {
                constructor(arg) {
                    this.mLastFlingY = 0;
                    this.mCheckFlywheel = (() => {
                        const _this = this;
                        class _Inner {
                            run() {
                                const activeId = _this._AbsListView_this.mActivePointerId;
                                const vt = _this._AbsListView_this.mVelocityTracker;
                                const scroller = _this.mScroller;
                                if (vt == null || activeId == AbsListView.INVALID_POINTER) {
                                    return;
                                }
                                vt.computeCurrentVelocity(1000, _this._AbsListView_this.mMaximumVelocity);
                                const yvel = -vt.getYVelocity(activeId);
                                if (Math.abs(yvel) >= _this._AbsListView_this.mMinimumVelocity && scroller.isScrollingInDirection(0, yvel)) {
                                    _this._AbsListView_this.postDelayed(_this, FlingRunnable.FLYWHEEL_TIMEOUT);
                                }
                                else {
                                    _this.endFling();
                                    _this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                                    _this._AbsListView_this.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                                }
                            }
                        }
                        return new _Inner();
                    })();
                    this._AbsListView_this = arg;
                    this.mScroller = new OverScroller();
                }
                start(initialVelocity) {
                    let initialY = initialVelocity < 0 ? Integer.MAX_VALUE : 0;
                    this.mLastFlingY = initialY;
                    this.mScroller.setInterpolator(null);
                    this.mScroller.fling(0, initialY, 0, initialVelocity, 0, Integer.MAX_VALUE, 0, Integer.MAX_VALUE);
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_FLING;
                    this._AbsListView_this.postOnAnimation(this);
                    if (AbsListView.PROFILE_FLINGING) {
                        if (!this._AbsListView_this.mFlingProfilingStarted) {
                            this._AbsListView_this.mFlingProfilingStarted = true;
                        }
                    }
                }
                startSpringback() {
                    if (this.mScroller.springBack(0, this._AbsListView_this.mScrollY, 0, 0, 0, 0)) {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                        this._AbsListView_this.invalidate();
                        this._AbsListView_this.postOnAnimation(this);
                    }
                    else {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        this._AbsListView_this.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                }
                startOverfling(initialVelocity) {
                    this.mScroller.setInterpolator(null);
                    let minY = Integer.MIN_VALUE, maxY = Integer.MAX_VALUE;
                    if (this._AbsListView_this.mScrollY < 0)
                        minY = 0;
                    else if (this._AbsListView_this.mScrollY > 0)
                        maxY = 0;
                    this.mScroller.fling(0, this._AbsListView_this.mScrollY, 0, initialVelocity, 0, 0, minY, maxY, 0, this._AbsListView_this.getHeight());
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                    this._AbsListView_this.invalidate();
                    this._AbsListView_this.postOnAnimation(this);
                }
                edgeReached(delta) {
                    this.mScroller.notifyVerticalEdgeReached(this._AbsListView_this.mScrollY, 0, this._AbsListView_this.mOverflingDistance);
                    const overscrollMode = this._AbsListView_this.getOverScrollMode();
                    if (overscrollMode == AbsListView.OVER_SCROLL_ALWAYS || (overscrollMode == AbsListView.OVER_SCROLL_IF_CONTENT_SCROLLS && !this._AbsListView_this.contentFits())) {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                    }
                    else {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        if (this._AbsListView_this.mPositionScroller != null) {
                            this._AbsListView_this.mPositionScroller.stop();
                        }
                    }
                    this._AbsListView_this.invalidate();
                    this._AbsListView_this.postOnAnimation(this);
                }
                startScroll(distance, duration, linear) {
                    let initialY = distance < 0 ? Integer.MAX_VALUE : 0;
                    this.mLastFlingY = initialY;
                    this.mScroller.setInterpolator(linear ? AbsListView.sLinearInterpolator : null);
                    this.mScroller.startScroll(0, initialY, 0, distance, duration);
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_FLING;
                    this._AbsListView_this.postOnAnimation(this);
                }
                endFling() {
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                    this._AbsListView_this.removeCallbacks(this);
                    this._AbsListView_this.removeCallbacks(this.mCheckFlywheel);
                    this._AbsListView_this.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    this._AbsListView_this.clearScrollingCache();
                    this.mScroller.abortAnimation();
                }
                flywheelTouch() {
                    this._AbsListView_this.postDelayed(this.mCheckFlywheel, FlingRunnable.FLYWHEEL_TIMEOUT);
                }
                run() {
                    switch (this._AbsListView_this.mTouchMode) {
                        default:
                            this.endFling();
                            return;
                        case AbsListView.TOUCH_MODE_SCROLL:
                            if (this.mScroller.isFinished()) {
                                return;
                            }
                        case AbsListView.TOUCH_MODE_FLING:
                            {
                                if (this._AbsListView_this.mDataChanged) {
                                    this._AbsListView_this.layoutChildren();
                                }
                                if (this._AbsListView_this.mItemCount == 0 || this._AbsListView_this.getChildCount() == 0) {
                                    this.endFling();
                                    return;
                                }
                                const scroller = this.mScroller;
                                let more = scroller.computeScrollOffset();
                                const y = scroller.getCurrY();
                                let delta = this.mLastFlingY - y;
                                if (delta > 0) {
                                    this._AbsListView_this.mMotionPosition = this._AbsListView_this.mFirstPosition;
                                    const firstView = this._AbsListView_this.getChildAt(0);
                                    this._AbsListView_this.mMotionViewOriginalTop = firstView.getTop();
                                    delta = Math.min(this._AbsListView_this.getHeight() - this._AbsListView_this.mPaddingBottom - this._AbsListView_this.mPaddingTop - 1, delta);
                                }
                                else {
                                    let offsetToLast = this._AbsListView_this.getChildCount() - 1;
                                    this._AbsListView_this.mMotionPosition = this._AbsListView_this.mFirstPosition + offsetToLast;
                                    const lastView = this._AbsListView_this.getChildAt(offsetToLast);
                                    this._AbsListView_this.mMotionViewOriginalTop = lastView.getTop();
                                    delta = Math.max(-(this._AbsListView_this.getHeight() - this._AbsListView_this.mPaddingBottom - this._AbsListView_this.mPaddingTop - 1), delta);
                                }
                                let motionView = this._AbsListView_this.getChildAt(this._AbsListView_this.mMotionPosition - this._AbsListView_this.mFirstPosition);
                                let oldTop = 0;
                                if (motionView != null) {
                                    oldTop = motionView.getTop();
                                }
                                const atEdge = this._AbsListView_this.trackMotionScroll(delta, delta);
                                const atEnd = atEdge && (delta != 0);
                                if (atEnd) {
                                    if (motionView != null) {
                                        let overshoot = -(delta - (motionView.getTop() - oldTop));
                                        this._AbsListView_this.overScrollBy(0, overshoot, 0, this._AbsListView_this.mScrollY, 0, 0, 0, this._AbsListView_this.mOverflingDistance, false);
                                    }
                                    if (more) {
                                        this.edgeReached(delta);
                                    }
                                    break;
                                }
                                if (more && !atEnd) {
                                    if (atEdge)
                                        this._AbsListView_this.invalidate();
                                    this.mLastFlingY = y;
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    this.endFling();
                                    if (AbsListView.PROFILE_FLINGING) {
                                        if (this._AbsListView_this.mFlingProfilingStarted) {
                                            this._AbsListView_this.mFlingProfilingStarted = false;
                                        }
                                    }
                                }
                                break;
                            }
                        case AbsListView.TOUCH_MODE_OVERFLING:
                            {
                                const scroller = this.mScroller;
                                if (scroller.computeScrollOffset()) {
                                    const scrollY = this._AbsListView_this.mScrollY;
                                    const currY = scroller.getCurrY();
                                    let deltaY = currY - scrollY;
                                    const crossDown = scrollY <= 0 && currY > 0;
                                    const crossUp = scrollY >= 0 && currY < 0;
                                    if (crossDown || crossUp) {
                                        let velocity = Math.floor(scroller.getCurrVelocity());
                                        if (crossUp)
                                            velocity = -velocity;
                                        scroller.abortAnimation();
                                        this.start(velocity);
                                        deltaY = -scrollY;
                                    }
                                    if (this._AbsListView_this.overScrollBy(0, deltaY, 0, scrollY, 0, 0, 0, this._AbsListView_this.mOverflingDistance, false)) {
                                        this.startSpringback();
                                    }
                                    else {
                                        this._AbsListView_this.invalidate();
                                        this._AbsListView_this.postOnAnimation(this);
                                    }
                                }
                                else {
                                    this.endFling();
                                }
                                break;
                            }
                    }
                }
            }
            FlingRunnable.FLYWHEEL_TIMEOUT = 40;
            AbsListView.FlingRunnable = FlingRunnable;
            class PositionScroller {
                constructor(arg) {
                    this.mMode = 0;
                    this.mTargetPos = 0;
                    this.mBoundPos = 0;
                    this.mLastSeenPos = 0;
                    this.mScrollDuration = 0;
                    this.mExtraScroll = 0;
                    this.mOffsetFromTop = 0;
                    this._AbsListView_this = arg;
                    this.mExtraScroll = ViewConfiguration.get().getScaledFadingEdgeLength();
                }
                start(position, boundPosition) {
                    if (boundPosition == null)
                        this._start_1(position);
                    else
                        this._start_2(position, boundPosition);
                }
                _start_1(position) {
                    this.stop();
                    if (this._AbsListView_this.mDataChanged) {
                        this._AbsListView_this.mPositionScrollAfterLayout = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.start(position);
                                }
                            }
                            return new _Inner();
                        })();
                        return;
                    }
                    const childCount = this._AbsListView_this.getChildCount();
                    if (childCount == 0) {
                        return;
                    }
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const lastPos = firstPos + childCount - 1;
                    let viewTravelCount;
                    let clampedPosition = Math.max(0, Math.min(this._AbsListView_this.getCount() - 1, position));
                    if (clampedPosition < firstPos) {
                        viewTravelCount = firstPos - clampedPosition + 1;
                        this.mMode = PositionScroller.MOVE_UP_POS;
                    }
                    else if (clampedPosition > lastPos) {
                        viewTravelCount = clampedPosition - lastPos + 1;
                        this.mMode = PositionScroller.MOVE_DOWN_POS;
                    }
                    else {
                        this.scrollToVisible(clampedPosition, AbsListView.INVALID_POSITION, PositionScroller.SCROLL_DURATION);
                        return;
                    }
                    if (viewTravelCount > 0) {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION / viewTravelCount;
                    }
                    else {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION;
                    }
                    this.mTargetPos = clampedPosition;
                    this.mBoundPos = AbsListView.INVALID_POSITION;
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this._AbsListView_this.postOnAnimation(this);
                }
                _start_2(position, boundPosition) {
                    this.stop();
                    if (boundPosition == AbsListView.INVALID_POSITION) {
                        this.start(position);
                        return;
                    }
                    if (this._AbsListView_this.mDataChanged) {
                        this._AbsListView_this.mPositionScrollAfterLayout = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.start(position, boundPosition);
                                }
                            }
                            return new _Inner();
                        })();
                        return;
                    }
                    const childCount = this._AbsListView_this.getChildCount();
                    if (childCount == 0) {
                        return;
                    }
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const lastPos = firstPos + childCount - 1;
                    let viewTravelCount;
                    let clampedPosition = Math.max(0, Math.min(this._AbsListView_this.getCount() - 1, position));
                    if (clampedPosition < firstPos) {
                        const boundPosFromLast = lastPos - boundPosition;
                        if (boundPosFromLast < 1) {
                            return;
                        }
                        const posTravel = firstPos - clampedPosition + 1;
                        const boundTravel = boundPosFromLast - 1;
                        if (boundTravel < posTravel) {
                            viewTravelCount = boundTravel;
                            this.mMode = PositionScroller.MOVE_UP_BOUND;
                        }
                        else {
                            viewTravelCount = posTravel;
                            this.mMode = PositionScroller.MOVE_UP_POS;
                        }
                    }
                    else if (clampedPosition > lastPos) {
                        const boundPosFromFirst = boundPosition - firstPos;
                        if (boundPosFromFirst < 1) {
                            return;
                        }
                        const posTravel = clampedPosition - lastPos + 1;
                        const boundTravel = boundPosFromFirst - 1;
                        if (boundTravel < posTravel) {
                            viewTravelCount = boundTravel;
                            this.mMode = PositionScroller.MOVE_DOWN_BOUND;
                        }
                        else {
                            viewTravelCount = posTravel;
                            this.mMode = PositionScroller.MOVE_DOWN_POS;
                        }
                    }
                    else {
                        this.scrollToVisible(clampedPosition, boundPosition, PositionScroller.SCROLL_DURATION);
                        return;
                    }
                    if (viewTravelCount > 0) {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION / viewTravelCount;
                    }
                    else {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION;
                    }
                    this.mTargetPos = clampedPosition;
                    this.mBoundPos = boundPosition;
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this._AbsListView_this.postOnAnimation(this);
                }
                startWithOffset(position, offset, duration = PositionScroller.SCROLL_DURATION) {
                    this.stop();
                    if (this._AbsListView_this.mDataChanged) {
                        const postOffset = offset;
                        this._AbsListView_this.mPositionScrollAfterLayout = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.startWithOffset(position, postOffset, duration);
                                }
                            }
                            return new _Inner();
                        })();
                        return;
                    }
                    const childCount = this._AbsListView_this.getChildCount();
                    if (childCount == 0) {
                        return;
                    }
                    offset += this._AbsListView_this.getPaddingTop();
                    this.mTargetPos = Math.max(0, Math.min(this._AbsListView_this.getCount() - 1, position));
                    this.mOffsetFromTop = offset;
                    this.mBoundPos = AbsListView.INVALID_POSITION;
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this.mMode = PositionScroller.MOVE_OFFSET;
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const lastPos = firstPos + childCount - 1;
                    let viewTravelCount;
                    if (this.mTargetPos < firstPos) {
                        viewTravelCount = firstPos - this.mTargetPos;
                    }
                    else if (this.mTargetPos > lastPos) {
                        viewTravelCount = this.mTargetPos - lastPos;
                    }
                    else {
                        const targetTop = this._AbsListView_this.getChildAt(this.mTargetPos - firstPos).getTop();
                        this._AbsListView_this.smoothScrollBy(targetTop - offset, duration, true);
                        return;
                    }
                    const screenTravelCount = viewTravelCount / childCount;
                    this.mScrollDuration = screenTravelCount < 1 ? duration : Math.floor((duration / screenTravelCount));
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this._AbsListView_this.postOnAnimation(this);
                }
                scrollToVisible(targetPos, boundPos, duration) {
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const childCount = this._AbsListView_this.getChildCount();
                    const lastPos = firstPos + childCount - 1;
                    const paddedTop = this._AbsListView_this.mListPadding.top;
                    const paddedBottom = this._AbsListView_this.getHeight() - this._AbsListView_this.mListPadding.bottom;
                    if (targetPos < firstPos || targetPos > lastPos) {
                        Log.w(AbsListView.TAG_AbsListView, "scrollToVisible called with targetPos " + targetPos + " not visible [" + firstPos + ", " + lastPos + "]");
                    }
                    if (boundPos < firstPos || boundPos > lastPos) {
                        boundPos = AbsListView.INVALID_POSITION;
                    }
                    const targetChild = this._AbsListView_this.getChildAt(targetPos - firstPos);
                    const targetTop = targetChild.getTop();
                    const targetBottom = targetChild.getBottom();
                    let scrollBy = 0;
                    if (targetBottom > paddedBottom) {
                        scrollBy = targetBottom - paddedBottom;
                    }
                    if (targetTop < paddedTop) {
                        scrollBy = targetTop - paddedTop;
                    }
                    if (scrollBy == 0) {
                        return;
                    }
                    if (boundPos >= 0) {
                        const boundChild = this._AbsListView_this.getChildAt(boundPos - firstPos);
                        const boundTop = boundChild.getTop();
                        const boundBottom = boundChild.getBottom();
                        const absScroll = Math.abs(scrollBy);
                        if (scrollBy < 0 && boundBottom + absScroll > paddedBottom) {
                            scrollBy = Math.max(0, boundBottom - paddedBottom);
                        }
                        else if (scrollBy > 0 && boundTop - absScroll < paddedTop) {
                            scrollBy = Math.min(0, boundTop - paddedTop);
                        }
                    }
                    this._AbsListView_this.smoothScrollBy(scrollBy, duration);
                }
                stop() {
                    this._AbsListView_this.removeCallbacks(this);
                }
                run() {
                    const listHeight = this._AbsListView_this.getHeight();
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    switch (this.mMode) {
                        case PositionScroller.MOVE_DOWN_POS:
                            {
                                const lastViewIndex = this._AbsListView_this.getChildCount() - 1;
                                const lastPos = firstPos + lastViewIndex;
                                if (lastViewIndex < 0) {
                                    return;
                                }
                                if (lastPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const lastView = this._AbsListView_this.getChildAt(lastViewIndex);
                                const lastViewHeight = lastView.getHeight();
                                const lastViewTop = lastView.getTop();
                                const lastViewPixelsShowing = listHeight - lastViewTop;
                                const extraScroll = lastPos < this._AbsListView_this.mItemCount - 1 ? Math.max(this._AbsListView_this.mListPadding.bottom, this.mExtraScroll) : this._AbsListView_this.mListPadding.bottom;
                                const scrollBy = lastViewHeight - lastViewPixelsShowing + extraScroll;
                                this._AbsListView_this.smoothScrollBy(scrollBy, this.mScrollDuration, true);
                                this.mLastSeenPos = lastPos;
                                if (lastPos < this.mTargetPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                break;
                            }
                        case PositionScroller.MOVE_DOWN_BOUND:
                            {
                                const nextViewIndex = 1;
                                const childCount = this._AbsListView_this.getChildCount();
                                if (firstPos == this.mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= this._AbsListView_this.mItemCount) {
                                    return;
                                }
                                const nextPos = firstPos + nextViewIndex;
                                if (nextPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const nextView = this._AbsListView_this.getChildAt(nextViewIndex);
                                const nextViewHeight = nextView.getHeight();
                                const nextViewTop = nextView.getTop();
                                const extraScroll = Math.max(this._AbsListView_this.mListPadding.bottom, this.mExtraScroll);
                                if (nextPos < this.mBoundPos) {
                                    this._AbsListView_this.smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), this.mScrollDuration, true);
                                    this.mLastSeenPos = nextPos;
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    if (nextViewTop > extraScroll) {
                                        this._AbsListView_this.smoothScrollBy(nextViewTop - extraScroll, this.mScrollDuration, true);
                                    }
                                }
                                break;
                            }
                        case PositionScroller.MOVE_UP_POS:
                            {
                                if (firstPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const firstView = this._AbsListView_this.getChildAt(0);
                                if (firstView == null) {
                                    return;
                                }
                                const firstViewTop = firstView.getTop();
                                const extraScroll = firstPos > 0 ? Math.max(this.mExtraScroll, this._AbsListView_this.mListPadding.top) : this._AbsListView_this.mListPadding.top;
                                this._AbsListView_this.smoothScrollBy(firstViewTop - extraScroll, this.mScrollDuration, true);
                                this.mLastSeenPos = firstPos;
                                if (firstPos > this.mTargetPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                break;
                            }
                        case PositionScroller.MOVE_UP_BOUND:
                            {
                                const lastViewIndex = this._AbsListView_this.getChildCount() - 2;
                                if (lastViewIndex < 0) {
                                    return;
                                }
                                const lastPos = firstPos + lastViewIndex;
                                if (lastPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const lastView = this._AbsListView_this.getChildAt(lastViewIndex);
                                const lastViewHeight = lastView.getHeight();
                                const lastViewTop = lastView.getTop();
                                const lastViewPixelsShowing = listHeight - lastViewTop;
                                const extraScroll = Math.max(this._AbsListView_this.mListPadding.top, this.mExtraScroll);
                                this.mLastSeenPos = lastPos;
                                if (lastPos > this.mBoundPos) {
                                    this._AbsListView_this.smoothScrollBy(-(lastViewPixelsShowing - extraScroll), this.mScrollDuration, true);
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    const bottom = listHeight - extraScroll;
                                    const lastViewBottom = lastViewTop + lastViewHeight;
                                    if (bottom > lastViewBottom) {
                                        this._AbsListView_this.smoothScrollBy(-(bottom - lastViewBottom), this.mScrollDuration, true);
                                    }
                                }
                                break;
                            }
                        case PositionScroller.MOVE_OFFSET:
                            {
                                if (this.mLastSeenPos == firstPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                this.mLastSeenPos = firstPos;
                                const childCount = this._AbsListView_this.getChildCount();
                                const position = this.mTargetPos;
                                const lastPos = firstPos + childCount - 1;
                                let viewTravelCount = 0;
                                if (position < firstPos) {
                                    viewTravelCount = firstPos - position + 1;
                                }
                                else if (position > lastPos) {
                                    viewTravelCount = position - lastPos;
                                }
                                const screenTravelCount = viewTravelCount / childCount;
                                const modifier = Math.min(Math.abs(screenTravelCount), 1.);
                                if (position < firstPos) {
                                    const distance = Math.floor((-this._AbsListView_this.getHeight() * modifier));
                                    const duration = Math.floor((this.mScrollDuration * modifier));
                                    this._AbsListView_this.smoothScrollBy(distance, duration, true);
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else if (position > lastPos) {
                                    const distance = Math.floor((this._AbsListView_this.getHeight() * modifier));
                                    const duration = Math.floor((this.mScrollDuration * modifier));
                                    this._AbsListView_this.smoothScrollBy(distance, duration, true);
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    const targetTop = this._AbsListView_this.getChildAt(position - firstPos).getTop();
                                    const distance = targetTop - this.mOffsetFromTop;
                                    const duration = Math.floor((this.mScrollDuration * (Math.abs(distance) / this._AbsListView_this.getHeight())));
                                    this._AbsListView_this.smoothScrollBy(distance, duration, true);
                                }
                                break;
                            }
                        default:
                            break;
                    }
                }
            }
            PositionScroller.SCROLL_DURATION = 200;
            PositionScroller.MOVE_DOWN_POS = 1;
            PositionScroller.MOVE_UP_POS = 2;
            PositionScroller.MOVE_DOWN_BOUND = 3;
            PositionScroller.MOVE_UP_BOUND = 4;
            PositionScroller.MOVE_OFFSET = 5;
            AbsListView.PositionScroller = PositionScroller;
            class AdapterDataSetObserver extends AdapterView.AdapterDataSetObserver {
                constructor(arg) {
                    super(arg);
                    this._AbsListView_this = arg;
                }
                onChanged() {
                    super.onChanged();
                }
                onInvalidated() {
                    super.onInvalidated();
                }
            }
            AbsListView.AdapterDataSetObserver = AdapterDataSetObserver;
            class LayoutParams extends ViewGroup.LayoutParams {
                constructor(...args) {
                    super();
                    this.viewType = 0;
                    this.scrappedFromPosition = 0;
                    this.itemId = -1;
                    if (args.length === 1) {
                        super(args[0]);
                    }
                    else if (args.length === 2) {
                        super(args[0], args[1]);
                    }
                    else if (args.length === 3) {
                        super(args[0], args[1]);
                        this.viewType = args[2];
                    }
                }
            }
            AbsListView.LayoutParams = LayoutParams;
            class RecycleBin {
                constructor(arg) {
                    this.mFirstActivePosition = 0;
                    this.mActiveViews = [];
                    this.mViewTypeCount = 0;
                    this._AbsListView_this = arg;
                }
                setViewTypeCount(viewTypeCount) {
                    if (viewTypeCount < 1) {
                        throw Error(`new IllegalArgumentException("Can't have a viewTypeCount < 1")`);
                    }
                    let scrapViews = new Array(viewTypeCount);
                    for (let i = 0; i < viewTypeCount; i++) {
                        scrapViews[i] = new ArrayList();
                    }
                    this.mViewTypeCount = viewTypeCount;
                    this.mCurrentScrap = scrapViews[0];
                    this.mScrapViews = scrapViews;
                }
                markChildrenDirty() {
                    if (this.mViewTypeCount == 1) {
                        const scrap = this.mCurrentScrap;
                        const scrapCount = scrap.size();
                        for (let i = 0; i < scrapCount; i++) {
                            scrap.get(i).forceLayout();
                        }
                    }
                    else {
                        const typeCount = this.mViewTypeCount;
                        for (let i = 0; i < typeCount; i++) {
                            const scrap = this.mScrapViews[i];
                            const scrapCount = scrap.size();
                            for (let j = 0; j < scrapCount; j++) {
                                scrap.get(j).forceLayout();
                            }
                        }
                    }
                    if (this.mTransientStateViews != null) {
                        const count = this.mTransientStateViews.size();
                        for (let i = 0; i < count; i++) {
                            this.mTransientStateViews.valueAt(i).forceLayout();
                        }
                    }
                    if (this.mTransientStateViewsById != null) {
                        const count = this.mTransientStateViewsById.size();
                        for (let i = 0; i < count; i++) {
                            this.mTransientStateViewsById.valueAt(i).forceLayout();
                        }
                    }
                }
                shouldRecycleViewType(viewType) {
                    return viewType >= 0;
                }
                clear() {
                    if (this.mViewTypeCount == 1) {
                        const scrap = this.mCurrentScrap;
                        const scrapCount = scrap.size();
                        for (let i = 0; i < scrapCount; i++) {
                            this._AbsListView_this.removeDetachedView(scrap.remove(scrapCount - 1 - i), false);
                        }
                    }
                    else {
                        const typeCount = this.mViewTypeCount;
                        for (let i = 0; i < typeCount; i++) {
                            const scrap = this.mScrapViews[i];
                            const scrapCount = scrap.size();
                            for (let j = 0; j < scrapCount; j++) {
                                this._AbsListView_this.removeDetachedView(scrap.remove(scrapCount - 1 - j), false);
                            }
                        }
                    }
                    if (this.mTransientStateViews != null) {
                        this.mTransientStateViews.clear();
                    }
                    if (this.mTransientStateViewsById != null) {
                        this.mTransientStateViewsById.clear();
                    }
                }
                fillActiveViews(childCount, firstActivePosition) {
                    if (this.mActiveViews.length < childCount) {
                        this.mActiveViews = new Array(childCount);
                    }
                    this.mFirstActivePosition = firstActivePosition;
                    const activeViews = this.mActiveViews;
                    for (let i = 0; i < childCount; i++) {
                        let child = this._AbsListView_this.getChildAt(i);
                        let lp = child.getLayoutParams();
                        if (lp != null && lp.viewType != AbsListView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                            activeViews[i] = child;
                        }
                    }
                }
                getActiveView(position) {
                    let index = position - this.mFirstActivePosition;
                    const activeViews = this.mActiveViews;
                    if (index >= 0 && index < activeViews.length) {
                        const match = activeViews[index];
                        activeViews[index] = null;
                        return match;
                    }
                    return null;
                }
                getTransientStateView(position) {
                    if (this._AbsListView_this.mAdapter != null && this._AbsListView_this.mAdapterHasStableIds && this.mTransientStateViewsById != null) {
                        let id = this._AbsListView_this.mAdapter.getItemId(position);
                        let result = this.mTransientStateViewsById.get(id);
                        this.mTransientStateViewsById.remove(id);
                        return result;
                    }
                    if (this.mTransientStateViews != null) {
                        const index = this.mTransientStateViews.indexOfKey(position);
                        if (index >= 0) {
                            let result = this.mTransientStateViews.valueAt(index);
                            this.mTransientStateViews.removeAt(index);
                            return result;
                        }
                    }
                    return null;
                }
                clearTransientStateViews() {
                    if (this.mTransientStateViews != null) {
                        this.mTransientStateViews.clear();
                    }
                    if (this.mTransientStateViewsById != null) {
                        this.mTransientStateViewsById.clear();
                    }
                }
                getScrapView(position) {
                    if (this.mViewTypeCount == 1) {
                        return AbsListView.retrieveFromScrap(this.mCurrentScrap, position);
                    }
                    else {
                        let whichScrap = this._AbsListView_this.mAdapter.getItemViewType(position);
                        if (whichScrap >= 0 && whichScrap < this.mScrapViews.length) {
                            return AbsListView.retrieveFromScrap(this.mScrapViews[whichScrap], position);
                        }
                    }
                    return null;
                }
                addScrapView(scrap, position) {
                    const lp = scrap.getLayoutParams();
                    if (lp == null) {
                        return;
                    }
                    lp.scrappedFromPosition = position;
                    const viewType = lp.viewType;
                    if (!this.shouldRecycleViewType(viewType)) {
                        return;
                    }
                    scrap.dispatchStartTemporaryDetach();
                    const scrapHasTransientState = scrap.hasTransientState();
                    if (scrapHasTransientState) {
                        if (this._AbsListView_this.mAdapter != null && this._AbsListView_this.mAdapterHasStableIds) {
                            if (this.mTransientStateViewsById == null) {
                                this.mTransientStateViewsById = new LongSparseArray();
                            }
                            this.mTransientStateViewsById.put(lp.itemId, scrap);
                        }
                        else if (!this._AbsListView_this.mDataChanged) {
                            if (this.mTransientStateViews == null) {
                                this.mTransientStateViews = new SparseArray();
                            }
                            this.mTransientStateViews.put(position, scrap);
                        }
                        else {
                            if (this.mSkippedScrap == null) {
                                this.mSkippedScrap = new ArrayList();
                            }
                            this.mSkippedScrap.add(scrap);
                        }
                    }
                    else {
                        if (this.mViewTypeCount == 1) {
                            this.mCurrentScrap.add(scrap);
                        }
                        else {
                            this.mScrapViews[viewType].add(scrap);
                        }
                        if (this.mRecyclerListener != null) {
                            this.mRecyclerListener.onMovedToScrapHeap(scrap);
                        }
                    }
                }
                removeSkippedScrap() {
                    if (this.mSkippedScrap == null) {
                        return;
                    }
                    const count = this.mSkippedScrap.size();
                    for (let i = 0; i < count; i++) {
                        this._AbsListView_this.removeDetachedView(this.mSkippedScrap.get(i), false);
                    }
                    this.mSkippedScrap.clear();
                }
                scrapActiveViews() {
                    const activeViews = this.mActiveViews;
                    const hasListener = this.mRecyclerListener != null;
                    const multipleScraps = this.mViewTypeCount > 1;
                    let scrapViews = this.mCurrentScrap;
                    const count = activeViews.length;
                    for (let i = count - 1; i >= 0; i--) {
                        const victim = activeViews[i];
                        if (victim != null) {
                            const lp = victim.getLayoutParams();
                            let whichScrap = lp.viewType;
                            activeViews[i] = null;
                            const scrapHasTransientState = victim.hasTransientState();
                            if (!this.shouldRecycleViewType(whichScrap) || scrapHasTransientState) {
                                if (whichScrap != AbsListView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState) {
                                    this._AbsListView_this.removeDetachedView(victim, false);
                                }
                                if (scrapHasTransientState) {
                                    if (this._AbsListView_this.mAdapter != null && this._AbsListView_this.mAdapterHasStableIds) {
                                        if (this.mTransientStateViewsById == null) {
                                            this.mTransientStateViewsById = new LongSparseArray();
                                        }
                                        let id = this._AbsListView_this.mAdapter.getItemId(this.mFirstActivePosition + i);
                                        this.mTransientStateViewsById.put(id, victim);
                                    }
                                    else {
                                        if (this.mTransientStateViews == null) {
                                            this.mTransientStateViews = new SparseArray();
                                        }
                                        this.mTransientStateViews.put(this.mFirstActivePosition + i, victim);
                                    }
                                }
                                continue;
                            }
                            if (multipleScraps) {
                                scrapViews = this.mScrapViews[whichScrap];
                            }
                            victim.dispatchStartTemporaryDetach();
                            lp.scrappedFromPosition = this.mFirstActivePosition + i;
                            scrapViews.add(victim);
                            if (hasListener) {
                                this.mRecyclerListener.onMovedToScrapHeap(victim);
                            }
                        }
                    }
                    this.pruneScrapViews();
                }
                pruneScrapViews() {
                    const maxViews = this.mActiveViews.length;
                    const viewTypeCount = this.mViewTypeCount;
                    const scrapViews = this.mScrapViews;
                    for (let i = 0; i < viewTypeCount; ++i) {
                        const scrapPile = scrapViews[i];
                        let size = scrapPile.size();
                        const extras = size - maxViews;
                        size--;
                        for (let j = 0; j < extras; j++) {
                            this._AbsListView_this.removeDetachedView(scrapPile.remove(size--), false);
                        }
                    }
                    if (this.mTransientStateViews != null) {
                        for (let i = 0; i < this.mTransientStateViews.size(); i++) {
                            const v = this.mTransientStateViews.valueAt(i);
                            if (!v.hasTransientState()) {
                                this.mTransientStateViews.removeAt(i);
                                i--;
                            }
                        }
                    }
                    if (this.mTransientStateViewsById != null) {
                        for (let i = 0; i < this.mTransientStateViewsById.size(); i++) {
                            const v = this.mTransientStateViewsById.valueAt(i);
                            if (!v.hasTransientState()) {
                                this.mTransientStateViewsById.removeAt(i);
                                i--;
                            }
                        }
                    }
                }
                reclaimScrapViews(views) {
                    if (this.mViewTypeCount == 1) {
                        views.addAll(this.mCurrentScrap);
                    }
                    else {
                        const viewTypeCount = this.mViewTypeCount;
                        const scrapViews = this.mScrapViews;
                        for (let i = 0; i < viewTypeCount; ++i) {
                            const scrapPile = scrapViews[i];
                            views.addAll(scrapPile);
                        }
                    }
                }
                setCacheColorHint(color) {
                    if (this.mViewTypeCount == 1) {
                        const scrap = this.mCurrentScrap;
                        const scrapCount = scrap.size();
                        for (let i = 0; i < scrapCount; i++) {
                            scrap.get(i).setDrawingCacheBackgroundColor(color);
                        }
                    }
                    else {
                        const typeCount = this.mViewTypeCount;
                        for (let i = 0; i < typeCount; i++) {
                            const scrap = this.mScrapViews[i];
                            const scrapCount = scrap.size();
                            for (let j = 0; j < scrapCount; j++) {
                                scrap.get(j).setDrawingCacheBackgroundColor(color);
                            }
                        }
                    }
                    const activeViews = this.mActiveViews;
                    const count = activeViews.length;
                    for (let i = 0; i < count; ++i) {
                        const victim = activeViews[i];
                        if (victim != null) {
                            victim.setDrawingCacheBackgroundColor(color);
                        }
                    }
                }
            }
            AbsListView.RecycleBin = RecycleBin;
        })(AbsListView = widget.AbsListView || (widget.AbsListView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/WrapperListAdapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ArrayList = java.util.ArrayList;
        var AdapterView = android.widget.AdapterView;
        class HeaderViewListAdapter {
            constructor(headerViewInfos, footerViewInfos, adapter) {
                this.mAdapter = adapter;
                this.mIsFilterable = false;
                if (headerViewInfos == null) {
                    this.mHeaderViewInfos = HeaderViewListAdapter.EMPTY_INFO_LIST;
                }
                else {
                    this.mHeaderViewInfos = headerViewInfos;
                }
                if (footerViewInfos == null) {
                    this.mFooterViewInfos = HeaderViewListAdapter.EMPTY_INFO_LIST;
                }
                else {
                    this.mFooterViewInfos = footerViewInfos;
                }
                this.mAreAllFixedViewsSelectable = this.areAllListInfosSelectable(this.mHeaderViewInfos) && this.areAllListInfosSelectable(this.mFooterViewInfos);
            }
            getHeadersCount() {
                return this.mHeaderViewInfos.size();
            }
            getFootersCount() {
                return this.mFooterViewInfos.size();
            }
            isEmpty() {
                return this.mAdapter == null || this.mAdapter.isEmpty();
            }
            areAllListInfosSelectable(infos) {
                if (infos != null) {
                    for (let info of infos.array) {
                        if (!info.isSelectable) {
                            return false;
                        }
                    }
                }
                return true;
            }
            removeHeader(v) {
                for (let i = 0; i < this.mHeaderViewInfos.size(); i++) {
                    let info = this.mHeaderViewInfos.get(i);
                    if (info.view == v) {
                        this.mHeaderViewInfos.remove(i);
                        this.mAreAllFixedViewsSelectable = this.areAllListInfosSelectable(this.mHeaderViewInfos) && this.areAllListInfosSelectable(this.mFooterViewInfos);
                        return true;
                    }
                }
                return false;
            }
            removeFooter(v) {
                for (let i = 0; i < this.mFooterViewInfos.size(); i++) {
                    let info = this.mFooterViewInfos.get(i);
                    if (info.view == v) {
                        this.mFooterViewInfos.remove(i);
                        this.mAreAllFixedViewsSelectable = this.areAllListInfosSelectable(this.mHeaderViewInfos) && this.areAllListInfosSelectable(this.mFooterViewInfos);
                        return true;
                    }
                }
                return false;
            }
            getCount() {
                if (this.mAdapter != null) {
                    return this.getFootersCount() + this.getHeadersCount() + this.mAdapter.getCount();
                }
                else {
                    return this.getFootersCount() + this.getHeadersCount();
                }
            }
            areAllItemsEnabled() {
                if (this.mAdapter != null) {
                    return this.mAreAllFixedViewsSelectable && this.mAdapter.areAllItemsEnabled();
                }
                else {
                    return true;
                }
            }
            isEnabled(position) {
                let numHeaders = this.getHeadersCount();
                if (position < numHeaders) {
                    return this.mHeaderViewInfos.get(position).isSelectable;
                }
                const adjPosition = position - numHeaders;
                let adapterCount = 0;
                if (this.mAdapter != null) {
                    adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.isEnabled(adjPosition);
                    }
                }
                return this.mFooterViewInfos.get(adjPosition - adapterCount).isSelectable;
            }
            getItem(position) {
                let numHeaders = this.getHeadersCount();
                if (position < numHeaders) {
                    return this.mHeaderViewInfos.get(position).data;
                }
                const adjPosition = position - numHeaders;
                let adapterCount = 0;
                if (this.mAdapter != null) {
                    adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getItem(adjPosition);
                    }
                }
                return this.mFooterViewInfos.get(adjPosition - adapterCount).data;
            }
            getItemId(position) {
                let numHeaders = this.getHeadersCount();
                if (this.mAdapter != null && position >= numHeaders) {
                    let adjPosition = position - numHeaders;
                    let adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getItemId(adjPosition);
                    }
                }
                return -1;
            }
            hasStableIds() {
                if (this.mAdapter != null) {
                    return this.mAdapter.hasStableIds();
                }
                return false;
            }
            getView(position, convertView, parent) {
                let numHeaders = this.getHeadersCount();
                if (position < numHeaders) {
                    return this.mHeaderViewInfos.get(position).view;
                }
                const adjPosition = position - numHeaders;
                let adapterCount = 0;
                if (this.mAdapter != null) {
                    adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getView(adjPosition, convertView, parent);
                    }
                }
                return this.mFooterViewInfos.get(adjPosition - adapterCount).view;
            }
            getItemViewType(position) {
                let numHeaders = this.getHeadersCount();
                if (this.mAdapter != null && position >= numHeaders) {
                    let adjPosition = position - numHeaders;
                    let adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getItemViewType(adjPosition);
                    }
                }
                return AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER;
            }
            getViewTypeCount() {
                if (this.mAdapter != null) {
                    return this.mAdapter.getViewTypeCount();
                }
                return 1;
            }
            registerDataSetObserver(observer) {
                if (this.mAdapter != null) {
                    this.mAdapter.registerDataSetObserver(observer);
                }
            }
            unregisterDataSetObserver(observer) {
                if (this.mAdapter != null) {
                    this.mAdapter.unregisterDataSetObserver(observer);
                }
            }
            getFilter() {
                return null;
            }
            getWrappedAdapter() {
                return this.mAdapter;
            }
        }
        HeaderViewListAdapter.EMPTY_INFO_LIST = new ArrayList();
        widget.HeaderViewListAdapter = HeaderViewListAdapter;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="../../java/util/ArrayList.ts"/>
var android;
(function (android) {
    var database;
    (function (database) {
        var ArrayList = java.util.ArrayList;
        class Observable {
            constructor() {
                this.mObservers = new ArrayList();
            }
            registerObserver(observer) {
                if (observer == null) {
                    throw new Error("The observer is null.");
                }
                if (this.mObservers.contains(observer)) {
                    throw new Error("Observer " + observer + " is already registered.");
                }
                this.mObservers.add(observer);
            }
            unregisterObserver(observer) {
                if (observer == null) {
                    throw new Error("The observer is null.");
                }
                let index = this.mObservers.indexOf(observer);
                if (index == -1) {
                    throw new Error("Observer " + observer + " was not registered.");
                }
                this.mObservers.remove(index);
            }
            unregisterAll() {
                this.mObservers.clear();
            }
        }
        database.Observable = Observable;
    })(database = android.database || (android.database = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="Observable.ts"/>
///<reference path="DataSetObserver.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
var android;
(function (android) {
    var database;
    (function (database) {
        var Observable = android.database.Observable;
        class DataSetObservable extends Observable {
            notifyChanged() {
                for (let i = this.mObservers.size() - 1; i >= 0; i--) {
                    this.mObservers.get(i).onChanged();
                }
            }
            notifyInvalidated() {
                for (let i = this.mObservers.size() - 1; i >= 0; i--) {
                    this.mObservers.get(i).onInvalidated();
                }
            }
        }
        database.DataSetObservable = DataSetObservable;
    })(database = android.database || (android.database = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/SpinnerAdapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var DataSetObservable = android.database.DataSetObservable;
        class BaseAdapter {
            constructor() {
                this.mDataSetObservable = new DataSetObservable();
            }
            hasStableIds() {
                return false;
            }
            registerDataSetObserver(observer) {
                this.mDataSetObservable.registerObserver(observer);
            }
            unregisterDataSetObserver(observer) {
                this.mDataSetObservable.unregisterObserver(observer);
            }
            notifyDataSetChanged() {
                this.mDataSetObservable.notifyChanged();
            }
            notifyDataSetInvalidated() {
                this.mDataSetObservable.notifyInvalidated();
            }
            areAllItemsEnabled() {
                return true;
            }
            isEnabled(position) {
                return true;
            }
            getDropDownView(position, convertView, parent) {
                return this.getView(position, convertView, parent);
            }
            getItemViewType(position) {
                return 0;
            }
            getViewTypeCount() {
                return 1;
            }
            isEmpty() {
                return this.getCount() == 0;
            }
        }
        widget.BaseAdapter = BaseAdapter;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/PixelFormat.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/util/MathUtils.ts"/>
///<reference path="../../android/util/SparseBooleanArray.ts"/>
///<reference path="../../android/view/FocusFinder.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/ViewRootImpl.ts"/>
///<reference path="../../android/os/Trace.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/HeaderViewListAdapter.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/WrapperListAdapter.ts"/>
///<reference path="../../android/widget/BaseAdapter.ts"/>
///<reference path="../../android/R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Paint = android.graphics.Paint;
        var PixelFormat = android.graphics.PixelFormat;
        var Rect = android.graphics.Rect;
        var MathUtils = android.util.MathUtils;
        var FocusFinder = android.view.FocusFinder;
        var KeyEvent = android.view.KeyEvent;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Trace = android.os.Trace;
        var ArrayList = java.util.ArrayList;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        var AbsListView = android.widget.AbsListView;
        var AdapterView = android.widget.AdapterView;
        var HeaderViewListAdapter = android.widget.HeaderViewListAdapter;
        class ListView extends AbsListView {
            constructor(context, bindElement, defStyle = android.R.attr.listViewStyle) {
                super(context, bindElement, null);
                this.mHeaderViewInfos = new ArrayList();
                this.mFooterViewInfos = new ArrayList();
                this.mDividerHeight = 0;
                this.mIsCacheColorOpaque = false;
                this.mDividerIsOpaque = false;
                this.mHeaderDividersEnabled = true;
                this.mFooterDividersEnabled = true;
                this.mAreAllItemsSelectable = true;
                this.mItemsCanFocus = false;
                this.mTempRect = new Rect();
                this.mArrowScrollFocusResult = new ListView.ArrowScrollFocusResult();
                this._attrBinder.addAttr('divider', (value) => {
                    let divider = this._attrBinder.parseDrawable(value);
                    if (divider)
                        this.setDivider(divider);
                });
                this._attrBinder.addAttr('overScrollHeader', (value) => {
                    let header = this._attrBinder.parseDrawable(value);
                    if (header)
                        this.setOverscrollHeader(header);
                });
                this._attrBinder.addAttr('overScrollFooter', (value) => {
                    let footer = this._attrBinder.parseDrawable(value);
                    if (footer)
                        this.setOverscrollFooter(footer);
                });
                this._attrBinder.addAttr('dividerHeight', (value) => {
                    let dividerHeight = this._attrBinder.parseNumber(value, -1);
                    if (dividerHeight >= 0) {
                        this.setDividerHeight(dividerHeight);
                    }
                });
                this._attrBinder.addAttr('headerDividersEnabled', (value) => {
                    this.setHeaderDividersEnabled(this._attrBinder.parseBoolean(value, true));
                });
                this._attrBinder.addAttr('footerDividersEnabled', (value) => {
                    this.setFooterDividersEnabled(this._attrBinder.parseBoolean(value, true));
                });
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
            }
            getMaxScrollAmount() {
                return Math.floor((ListView.MAX_SCROLL_FACTOR * (this.mBottom - this.mTop)));
            }
            adjustViewsUpOrDown() {
                const childCount = this.getChildCount();
                let delta;
                if (childCount > 0) {
                    let child;
                    if (!this.mStackFromBottom) {
                        child = this.getChildAt(0);
                        delta = child.getTop() - this.mListPadding.top;
                        if (this.mFirstPosition != 0) {
                            delta -= this.mDividerHeight;
                        }
                        if (delta < 0) {
                            delta = 0;
                        }
                    }
                    else {
                        child = this.getChildAt(childCount - 1);
                        delta = child.getBottom() - (this.getHeight() - this.mListPadding.bottom);
                        if (this.mFirstPosition + childCount < this.mItemCount) {
                            delta += this.mDividerHeight;
                        }
                        if (delta > 0) {
                            delta = 0;
                        }
                    }
                    if (delta != 0) {
                        this.offsetChildrenTopAndBottom(-delta);
                    }
                }
            }
            addHeaderView(v, data = null, isSelectable = true) {
                const info = new ListView.FixedViewInfo(this);
                info.view = v;
                info.data = data;
                info.isSelectable = isSelectable;
                this.mHeaderViewInfos.add(info);
                if (this.mAdapter != null) {
                    if (!(this.mAdapter instanceof HeaderViewListAdapter)) {
                        this.mAdapter = new HeaderViewListAdapter(this.mHeaderViewInfos, this.mFooterViewInfos, this.mAdapter);
                    }
                    if (this.mDataSetObserver != null) {
                        this.mDataSetObserver.onChanged();
                    }
                }
            }
            getHeaderViewsCount() {
                return this.mHeaderViewInfos.size();
            }
            removeHeaderView(v) {
                if (this.mHeaderViewInfos.size() > 0) {
                    let result = false;
                    if (this.mAdapter != null && this.mAdapter.removeHeader(v)) {
                        if (this.mDataSetObserver != null) {
                            this.mDataSetObserver.onChanged();
                        }
                        result = true;
                    }
                    this.removeFixedViewInfo(v, this.mHeaderViewInfos);
                    return result;
                }
                return false;
            }
            removeFixedViewInfo(v, where) {
                let len = where.size();
                for (let i = 0; i < len; ++i) {
                    let info = where.get(i);
                    if (info.view == v) {
                        where.remove(i);
                        break;
                    }
                }
            }
            addFooterView(v, data = null, isSelectable = true) {
                const info = new ListView.FixedViewInfo(this);
                info.view = v;
                info.data = data;
                info.isSelectable = isSelectable;
                this.mFooterViewInfos.add(info);
                if (this.mAdapter != null) {
                    if (!(this.mAdapter instanceof HeaderViewListAdapter)) {
                        this.mAdapter = new HeaderViewListAdapter(this.mHeaderViewInfos, this.mFooterViewInfos, this.mAdapter);
                    }
                    if (this.mDataSetObserver != null) {
                        this.mDataSetObserver.onChanged();
                    }
                }
            }
            getFooterViewsCount() {
                return this.mFooterViewInfos.size();
            }
            removeFooterView(v) {
                if (this.mFooterViewInfos.size() > 0) {
                    let result = false;
                    if (this.mAdapter != null && this.mAdapter.removeFooter(v)) {
                        if (this.mDataSetObserver != null) {
                            this.mDataSetObserver.onChanged();
                        }
                        result = true;
                    }
                    this.removeFixedViewInfo(v, this.mFooterViewInfos);
                    return result;
                }
                return false;
            }
            getAdapter() {
                return this.mAdapter;
            }
            setAdapter(adapter) {
                if (this.mAdapter != null && this.mDataSetObserver != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                }
                this.resetList();
                this.mRecycler.clear();
                if (this.mHeaderViewInfos.size() > 0 || this.mFooterViewInfos.size() > 0) {
                    this.mAdapter = new HeaderViewListAdapter(this.mHeaderViewInfos, this.mFooterViewInfos, adapter);
                }
                else {
                    this.mAdapter = adapter;
                }
                this.mOldSelectedPosition = ListView.INVALID_POSITION;
                this.mOldSelectedRowId = ListView.INVALID_ROW_ID;
                super.setAdapter(adapter);
                if (this.mAdapter != null) {
                    this.mAreAllItemsSelectable = this.mAdapter.areAllItemsEnabled();
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                    this.checkFocus();
                    this.mDataSetObserver = new AbsListView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    this.mRecycler.setViewTypeCount(this.mAdapter.getViewTypeCount());
                    let position;
                    if (this.mStackFromBottom) {
                        position = this.lookForSelectablePosition(this.mItemCount - 1, false);
                    }
                    else {
                        position = this.lookForSelectablePosition(0, true);
                    }
                    this.setSelectedPositionInt(position);
                    this.setNextSelectedPositionInt(position);
                    if (this.mItemCount == 0) {
                        this.checkSelectionChanged();
                    }
                }
                else {
                    this.mAreAllItemsSelectable = true;
                    this.checkFocus();
                    this.checkSelectionChanged();
                }
                this.requestLayout();
            }
            resetList() {
                this.clearRecycledState(this.mHeaderViewInfos);
                this.clearRecycledState(this.mFooterViewInfos);
                super.resetList();
                this.mLayoutMode = ListView.LAYOUT_NORMAL;
            }
            clearRecycledState(infos) {
                if (infos != null) {
                    const count = infos.size();
                    for (let i = 0; i < count; i++) {
                        const child = infos.get(i).view;
                        const p = child.getLayoutParams();
                        if (p != null) {
                            p.recycledHeaderFooter = false;
                        }
                    }
                }
            }
            showingTopFadingEdge() {
                const listTop = this.mScrollY + this.mListPadding.top;
                return (this.mFirstPosition > 0) || (this.getChildAt(0).getTop() > listTop);
            }
            showingBottomFadingEdge() {
                const childCount = this.getChildCount();
                const bottomOfBottomChild = this.getChildAt(childCount - 1).getBottom();
                const lastVisiblePosition = this.mFirstPosition + childCount - 1;
                const listBottom = this.mScrollY + this.getHeight() - this.mListPadding.bottom;
                return (lastVisiblePosition < this.mItemCount - 1) || (bottomOfBottomChild < listBottom);
            }
            requestChildRectangleOnScreen(child, rect, immediate) {
                let rectTopWithinChild = rect.top;
                rect.offset(child.getLeft(), child.getTop());
                rect.offset(-child.getScrollX(), -child.getScrollY());
                const height = this.getHeight();
                let listUnfadedTop = this.getScrollY();
                let listUnfadedBottom = listUnfadedTop + height;
                const fadingEdge = this.getVerticalFadingEdgeLength();
                if (this.showingTopFadingEdge()) {
                    if ((this.mSelectedPosition > 0) || (rectTopWithinChild > fadingEdge)) {
                        listUnfadedTop += fadingEdge;
                    }
                }
                let childCount = this.getChildCount();
                let bottomOfBottomChild = this.getChildAt(childCount - 1).getBottom();
                if (this.showingBottomFadingEdge()) {
                    if ((this.mSelectedPosition < this.mItemCount - 1) || (rect.bottom < (bottomOfBottomChild - fadingEdge))) {
                        listUnfadedBottom -= fadingEdge;
                    }
                }
                let scrollYDelta = 0;
                if (rect.bottom > listUnfadedBottom && rect.top > listUnfadedTop) {
                    if (rect.height() > height) {
                        scrollYDelta += (rect.top - listUnfadedTop);
                    }
                    else {
                        scrollYDelta += (rect.bottom - listUnfadedBottom);
                    }
                    let distanceToBottom = bottomOfBottomChild - listUnfadedBottom;
                    scrollYDelta = Math.min(scrollYDelta, distanceToBottom);
                }
                else if (rect.top < listUnfadedTop && rect.bottom < listUnfadedBottom) {
                    if (rect.height() > height) {
                        scrollYDelta -= (listUnfadedBottom - rect.bottom);
                    }
                    else {
                        scrollYDelta -= (listUnfadedTop - rect.top);
                    }
                    let top = this.getChildAt(0).getTop();
                    let deltaToTop = top - listUnfadedTop;
                    scrollYDelta = Math.max(scrollYDelta, deltaToTop);
                }
                const scroll = scrollYDelta != 0;
                if (scroll) {
                    this.scrollListItemsBy(-scrollYDelta);
                    this.positionSelector(ListView.INVALID_POSITION, child);
                    this.mSelectedTop = child.getTop();
                    this.invalidate();
                }
                return scroll;
            }
            fillGap(down) {
                const count = this.getChildCount();
                if (down) {
                    let paddingTop = 0;
                    if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                        paddingTop = this.getListPaddingTop();
                    }
                    const startOffset = count > 0 ? this.getChildAt(count - 1).getBottom() + this.mDividerHeight : paddingTop;
                    this.fillDown(this.mFirstPosition + count, startOffset);
                    this.correctTooHigh(this.getChildCount());
                }
                else {
                    let paddingBottom = 0;
                    if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                        paddingBottom = this.getListPaddingBottom();
                    }
                    const startOffset = count > 0 ? this.getChildAt(0).getTop() - this.mDividerHeight : this.getHeight() - paddingBottom;
                    this.fillUp(this.mFirstPosition - 1, startOffset);
                    this.correctTooLow(this.getChildCount());
                }
            }
            fillDown(pos, nextTop) {
                let selectedView = null;
                let end = (this.mBottom - this.mTop);
                if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                    end -= this.mListPadding.bottom;
                }
                while (nextTop < end && pos < this.mItemCount) {
                    let selected = pos == this.mSelectedPosition;
                    let child = this.makeAndAddView(pos, nextTop, true, this.mListPadding.left, selected);
                    nextTop = child.getBottom() + this.mDividerHeight;
                    if (selected) {
                        selectedView = child;
                    }
                    pos++;
                }
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            fillUp(pos, nextBottom) {
                let selectedView = null;
                let end = 0;
                if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                    end = this.mListPadding.top;
                }
                while (nextBottom > end && pos >= 0) {
                    let selected = pos == this.mSelectedPosition;
                    let child = this.makeAndAddView(pos, nextBottom, false, this.mListPadding.left, selected);
                    nextBottom = child.getTop() - this.mDividerHeight;
                    if (selected) {
                        selectedView = child;
                    }
                    pos--;
                }
                this.mFirstPosition = pos + 1;
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            fillFromTop(nextTop) {
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mSelectedPosition);
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mItemCount - 1);
                if (this.mFirstPosition < 0) {
                    this.mFirstPosition = 0;
                }
                return this.fillDown(this.mFirstPosition, nextTop);
            }
            fillFromMiddle(childrenTop, childrenBottom) {
                let height = childrenBottom - childrenTop;
                let position = this.reconcileSelectedPosition();
                let sel = this.makeAndAddView(position, childrenTop, true, this.mListPadding.left, true);
                this.mFirstPosition = position;
                let selHeight = sel.getMeasuredHeight();
                if (selHeight <= height) {
                    sel.offsetTopAndBottom((height - selHeight) / 2);
                }
                this.fillAboveAndBelow(sel, position);
                if (!this.mStackFromBottom) {
                    this.correctTooHigh(this.getChildCount());
                }
                else {
                    this.correctTooLow(this.getChildCount());
                }
                return sel;
            }
            fillAboveAndBelow(sel, position) {
                const dividerHeight = this.mDividerHeight;
                if (!this.mStackFromBottom) {
                    this.fillUp(position - 1, sel.getTop() - dividerHeight);
                    this.adjustViewsUpOrDown();
                    this.fillDown(position + 1, sel.getBottom() + dividerHeight);
                }
                else {
                    this.fillDown(position + 1, sel.getBottom() + dividerHeight);
                    this.adjustViewsUpOrDown();
                    this.fillUp(position - 1, sel.getTop() - dividerHeight);
                }
            }
            fillFromSelection(selectedTop, childrenTop, childrenBottom) {
                let fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                let sel;
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition);
                const bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, selectedPosition);
                sel = this.makeAndAddView(selectedPosition, selectedTop, true, this.mListPadding.left, true);
                if (sel.getBottom() > bottomSelectionPixel) {
                    const spaceAbove = sel.getTop() - topSelectionPixel;
                    const spaceBelow = sel.getBottom() - bottomSelectionPixel;
                    const offset = Math.min(spaceAbove, spaceBelow);
                    sel.offsetTopAndBottom(-offset);
                }
                else if (sel.getTop() < topSelectionPixel) {
                    const spaceAbove = topSelectionPixel - sel.getTop();
                    const spaceBelow = bottomSelectionPixel - sel.getBottom();
                    const offset = Math.min(spaceAbove, spaceBelow);
                    sel.offsetTopAndBottom(offset);
                }
                this.fillAboveAndBelow(sel, selectedPosition);
                if (!this.mStackFromBottom) {
                    this.correctTooHigh(this.getChildCount());
                }
                else {
                    this.correctTooLow(this.getChildCount());
                }
                return sel;
            }
            getBottomSelectionPixel(childrenBottom, fadingEdgeLength, selectedPosition) {
                let bottomSelectionPixel = childrenBottom;
                if (selectedPosition != this.mItemCount - 1) {
                    bottomSelectionPixel -= fadingEdgeLength;
                }
                return bottomSelectionPixel;
            }
            getTopSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition) {
                let topSelectionPixel = childrenTop;
                if (selectedPosition > 0) {
                    topSelectionPixel += fadingEdgeLength;
                }
                return topSelectionPixel;
            }
            smoothScrollToPosition(position, boundPosition) {
                super.smoothScrollToPosition(position, boundPosition);
            }
            smoothScrollByOffset(offset) {
                super.smoothScrollByOffset(offset);
            }
            moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom) {
                let fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                let sel;
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition);
                const bottomSelectionPixel = this.getBottomSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition);
                if (delta > 0) {
                    oldSel = this.makeAndAddView(selectedPosition - 1, oldSel.getTop(), true, this.mListPadding.left, false);
                    const dividerHeight = this.mDividerHeight;
                    sel = this.makeAndAddView(selectedPosition, oldSel.getBottom() + dividerHeight, true, this.mListPadding.left, true);
                    if (sel.getBottom() > bottomSelectionPixel) {
                        let spaceAbove = sel.getTop() - topSelectionPixel;
                        let spaceBelow = sel.getBottom() - bottomSelectionPixel;
                        let halfVerticalSpace = (childrenBottom - childrenTop) / 2;
                        let offset = Math.min(spaceAbove, spaceBelow);
                        offset = Math.min(offset, halfVerticalSpace);
                        oldSel.offsetTopAndBottom(-offset);
                        sel.offsetTopAndBottom(-offset);
                    }
                    if (!this.mStackFromBottom) {
                        this.fillUp(this.mSelectedPosition - 2, sel.getTop() - dividerHeight);
                        this.adjustViewsUpOrDown();
                        this.fillDown(this.mSelectedPosition + 1, sel.getBottom() + dividerHeight);
                    }
                    else {
                        this.fillDown(this.mSelectedPosition + 1, sel.getBottom() + dividerHeight);
                        this.adjustViewsUpOrDown();
                        this.fillUp(this.mSelectedPosition - 2, sel.getTop() - dividerHeight);
                    }
                }
                else if (delta < 0) {
                    if (newSel != null) {
                        sel = this.makeAndAddView(selectedPosition, newSel.getTop(), true, this.mListPadding.left, true);
                    }
                    else {
                        sel = this.makeAndAddView(selectedPosition, oldSel.getTop(), false, this.mListPadding.left, true);
                    }
                    if (sel.getTop() < topSelectionPixel) {
                        let spaceAbove = topSelectionPixel - sel.getTop();
                        let spaceBelow = bottomSelectionPixel - sel.getBottom();
                        let halfVerticalSpace = (childrenBottom - childrenTop) / 2;
                        let offset = Math.min(spaceAbove, spaceBelow);
                        offset = Math.min(offset, halfVerticalSpace);
                        sel.offsetTopAndBottom(offset);
                    }
                    this.fillAboveAndBelow(sel, selectedPosition);
                }
                else {
                    let oldTop = oldSel.getTop();
                    sel = this.makeAndAddView(selectedPosition, oldTop, true, this.mListPadding.left, true);
                    if (oldTop < childrenTop) {
                        let newBottom = sel.getBottom();
                        if (newBottom < childrenTop + 20) {
                            sel.offsetTopAndBottom(childrenTop - sel.getTop());
                        }
                    }
                    this.fillAboveAndBelow(sel, selectedPosition);
                }
                return sel;
            }
            onSizeChanged(w, h, oldw, oldh) {
                if (this.getChildCount() > 0) {
                    let focusedChild = this.getFocusedChild();
                    if (focusedChild != null) {
                        const childPosition = this.mFirstPosition + this.indexOfChild(focusedChild);
                        const childBottom = focusedChild.getBottom();
                        const offset = Math.max(0, childBottom - (h - this.mPaddingTop));
                        const top = focusedChild.getTop() - offset;
                        if (this.mFocusSelector == null) {
                            this.mFocusSelector = new ListView.FocusSelector(this);
                        }
                        this.post(this.mFocusSelector.setup(childPosition, top));
                    }
                }
                super.onSizeChanged(w, h, oldw, oldh);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                let widthMode = ListView.MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = ListView.MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = ListView.MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = ListView.MeasureSpec.getSize(heightMeasureSpec);
                let childWidth = 0;
                let childHeight = 0;
                let childState = 0;
                this.mItemCount = this.mAdapter == null ? 0 : this.mAdapter.getCount();
                if (this.mItemCount > 0 && (widthMode == ListView.MeasureSpec.UNSPECIFIED || heightMode == ListView.MeasureSpec.UNSPECIFIED)) {
                    const child = this.obtainView(0, this.mIsScrap);
                    this.measureScrapChild(child, 0, widthMeasureSpec);
                    childWidth = child.getMeasuredWidth();
                    childHeight = child.getMeasuredHeight();
                    childState = ListView.combineMeasuredStates(childState, child.getMeasuredState());
                    if (this.recycleOnMeasure() && this.mRecycler.shouldRecycleViewType(child.getLayoutParams().viewType)) {
                        this.mRecycler.addScrapView(child, -1);
                    }
                }
                if (widthMode == ListView.MeasureSpec.UNSPECIFIED) {
                    widthSize = this.mListPadding.left + this.mListPadding.right + childWidth + this.getVerticalScrollbarWidth();
                }
                else {
                    widthSize |= (childState & ListView.MEASURED_STATE_MASK);
                }
                if (heightMode == ListView.MeasureSpec.UNSPECIFIED) {
                    heightSize = this.mListPadding.top + this.mListPadding.bottom + childHeight + this.getVerticalFadingEdgeLength() * 2;
                }
                if (heightMode == ListView.MeasureSpec.AT_MOST) {
                    heightSize = this.measureHeightOfChildren(widthMeasureSpec, 0, ListView.NO_POSITION, heightSize, -1);
                }
                this.setMeasuredDimension(widthSize, heightSize);
                this.mWidthMeasureSpec = widthMeasureSpec;
            }
            measureScrapChild(child, position, widthMeasureSpec) {
                let p = child.getLayoutParams();
                if (p == null) {
                    p = this.generateDefaultLayoutParams();
                    child.setLayoutParams(p);
                }
                p.viewType = this.mAdapter.getItemViewType(position);
                p.forceAdd = true;
                let childWidthSpec = ViewGroup.getChildMeasureSpec(widthMeasureSpec, this.mListPadding.left + this.mListPadding.right, p.width);
                let lpHeight = p.height;
                let childHeightSpec;
                if (lpHeight > 0) {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(lpHeight, ListView.MeasureSpec.EXACTLY);
                }
                else {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(0, ListView.MeasureSpec.UNSPECIFIED);
                }
                child.measure(childWidthSpec, childHeightSpec);
            }
            recycleOnMeasure() {
                return true;
            }
            measureHeightOfChildren(widthMeasureSpec, startPosition, endPosition, maxHeight, disallowPartialChildPosition) {
                const adapter = this.mAdapter;
                if (adapter == null) {
                    return this.mListPadding.top + this.mListPadding.bottom;
                }
                let returnedHeight = this.mListPadding.top + this.mListPadding.bottom;
                const dividerHeight = ((this.mDividerHeight > 0) && this.mDivider != null) ? this.mDividerHeight : 0;
                let prevHeightWithoutPartialChild = 0;
                let i;
                let child;
                endPosition = (endPosition == ListView.NO_POSITION) ? adapter.getCount() - 1 : endPosition;
                const recycleBin = this.mRecycler;
                const recyle = this.recycleOnMeasure();
                const isScrap = this.mIsScrap;
                for (i = startPosition; i <= endPosition; ++i) {
                    child = this.obtainView(i, isScrap);
                    this.measureScrapChild(child, i, widthMeasureSpec);
                    if (i > 0) {
                        returnedHeight += dividerHeight;
                    }
                    if (recyle && recycleBin.shouldRecycleViewType(child.getLayoutParams().viewType)) {
                        recycleBin.addScrapView(child, -1);
                    }
                    returnedHeight += child.getMeasuredHeight();
                    if (returnedHeight >= maxHeight) {
                        return (disallowPartialChildPosition >= 0) &&
                            (i > disallowPartialChildPosition) &&
                            (prevHeightWithoutPartialChild > 0) &&
                            (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
                    }
                    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
                        prevHeightWithoutPartialChild = returnedHeight;
                    }
                }
                return returnedHeight;
            }
            findMotionRow(y) {
                let childCount = this.getChildCount();
                if (childCount > 0) {
                    if (!this.mStackFromBottom) {
                        for (let i = 0; i < childCount; i++) {
                            let v = this.getChildAt(i);
                            if (y <= v.getBottom()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                    else {
                        for (let i = childCount - 1; i >= 0; i--) {
                            let v = this.getChildAt(i);
                            if (y >= v.getTop()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                }
                return ListView.INVALID_POSITION;
            }
            fillSpecific(position, top) {
                let tempIsSelected = position == this.mSelectedPosition;
                let temp = this.makeAndAddView(position, top, true, this.mListPadding.left, tempIsSelected);
                this.mFirstPosition = position;
                let above;
                let below;
                const dividerHeight = this.mDividerHeight;
                if (!this.mStackFromBottom) {
                    above = this.fillUp(position - 1, temp.getTop() - dividerHeight);
                    this.adjustViewsUpOrDown();
                    below = this.fillDown(position + 1, temp.getBottom() + dividerHeight);
                    let childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooHigh(childCount);
                    }
                }
                else {
                    below = this.fillDown(position + 1, temp.getBottom() + dividerHeight);
                    this.adjustViewsUpOrDown();
                    above = this.fillUp(position - 1, temp.getTop() - dividerHeight);
                    let childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooLow(childCount);
                    }
                }
                if (tempIsSelected) {
                    return temp;
                }
                else if (above != null) {
                    return above;
                }
                else {
                    return below;
                }
            }
            correctTooHigh(childCount) {
                let lastPosition = this.mFirstPosition + childCount - 1;
                if (lastPosition == this.mItemCount - 1 && childCount > 0) {
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let bottomOffset = end - lastBottom;
                    let firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    if (bottomOffset > 0 && (this.mFirstPosition > 0 || firstTop < this.mListPadding.top)) {
                        if (this.mFirstPosition == 0) {
                            bottomOffset = Math.min(bottomOffset, this.mListPadding.top - firstTop);
                        }
                        this.offsetChildrenTopAndBottom(bottomOffset);
                        if (this.mFirstPosition > 0) {
                            this.fillUp(this.mFirstPosition - 1, firstChild.getTop() - this.mDividerHeight);
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            correctTooLow(childCount) {
                if (this.mFirstPosition == 0 && childCount > 0) {
                    const firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    const start = this.mListPadding.top;
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let topOffset = firstTop - start;
                    let lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    let lastPosition = this.mFirstPosition + childCount - 1;
                    if (topOffset > 0) {
                        if (lastPosition < this.mItemCount - 1 || lastBottom > end) {
                            if (lastPosition == this.mItemCount - 1) {
                                topOffset = Math.min(topOffset, lastBottom - end);
                            }
                            this.offsetChildrenTopAndBottom(-topOffset);
                            if (lastPosition < this.mItemCount - 1) {
                                this.fillDown(lastPosition + 1, lastChild.getBottom() + this.mDividerHeight);
                                this.adjustViewsUpOrDown();
                            }
                        }
                        else if (lastPosition == this.mItemCount - 1) {
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            layoutChildren() {
                const blockLayoutRequests = this.mBlockLayoutRequests;
                if (blockLayoutRequests) {
                    return;
                }
                this.mBlockLayoutRequests = true;
                try {
                    super.layoutChildren();
                    this.invalidate();
                    if (this.mAdapter == null) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    const childrenTop = this.mListPadding.top;
                    const childrenBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                    const childCount = this.getChildCount();
                    let index = 0;
                    let delta = 0;
                    let sel;
                    let oldSel = null;
                    let oldFirst = null;
                    let newSel = null;
                    switch (this.mLayoutMode) {
                        case ListView.LAYOUT_SET_SELECTION:
                            index = this.mNextSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                newSel = this.getChildAt(index);
                            }
                            break;
                        case ListView.LAYOUT_FORCE_TOP:
                        case ListView.LAYOUT_FORCE_BOTTOM:
                        case ListView.LAYOUT_SPECIFIC:
                        case ListView.LAYOUT_SYNC:
                            break;
                        case ListView.LAYOUT_MOVE_SELECTION:
                        default:
                            index = this.mSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                oldSel = this.getChildAt(index);
                            }
                            oldFirst = this.getChildAt(0);
                            if (this.mNextSelectedPosition >= 0) {
                                delta = this.mNextSelectedPosition - this.mSelectedPosition;
                            }
                            newSel = this.getChildAt(index + delta);
                    }
                    let dataChanged = this.mDataChanged;
                    if (dataChanged) {
                        this.handleDataChanged();
                    }
                    if (this.mItemCount == 0) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    else if (this.mItemCount != this.mAdapter.getCount()) {
                        throw Error(`IllegalStateException("The content of the adapter has changed but
                ListView did not receive a notification. Make sure the content of
                your adapter is not modified from a background thread, but only from
                the UI thread. Make sure your adapter calls notifyDataSetChanged()
                when its content changes. [in ListView(${this.getId()},${this.constructor.name})
                with Adapter(${this.mAdapter.constructor.name})]")`);
                    }
                    this.setSelectedPositionInt(this.mNextSelectedPosition);
                    const accessFocusedChild = null;
                    const focusedChild = this.getFocusedChild();
                    if (focusedChild != null) {
                        focusedChild.setHasTransientState(true);
                    }
                    const firstPosition = this.mFirstPosition;
                    const recycleBin = this.mRecycler;
                    if (dataChanged) {
                        for (let i = 0; i < childCount; i++) {
                            recycleBin.addScrapView(this.getChildAt(i), firstPosition + i);
                        }
                    }
                    else {
                        recycleBin.fillActiveViews(childCount, firstPosition);
                    }
                    this.detachAllViewsFromParent();
                    recycleBin.removeSkippedScrap();
                    switch (this.mLayoutMode) {
                        case ListView.LAYOUT_SET_SELECTION:
                            if (newSel != null) {
                                sel = this.fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                            }
                            else {
                                sel = this.fillFromMiddle(childrenTop, childrenBottom);
                            }
                            break;
                        case ListView.LAYOUT_SYNC:
                            sel = this.fillSpecific(this.mSyncPosition, this.mSpecificTop);
                            break;
                        case ListView.LAYOUT_FORCE_BOTTOM:
                            sel = this.fillUp(this.mItemCount - 1, childrenBottom);
                            this.adjustViewsUpOrDown();
                            break;
                        case ListView.LAYOUT_FORCE_TOP:
                            this.mFirstPosition = 0;
                            sel = this.fillFromTop(childrenTop);
                            this.adjustViewsUpOrDown();
                            break;
                        case ListView.LAYOUT_SPECIFIC:
                            sel = this.fillSpecific(this.reconcileSelectedPosition(), this.mSpecificTop);
                            break;
                        case ListView.LAYOUT_MOVE_SELECTION:
                            sel = this.moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                            break;
                        default:
                            if (childCount == 0) {
                                if (!this.mStackFromBottom) {
                                    const position = this.lookForSelectablePosition(0, true);
                                    this.setSelectedPositionInt(position);
                                    sel = this.fillFromTop(childrenTop);
                                }
                                else {
                                    const position = this.lookForSelectablePosition(this.mItemCount - 1, false);
                                    this.setSelectedPositionInt(position);
                                    sel = this.fillUp(this.mItemCount - 1, childrenBottom);
                                }
                            }
                            else {
                                if (this.mSelectedPosition >= 0 && this.mSelectedPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                                }
                                else if (this.mFirstPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                                }
                                else {
                                    sel = this.fillSpecific(0, childrenTop);
                                }
                            }
                            break;
                    }
                    recycleBin.scrapActiveViews();
                    if (sel != null) {
                        const shouldPlaceFocus = this.mItemsCanFocus && this.hasFocus();
                        const maintainedFocus = focusedChild != null && focusedChild.hasFocus();
                        if (shouldPlaceFocus && !maintainedFocus && !sel.hasFocus()) {
                            if (sel.requestFocus()) {
                                sel.setSelected(false);
                                this.mSelectorRect.setEmpty();
                            }
                            else {
                                const focused = this.getFocusedChild();
                                if (focused != null) {
                                    focused.clearFocus();
                                }
                                this.positionSelector(ListView.INVALID_POSITION, sel);
                            }
                        }
                        else {
                            this.positionSelector(ListView.INVALID_POSITION, sel);
                        }
                        this.mSelectedTop = sel.getTop();
                    }
                    else {
                        if (this.mTouchMode == ListView.TOUCH_MODE_TAP || this.mTouchMode == ListView.TOUCH_MODE_DONE_WAITING) {
                            const child = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                            if (child != null) {
                                this.positionSelector(this.mMotionPosition, child);
                            }
                        }
                        else {
                            this.mSelectedTop = 0;
                            this.mSelectorRect.setEmpty();
                        }
                    }
                    if (accessFocusedChild != null) {
                        accessFocusedChild.setHasTransientState(false);
                    }
                    if (focusedChild != null) {
                        focusedChild.setHasTransientState(false);
                    }
                    this.mLayoutMode = ListView.LAYOUT_NORMAL;
                    this.mDataChanged = false;
                    if (this.mPositionScrollAfterLayout != null) {
                        this.post(this.mPositionScrollAfterLayout);
                        this.mPositionScrollAfterLayout = null;
                    }
                    this.mNeedSync = false;
                    this.setNextSelectedPositionInt(this.mSelectedPosition);
                    this.updateScrollIndicators();
                    if (this.mItemCount > 0) {
                        this.checkSelectionChanged();
                    }
                    this.invokeOnItemScrollListener();
                }
                finally {
                    if (!blockLayoutRequests) {
                        this.mBlockLayoutRequests = false;
                    }
                }
            }
            makeAndAddView(position, y, flow, childrenLeft, selected) {
                let child;
                if (!this.mDataChanged) {
                    child = this.mRecycler.getActiveView(position);
                    if (child != null) {
                        this.setupChild(child, position, y, flow, childrenLeft, selected, true);
                        return child;
                    }
                }
                child = this.obtainView(position, this.mIsScrap);
                this.setupChild(child, position, y, flow, childrenLeft, selected, this.mIsScrap[0]);
                return child;
            }
            setupChild(child, position, y, flowDown, childrenLeft, selected, recycled) {
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setupListItem");
                const isSelected = selected && this.shouldShowSelector();
                const updateChildSelected = isSelected != child.isSelected();
                const mode = this.mTouchMode;
                const isPressed = mode > ListView.TOUCH_MODE_DOWN && mode < ListView.TOUCH_MODE_SCROLL && this.mMotionPosition == position;
                const updateChildPressed = isPressed != child.isPressed();
                const needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();
                let p = child.getLayoutParams();
                if (p == null) {
                    p = this.generateDefaultLayoutParams();
                }
                if (!(p instanceof AbsListView.LayoutParams)) {
                    throw Error('ClassCaseException(' + p.constructor.name + ' can\'t case to AbsListView.LayoutParams)');
                }
                p.viewType = this.mAdapter.getItemViewType(position);
                if ((recycled && !p.forceAdd) || (p.recycledHeaderFooter && p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) {
                    this.attachViewToParent(child, flowDown ? -1 : 0, p);
                }
                else {
                    p.forceAdd = false;
                    if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                        p.recycledHeaderFooter = true;
                    }
                    this.addViewInLayout(child, flowDown ? -1 : 0, p, true);
                }
                if (updateChildSelected) {
                    child.setSelected(isSelected);
                }
                if (updateChildPressed) {
                    child.setPressed(isPressed);
                }
                if (this.mChoiceMode != ListView.CHOICE_MODE_NONE && this.mCheckStates != null) {
                    if (child['setChecked']) {
                        child.setChecked(this.mCheckStates.get(position));
                    }
                    else {
                        child.setActivated(this.mCheckStates.get(position));
                    }
                }
                if (needToMeasure) {
                    let childWidthSpec = ViewGroup.getChildMeasureSpec(this.mWidthMeasureSpec, this.mListPadding.left + this.mListPadding.right, p.width);
                    let lpHeight = p.height;
                    let childHeightSpec;
                    if (lpHeight > 0) {
                        childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(lpHeight, ListView.MeasureSpec.EXACTLY);
                    }
                    else {
                        childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(0, ListView.MeasureSpec.UNSPECIFIED);
                    }
                    child.measure(childWidthSpec, childHeightSpec);
                }
                else {
                    this.cleanupLayoutState(child);
                }
                const w = child.getMeasuredWidth();
                const h = child.getMeasuredHeight();
                const childTop = flowDown ? y : y - h;
                if (needToMeasure) {
                    const childRight = childrenLeft + w;
                    const childBottom = childTop + h;
                    child.layout(childrenLeft, childTop, childRight, childBottom);
                }
                else {
                    child.offsetLeftAndRight(childrenLeft - child.getLeft());
                    child.offsetTopAndBottom(childTop - child.getTop());
                }
                if (this.mCachingStarted && !child.isDrawingCacheEnabled()) {
                    child.setDrawingCacheEnabled(true);
                }
                if (recycled && (child.getLayoutParams().scrappedFromPosition) != position) {
                    child.jumpDrawablesToCurrentState();
                }
                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            }
            canAnimate() {
                return super.canAnimate() && this.mItemCount > 0;
            }
            setSelection(position) {
                this.setSelectionFromTop(position, 0);
            }
            setSelectionFromTop(position, y) {
                if (this.mAdapter == null) {
                    return;
                }
                if (!this.isInTouchMode()) {
                    position = this.lookForSelectablePosition(position, true);
                    if (position >= 0) {
                        this.setNextSelectedPositionInt(position);
                    }
                }
                else {
                    this.mResurrectToPosition = position;
                }
                if (position >= 0) {
                    this.mLayoutMode = ListView.LAYOUT_SPECIFIC;
                    this.mSpecificTop = this.mListPadding.top + y;
                    if (this.mNeedSync) {
                        this.mSyncPosition = position;
                        this.mSyncRowId = this.mAdapter.getItemId(position);
                    }
                    if (this.mPositionScroller != null) {
                        this.mPositionScroller.stop();
                    }
                    this.requestLayout();
                }
            }
            setSelectionInt(position) {
                this.setNextSelectedPositionInt(position);
                let awakeScrollbars = false;
                const selectedPosition = this.mSelectedPosition;
                if (selectedPosition >= 0) {
                    if (position == selectedPosition - 1) {
                        awakeScrollbars = true;
                    }
                    else if (position == selectedPosition + 1) {
                        awakeScrollbars = true;
                    }
                }
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.layoutChildren();
                if (awakeScrollbars) {
                    this.awakenScrollBars();
                }
            }
            lookForSelectablePosition(position, lookDown) {
                const adapter = this.mAdapter;
                if (adapter == null || this.isInTouchMode()) {
                    return ListView.INVALID_POSITION;
                }
                const count = adapter.getCount();
                if (!this.mAreAllItemsSelectable) {
                    if (lookDown) {
                        position = Math.max(0, position);
                        while (position < count && !adapter.isEnabled(position)) {
                            position++;
                        }
                    }
                    else {
                        position = Math.min(position, count - 1);
                        while (position >= 0 && !adapter.isEnabled(position)) {
                            position--;
                        }
                    }
                }
                if (position < 0 || position >= count) {
                    return ListView.INVALID_POSITION;
                }
                return position;
            }
            lookForSelectablePositionAfter(current, position, lookDown) {
                const adapter = this.mAdapter;
                if (adapter == null || this.isInTouchMode()) {
                    return ListView.INVALID_POSITION;
                }
                const after = this.lookForSelectablePosition(position, lookDown);
                if (after != ListView.INVALID_POSITION) {
                    return after;
                }
                const count = adapter.getCount();
                current = MathUtils.constrain(current, -1, count - 1);
                if (lookDown) {
                    position = Math.min(position - 1, count - 1);
                    while ((position > current) && !adapter.isEnabled(position)) {
                        position--;
                    }
                    if (position <= current) {
                        return ListView.INVALID_POSITION;
                    }
                }
                else {
                    position = Math.max(0, position + 1);
                    while ((position < current) && !adapter.isEnabled(position)) {
                        position++;
                    }
                    if (position >= current) {
                        return ListView.INVALID_POSITION;
                    }
                }
                return position;
            }
            setSelectionAfterHeaderView() {
                const count = this.mHeaderViewInfos.size();
                if (count > 0) {
                    this.mNextSelectedPosition = 0;
                    return;
                }
                if (this.mAdapter != null) {
                    this.setSelection(count);
                }
                else {
                    this.mNextSelectedPosition = count;
                    this.mLayoutMode = ListView.LAYOUT_SET_SELECTION;
                }
            }
            dispatchKeyEvent(event) {
                let handled = super.dispatchKeyEvent(event);
                if (!handled) {
                    let focused = this.getFocusedChild();
                    if (focused != null && event.getAction() == KeyEvent.ACTION_DOWN) {
                        handled = this.onKeyDown(event.getKeyCode(), event);
                    }
                }
                return handled;
            }
            onKeyDown(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            onKeyMultiple(keyCode, repeatCount, event) {
                return this.commonKey(keyCode, repeatCount, event);
            }
            onKeyUp(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            commonKey(keyCode, count, event) {
                if (this.mAdapter == null || !this.isAttachedToWindow()) {
                    return false;
                }
                if (this.mDataChanged) {
                    this.layoutChildren();
                }
                let handled = false;
                let action = event.getAction();
                if (action != KeyEvent.ACTION_UP) {
                    switch (keyCode) {
                        case KeyEvent.KEYCODE_DPAD_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled) {
                                    while (count-- > 0) {
                                        if (this.arrowScroll(ListView.FOCUS_UP)) {
                                            handled = true;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled) {
                                    while (count-- > 0) {
                                        if (this.arrowScroll(ListView.FOCUS_DOWN)) {
                                            handled = true;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (event.hasNoModifiers()) {
                                handled = this.handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (event.hasNoModifiers()) {
                                handled = this.handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_CENTER:
                        case KeyEvent.KEYCODE_ENTER:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled && event.getRepeatCount() == 0 && this.getChildCount() > 0) {
                                    this.keyPressed();
                                    handled = true;
                                }
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_UP);
                            }
                            handled = true;
                            break;
                        case KeyEvent.KEYCODE_PAGE_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_UP);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_PAGE_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_HOME:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_END:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_TAB:
                            if (false) {
                                if (event.hasNoModifiers()) {
                                    handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(ListView.FOCUS_DOWN);
                                }
                                else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                    handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(ListView.FOCUS_UP);
                                }
                            }
                            break;
                    }
                }
                if (handled) {
                    return true;
                }
                switch (action) {
                    case KeyEvent.ACTION_DOWN:
                        return super.onKeyDown(keyCode, event);
                    case KeyEvent.ACTION_UP:
                        return super.onKeyUp(keyCode, event);
                    default:
                        return false;
                }
            }
            pageScroll(direction) {
                let nextPage;
                let down;
                if (direction == ListView.FOCUS_UP) {
                    nextPage = Math.max(0, this.mSelectedPosition - this.getChildCount() - 1);
                    down = false;
                }
                else if (direction == ListView.FOCUS_DOWN) {
                    nextPage = Math.min(this.mItemCount - 1, this.mSelectedPosition + this.getChildCount() - 1);
                    down = true;
                }
                else {
                    return false;
                }
                if (nextPage >= 0) {
                    const position = this.lookForSelectablePositionAfter(this.mSelectedPosition, nextPage, down);
                    if (position >= 0) {
                        this.mLayoutMode = ListView.LAYOUT_SPECIFIC;
                        this.mSpecificTop = this.mPaddingTop + this.getVerticalFadingEdgeLength();
                        if (down && (position > (this.mItemCount - this.getChildCount()))) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_BOTTOM;
                        }
                        if (!down && (position < this.getChildCount())) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_TOP;
                        }
                        this.setSelectionInt(position);
                        this.invokeOnItemScrollListener();
                        if (!this.awakenScrollBars()) {
                            this.invalidate();
                        }
                        return true;
                    }
                }
                return false;
            }
            fullScroll(direction) {
                let moved = false;
                if (direction == ListView.FOCUS_UP) {
                    if (this.mSelectedPosition != 0) {
                        const position = this.lookForSelectablePositionAfter(this.mSelectedPosition, 0, true);
                        if (position >= 0) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_TOP;
                            this.setSelectionInt(position);
                            this.invokeOnItemScrollListener();
                        }
                        moved = true;
                    }
                }
                else if (direction == ListView.FOCUS_DOWN) {
                    const lastItem = (this.mItemCount - 1);
                    if (this.mSelectedPosition < lastItem) {
                        const position = this.lookForSelectablePositionAfter(this.mSelectedPosition, lastItem, false);
                        if (position >= 0) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_BOTTOM;
                            this.setSelectionInt(position);
                            this.invokeOnItemScrollListener();
                        }
                        moved = true;
                    }
                }
                if (moved && !this.awakenScrollBars()) {
                    this.awakenScrollBars();
                    this.invalidate();
                }
                return moved;
            }
            handleHorizontalFocusWithinListItem(direction) {
                if (direction != View.FOCUS_LEFT && direction != View.FOCUS_RIGHT) {
                    throw Error(`new IllegalArgumentException("direction must be one of" + " {View.FOCUS_LEFT, View.FOCUS_RIGHT}")`);
                }
                const numChildren = this.getChildCount();
                if (this.mItemsCanFocus && numChildren > 0 && this.mSelectedPosition != ListView.INVALID_POSITION) {
                    const selectedView = this.getSelectedView();
                    if (selectedView != null && selectedView.hasFocus() && selectedView instanceof ViewGroup) {
                        const currentFocus = selectedView.findFocus();
                        const nextFocus = FocusFinder.getInstance().findNextFocus(selectedView, currentFocus, direction);
                        if (nextFocus != null) {
                            currentFocus.getFocusedRect(this.mTempRect);
                            this.offsetDescendantRectToMyCoords(currentFocus, this.mTempRect);
                            this.offsetRectIntoDescendantCoords(nextFocus, this.mTempRect);
                            if (nextFocus.requestFocus(direction, this.mTempRect)) {
                                return true;
                            }
                        }
                        const globalNextFocus = FocusFinder.getInstance().findNextFocus(this.getRootView(), currentFocus, direction);
                        if (globalNextFocus != null) {
                            return this.isViewAncestorOf(globalNextFocus, this);
                        }
                    }
                }
                return false;
            }
            arrowScroll(direction) {
                try {
                    this.mInLayout = true;
                    const handled = this.arrowScrollImpl(direction);
                    if (handled) {
                        this.playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
                    }
                    return handled;
                }
                finally {
                    this.mInLayout = false;
                }
            }
            nextSelectedPositionForDirection(selectedView, selectedPos, direction) {
                let nextSelected;
                if (direction == View.FOCUS_DOWN) {
                    const listBottom = this.getHeight() - this.mListPadding.bottom;
                    if (selectedView != null && selectedView.getBottom() <= listBottom) {
                        nextSelected = selectedPos != ListView.INVALID_POSITION && selectedPos >= this.mFirstPosition ? selectedPos + 1 : this.mFirstPosition;
                    }
                    else {
                        return ListView.INVALID_POSITION;
                    }
                }
                else {
                    const listTop = this.mListPadding.top;
                    if (selectedView != null && selectedView.getTop() >= listTop) {
                        const lastPos = this.mFirstPosition + this.getChildCount() - 1;
                        nextSelected = selectedPos != ListView.INVALID_POSITION && selectedPos <= lastPos ? selectedPos - 1 : lastPos;
                    }
                    else {
                        return ListView.INVALID_POSITION;
                    }
                }
                if (nextSelected < 0 || nextSelected >= this.mAdapter.getCount()) {
                    return ListView.INVALID_POSITION;
                }
                return this.lookForSelectablePosition(nextSelected, direction == View.FOCUS_DOWN);
            }
            arrowScrollImpl(direction) {
                if (this.getChildCount() <= 0) {
                    return false;
                }
                let selectedView = this.getSelectedView();
                let selectedPos = this.mSelectedPosition;
                let nextSelectedPosition = this.nextSelectedPositionForDirection(selectedView, selectedPos, direction);
                let amountToScroll = this.amountToScroll(direction, nextSelectedPosition);
                const focusResult = this.mItemsCanFocus ? this.arrowScrollFocused(direction) : null;
                if (focusResult != null) {
                    nextSelectedPosition = focusResult.getSelectedPosition();
                    amountToScroll = focusResult.getAmountToScroll();
                }
                let needToRedraw = focusResult != null;
                if (nextSelectedPosition != ListView.INVALID_POSITION) {
                    this.handleNewSelectionChange(selectedView, direction, nextSelectedPosition, focusResult != null);
                    this.setSelectedPositionInt(nextSelectedPosition);
                    this.setNextSelectedPositionInt(nextSelectedPosition);
                    selectedView = this.getSelectedView();
                    selectedPos = nextSelectedPosition;
                    if (this.mItemsCanFocus && focusResult == null) {
                        const focused = this.getFocusedChild();
                        if (focused != null) {
                            focused.clearFocus();
                        }
                    }
                    needToRedraw = true;
                    this.checkSelectionChanged();
                }
                if (amountToScroll > 0) {
                    this.scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
                    needToRedraw = true;
                }
                if (this.mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
                    const focused = selectedView.findFocus();
                    if (!this.isViewAncestorOf(focused, this) || this.distanceToView(focused) > 0) {
                        focused.clearFocus();
                    }
                }
                if (nextSelectedPosition == ListView.INVALID_POSITION && selectedView != null && !this.isViewAncestorOf(selectedView, this)) {
                    selectedView = null;
                    this.hideSelector();
                    this.mResurrectToPosition = ListView.INVALID_POSITION;
                }
                if (needToRedraw) {
                    if (selectedView != null) {
                        this.positionSelector(selectedPos, selectedView);
                        this.mSelectedTop = selectedView.getTop();
                    }
                    if (!this.awakenScrollBars()) {
                        this.invalidate();
                    }
                    this.invokeOnItemScrollListener();
                    return true;
                }
                return false;
            }
            handleNewSelectionChange(selectedView, direction, newSelectedPosition, newFocusAssigned) {
                if (newSelectedPosition == ListView.INVALID_POSITION) {
                    throw Error(`new IllegalArgumentException("newSelectedPosition needs to be valid")`);
                }
                let topView;
                let bottomView;
                let topViewIndex, bottomViewIndex;
                let topSelected = false;
                const selectedIndex = this.mSelectedPosition - this.mFirstPosition;
                const nextSelectedIndex = newSelectedPosition - this.mFirstPosition;
                if (direction == View.FOCUS_UP) {
                    topViewIndex = nextSelectedIndex;
                    bottomViewIndex = selectedIndex;
                    topView = this.getChildAt(topViewIndex);
                    bottomView = selectedView;
                    topSelected = true;
                }
                else {
                    topViewIndex = selectedIndex;
                    bottomViewIndex = nextSelectedIndex;
                    topView = selectedView;
                    bottomView = this.getChildAt(bottomViewIndex);
                }
                const numChildren = this.getChildCount();
                if (topView != null) {
                    topView.setSelected(!newFocusAssigned && topSelected);
                    this.measureAndAdjustDown(topView, topViewIndex, numChildren);
                }
                if (bottomView != null) {
                    bottomView.setSelected(!newFocusAssigned && !topSelected);
                    this.measureAndAdjustDown(bottomView, bottomViewIndex, numChildren);
                }
            }
            measureAndAdjustDown(child, childIndex, numChildren) {
                let oldHeight = child.getHeight();
                this.measureItem(child);
                if (child.getMeasuredHeight() != oldHeight) {
                    this.relayoutMeasuredItem(child);
                    const heightDelta = child.getMeasuredHeight() - oldHeight;
                    for (let i = childIndex + 1; i < numChildren; i++) {
                        this.getChildAt(i).offsetTopAndBottom(heightDelta);
                    }
                }
            }
            measureItem(child) {
                let p = child.getLayoutParams();
                if (p == null) {
                    p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
                }
                let childWidthSpec = ViewGroup.getChildMeasureSpec(this.mWidthMeasureSpec, this.mListPadding.left + this.mListPadding.right, p.width);
                let lpHeight = p.height;
                let childHeightSpec;
                if (lpHeight > 0) {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(lpHeight, ListView.MeasureSpec.EXACTLY);
                }
                else {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(0, ListView.MeasureSpec.UNSPECIFIED);
                }
                child.measure(childWidthSpec, childHeightSpec);
            }
            relayoutMeasuredItem(child) {
                const w = child.getMeasuredWidth();
                const h = child.getMeasuredHeight();
                const childLeft = this.mListPadding.left;
                const childRight = childLeft + w;
                const childTop = child.getTop();
                const childBottom = childTop + h;
                child.layout(childLeft, childTop, childRight, childBottom);
            }
            getArrowScrollPreviewLength() {
                return Math.max(ListView.MIN_SCROLL_PREVIEW_PIXELS, this.getVerticalFadingEdgeLength());
            }
            amountToScroll(direction, nextSelectedPosition) {
                const listBottom = this.getHeight() - this.mListPadding.bottom;
                const listTop = this.mListPadding.top;
                let numChildren = this.getChildCount();
                if (direction == View.FOCUS_DOWN) {
                    let indexToMakeVisible = numChildren - 1;
                    if (nextSelectedPosition != ListView.INVALID_POSITION) {
                        indexToMakeVisible = nextSelectedPosition - this.mFirstPosition;
                    }
                    while (numChildren <= indexToMakeVisible) {
                        this.addViewBelow(this.getChildAt(numChildren - 1), this.mFirstPosition + numChildren - 1);
                        numChildren++;
                    }
                    const positionToMakeVisible = this.mFirstPosition + indexToMakeVisible;
                    const viewToMakeVisible = this.getChildAt(indexToMakeVisible);
                    let goalBottom = listBottom;
                    if (positionToMakeVisible < this.mItemCount - 1) {
                        goalBottom -= this.getArrowScrollPreviewLength();
                    }
                    if (viewToMakeVisible.getBottom() <= goalBottom) {
                        return 0;
                    }
                    if (nextSelectedPosition != ListView.INVALID_POSITION && (goalBottom - viewToMakeVisible.getTop()) >= this.getMaxScrollAmount()) {
                        return 0;
                    }
                    let amountToScroll = (viewToMakeVisible.getBottom() - goalBottom);
                    if ((this.mFirstPosition + numChildren) == this.mItemCount) {
                        const max = this.getChildAt(numChildren - 1).getBottom() - listBottom;
                        amountToScroll = Math.min(amountToScroll, max);
                    }
                    return Math.min(amountToScroll, this.getMaxScrollAmount());
                }
                else {
                    let indexToMakeVisible = 0;
                    if (nextSelectedPosition != ListView.INVALID_POSITION) {
                        indexToMakeVisible = nextSelectedPosition - this.mFirstPosition;
                    }
                    while (indexToMakeVisible < 0) {
                        this.addViewAbove(this.getChildAt(0), this.mFirstPosition);
                        this.mFirstPosition--;
                        indexToMakeVisible = nextSelectedPosition - this.mFirstPosition;
                    }
                    const positionToMakeVisible = this.mFirstPosition + indexToMakeVisible;
                    const viewToMakeVisible = this.getChildAt(indexToMakeVisible);
                    let goalTop = listTop;
                    if (positionToMakeVisible > 0) {
                        goalTop += this.getArrowScrollPreviewLength();
                    }
                    if (viewToMakeVisible.getTop() >= goalTop) {
                        return 0;
                    }
                    if (nextSelectedPosition != ListView.INVALID_POSITION && (viewToMakeVisible.getBottom() - goalTop) >= this.getMaxScrollAmount()) {
                        return 0;
                    }
                    let amountToScroll = (goalTop - viewToMakeVisible.getTop());
                    if (this.mFirstPosition == 0) {
                        const max = listTop - this.getChildAt(0).getTop();
                        amountToScroll = Math.min(amountToScroll, max);
                    }
                    return Math.min(amountToScroll, this.getMaxScrollAmount());
                }
            }
            lookForSelectablePositionOnScreen(direction) {
                const firstPosition = this.mFirstPosition;
                if (direction == View.FOCUS_DOWN) {
                    let startPos = (this.mSelectedPosition != ListView.INVALID_POSITION) ? this.mSelectedPosition + 1 : firstPosition;
                    if (startPos >= this.mAdapter.getCount()) {
                        return ListView.INVALID_POSITION;
                    }
                    if (startPos < firstPosition) {
                        startPos = firstPosition;
                    }
                    const lastVisiblePos = this.getLastVisiblePosition();
                    const adapter = this.getAdapter();
                    for (let pos = startPos; pos <= lastVisiblePos; pos++) {
                        if (adapter.isEnabled(pos) && this.getChildAt(pos - firstPosition).getVisibility() == View.VISIBLE) {
                            return pos;
                        }
                    }
                }
                else {
                    let last = firstPosition + this.getChildCount() - 1;
                    let startPos = (this.mSelectedPosition != ListView.INVALID_POSITION) ? this.mSelectedPosition - 1 : firstPosition + this.getChildCount() - 1;
                    if (startPos < 0 || startPos >= this.mAdapter.getCount()) {
                        return ListView.INVALID_POSITION;
                    }
                    if (startPos > last) {
                        startPos = last;
                    }
                    const adapter = this.getAdapter();
                    for (let pos = startPos; pos >= firstPosition; pos--) {
                        if (adapter.isEnabled(pos) && this.getChildAt(pos - firstPosition).getVisibility() == View.VISIBLE) {
                            return pos;
                        }
                    }
                }
                return ListView.INVALID_POSITION;
            }
            arrowScrollFocused(direction) {
                const selectedView = this.getSelectedView();
                let newFocus;
                if (selectedView != null && selectedView.hasFocus()) {
                    let oldFocus = selectedView.findFocus();
                    newFocus = FocusFinder.getInstance().findNextFocus(this, oldFocus, direction);
                }
                else {
                    if (direction == View.FOCUS_DOWN) {
                        const topFadingEdgeShowing = (this.mFirstPosition > 0);
                        const listTop = this.mListPadding.top + (topFadingEdgeShowing ? this.getArrowScrollPreviewLength() : 0);
                        const ySearchPoint = (selectedView != null && selectedView.getTop() > listTop) ? selectedView.getTop() : listTop;
                        this.mTempRect.set(0, ySearchPoint, 0, ySearchPoint);
                    }
                    else {
                        const bottomFadingEdgeShowing = (this.mFirstPosition + this.getChildCount() - 1) < this.mItemCount;
                        const listBottom = this.getHeight() - this.mListPadding.bottom - (bottomFadingEdgeShowing ? this.getArrowScrollPreviewLength() : 0);
                        const ySearchPoint = (selectedView != null && selectedView.getBottom() < listBottom) ? selectedView.getBottom() : listBottom;
                        this.mTempRect.set(0, ySearchPoint, 0, ySearchPoint);
                    }
                    newFocus = FocusFinder.getInstance().findNextFocusFromRect(this, this.mTempRect, direction);
                }
                if (newFocus != null) {
                    const positionOfNewFocus = this.positionOfNewFocus(newFocus);
                    if (this.mSelectedPosition != ListView.INVALID_POSITION && positionOfNewFocus != this.mSelectedPosition) {
                        const selectablePosition = this.lookForSelectablePositionOnScreen(direction);
                        if (selectablePosition != ListView.INVALID_POSITION && ((direction == View.FOCUS_DOWN && selectablePosition < positionOfNewFocus) || (direction == View.FOCUS_UP && selectablePosition > positionOfNewFocus))) {
                            return null;
                        }
                    }
                    let focusScroll = this.amountToScrollToNewFocus(direction, newFocus, positionOfNewFocus);
                    const maxScrollAmount = this.getMaxScrollAmount();
                    if (focusScroll < maxScrollAmount) {
                        newFocus.requestFocus(direction);
                        this.mArrowScrollFocusResult.populate(positionOfNewFocus, focusScroll);
                        return this.mArrowScrollFocusResult;
                    }
                    else if (this.distanceToView(newFocus) < maxScrollAmount) {
                        newFocus.requestFocus(direction);
                        this.mArrowScrollFocusResult.populate(positionOfNewFocus, maxScrollAmount);
                        return this.mArrowScrollFocusResult;
                    }
                }
                return null;
            }
            positionOfNewFocus(newFocus) {
                const numChildren = this.getChildCount();
                for (let i = 0; i < numChildren; i++) {
                    const child = this.getChildAt(i);
                    if (this.isViewAncestorOf(newFocus, child)) {
                        return this.mFirstPosition + i;
                    }
                }
                throw Error(`new IllegalArgumentException("newFocus is not a child of any of the" + " children of the list!")`);
            }
            isViewAncestorOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof ViewGroup) && this.isViewAncestorOf(theParent, parent);
            }
            amountToScrollToNewFocus(direction, newFocus, positionOfNewFocus) {
                let amountToScroll = 0;
                newFocus.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(newFocus, this.mTempRect);
                if (direction == View.FOCUS_UP) {
                    if (this.mTempRect.top < this.mListPadding.top) {
                        amountToScroll = this.mListPadding.top - this.mTempRect.top;
                        if (positionOfNewFocus > 0) {
                            amountToScroll += this.getArrowScrollPreviewLength();
                        }
                    }
                }
                else {
                    const listBottom = this.getHeight() - this.mListPadding.bottom;
                    if (this.mTempRect.bottom > listBottom) {
                        amountToScroll = this.mTempRect.bottom - listBottom;
                        if (positionOfNewFocus < this.mItemCount - 1) {
                            amountToScroll += this.getArrowScrollPreviewLength();
                        }
                    }
                }
                return amountToScroll;
            }
            distanceToView(descendant) {
                let distance = 0;
                descendant.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(descendant, this.mTempRect);
                const listBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                if (this.mTempRect.bottom < this.mListPadding.top) {
                    distance = this.mListPadding.top - this.mTempRect.bottom;
                }
                else if (this.mTempRect.top > listBottom) {
                    distance = this.mTempRect.top - listBottom;
                }
                return distance;
            }
            scrollListItemsBy(amount) {
                this.offsetChildrenTopAndBottom(amount);
                const listBottom = this.getHeight() - this.mListPadding.bottom;
                const listTop = this.mListPadding.top;
                const recycleBin = this.mRecycler;
                if (amount < 0) {
                    let numChildren = this.getChildCount();
                    let last = this.getChildAt(numChildren - 1);
                    while (last.getBottom() < listBottom) {
                        const lastVisiblePosition = this.mFirstPosition + numChildren - 1;
                        if (lastVisiblePosition < this.mItemCount - 1) {
                            last = this.addViewBelow(last, lastVisiblePosition);
                            numChildren++;
                        }
                        else {
                            break;
                        }
                    }
                    if (last.getBottom() < listBottom) {
                        this.offsetChildrenTopAndBottom(listBottom - last.getBottom());
                    }
                    let first = this.getChildAt(0);
                    while (first.getBottom() < listTop) {
                        let layoutParams = first.getLayoutParams();
                        if (recycleBin.shouldRecycleViewType(layoutParams.viewType)) {
                            recycleBin.addScrapView(first, this.mFirstPosition);
                        }
                        this.detachViewFromParent(first);
                        first = this.getChildAt(0);
                        this.mFirstPosition++;
                    }
                }
                else {
                    let first = this.getChildAt(0);
                    while ((first.getTop() > listTop) && (this.mFirstPosition > 0)) {
                        first = this.addViewAbove(first, this.mFirstPosition);
                        this.mFirstPosition--;
                    }
                    if (first.getTop() > listTop) {
                        this.offsetChildrenTopAndBottom(listTop - first.getTop());
                    }
                    let lastIndex = this.getChildCount() - 1;
                    let last = this.getChildAt(lastIndex);
                    while (last.getTop() > listBottom) {
                        let layoutParams = last.getLayoutParams();
                        if (recycleBin.shouldRecycleViewType(layoutParams.viewType)) {
                            recycleBin.addScrapView(last, this.mFirstPosition + lastIndex);
                        }
                        this.detachViewFromParent(last);
                        last = this.getChildAt(--lastIndex);
                    }
                }
            }
            addViewAbove(theView, position) {
                let abovePosition = position - 1;
                let view = this.obtainView(abovePosition, this.mIsScrap);
                let edgeOfNewChild = theView.getTop() - this.mDividerHeight;
                this.setupChild(view, abovePosition, edgeOfNewChild, false, this.mListPadding.left, false, this.mIsScrap[0]);
                return view;
            }
            addViewBelow(theView, position) {
                let belowPosition = position + 1;
                let view = this.obtainView(belowPosition, this.mIsScrap);
                let edgeOfNewChild = theView.getBottom() + this.mDividerHeight;
                this.setupChild(view, belowPosition, edgeOfNewChild, true, this.mListPadding.left, false, this.mIsScrap[0]);
                return view;
            }
            setItemsCanFocus(itemsCanFocus) {
                this.mItemsCanFocus = itemsCanFocus;
                if (!itemsCanFocus) {
                    this.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
                }
            }
            getItemsCanFocus() {
                return this.mItemsCanFocus;
            }
            isOpaque() {
                let retValue = (this.mCachingActive && this.mIsCacheColorOpaque && this.mDividerIsOpaque && this.hasOpaqueScrollbars()) || super.isOpaque();
                if (retValue) {
                    const listTop = this.mListPadding != null ? this.mListPadding.top : this.mPaddingTop;
                    let first = this.getChildAt(0);
                    if (first == null || first.getTop() > listTop) {
                        return false;
                    }
                    const listBottom = this.getHeight() - (this.mListPadding != null ? this.mListPadding.bottom : this.mPaddingBottom);
                    let last = this.getChildAt(this.getChildCount() - 1);
                    if (last == null || last.getBottom() < listBottom) {
                        return false;
                    }
                }
                return retValue;
            }
            setCacheColorHint(color) {
                const opaque = (color >>> 24) == 0xFF;
                this.mIsCacheColorOpaque = opaque;
                if (opaque) {
                    if (this.mDividerPaint == null) {
                        this.mDividerPaint = new Paint();
                    }
                    this.mDividerPaint.setColor(color);
                }
                super.setCacheColorHint(color);
            }
            drawOverscrollHeader(canvas, drawable, bounds) {
                const height = drawable.getMinimumHeight();
                canvas.save();
                canvas.clipRect(bounds);
                const span = bounds.bottom - bounds.top;
                if (span < height) {
                    bounds.top = bounds.bottom - height;
                }
                drawable.setBounds(bounds);
                drawable.draw(canvas);
                canvas.restore();
            }
            drawOverscrollFooter(canvas, drawable, bounds) {
                const height = drawable.getMinimumHeight();
                canvas.save();
                canvas.clipRect(bounds);
                const span = bounds.bottom - bounds.top;
                if (span < height) {
                    bounds.bottom = bounds.top + height;
                }
                drawable.setBounds(bounds);
                drawable.draw(canvas);
                canvas.restore();
            }
            dispatchDraw(canvas) {
                if (this.mCachingStarted) {
                    this.mCachingActive = true;
                }
                const dividerHeight = this.mDividerHeight;
                const overscrollHeader = this.mOverScrollHeader;
                const overscrollFooter = this.mOverScrollFooter;
                const drawOverscrollHeader = overscrollHeader != null;
                const drawOverscrollFooter = overscrollFooter != null;
                const drawDividers = dividerHeight > 0 && this.mDivider != null;
                if (drawDividers || drawOverscrollHeader || drawOverscrollFooter) {
                    const bounds = this.mTempRect;
                    bounds.left = this.mPaddingLeft;
                    bounds.right = this.mRight - this.mLeft - this.mPaddingRight;
                    const count = this.getChildCount();
                    const headerCount = this.mHeaderViewInfos.size();
                    const itemCount = this.mItemCount;
                    const footerLimit = (itemCount - this.mFooterViewInfos.size());
                    const headerDividers = this.mHeaderDividersEnabled;
                    const footerDividers = this.mFooterDividersEnabled;
                    const first = this.mFirstPosition;
                    const areAllItemsSelectable = this.mAreAllItemsSelectable;
                    const adapter = this.mAdapter;
                    const fillForMissingDividers = this.isOpaque() && !super.isOpaque();
                    if (fillForMissingDividers && this.mDividerPaint == null && this.mIsCacheColorOpaque) {
                        this.mDividerPaint = new Paint();
                        this.mDividerPaint.setColor(this.getCacheColorHint());
                    }
                    const paint = this.mDividerPaint;
                    let effectivePaddingTop = 0;
                    let effectivePaddingBottom = 0;
                    if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                        effectivePaddingTop = this.mListPadding.top;
                        effectivePaddingBottom = this.mListPadding.bottom;
                    }
                    const listBottom = this.mBottom - this.mTop - effectivePaddingBottom + this.mScrollY;
                    if (!this.mStackFromBottom) {
                        let bottom = 0;
                        const scrollY = this.mScrollY;
                        if (count > 0 && scrollY < 0) {
                            if (drawOverscrollHeader) {
                                bounds.bottom = 0;
                                bounds.top = scrollY;
                                this.drawOverscrollHeader(canvas, overscrollHeader, bounds);
                            }
                            else if (drawDividers) {
                                bounds.bottom = 0;
                                bounds.top = -dividerHeight;
                                this.drawDivider(canvas, bounds, -1);
                            }
                        }
                        for (let i = 0; i < count; i++) {
                            const itemIndex = (first + i);
                            const isHeader = (itemIndex < headerCount);
                            const isFooter = (itemIndex >= footerLimit);
                            if ((headerDividers || !isHeader) && (footerDividers || !isFooter)) {
                                const child = this.getChildAt(i);
                                bottom = child.getBottom();
                                const isLastItem = (i == (count - 1));
                                if (drawDividers && (bottom < listBottom) && !(drawOverscrollFooter && isLastItem)) {
                                    const nextIndex = (itemIndex + 1);
                                    if (areAllItemsSelectable || ((adapter.isEnabled(itemIndex) || (headerDividers && isHeader) || (footerDividers && isFooter)) && (isLastItem || adapter.isEnabled(nextIndex) || (headerDividers && (nextIndex < headerCount)) || (footerDividers && (nextIndex >= footerLimit))))) {
                                        bounds.top = bottom;
                                        bounds.bottom = bottom + dividerHeight;
                                        this.drawDivider(canvas, bounds, i);
                                    }
                                    else if (fillForMissingDividers) {
                                        bounds.top = bottom;
                                        bounds.bottom = bottom + dividerHeight;
                                        canvas.drawRect(bounds, paint);
                                    }
                                }
                            }
                        }
                        const overFooterBottom = this.mBottom + this.mScrollY;
                        if (drawOverscrollFooter && first + count == itemCount && overFooterBottom > bottom) {
                            bounds.top = bottom;
                            bounds.bottom = overFooterBottom;
                            this.drawOverscrollFooter(canvas, overscrollFooter, bounds);
                        }
                    }
                    else {
                        let top;
                        const scrollY = this.mScrollY;
                        if (count > 0 && drawOverscrollHeader) {
                            bounds.top = scrollY;
                            bounds.bottom = this.getChildAt(0).getTop();
                            this.drawOverscrollHeader(canvas, overscrollHeader, bounds);
                        }
                        const start = drawOverscrollHeader ? 1 : 0;
                        for (let i = start; i < count; i++) {
                            const itemIndex = (first + i);
                            const isHeader = (itemIndex < headerCount);
                            const isFooter = (itemIndex >= footerLimit);
                            if ((headerDividers || !isHeader) && (footerDividers || !isFooter)) {
                                const child = this.getChildAt(i);
                                top = child.getTop();
                                if (drawDividers && (top > effectivePaddingTop)) {
                                    const isFirstItem = (i == start);
                                    const previousIndex = (itemIndex - 1);
                                    if (areAllItemsSelectable || ((adapter.isEnabled(itemIndex) || (headerDividers && isHeader) || (footerDividers && isFooter)) && (isFirstItem || adapter.isEnabled(previousIndex) || (headerDividers && (previousIndex < headerCount)) || (footerDividers && (previousIndex >= footerLimit))))) {
                                        bounds.top = top - dividerHeight;
                                        bounds.bottom = top;
                                        this.drawDivider(canvas, bounds, i - 1);
                                    }
                                    else if (fillForMissingDividers) {
                                        bounds.top = top - dividerHeight;
                                        bounds.bottom = top;
                                        canvas.drawRect(bounds, paint);
                                    }
                                }
                            }
                        }
                        if (count > 0 && scrollY > 0) {
                            if (drawOverscrollFooter) {
                                const absListBottom = this.mBottom;
                                bounds.top = absListBottom;
                                bounds.bottom = absListBottom + scrollY;
                                this.drawOverscrollFooter(canvas, overscrollFooter, bounds);
                            }
                            else if (drawDividers) {
                                bounds.top = listBottom;
                                bounds.bottom = listBottom + dividerHeight;
                                this.drawDivider(canvas, bounds, -1);
                            }
                        }
                    }
                }
                super.dispatchDraw(canvas);
            }
            drawChild(canvas, child, drawingTime) {
                let more = super.drawChild(canvas, child, drawingTime);
                if (this.mCachingActive && child.mCachingFailed) {
                    this.mCachingActive = false;
                }
                return more;
            }
            drawDivider(canvas, bounds, childIndex) {
                const divider = this.mDivider;
                divider.setBounds(bounds);
                divider.draw(canvas);
            }
            getDivider() {
                return this.mDivider;
            }
            setDivider(divider) {
                if (divider != null) {
                    this.mDividerHeight = divider.getIntrinsicHeight();
                }
                else {
                    this.mDividerHeight = 0;
                }
                this.mDivider = divider;
                this.mDividerIsOpaque = divider == null || divider.getOpacity() == PixelFormat.OPAQUE;
                this.requestLayout();
                this.invalidate();
            }
            getDividerHeight() {
                return this.mDividerHeight;
            }
            setDividerHeight(height) {
                this.mDividerHeight = height;
                this.requestLayout();
                this.invalidate();
            }
            setHeaderDividersEnabled(headerDividersEnabled) {
                this.mHeaderDividersEnabled = headerDividersEnabled;
                this.invalidate();
            }
            areHeaderDividersEnabled() {
                return this.mHeaderDividersEnabled;
            }
            setFooterDividersEnabled(footerDividersEnabled) {
                this.mFooterDividersEnabled = footerDividersEnabled;
                this.invalidate();
            }
            areFooterDividersEnabled() {
                return this.mFooterDividersEnabled;
            }
            setOverscrollHeader(header) {
                this.mOverScrollHeader = header;
                if (this.mScrollY < 0) {
                    this.invalidate();
                }
            }
            getOverscrollHeader() {
                return this.mOverScrollHeader;
            }
            setOverscrollFooter(footer) {
                this.mOverScrollFooter = footer;
                this.invalidate();
            }
            getOverscrollFooter() {
                return this.mOverScrollFooter;
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
                const adapter = this.mAdapter;
                let closetChildIndex = -1;
                let closestChildTop = 0;
                if (adapter != null && gainFocus && previouslyFocusedRect != null) {
                    previouslyFocusedRect.offset(this.mScrollX, this.mScrollY);
                    if (adapter.getCount() < this.getChildCount() + this.mFirstPosition) {
                        this.mLayoutMode = ListView.LAYOUT_NORMAL;
                        this.layoutChildren();
                    }
                    let otherRect = this.mTempRect;
                    let minDistance = Integer.MAX_VALUE;
                    const childCount = this.getChildCount();
                    const firstPosition = this.mFirstPosition;
                    for (let i = 0; i < childCount; i++) {
                        if (!adapter.isEnabled(firstPosition + i)) {
                            continue;
                        }
                        let other = this.getChildAt(i);
                        other.getDrawingRect(otherRect);
                        this.offsetDescendantRectToMyCoords(other, otherRect);
                        let distance = ListView.getDistance(previouslyFocusedRect, otherRect, direction);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closetChildIndex = i;
                            closestChildTop = other.getTop();
                        }
                    }
                }
                if (closetChildIndex >= 0) {
                    this.setSelectionFromTop(closetChildIndex + this.mFirstPosition, closestChildTop);
                }
                else {
                    this.requestLayout();
                }
            }
            onFinishInflate() {
                super.onFinishInflate();
                let count = this.getChildCount();
                if (count > 0) {
                    for (let i = 0; i < count; ++i) {
                        this.addHeaderView(this.getChildAt(i));
                    }
                    this.removeAllViews();
                }
            }
            findViewTraversal(id) {
                let v;
                v = super.findViewTraversal(id);
                if (v == null) {
                    v = this.findViewInHeadersOrFooters(this.mHeaderViewInfos, id);
                    if (v != null) {
                        return v;
                    }
                    v = this.findViewInHeadersOrFooters(this.mFooterViewInfos, id);
                    if (v != null) {
                        return v;
                    }
                }
                return v;
            }
            findViewInHeadersOrFooters(where, id) {
                if (where != null) {
                    let len = where.size();
                    let v;
                    for (let i = 0; i < len; i++) {
                        v = where.get(i).view;
                        if (!v.isRootNamespace()) {
                            v = v.findViewById(id);
                            if (v != null) {
                                return v;
                            }
                        }
                    }
                }
                return null;
            }
            findViewByPredicateTraversal(predicate, childToSkip) {
                let v;
                v = super.findViewByPredicateTraversal(predicate, childToSkip);
                if (v == null) {
                    v = this.findViewByPredicateInHeadersOrFooters(this.mHeaderViewInfos, predicate, childToSkip);
                    if (v != null) {
                        return v;
                    }
                    v = this.findViewByPredicateInHeadersOrFooters(this.mFooterViewInfos, predicate, childToSkip);
                    if (v != null) {
                        return v;
                    }
                }
                return v;
            }
            findViewByPredicateInHeadersOrFooters(where, predicate, childToSkip) {
                if (where != null) {
                    let len = where.size();
                    let v;
                    for (let i = 0; i < len; i++) {
                        v = where.get(i).view;
                        if (v != childToSkip && !v.isRootNamespace()) {
                            v = v.findViewByPredicate(predicate);
                            if (v != null) {
                                return v;
                            }
                        }
                    }
                }
                return null;
            }
            getCheckItemIds() {
                if (this.mAdapter != null && this.mAdapter.hasStableIds()) {
                    return this.getCheckedItemIds();
                }
                if (this.mChoiceMode != ListView.CHOICE_MODE_NONE && this.mCheckStates != null && this.mAdapter != null) {
                    const states = this.mCheckStates;
                    const count = states.size();
                    const ids = new Array(count);
                    const adapter = this.mAdapter;
                    let checkedCount = 0;
                    for (let i = 0; i < count; i++) {
                        if (states.valueAt(i)) {
                            ids[checkedCount++] = adapter.getItemId(states.keyAt(i));
                        }
                    }
                    if (checkedCount == count) {
                        return ids;
                    }
                    else {
                        const result = new Array(checkedCount);
                        System.arraycopy(ids, 0, result, 0, checkedCount);
                        return result;
                    }
                }
                return new Array(0);
            }
        }
        ListView.NO_POSITION = -1;
        ListView.MAX_SCROLL_FACTOR = 0.33;
        ListView.MIN_SCROLL_PREVIEW_PIXELS = 2;
        widget.ListView = ListView;
        (function (ListView) {
            class FixedViewInfo {
                constructor(arg) {
                    this._ListView_this = arg;
                }
            }
            ListView.FixedViewInfo = FixedViewInfo;
            class FocusSelector {
                constructor(arg) {
                    this.mPosition = 0;
                    this.mPositionTop = 0;
                    this._ListView_this = arg;
                }
                setup(position, top) {
                    this.mPosition = position;
                    this.mPositionTop = top;
                    return this;
                }
                run() {
                    this._ListView_this.setSelectionFromTop(this.mPosition, this.mPositionTop);
                }
            }
            ListView.FocusSelector = FocusSelector;
            class ArrowScrollFocusResult {
                constructor() {
                    this.mSelectedPosition = 0;
                    this.mAmountToScroll = 0;
                }
                populate(selectedPosition, amountToScroll) {
                    this.mSelectedPosition = selectedPosition;
                    this.mAmountToScroll = amountToScroll;
                }
                getSelectedPosition() {
                    return this.mSelectedPosition;
                }
                getAmountToScroll() {
                    return this.mAmountToScroll;
                }
            }
            ListView.ArrowScrollFocusResult = ArrowScrollFocusResult;
        })(ListView = widget.ListView || (widget.ListView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/view/FocusFinder.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/animation/AnimationUtils.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var Log = android.util.Log;
        var FocusFinder = android.view.FocusFinder;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var View = android.view.View;
        var ViewConfiguration = android.view.ViewConfiguration;
        var ViewGroup = android.view.ViewGroup;
        var AnimationUtils = android.view.animation.AnimationUtils;
        var FrameLayout = android.widget.FrameLayout;
        var OverScroller = android.widget.OverScroller;
        var ScrollView = android.widget.ScrollView;
        class HorizontalScrollView extends FrameLayout {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mLastScroll = 0;
                this.mTempRect = new Rect();
                this.mLastMotionX = 0;
                this.mIsLayoutDirty = true;
                this.mChildToScrollTo = null;
                this.mIsBeingDragged = false;
                this.mSmoothScrollingEnabled = true;
                this.mMinimumVelocity = 0;
                this.mMaximumVelocity = 0;
                this.mOverscrollDistance = 0;
                this._mOverflingDistance = 0;
                this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                this.initScrollView();
                this._attrBinder.addAttr('fillViewport', (value) => {
                    this.setFillViewport(this._attrBinder.parseBoolean(value));
                });
            }
            get mOverflingDistance() {
                if (this.mScrollX < -this._mOverflingDistance)
                    return -this.mScrollX;
                let overDistance = this.mScrollX - this.getScrollRange();
                if (overDistance > this._mOverflingDistance)
                    return overDistance;
                return this._mOverflingDistance;
            }
            set mOverflingDistance(value) {
                this._mOverflingDistance = value;
            }
            getLeftFadingEdgeStrength() {
                if (this.getChildCount() == 0) {
                    return 0.0;
                }
                const length = this.getHorizontalFadingEdgeLength();
                if (this.mScrollX < length) {
                    return this.mScrollX / length;
                }
                return 1.0;
            }
            getRightFadingEdgeStrength() {
                if (this.getChildCount() == 0) {
                    return 0.0;
                }
                const length = this.getHorizontalFadingEdgeLength();
                const rightEdge = this.getWidth() - this.mPaddingRight;
                const span = this.getChildAt(0).getRight() - this.mScrollX - rightEdge;
                if (span < length) {
                    return span / length;
                }
                return 1.0;
            }
            getMaxScrollAmount() {
                return Math.floor((HorizontalScrollView.MAX_SCROLL_FACTOR * (this.mRight - this.mLeft)));
            }
            initScrollView() {
                this.mScroller = new OverScroller();
                this.setFocusable(true);
                this.setDescendantFocusability(HorizontalScrollView.FOCUS_AFTER_DESCENDANTS);
                this.setWillNotDraw(false);
                const configuration = ViewConfiguration.get();
                this.mTouchSlop = configuration.getScaledTouchSlop();
                this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mOverscrollDistance = configuration.getScaledOverscrollDistance();
                this._mOverflingDistance = configuration.getScaledOverflingDistance();
                this.initScrollCache();
                this.setHorizontalScrollBarEnabled(true);
            }
            addView(...args) {
                if (this.getChildCount() > 0) {
                    throw new Error("ScrollView can host only one direct child");
                }
                return super.addView(...args);
            }
            canScroll() {
                let child = this.getChildAt(0);
                if (child != null) {
                    let childWidth = child.getWidth();
                    return this.getWidth() < childWidth + this.mPaddingLeft + this.mPaddingRight;
                }
                return false;
            }
            isFillViewport() {
                return this.mFillViewport;
            }
            setFillViewport(fillViewport) {
                if (fillViewport != this.mFillViewport) {
                    this.mFillViewport = fillViewport;
                    this.requestLayout();
                }
            }
            isSmoothScrollingEnabled() {
                return this.mSmoothScrollingEnabled;
            }
            setSmoothScrollingEnabled(smoothScrollingEnabled) {
                this.mSmoothScrollingEnabled = smoothScrollingEnabled;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                if (!this.mFillViewport) {
                    return;
                }
                const widthMode = HorizontalScrollView.MeasureSpec.getMode(widthMeasureSpec);
                if (widthMode == HorizontalScrollView.MeasureSpec.UNSPECIFIED) {
                    return;
                }
                if (this.getChildCount() > 0) {
                    const child = this.getChildAt(0);
                    let width = this.getMeasuredWidth();
                    if (child.getMeasuredWidth() < width) {
                        const lp = child.getLayoutParams();
                        let childHeightMeasureSpec = HorizontalScrollView.getChildMeasureSpec(heightMeasureSpec, this.mPaddingTop + this.mPaddingBottom, lp.height);
                        width -= this.mPaddingLeft;
                        width -= this.mPaddingRight;
                        let childWidthMeasureSpec = HorizontalScrollView.MeasureSpec.makeMeasureSpec(width, HorizontalScrollView.MeasureSpec.EXACTLY);
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            dispatchKeyEvent(event) {
                return super.dispatchKeyEvent(event) || this.executeKeyEvent(event);
            }
            executeKeyEvent(event) {
                this.mTempRect.setEmpty();
                if (!this.canScroll()) {
                    if (this.isFocused()) {
                        let currentFocused = this.findFocus();
                        if (currentFocused == this)
                            currentFocused = null;
                        let nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_RIGHT);
                        return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_RIGHT);
                    }
                    return false;
                }
                let handled = false;
                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    switch (event.getKeyCode()) {
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_LEFT);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_LEFT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_RIGHT);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_RIGHT);
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            this.pageScroll(event.isShiftPressed() ? View.FOCUS_LEFT : View.FOCUS_RIGHT);
                            break;
                    }
                }
                return handled;
            }
            inChild(x, y) {
                if (this.getChildCount() > 0) {
                    const scrollX = this.mScrollX;
                    const child = this.getChildAt(0);
                    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() - scrollX || x >= child.getRight() - scrollX);
                }
                return false;
            }
            initOrResetVelocityTracker() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    this.mVelocityTracker.clear();
                }
            }
            initVelocityTrackerIfNotExists() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
            }
            recycleVelocityTracker() {
                if (this.mVelocityTracker != null) {
                    this.mVelocityTracker.recycle();
                    this.mVelocityTracker = null;
                }
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept) {
                    this.recycleVelocityTracker();
                }
                super.requestDisallowInterceptTouchEvent(disallowIntercept);
            }
            onInterceptTouchEvent(ev) {
                const action = ev.getAction();
                if ((action == MotionEvent.ACTION_MOVE) && (this.mIsBeingDragged)) {
                    return true;
                }
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_MOVE:
                        {
                            const activePointerId = this.mActivePointerId;
                            if (activePointerId == HorizontalScrollView.INVALID_POINTER) {
                                break;
                            }
                            const pointerIndex = ev.findPointerIndex(activePointerId);
                            if (pointerIndex == -1) {
                                Log.e(HorizontalScrollView.TAG, "Invalid pointerId=" + activePointerId + " in onInterceptTouchEvent");
                                break;
                            }
                            const x = Math.floor(ev.getX(pointerIndex));
                            const xDiff = Math.floor(Math.abs(x - this.mLastMotionX));
                            if (xDiff > this.mTouchSlop) {
                                this.mIsBeingDragged = true;
                                this.mLastMotionX = x;
                                this.initVelocityTrackerIfNotExists();
                                this.mVelocityTracker.addMovement(ev);
                                if (this.mParent != null)
                                    this.mParent.requestDisallowInterceptTouchEvent(true);
                            }
                            break;
                        }
                    case MotionEvent.ACTION_DOWN:
                        {
                            const x = Math.floor(ev.getX());
                            if (!this.inChild(Math.floor(x), Math.floor(ev.getY()))) {
                                this.mIsBeingDragged = false;
                                this.recycleVelocityTracker();
                                break;
                            }
                            this.mLastMotionX = x;
                            this.mActivePointerId = ev.getPointerId(0);
                            this.initOrResetVelocityTracker();
                            this.mVelocityTracker.addMovement(ev);
                            this.mIsBeingDragged = !this.mScroller.isFinished();
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        this.mIsBeingDragged = false;
                        this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                        if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0)) {
                            this.postInvalidateOnAnimation();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_DOWN:
                        {
                            const index = ev.getActionIndex();
                            this.mLastMotionX = Math.floor(ev.getX(index));
                            this.mActivePointerId = ev.getPointerId(index);
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        this.mLastMotionX = Math.floor(ev.getX(ev.findPointerIndex(this.mActivePointerId)));
                        break;
                }
                return this.mIsBeingDragged;
            }
            onTouchEvent(ev) {
                this.initVelocityTrackerIfNotExists();
                this.mVelocityTracker.addMovement(ev);
                const action = ev.getAction();
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            if (this.getChildCount() == 0) {
                                return false;
                            }
                            if ((this.mIsBeingDragged = !this.mScroller.isFinished())) {
                                const parent = this.getParent();
                                if (parent != null) {
                                    parent.requestDisallowInterceptTouchEvent(true);
                                }
                            }
                            if (!this.mScroller.isFinished()) {
                                this.mScroller.abortAnimation();
                            }
                            this.mLastMotionX = Math.floor(ev.getX());
                            this.mActivePointerId = ev.getPointerId(0);
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                        if (activePointerIndex == -1) {
                            Log.e(HorizontalScrollView.TAG, "Invalid pointerId=" + this.mActivePointerId + " in onTouchEvent");
                            break;
                        }
                        const x = Math.floor(ev.getX(activePointerIndex));
                        let deltaX = this.mLastMotionX - x;
                        if (!this.mIsBeingDragged && Math.abs(deltaX) > this.mTouchSlop) {
                            const parent = this.getParent();
                            if (parent != null) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                            this.mIsBeingDragged = true;
                            if (deltaX > 0) {
                                deltaX -= this.mTouchSlop;
                            }
                            else {
                                deltaX += this.mTouchSlop;
                            }
                        }
                        if (this.mIsBeingDragged) {
                            this.mLastMotionX = x;
                            const oldX = this.mScrollX;
                            const oldY = this.mScrollY;
                            const range = this.getScrollRange();
                            const overscrollMode = this.getOverScrollMode();
                            const canOverscroll = overscrollMode == HorizontalScrollView.OVER_SCROLL_ALWAYS || (overscrollMode == HorizontalScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                            if (this.overScrollBy(deltaX, 0, this.mScrollX, 0, range, 0, this.mOverscrollDistance, 0, true)) {
                                this.mVelocityTracker.clear();
                            }
                            if (canOverscroll) {
                            }
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        if (this.mIsBeingDragged) {
                            const velocityTracker = this.mVelocityTracker;
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                            let initialVelocity = Math.floor(velocityTracker.getXVelocity(this.mActivePointerId));
                            if (this.getChildCount() > 0) {
                                let isOverDrag = this.mScrollX < 0 || this.mScrollX > this.getScrollRange();
                                if (!isOverDrag && (Math.abs(initialVelocity) > this.mMinimumVelocity)) {
                                    this.fling(-initialVelocity);
                                }
                                else {
                                    if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0)) {
                                        this.postInvalidateOnAnimation();
                                    }
                                }
                            }
                            this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                            this.mIsBeingDragged = false;
                            this.recycleVelocityTracker();
                        }
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        if (this.mIsBeingDragged && this.getChildCount() > 0) {
                            if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0)) {
                                this.postInvalidateOnAnimation();
                            }
                            this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                            this.mIsBeingDragged = false;
                            this.recycleVelocityTracker();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        break;
                }
                return true;
            }
            onSecondaryPointerUp(ev) {
                const pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                const pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == this.mActivePointerId) {
                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    this.mLastMotionX = Math.floor(ev.getX(newPointerIndex));
                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                    if (this.mVelocityTracker != null) {
                        this.mVelocityTracker.clear();
                    }
                }
            }
            onGenericMotionEvent(event) {
                if (event.isPointerEvent()) {
                    switch (event.getAction()) {
                        case MotionEvent.ACTION_SCROLL:
                            {
                                if (!this.mIsBeingDragged) {
                                    let hscroll;
                                    hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
                                    if (hscroll != 0) {
                                        const delta = Math.floor((hscroll * this.getHorizontalScrollFactor()));
                                        const range = this.getScrollRange();
                                        let oldScrollX = this.mScrollX;
                                        let newScrollX = oldScrollX + delta;
                                        if (newScrollX < 0) {
                                            newScrollX = 0;
                                        }
                                        else if (newScrollX > range) {
                                            newScrollX = range;
                                        }
                                        if (newScrollX != oldScrollX) {
                                            super.scrollTo(newScrollX, this.mScrollY);
                                            return true;
                                        }
                                    }
                                }
                            }
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            shouldDelayChildPressedState() {
                return true;
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
                if (!this.mScroller.isFinished()) {
                    const oldX = this.mScrollX;
                    const oldY = this.mScrollY;
                    this.mScrollX = scrollX;
                    this.mScrollY = scrollY;
                    this.invalidateParentIfNeeded();
                    this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                    if (clampedX) {
                        this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0);
                    }
                }
                else {
                    super.scrollTo(scrollX, scrollY);
                }
                this.awakenScrollBars();
            }
            getScrollRange() {
                let scrollRange = 0;
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    scrollRange = Math.max(0, child.getWidth() - (this.getWidth() - this.mPaddingLeft - this.mPaddingRight));
                }
                return scrollRange;
            }
            findFocusableViewInMyBounds(leftFocus, left, preferredFocusable) {
                const fadingEdgeLength = this.getHorizontalFadingEdgeLength() / 2;
                const leftWithoutFadingEdge = left + fadingEdgeLength;
                const rightWithoutFadingEdge = left + this.getWidth() - fadingEdgeLength;
                if ((preferredFocusable != null) && (preferredFocusable.getLeft() < rightWithoutFadingEdge) && (preferredFocusable.getRight() > leftWithoutFadingEdge)) {
                    return preferredFocusable;
                }
                return this.findFocusableViewInBounds(leftFocus, leftWithoutFadingEdge, rightWithoutFadingEdge);
            }
            findFocusableViewInBounds(leftFocus, left, right) {
                let focusables = this.getFocusables(View.FOCUS_FORWARD);
                let focusCandidate = null;
                let foundFullyContainedFocusable = false;
                let count = focusables.size();
                for (let i = 0; i < count; i++) {
                    let view = focusables.get(i);
                    let viewLeft = view.getLeft();
                    let viewRight = view.getRight();
                    if (left < viewRight && viewLeft < right) {
                        const viewIsFullyContained = (left < viewLeft) && (viewRight < right);
                        if (focusCandidate == null) {
                            focusCandidate = view;
                            foundFullyContainedFocusable = viewIsFullyContained;
                        }
                        else {
                            const viewIsCloserToBoundary = (leftFocus && viewLeft < focusCandidate.getLeft()) || (!leftFocus && viewRight > focusCandidate.getRight());
                            if (foundFullyContainedFocusable) {
                                if (viewIsFullyContained && viewIsCloserToBoundary) {
                                    focusCandidate = view;
                                }
                            }
                            else {
                                if (viewIsFullyContained) {
                                    focusCandidate = view;
                                    foundFullyContainedFocusable = true;
                                }
                                else if (viewIsCloserToBoundary) {
                                    focusCandidate = view;
                                }
                            }
                        }
                    }
                }
                return focusCandidate;
            }
            pageScroll(direction) {
                let right = direction == View.FOCUS_RIGHT;
                let width = this.getWidth();
                if (right) {
                    this.mTempRect.left = this.getScrollX() + width;
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(0);
                        if (this.mTempRect.left + width > view.getRight()) {
                            this.mTempRect.left = view.getRight() - width;
                        }
                    }
                }
                else {
                    this.mTempRect.left = this.getScrollX() - width;
                    if (this.mTempRect.left < 0) {
                        this.mTempRect.left = 0;
                    }
                }
                this.mTempRect.right = this.mTempRect.left + width;
                return this.scrollAndFocus(direction, this.mTempRect.left, this.mTempRect.right);
            }
            fullScroll(direction) {
                let right = direction == View.FOCUS_RIGHT;
                let width = this.getWidth();
                this.mTempRect.left = 0;
                this.mTempRect.right = width;
                if (right) {
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(0);
                        this.mTempRect.right = view.getRight();
                        this.mTempRect.left = this.mTempRect.right - width;
                    }
                }
                return this.scrollAndFocus(direction, this.mTempRect.left, this.mTempRect.right);
            }
            scrollAndFocus(direction, left, right) {
                let handled = true;
                let width = this.getWidth();
                let containerLeft = this.getScrollX();
                let containerRight = containerLeft + width;
                let goLeft = direction == View.FOCUS_LEFT;
                let newFocused = this.findFocusableViewInBounds(goLeft, left, right);
                if (newFocused == null) {
                    newFocused = this;
                }
                if (left >= containerLeft && right <= containerRight) {
                    handled = false;
                }
                else {
                    let delta = goLeft ? (left - containerLeft) : (right - containerRight);
                    this.doScrollX(delta);
                }
                if (newFocused != this.findFocus())
                    newFocused.requestFocus(direction);
                return handled;
            }
            arrowScroll(direction) {
                let currentFocused = this.findFocus();
                if (currentFocused == this)
                    currentFocused = null;
                let nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
                const maxJump = this.getMaxScrollAmount();
                if (nextFocused != null && this.isWithinDeltaOfScreen(nextFocused, maxJump)) {
                    nextFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(nextFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollX(scrollDelta);
                    nextFocused.requestFocus(direction);
                }
                else {
                    let scrollDelta = maxJump;
                    if (direction == View.FOCUS_LEFT && this.getScrollX() < scrollDelta) {
                        scrollDelta = this.getScrollX();
                    }
                    else if (direction == View.FOCUS_RIGHT && this.getChildCount() > 0) {
                        let daRight = this.getChildAt(0).getRight();
                        let screenRight = this.getScrollX() + this.getWidth();
                        if (daRight - screenRight < maxJump) {
                            scrollDelta = daRight - screenRight;
                        }
                    }
                    if (scrollDelta == 0) {
                        return false;
                    }
                    this.doScrollX(direction == View.FOCUS_RIGHT ? scrollDelta : -scrollDelta);
                }
                if (currentFocused != null && currentFocused.isFocused() && this.isOffScreen(currentFocused)) {
                    const descendantFocusability = this.getDescendantFocusability();
                    this.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
                    this.requestFocus();
                    this.setDescendantFocusability(descendantFocusability);
                }
                return true;
            }
            isOffScreen(descendant) {
                return !this.isWithinDeltaOfScreen(descendant, 0);
            }
            isWithinDeltaOfScreen(descendant, delta) {
                descendant.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(descendant, this.mTempRect);
                return (this.mTempRect.right + delta) >= this.getScrollX() && (this.mTempRect.left - delta) <= (this.getScrollX() + this.getWidth());
            }
            doScrollX(delta) {
                if (delta != 0) {
                    if (this.mSmoothScrollingEnabled) {
                        this.smoothScrollBy(delta, 0);
                    }
                    else {
                        this.scrollBy(delta, 0);
                    }
                }
            }
            smoothScrollBy(dx, dy) {
                if (this.getChildCount() == 0) {
                    return;
                }
                let duration = AnimationUtils.currentAnimationTimeMillis() - this.mLastScroll;
                if (duration > HorizontalScrollView.ANIMATED_SCROLL_GAP) {
                    const width = this.getWidth() - this.mPaddingRight - this.mPaddingLeft;
                    const right = this.getChildAt(0).getWidth();
                    const maxX = Math.max(0, right - width);
                    const scrollX = this.mScrollX;
                    dx = Math.max(0, Math.min(scrollX + dx, maxX)) - scrollX;
                    this.mScroller.startScroll(scrollX, this.mScrollY, dx, 0);
                    this.postInvalidateOnAnimation();
                }
                else {
                    if (!this.mScroller.isFinished()) {
                        this.mScroller.abortAnimation();
                    }
                    this.scrollBy(dx, dy);
                }
                this.mLastScroll = AnimationUtils.currentAnimationTimeMillis();
            }
            smoothScrollTo(x, y) {
                this.smoothScrollBy(x - this.mScrollX, y - this.mScrollY);
            }
            computeHorizontalScrollRange() {
                const count = this.getChildCount();
                const contentWidth = this.getWidth() - this.mPaddingLeft - this.mPaddingRight;
                if (count == 0) {
                    return contentWidth;
                }
                let scrollRange = this.getChildAt(0).getRight();
                const scrollX = this.mScrollX;
                const overscrollRight = Math.max(0, scrollRange - contentWidth);
                if (scrollX < 0) {
                    scrollRange -= scrollX;
                }
                else if (scrollX > overscrollRight) {
                    scrollRange += scrollX - overscrollRight;
                }
                return scrollRange;
            }
            computeHorizontalScrollOffset() {
                return Math.max(0, super.computeHorizontalScrollOffset());
            }
            measureChild(child, parentWidthMeasureSpec, parentHeightMeasureSpec) {
                let lp = child.getLayoutParams();
                let childWidthMeasureSpec;
                let childHeightMeasureSpec;
                childHeightMeasureSpec = HorizontalScrollView.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom, lp.height);
                childWidthMeasureSpec = HorizontalScrollView.MeasureSpec.makeMeasureSpec(0, HorizontalScrollView.MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed) {
                const lp = child.getLayoutParams();
                const childHeightMeasureSpec = HorizontalScrollView.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height);
                const childWidthMeasureSpec = HorizontalScrollView.MeasureSpec.makeMeasureSpec(lp.leftMargin + lp.rightMargin, HorizontalScrollView.MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            computeScroll() {
                if (this.mScroller.computeScrollOffset()) {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    let x = this.mScroller.getCurrX();
                    let y = this.mScroller.getCurrY();
                    if (oldX != x || oldY != y) {
                        const range = this.getScrollRange();
                        const overscrollMode = this.getOverScrollMode();
                        const canOverscroll = overscrollMode == HorizontalScrollView.OVER_SCROLL_ALWAYS || (overscrollMode == HorizontalScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                        this.overScrollBy(x - oldX, y - oldY, oldX, oldY, range, 0, this.mOverflingDistance, 0, false);
                        this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                        if (canOverscroll) {
                        }
                    }
                    if (!this.awakenScrollBars()) {
                        this.postInvalidateOnAnimation();
                    }
                }
            }
            scrollToChild(child) {
                child.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(child, this.mTempRect);
                let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                if (scrollDelta != 0) {
                    this.scrollBy(scrollDelta, 0);
                }
            }
            scrollToChildRect(rect, immediate) {
                const delta = this.computeScrollDeltaToGetChildRectOnScreen(rect);
                const scroll = delta != 0;
                if (scroll) {
                    if (immediate) {
                        this.scrollBy(delta, 0);
                    }
                    else {
                        this.smoothScrollBy(delta, 0);
                    }
                }
                return scroll;
            }
            computeScrollDeltaToGetChildRectOnScreen(rect) {
                if (this.getChildCount() == 0)
                    return 0;
                let width = this.getWidth();
                let screenLeft = this.getScrollX();
                let screenRight = screenLeft + width;
                let fadingEdge = this.getHorizontalFadingEdgeLength();
                if (rect.left > 0) {
                    screenLeft += fadingEdge;
                }
                if (rect.right < this.getChildAt(0).getWidth()) {
                    screenRight -= fadingEdge;
                }
                let scrollXDelta = 0;
                if (rect.right > screenRight && rect.left > screenLeft) {
                    if (rect.width() > width) {
                        scrollXDelta += (rect.left - screenLeft);
                    }
                    else {
                        scrollXDelta += (rect.right - screenRight);
                    }
                    let right = this.getChildAt(0).getRight();
                    let distanceToRight = right - screenRight;
                    scrollXDelta = Math.min(scrollXDelta, distanceToRight);
                }
                else if (rect.left < screenLeft && rect.right < screenRight) {
                    if (rect.width() > width) {
                        scrollXDelta -= (screenRight - rect.right);
                    }
                    else {
                        scrollXDelta -= (screenLeft - rect.left);
                    }
                    scrollXDelta = Math.max(scrollXDelta, -this.getScrollX());
                }
                return scrollXDelta;
            }
            requestChildFocus(child, focused) {
                if (!this.mIsLayoutDirty) {
                    this.scrollToChild(focused);
                }
                else {
                    this.mChildToScrollTo = focused;
                }
                super.requestChildFocus(child, focused);
            }
            onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                if (direction == View.FOCUS_FORWARD) {
                    direction = View.FOCUS_RIGHT;
                }
                else if (direction == View.FOCUS_BACKWARD) {
                    direction = View.FOCUS_LEFT;
                }
                const nextFocus = previouslyFocusedRect == null ? FocusFinder.getInstance().findNextFocus(this, null, direction) : FocusFinder.getInstance().findNextFocusFromRect(this, previouslyFocusedRect, direction);
                if (nextFocus == null) {
                    return false;
                }
                if (this.isOffScreen(nextFocus)) {
                    return false;
                }
                return nextFocus.requestFocus(direction, previouslyFocusedRect);
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                rectangle.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
                return this.scrollToChildRect(rectangle, immediate);
            }
            requestLayout() {
                this.mIsLayoutDirty = true;
                super.requestLayout();
            }
            onLayout(changed, l, t, r, b) {
                let childWidth = 0;
                let childMargins = 0;
                if (this.getChildCount() > 0) {
                    childWidth = this.getChildAt(0).getMeasuredWidth();
                    let childParams = this.getChildAt(0).getLayoutParams();
                    childMargins = childParams.leftMargin + childParams.rightMargin;
                }
                const available = r - l - this.getPaddingLeftWithForeground() - this.getPaddingRightWithForeground() - childMargins;
                const forceLeftGravity = (childWidth > available);
                this.layoutChildren(l, t, r, b, forceLeftGravity);
                this.mIsLayoutDirty = false;
                if (this.mChildToScrollTo != null && HorizontalScrollView.isViewDescendantOf(this.mChildToScrollTo, this)) {
                    this.scrollToChild(this.mChildToScrollTo);
                }
                this.mChildToScrollTo = null;
                if (!this.isLaidOut()) {
                    const scrollRange = Math.max(0, childWidth - (r - l - this.mPaddingLeft - this.mPaddingRight));
                    {
                        if (this.isLayoutRtl()) {
                            this.mScrollX = scrollRange - this.mScrollX;
                        }
                    }
                    if (this.mScrollX > scrollRange) {
                        this.mScrollX = scrollRange;
                    }
                    else if (this.mScrollX < 0) {
                        this.mScrollX = 0;
                    }
                }
                this.scrollTo(this.mScrollX, this.mScrollY);
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                let currentFocused = this.findFocus();
                if (null == currentFocused || this == currentFocused)
                    return;
                const maxJump = this.mRight - this.mLeft;
                if (this.isWithinDeltaOfScreen(currentFocused, maxJump)) {
                    currentFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(currentFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollX(scrollDelta);
                }
            }
            static isViewDescendantOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof ViewGroup) && HorizontalScrollView.isViewDescendantOf(theParent, parent);
            }
            fling(velocityX) {
                if (this.getChildCount() > 0) {
                    let width = this.getWidth() - this.mPaddingRight - this.mPaddingLeft;
                    let right = this.getChildAt(0).getWidth();
                    this.mScroller.fling(this.mScrollX, this.mScrollY, velocityX, 0, 0, Math.max(0, right - width), 0, 0, width / 2, 0);
                    const movingRight = velocityX > 0;
                    let currentFocused = this.findFocus();
                    let newFocused = this.findFocusableViewInMyBounds(movingRight, this.mScroller.getFinalX(), currentFocused);
                    if (newFocused == null) {
                        newFocused = this;
                    }
                    if (newFocused != currentFocused) {
                        newFocused.requestFocus(movingRight ? View.FOCUS_RIGHT : View.FOCUS_LEFT);
                    }
                    this.postInvalidateOnAnimation();
                }
            }
            scrollTo(x, y) {
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    x = HorizontalScrollView.clamp(x, this.getWidth() - this.mPaddingRight - this.mPaddingLeft, child.getWidth());
                    y = HorizontalScrollView.clamp(y, this.getHeight() - this.mPaddingBottom - this.mPaddingTop, child.getHeight());
                    if (x != this.mScrollX || y != this.mScrollY) {
                        super.scrollTo(x, y);
                    }
                }
            }
            setOverScrollMode(mode) {
                super.setOverScrollMode(mode);
            }
            draw(canvas) {
                super.draw(canvas);
            }
            static clamp(n, my, child) {
                if (my >= child || n < 0) {
                    return 0;
                }
                if ((my + n) > child) {
                    return child - my;
                }
                return n;
            }
        }
        HorizontalScrollView.ANIMATED_SCROLL_GAP = ScrollView.ANIMATED_SCROLL_GAP;
        HorizontalScrollView.MAX_SCROLL_FACTOR = ScrollView.MAX_SCROLL_FACTOR;
        HorizontalScrollView.TAG = "HorizontalScrollView";
        HorizontalScrollView.INVALID_POINTER = -1;
        widget.HorizontalScrollView = HorizontalScrollView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/util/ArrayMap.ts"/>
///<reference path="../../java/util/ArrayDeque.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/util/Pools.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/util/SparseMap.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/widget/HorizontalScrollView.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ArrayMap = android.util.ArrayMap;
        var ArrayDeque = java.util.ArrayDeque;
        var ArrayList = java.util.ArrayList;
        var Rect = android.graphics.Rect;
        var SynchronizedPool = android.util.Pools.SynchronizedPool;
        var SparseMap = android.util.SparseMap;
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        class RelativeLayout extends ViewGroup {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mBaselineView = null;
                this.mGravity = Gravity.START | Gravity.TOP;
                this.mContentBounds = new Rect();
                this.mSelfBounds = new Rect();
                this.mIgnoreGravity = View.NO_ID;
                this.mGraph = new RelativeLayout.DependencyGraph();
                this.mAllowBrokenMeasureSpecs = false;
                this.mMeasureVerticalWithPaddingMargin = false;
                this._attrBinder.addAttr('ignoreGravity', (value) => {
                    this.setIgnoreGravity(value);
                });
                this._attrBinder.addAttr('gravity', (value) => {
                    this.setGravity(this._attrBinder.parseGravity(value, this.mGravity));
                });
                this.queryCompatibilityModes();
            }
            queryCompatibilityModes() {
                this.mAllowBrokenMeasureSpecs = false;
                this.mMeasureVerticalWithPaddingMargin = true;
            }
            shouldDelayChildPressedState() {
                return false;
            }
            setIgnoreGravity(viewId) {
                this.mIgnoreGravity = viewId;
            }
            getGravity() {
                return this.mGravity;
            }
            setGravity(gravity) {
                if (this.mGravity != gravity) {
                    if ((gravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK) == 0) {
                        gravity |= Gravity.START;
                    }
                    if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
                        gravity |= Gravity.TOP;
                    }
                    this.mGravity = gravity;
                    this.requestLayout();
                }
            }
            setHorizontalGravity(horizontalGravity) {
                const gravity = horizontalGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
                if ((this.mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK) != gravity) {
                    this.mGravity = (this.mGravity & ~Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK) | gravity;
                    this.requestLayout();
                }
            }
            setVerticalGravity(verticalGravity) {
                const gravity = verticalGravity & Gravity.VERTICAL_GRAVITY_MASK;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != gravity) {
                    this.mGravity = (this.mGravity & ~Gravity.VERTICAL_GRAVITY_MASK) | gravity;
                    this.requestLayout();
                }
            }
            getBaseline() {
                return this.mBaselineView != null ? this.mBaselineView.getBaseline() : super.getBaseline();
            }
            requestLayout() {
                super.requestLayout();
                this.mDirtyHierarchy = true;
            }
            sortChildren() {
                const count = this.getChildCount();
                if (this.mSortedVerticalChildren == null || this.mSortedVerticalChildren.length != count) {
                    this.mSortedVerticalChildren = new Array(count);
                }
                if (this.mSortedHorizontalChildren == null || this.mSortedHorizontalChildren.length != count) {
                    this.mSortedHorizontalChildren = new Array(count);
                }
                const graph = this.mGraph;
                graph.clear();
                for (let i = 0; i < count; i++) {
                    graph.add(this.getChildAt(i));
                }
                graph.getSortedViews(this.mSortedVerticalChildren, RelativeLayout.RULES_VERTICAL);
                graph.getSortedViews(this.mSortedHorizontalChildren, RelativeLayout.RULES_HORIZONTAL);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                if (this.mDirtyHierarchy) {
                    this.mDirtyHierarchy = false;
                    this.sortChildren();
                }
                let myWidth = -1;
                let myHeight = -1;
                let width = 0;
                let height = 0;
                const widthMode = RelativeLayout.MeasureSpec.getMode(widthMeasureSpec);
                const heightMode = RelativeLayout.MeasureSpec.getMode(heightMeasureSpec);
                const widthSize = RelativeLayout.MeasureSpec.getSize(widthMeasureSpec);
                const heightSize = RelativeLayout.MeasureSpec.getSize(heightMeasureSpec);
                if (widthMode != RelativeLayout.MeasureSpec.UNSPECIFIED) {
                    myWidth = widthSize;
                }
                if (heightMode != RelativeLayout.MeasureSpec.UNSPECIFIED) {
                    myHeight = heightSize;
                }
                if (widthMode == RelativeLayout.MeasureSpec.EXACTLY) {
                    width = myWidth;
                }
                if (heightMode == RelativeLayout.MeasureSpec.EXACTLY) {
                    height = myHeight;
                }
                this.mHasBaselineAlignedChild = false;
                let ignore = null;
                let gravity = this.mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
                const horizontalGravity = gravity != Gravity.START && gravity != 0;
                gravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                const verticalGravity = gravity != Gravity.TOP && gravity != 0;
                let left = Integer.MAX_VALUE;
                let top = Integer.MAX_VALUE;
                let right = Integer.MIN_VALUE;
                let bottom = Integer.MIN_VALUE;
                let offsetHorizontalAxis = false;
                let offsetVerticalAxis = false;
                if ((horizontalGravity || verticalGravity) && this.mIgnoreGravity != View.NO_ID) {
                    ignore = this.findViewById(this.mIgnoreGravity);
                }
                const isWrapContentWidth = widthMode != RelativeLayout.MeasureSpec.EXACTLY;
                const isWrapContentHeight = heightMode != RelativeLayout.MeasureSpec.EXACTLY;
                const layoutDirection = this.getLayoutDirection();
                if (this.isLayoutRtl() && myWidth == -1) {
                    myWidth = RelativeLayout.DEFAULT_WIDTH;
                }
                let views = this.mSortedHorizontalChildren;
                let count = views.length;
                for (let i = 0; i < count; i++) {
                    let child = views[i];
                    if (child.getVisibility() != RelativeLayout.GONE) {
                        let params = child.getLayoutParams();
                        let rules = params.getRules(layoutDirection);
                        this.applyHorizontalSizeRules(params, myWidth, rules);
                        this.measureChildHorizontal(child, params, myWidth, myHeight);
                        if (this.positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) {
                            offsetHorizontalAxis = true;
                        }
                    }
                }
                views = this.mSortedVerticalChildren;
                count = views.length;
                for (let i = 0; i < count; i++) {
                    let child = views[i];
                    if (child.getVisibility() != RelativeLayout.GONE) {
                        let params = child.getLayoutParams();
                        this.applyVerticalSizeRules(params, myHeight);
                        this._measureChild(child, params, myWidth, myHeight);
                        if (this.positionChildVertical(child, params, myHeight, isWrapContentHeight)) {
                            offsetVerticalAxis = true;
                        }
                        if (isWrapContentWidth) {
                            if (this.isLayoutRtl()) {
                                width = Math.max(width, myWidth - params.mLeft - params.leftMargin);
                            }
                            else {
                                width = Math.max(width, params.mRight + params.rightMargin);
                            }
                        }
                        if (isWrapContentHeight) {
                            height = Math.max(height, params.mBottom + params.bottomMargin);
                        }
                        if (child != ignore || verticalGravity) {
                            left = Math.min(left, params.mLeft - params.leftMargin);
                            top = Math.min(top, params.mTop - params.topMargin);
                        }
                        if (child != ignore || horizontalGravity) {
                            right = Math.max(right, params.mRight + params.rightMargin);
                            bottom = Math.max(bottom, params.mBottom + params.bottomMargin);
                        }
                    }
                }
                if (this.mHasBaselineAlignedChild) {
                    for (let i = 0; i < count; i++) {
                        let child = this.getChildAt(i);
                        if (child.getVisibility() != RelativeLayout.GONE) {
                            let params = child.getLayoutParams();
                            this.alignBaseline(child, params);
                            if (child != ignore || verticalGravity) {
                                left = Math.min(left, params.mLeft - params.leftMargin);
                                top = Math.min(top, params.mTop - params.topMargin);
                            }
                            if (child != ignore || horizontalGravity) {
                                right = Math.max(right, params.mRight + params.rightMargin);
                                bottom = Math.max(bottom, params.mBottom + params.bottomMargin);
                            }
                        }
                    }
                }
                if (isWrapContentWidth) {
                    width += this.mPaddingRight;
                    if (this.mLayoutParams != null && this.mLayoutParams.width >= 0) {
                        width = Math.max(width, this.mLayoutParams.width);
                    }
                    width = Math.max(width, this.getSuggestedMinimumWidth());
                    width = RelativeLayout.resolveSize(width, widthMeasureSpec);
                    if (offsetHorizontalAxis) {
                        for (let i = 0; i < count; i++) {
                            let child = this.getChildAt(i);
                            if (child.getVisibility() != RelativeLayout.GONE) {
                                let params = child.getLayoutParams();
                                const rules = params.getRules(layoutDirection);
                                if (rules[RelativeLayout.CENTER_IN_PARENT] != null || rules[RelativeLayout.CENTER_HORIZONTAL] != null) {
                                    RelativeLayout.centerHorizontal(child, params, width);
                                }
                                else if (rules[RelativeLayout.ALIGN_PARENT_RIGHT] != null) {
                                    const childWidth = child.getMeasuredWidth();
                                    params.mLeft = width - this.mPaddingRight - childWidth;
                                    params.mRight = params.mLeft + childWidth;
                                }
                            }
                        }
                    }
                }
                if (isWrapContentHeight) {
                    height += this.mPaddingBottom;
                    if (this.mLayoutParams != null && this.mLayoutParams.height >= 0) {
                        height = Math.max(height, this.mLayoutParams.height);
                    }
                    height = Math.max(height, this.getSuggestedMinimumHeight());
                    height = RelativeLayout.resolveSize(height, heightMeasureSpec);
                    if (offsetVerticalAxis) {
                        for (let i = 0; i < count; i++) {
                            let child = this.getChildAt(i);
                            if (child.getVisibility() != RelativeLayout.GONE) {
                                let params = child.getLayoutParams();
                                const rules = params.getRules(layoutDirection);
                                if (rules[RelativeLayout.CENTER_IN_PARENT] != null || rules[RelativeLayout.CENTER_VERTICAL] != null) {
                                    RelativeLayout.centerVertical(child, params, height);
                                }
                                else if (rules[RelativeLayout.ALIGN_PARENT_BOTTOM] != null) {
                                    const childHeight = child.getMeasuredHeight();
                                    params.mTop = height - this.mPaddingBottom - childHeight;
                                    params.mBottom = params.mTop + childHeight;
                                }
                            }
                        }
                    }
                }
                if (horizontalGravity || verticalGravity) {
                    const selfBounds = this.mSelfBounds;
                    selfBounds.set(this.mPaddingLeft, this.mPaddingTop, width - this.mPaddingRight, height - this.mPaddingBottom);
                    const contentBounds = this.mContentBounds;
                    Gravity.apply(this.mGravity, right - left, bottom - top, selfBounds, contentBounds, layoutDirection);
                    const horizontalOffset = contentBounds.left - left;
                    const verticalOffset = contentBounds.top - top;
                    if (horizontalOffset != 0 || verticalOffset != 0) {
                        for (let i = 0; i < count; i++) {
                            let child = this.getChildAt(i);
                            if (child.getVisibility() != RelativeLayout.GONE && child != ignore) {
                                let params = child.getLayoutParams();
                                if (horizontalGravity) {
                                    params.mLeft += horizontalOffset;
                                    params.mRight += horizontalOffset;
                                }
                                if (verticalGravity) {
                                    params.mTop += verticalOffset;
                                    params.mBottom += verticalOffset;
                                }
                            }
                        }
                    }
                }
                if (this.isLayoutRtl()) {
                    const offsetWidth = myWidth - width;
                    for (let i = 0; i < count; i++) {
                        let child = this.getChildAt(i);
                        if (child.getVisibility() != RelativeLayout.GONE) {
                            let params = child.getLayoutParams();
                            params.mLeft -= offsetWidth;
                            params.mRight -= offsetWidth;
                        }
                    }
                }
                this.setMeasuredDimension(width, height);
            }
            alignBaseline(child, params) {
                const layoutDirection = this.getLayoutDirection();
                let rules = params.getRules(layoutDirection);
                let anchorBaseline = this.getRelatedViewBaseline(rules, RelativeLayout.ALIGN_BASELINE);
                if (anchorBaseline != -1) {
                    let anchorParams = this.getRelatedViewParams(rules, RelativeLayout.ALIGN_BASELINE);
                    if (anchorParams != null) {
                        let offset = anchorParams.mTop + anchorBaseline;
                        let baseline = child.getBaseline();
                        if (baseline != -1) {
                            offset -= baseline;
                        }
                        let height = params.mBottom - params.mTop;
                        params.mTop = offset;
                        params.mBottom = params.mTop + height;
                    }
                }
                if (this.mBaselineView == null) {
                    this.mBaselineView = child;
                }
                else {
                    let lp = this.mBaselineView.getLayoutParams();
                    if (params.mTop < lp.mTop || (params.mTop == lp.mTop && params.mLeft < lp.mLeft)) {
                        this.mBaselineView = child;
                    }
                }
            }
            _measureChild(child, params, myWidth, myHeight) {
                let childWidthMeasureSpec = this.getChildMeasureSpec(params.mLeft, params.mRight, params.width, params.leftMargin, params.rightMargin, this.mPaddingLeft, this.mPaddingRight, myWidth);
                let childHeightMeasureSpec = this.getChildMeasureSpec(params.mTop, params.mBottom, params.height, params.topMargin, params.bottomMargin, this.mPaddingTop, this.mPaddingBottom, myHeight);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            measureChildHorizontal(child, params, myWidth, myHeight) {
                let childWidthMeasureSpec = this.getChildMeasureSpec(params.mLeft, params.mRight, params.width, params.leftMargin, params.rightMargin, this.mPaddingLeft, this.mPaddingRight, myWidth);
                let maxHeight = myHeight;
                if (this.mMeasureVerticalWithPaddingMargin) {
                    maxHeight = Math.max(0, myHeight - this.mPaddingTop - this.mPaddingBottom - params.topMargin - params.bottomMargin);
                }
                let childHeightMeasureSpec;
                if (myHeight < 0 && !this.mAllowBrokenMeasureSpecs) {
                    if (params.height >= 0) {
                        childHeightMeasureSpec = RelativeLayout.MeasureSpec.makeMeasureSpec(params.height, RelativeLayout.MeasureSpec.EXACTLY);
                    }
                    else {
                        childHeightMeasureSpec = RelativeLayout.MeasureSpec.makeMeasureSpec(0, RelativeLayout.MeasureSpec.UNSPECIFIED);
                    }
                }
                else if (params.width == RelativeLayout.LayoutParams.MATCH_PARENT) {
                    childHeightMeasureSpec = RelativeLayout.MeasureSpec.makeMeasureSpec(maxHeight, RelativeLayout.MeasureSpec.EXACTLY);
                }
                else {
                    childHeightMeasureSpec = RelativeLayout.MeasureSpec.makeMeasureSpec(maxHeight, RelativeLayout.MeasureSpec.AT_MOST);
                }
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            getChildMeasureSpec(childStart, childEnd, childSize, startMargin, endMargin, startPadding, endPadding, mySize) {
                if (mySize < 0 && !this.mAllowBrokenMeasureSpecs) {
                    if (childSize >= 0) {
                        return RelativeLayout.MeasureSpec.makeMeasureSpec(childSize, RelativeLayout.MeasureSpec.EXACTLY);
                    }
                    return RelativeLayout.MeasureSpec.makeMeasureSpec(0, RelativeLayout.MeasureSpec.UNSPECIFIED);
                }
                let childSpecMode = 0;
                let childSpecSize = 0;
                let tempStart = childStart;
                let tempEnd = childEnd;
                if (tempStart < 0) {
                    tempStart = startPadding + startMargin;
                }
                if (tempEnd < 0) {
                    tempEnd = mySize - endPadding - endMargin;
                }
                let maxAvailable = tempEnd - tempStart;
                if (childStart >= 0 && childEnd >= 0) {
                    childSpecMode = RelativeLayout.MeasureSpec.EXACTLY;
                    childSpecSize = maxAvailable;
                }
                else {
                    if (childSize >= 0) {
                        childSpecMode = RelativeLayout.MeasureSpec.EXACTLY;
                        if (maxAvailable >= 0) {
                            childSpecSize = Math.min(maxAvailable, childSize);
                        }
                        else {
                            childSpecSize = childSize;
                        }
                    }
                    else if (childSize == RelativeLayout.LayoutParams.MATCH_PARENT) {
                        childSpecMode = RelativeLayout.MeasureSpec.EXACTLY;
                        childSpecSize = maxAvailable;
                    }
                    else if (childSize == RelativeLayout.LayoutParams.WRAP_CONTENT) {
                        if (maxAvailable >= 0) {
                            childSpecMode = RelativeLayout.MeasureSpec.AT_MOST;
                            childSpecSize = maxAvailable;
                        }
                        else {
                            childSpecMode = RelativeLayout.MeasureSpec.UNSPECIFIED;
                            childSpecSize = 0;
                        }
                    }
                }
                return RelativeLayout.MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
            }
            positionChildHorizontal(child, params, myWidth, wrapContent) {
                const layoutDirection = this.getLayoutDirection();
                let rules = params.getRules(layoutDirection);
                if (params.mLeft < 0 && params.mRight >= 0) {
                    params.mLeft = params.mRight - child.getMeasuredWidth();
                }
                else if (params.mLeft >= 0 && params.mRight < 0) {
                    params.mRight = params.mLeft + child.getMeasuredWidth();
                }
                else if (params.mLeft < 0 && params.mRight < 0) {
                    if (rules[RelativeLayout.CENTER_IN_PARENT] != null || rules[RelativeLayout.CENTER_HORIZONTAL] != null) {
                        if (!wrapContent) {
                            RelativeLayout.centerHorizontal(child, params, myWidth);
                        }
                        else {
                            params.mLeft = this.mPaddingLeft + params.leftMargin;
                            params.mRight = params.mLeft + child.getMeasuredWidth();
                        }
                        return true;
                    }
                    else {
                        if (this.isLayoutRtl()) {
                            params.mRight = myWidth - this.mPaddingRight - params.rightMargin;
                            params.mLeft = params.mRight - child.getMeasuredWidth();
                        }
                        else {
                            params.mLeft = this.mPaddingLeft + params.leftMargin;
                            params.mRight = params.mLeft + child.getMeasuredWidth();
                        }
                    }
                }
                return rules[RelativeLayout.ALIGN_PARENT_END] != null;
            }
            positionChildVertical(child, params, myHeight, wrapContent) {
                let rules = params.getRules();
                if (params.mTop < 0 && params.mBottom >= 0) {
                    params.mTop = params.mBottom - child.getMeasuredHeight();
                }
                else if (params.mTop >= 0 && params.mBottom < 0) {
                    params.mBottom = params.mTop + child.getMeasuredHeight();
                }
                else if (params.mTop < 0 && params.mBottom < 0) {
                    if (rules[RelativeLayout.CENTER_IN_PARENT] != null || rules[RelativeLayout.CENTER_VERTICAL] != null) {
                        if (!wrapContent) {
                            RelativeLayout.centerVertical(child, params, myHeight);
                        }
                        else {
                            params.mTop = this.mPaddingTop + params.topMargin;
                            params.mBottom = params.mTop + child.getMeasuredHeight();
                        }
                        return true;
                    }
                    else {
                        params.mTop = this.mPaddingTop + params.topMargin;
                        params.mBottom = params.mTop + child.getMeasuredHeight();
                    }
                }
                return rules[RelativeLayout.ALIGN_PARENT_BOTTOM] != null;
            }
            applyHorizontalSizeRules(childParams, myWidth, rules) {
                let anchorParams;
                childParams.mLeft = -1;
                childParams.mRight = -1;
                anchorParams = this.getRelatedViewParams(rules, RelativeLayout.LEFT_OF);
                if (anchorParams != null) {
                    childParams.mRight = anchorParams.mLeft - (anchorParams.leftMargin + childParams.rightMargin);
                }
                else if (childParams.alignWithParent && rules[RelativeLayout.LEFT_OF] != null) {
                    if (myWidth >= 0) {
                        childParams.mRight = myWidth - this.mPaddingRight - childParams.rightMargin;
                    }
                }
                anchorParams = this.getRelatedViewParams(rules, RelativeLayout.RIGHT_OF);
                if (anchorParams != null) {
                    childParams.mLeft = anchorParams.mRight + (anchorParams.rightMargin + childParams.leftMargin);
                }
                else if (childParams.alignWithParent && rules[RelativeLayout.RIGHT_OF] != null) {
                    childParams.mLeft = this.mPaddingLeft + childParams.leftMargin;
                }
                anchorParams = this.getRelatedViewParams(rules, RelativeLayout.ALIGN_LEFT);
                if (anchorParams != null) {
                    childParams.mLeft = anchorParams.mLeft + childParams.leftMargin;
                }
                else if (childParams.alignWithParent && rules[RelativeLayout.ALIGN_LEFT] != null) {
                    childParams.mLeft = this.mPaddingLeft + childParams.leftMargin;
                }
                anchorParams = this.getRelatedViewParams(rules, RelativeLayout.ALIGN_RIGHT);
                if (anchorParams != null) {
                    childParams.mRight = anchorParams.mRight - childParams.rightMargin;
                }
                else if (childParams.alignWithParent && rules[RelativeLayout.ALIGN_RIGHT] != null) {
                    if (myWidth >= 0) {
                        childParams.mRight = myWidth - this.mPaddingRight - childParams.rightMargin;
                    }
                }
                if (null != rules[RelativeLayout.ALIGN_PARENT_LEFT]) {
                    childParams.mLeft = this.mPaddingLeft + childParams.leftMargin;
                }
                if (null != rules[RelativeLayout.ALIGN_PARENT_RIGHT]) {
                    if (myWidth >= 0) {
                        childParams.mRight = myWidth - this.mPaddingRight - childParams.rightMargin;
                    }
                }
            }
            applyVerticalSizeRules(childParams, myHeight) {
                let rules = childParams.getRules();
                let anchorParams;
                childParams.mTop = -1;
                childParams.mBottom = -1;
                anchorParams = this.getRelatedViewParams(rules, RelativeLayout.ABOVE);
                if (anchorParams != null) {
                    childParams.mBottom = anchorParams.mTop - (anchorParams.topMargin + childParams.bottomMargin);
                }
                else if (childParams.alignWithParent && rules[RelativeLayout.ABOVE] != null) {
                    if (myHeight >= 0) {
                        childParams.mBottom = myHeight - this.mPaddingBottom - childParams.bottomMargin;
                    }
                }
                anchorParams = this.getRelatedViewParams(rules, RelativeLayout.BELOW);
                if (anchorParams != null) {
                    childParams.mTop = anchorParams.mBottom + (anchorParams.bottomMargin + childParams.topMargin);
                }
                else if (childParams.alignWithParent && rules[RelativeLayout.BELOW] != null) {
                    childParams.mTop = this.mPaddingTop + childParams.topMargin;
                }
                anchorParams = this.getRelatedViewParams(rules, RelativeLayout.ALIGN_TOP);
                if (anchorParams != null) {
                    childParams.mTop = anchorParams.mTop + childParams.topMargin;
                }
                else if (childParams.alignWithParent && rules[RelativeLayout.ALIGN_TOP] != null) {
                    childParams.mTop = this.mPaddingTop + childParams.topMargin;
                }
                anchorParams = this.getRelatedViewParams(rules, RelativeLayout.ALIGN_BOTTOM);
                if (anchorParams != null) {
                    childParams.mBottom = anchorParams.mBottom - childParams.bottomMargin;
                }
                else if (childParams.alignWithParent && rules[RelativeLayout.ALIGN_BOTTOM] != null) {
                    if (myHeight >= 0) {
                        childParams.mBottom = myHeight - this.mPaddingBottom - childParams.bottomMargin;
                    }
                }
                if (null != rules[RelativeLayout.ALIGN_PARENT_TOP]) {
                    childParams.mTop = this.mPaddingTop + childParams.topMargin;
                }
                if (null != rules[RelativeLayout.ALIGN_PARENT_BOTTOM]) {
                    if (myHeight >= 0) {
                        childParams.mBottom = myHeight - this.mPaddingBottom - childParams.bottomMargin;
                    }
                }
                if (rules[RelativeLayout.ALIGN_BASELINE] != null) {
                    this.mHasBaselineAlignedChild = true;
                }
            }
            getRelatedView(rules, relation) {
                let id = rules[relation];
                if (id != null) {
                    let node = this.mGraph.mKeyNodes.get(id);
                    if (node == null)
                        return null;
                    let v = node.view;
                    while (v.getVisibility() == View.GONE) {
                        rules = v.getLayoutParams().getRules(v.getLayoutDirection());
                        node = this.mGraph.mKeyNodes.get((rules[relation]));
                        if (node == null)
                            return null;
                        v = node.view;
                    }
                    return v;
                }
                return null;
            }
            getRelatedViewParams(rules, relation) {
                let v = this.getRelatedView(rules, relation);
                if (v != null) {
                    let params = v.getLayoutParams();
                    if (params instanceof RelativeLayout.LayoutParams) {
                        return v.getLayoutParams();
                    }
                }
                return null;
            }
            getRelatedViewBaseline(rules, relation) {
                let v = this.getRelatedView(rules, relation);
                if (v != null) {
                    return v.getBaseline();
                }
                return -1;
            }
            static centerHorizontal(child, params, myWidth) {
                let childWidth = child.getMeasuredWidth();
                let left = (myWidth - childWidth) / 2;
                params.mLeft = left;
                params.mRight = left + childWidth;
            }
            static centerVertical(child, params, myHeight) {
                let childHeight = child.getMeasuredHeight();
                let top = (myHeight - childHeight) / 2;
                params.mTop = top;
                params.mBottom = top + childHeight;
            }
            onLayout(changed, l, t, r, b) {
                const count = this.getChildCount();
                for (let i = 0; i < count; i++) {
                    let child = this.getChildAt(i);
                    if (child.getVisibility() != RelativeLayout.GONE) {
                        let st = child.getLayoutParams();
                        child.layout(st.mLeft, st.mTop, st.mRight, st.mBottom);
                    }
                }
            }
            generateDefaultLayoutParams() {
                return new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
            }
            checkLayoutParams(p) {
                return p instanceof RelativeLayout.LayoutParams;
            }
            generateLayoutParams(p) {
                return new RelativeLayout.LayoutParams(p);
            }
        }
        RelativeLayout.TRUE = -1;
        RelativeLayout.LEFT_OF = 0;
        RelativeLayout.RIGHT_OF = 1;
        RelativeLayout.ABOVE = 2;
        RelativeLayout.BELOW = 3;
        RelativeLayout.ALIGN_BASELINE = 4;
        RelativeLayout.ALIGN_LEFT = 5;
        RelativeLayout.ALIGN_TOP = 6;
        RelativeLayout.ALIGN_RIGHT = 7;
        RelativeLayout.ALIGN_BOTTOM = 8;
        RelativeLayout.ALIGN_PARENT_LEFT = 9;
        RelativeLayout.ALIGN_PARENT_TOP = 10;
        RelativeLayout.ALIGN_PARENT_RIGHT = 11;
        RelativeLayout.ALIGN_PARENT_BOTTOM = 12;
        RelativeLayout.CENTER_IN_PARENT = 13;
        RelativeLayout.CENTER_HORIZONTAL = 14;
        RelativeLayout.CENTER_VERTICAL = 15;
        RelativeLayout.START_OF = 16;
        RelativeLayout.END_OF = 17;
        RelativeLayout.ALIGN_START = 18;
        RelativeLayout.ALIGN_END = 19;
        RelativeLayout.ALIGN_PARENT_START = 20;
        RelativeLayout.ALIGN_PARENT_END = 21;
        RelativeLayout.VERB_COUNT = 22;
        RelativeLayout.RULES_VERTICAL = [RelativeLayout.ABOVE, RelativeLayout.BELOW, RelativeLayout.ALIGN_BASELINE, RelativeLayout.ALIGN_TOP, RelativeLayout.ALIGN_BOTTOM];
        RelativeLayout.RULES_HORIZONTAL = [RelativeLayout.LEFT_OF, RelativeLayout.RIGHT_OF, RelativeLayout.ALIGN_LEFT, RelativeLayout.ALIGN_RIGHT, RelativeLayout.START_OF, RelativeLayout.END_OF, RelativeLayout.ALIGN_START, RelativeLayout.ALIGN_END];
        RelativeLayout.DEFAULT_WIDTH = 0x00010000;
        widget.RelativeLayout = RelativeLayout;
        (function (RelativeLayout) {
            class LayoutParams extends ViewGroup.MarginLayoutParams {
                constructor(...args) {
                    super(...args);
                    this.mRules = new Array(RelativeLayout.VERB_COUNT);
                    this.mInitialRules = new Array(RelativeLayout.VERB_COUNT);
                    this.mLeft = 0;
                    this.mTop = 0;
                    this.mRight = 0;
                    this.mBottom = 0;
                    this.mStart = LayoutParams.DEFAULT_MARGIN_RELATIVE;
                    this.mEnd = LayoutParams.DEFAULT_MARGIN_RELATIVE;
                    this.mRulesChanged = false;
                    this.mIsRtlCompatibilityMode = false;
                    if (args[0] instanceof LayoutParams) {
                        let source = args[0];
                        this.mIsRtlCompatibilityMode = source.mIsRtlCompatibilityMode;
                        this.mRulesChanged = source.mRulesChanged;
                        this.alignWithParent = source.alignWithParent;
                        System.arraycopy(source.mRules, RelativeLayout.LEFT_OF, this.mRules, RelativeLayout.LEFT_OF, RelativeLayout.VERB_COUNT);
                        System.arraycopy(source.mInitialRules, RelativeLayout.LEFT_OF, this.mInitialRules, RelativeLayout.LEFT_OF, RelativeLayout.VERB_COUNT);
                    }
                    this._attrBinder.addAttr('alignWithParentIfMissing', (value) => {
                        this.alignWithParent = this._attrBinder.parseBoolean(value, false);
                    });
                    this._attrBinder.addAttr('toLeftOf', (value) => {
                        this.addRule(RelativeLayout.LEFT_OF, value);
                    });
                    this._attrBinder.addAttr('toRightOf', (value) => {
                        this.addRule(RelativeLayout.RIGHT_OF, value);
                    });
                    this._attrBinder.addAttr('above', (value) => {
                        this.addRule(RelativeLayout.ABOVE, value);
                    });
                    this._attrBinder.addAttr('below', (value) => {
                        this.addRule(RelativeLayout.BELOW, value);
                    });
                    this._attrBinder.addAttr('alignBaseline', (value) => {
                        this.addRule(RelativeLayout.ALIGN_BASELINE, value);
                    });
                    this._attrBinder.addAttr('alignLeft', (value) => {
                        this.addRule(RelativeLayout.ALIGN_LEFT, value);
                    });
                    this._attrBinder.addAttr('alignTop', (value) => {
                        this.addRule(RelativeLayout.ALIGN_TOP, value);
                    });
                    this._attrBinder.addAttr('alignRight', (value) => {
                        this.addRule(RelativeLayout.ALIGN_RIGHT, value);
                    });
                    this._attrBinder.addAttr('alignBottom', (value) => {
                        this.addRule(RelativeLayout.ALIGN_BOTTOM, value);
                    });
                    this._attrBinder.addAttr('alignParentLeft', (value) => {
                        const anchor = this._attrBinder.parseBoolean(value, false) ? RelativeLayout.TRUE : null;
                        this.addRule(RelativeLayout.ALIGN_PARENT_LEFT, anchor);
                    });
                    this._attrBinder.addAttr('alignParentTop', (value) => {
                        const anchor = this._attrBinder.parseBoolean(value, false) ? RelativeLayout.TRUE : null;
                        this.addRule(RelativeLayout.ALIGN_PARENT_TOP, anchor);
                    });
                    this._attrBinder.addAttr('alignParentRight', (value) => {
                        const anchor = this._attrBinder.parseBoolean(value, false) ? RelativeLayout.TRUE : null;
                        this.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, anchor);
                    });
                    this._attrBinder.addAttr('alignParentBottom', (value) => {
                        const anchor = this._attrBinder.parseBoolean(value, false) ? RelativeLayout.TRUE : null;
                        this.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM, anchor);
                    });
                    this._attrBinder.addAttr('centerInParent', (value) => {
                        const anchor = this._attrBinder.parseBoolean(value, false) ? RelativeLayout.TRUE : null;
                        this.addRule(RelativeLayout.CENTER_IN_PARENT, anchor);
                    });
                    this._attrBinder.addAttr('centerHorizontal', (value) => {
                        const anchor = this._attrBinder.parseBoolean(value, false) ? RelativeLayout.TRUE : null;
                        this.addRule(RelativeLayout.CENTER_HORIZONTAL, anchor);
                    });
                    this._attrBinder.addAttr('centerVertical', (value) => {
                        const anchor = this._attrBinder.parseBoolean(value, false) ? RelativeLayout.TRUE : null;
                        this.addRule(RelativeLayout.CENTER_VERTICAL, anchor);
                    });
                    this._attrBinder.addAttr('toStartOf', (value) => {
                        this.addRule(RelativeLayout.LEFT_OF, value);
                    });
                    this._attrBinder.addAttr('toEndOf', (value) => {
                        this.addRule(RelativeLayout.RIGHT_OF, value);
                    });
                    this._attrBinder.addAttr('alignStart', (value) => {
                        this.addRule(RelativeLayout.ALIGN_LEFT, value);
                    });
                    this._attrBinder.addAttr('alignEnd', (value) => {
                        this.addRule(RelativeLayout.ALIGN_RIGHT, value);
                    });
                    this._attrBinder.addAttr('alignParentStart', (value) => {
                        const anchor = this._attrBinder.parseBoolean(value, false) ? RelativeLayout.TRUE : null;
                        this.addRule(RelativeLayout.ALIGN_PARENT_LEFT, anchor);
                    });
                    this._attrBinder.addAttr('alignParentEnd', (value) => {
                        const anchor = this._attrBinder.parseBoolean(value, false) ? RelativeLayout.TRUE : null;
                        this.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, anchor);
                    });
                }
                addRule(verb, anchor = RelativeLayout.TRUE) {
                    this.mRules[verb] = anchor;
                    this.mInitialRules[verb] = anchor;
                    this.mRulesChanged = true;
                }
                removeRule(verb) {
                    this.mRules[verb] = null;
                    this.mInitialRules[verb] = null;
                    this.mRulesChanged = true;
                }
                hasRelativeRules() {
                    return (this.mInitialRules[RelativeLayout.START_OF] != null || this.mInitialRules[RelativeLayout.END_OF] != null
                        || this.mInitialRules[RelativeLayout.ALIGN_START] != null || this.mInitialRules[RelativeLayout.ALIGN_END] != null
                        || this.mInitialRules[RelativeLayout.ALIGN_PARENT_START] != null || this.mInitialRules[RelativeLayout.ALIGN_PARENT_END] != null);
                }
                resolveRules(layoutDirection) {
                    const isLayoutRtl = (layoutDirection == View.LAYOUT_DIRECTION_RTL);
                    System.arraycopy(this.mInitialRules, RelativeLayout.LEFT_OF, this.mRules, RelativeLayout.LEFT_OF, RelativeLayout.VERB_COUNT);
                    if (this.mIsRtlCompatibilityMode) {
                        if (this.mRules[RelativeLayout.ALIGN_START] != null) {
                            if (this.mRules[RelativeLayout.ALIGN_LEFT] == null) {
                                this.mRules[RelativeLayout.ALIGN_LEFT] = this.mRules[RelativeLayout.ALIGN_START];
                            }
                            this.mRules[RelativeLayout.ALIGN_START] = null;
                        }
                        if (this.mRules[RelativeLayout.ALIGN_END] != null) {
                            if (this.mRules[RelativeLayout.ALIGN_RIGHT] == null) {
                                this.mRules[RelativeLayout.ALIGN_RIGHT] = this.mRules[RelativeLayout.ALIGN_END];
                            }
                            this.mRules[RelativeLayout.ALIGN_END] = null;
                        }
                        if (this.mRules[RelativeLayout.START_OF] != null) {
                            if (this.mRules[RelativeLayout.LEFT_OF] == null) {
                                this.mRules[RelativeLayout.LEFT_OF] = this.mRules[RelativeLayout.START_OF];
                            }
                            this.mRules[RelativeLayout.START_OF] = null;
                        }
                        if (this.mRules[RelativeLayout.END_OF] != null) {
                            if (this.mRules[RelativeLayout.RIGHT_OF] == null) {
                                this.mRules[RelativeLayout.RIGHT_OF] = this.mRules[RelativeLayout.END_OF];
                            }
                            this.mRules[RelativeLayout.END_OF] = null;
                        }
                        if (this.mRules[RelativeLayout.ALIGN_PARENT_START] != null) {
                            if (this.mRules[RelativeLayout.ALIGN_PARENT_LEFT] == null) {
                                this.mRules[RelativeLayout.ALIGN_PARENT_LEFT] = this.mRules[RelativeLayout.ALIGN_PARENT_START];
                            }
                            this.mRules[RelativeLayout.ALIGN_PARENT_START] = null;
                        }
                        if (this.mRules[RelativeLayout.ALIGN_PARENT_RIGHT] == null) {
                            if (this.mRules[RelativeLayout.ALIGN_PARENT_RIGHT] == null) {
                                this.mRules[RelativeLayout.ALIGN_PARENT_RIGHT] = this.mRules[RelativeLayout.ALIGN_PARENT_END];
                            }
                            this.mRules[RelativeLayout.ALIGN_PARENT_END] = null;
                        }
                    }
                    else {
                        if ((this.mRules[RelativeLayout.ALIGN_START] != null || this.mRules[RelativeLayout.ALIGN_END] != null)
                            && (this.mRules[RelativeLayout.ALIGN_LEFT] != null || this.mRules[RelativeLayout.ALIGN_RIGHT] != null)) {
                            this.mRules[RelativeLayout.ALIGN_LEFT] = null;
                            this.mRules[RelativeLayout.ALIGN_RIGHT] = null;
                        }
                        if (this.mRules[RelativeLayout.ALIGN_START] != null) {
                            this.mRules[isLayoutRtl ? RelativeLayout.ALIGN_RIGHT : RelativeLayout.ALIGN_LEFT] = this.mRules[RelativeLayout.ALIGN_START];
                            this.mRules[RelativeLayout.ALIGN_START] = null;
                        }
                        if (this.mRules[RelativeLayout.ALIGN_END] != null) {
                            this.mRules[isLayoutRtl ? RelativeLayout.ALIGN_LEFT : RelativeLayout.ALIGN_RIGHT] = this.mRules[RelativeLayout.ALIGN_END];
                            this.mRules[RelativeLayout.ALIGN_END] = null;
                        }
                        if ((this.mRules[RelativeLayout.START_OF] != null || this.mRules[RelativeLayout.END_OF] != null)
                            && (this.mRules[RelativeLayout.LEFT_OF] != null || this.mRules[RelativeLayout.RIGHT_OF] != null)) {
                            this.mRules[RelativeLayout.LEFT_OF] = null;
                            this.mRules[RelativeLayout.RIGHT_OF] = null;
                        }
                        if (this.mRules[RelativeLayout.START_OF] != null) {
                            this.mRules[isLayoutRtl ? RelativeLayout.RIGHT_OF : RelativeLayout.LEFT_OF] = this.mRules[RelativeLayout.START_OF];
                            this.mRules[RelativeLayout.START_OF] = null;
                        }
                        if (this.mRules[RelativeLayout.END_OF] != null) {
                            this.mRules[isLayoutRtl ? RelativeLayout.LEFT_OF : RelativeLayout.RIGHT_OF] = this.mRules[RelativeLayout.END_OF];
                            this.mRules[RelativeLayout.END_OF] = null;
                        }
                        if ((this.mRules[RelativeLayout.ALIGN_PARENT_START] != null || this.mRules[RelativeLayout.ALIGN_PARENT_END] != null)
                            && (this.mRules[RelativeLayout.ALIGN_PARENT_LEFT] != null || this.mRules[RelativeLayout.ALIGN_PARENT_RIGHT] != null)) {
                            this.mRules[RelativeLayout.ALIGN_PARENT_LEFT] = null;
                            this.mRules[RelativeLayout.ALIGN_PARENT_RIGHT] = null;
                        }
                        if (this.mRules[RelativeLayout.ALIGN_PARENT_START] != null) {
                            this.mRules[isLayoutRtl ? RelativeLayout.ALIGN_PARENT_RIGHT : RelativeLayout.ALIGN_PARENT_LEFT] = this.mRules[RelativeLayout.ALIGN_PARENT_START];
                            this.mRules[RelativeLayout.ALIGN_PARENT_START] = null;
                        }
                        if (this.mRules[RelativeLayout.ALIGN_PARENT_END] != null) {
                            this.mRules[isLayoutRtl ? RelativeLayout.ALIGN_PARENT_LEFT : RelativeLayout.ALIGN_PARENT_RIGHT] = this.mRules[RelativeLayout.ALIGN_PARENT_END];
                            this.mRules[RelativeLayout.ALIGN_PARENT_END] = null;
                        }
                    }
                    this.mRulesChanged = false;
                }
                getRules(layoutDirection) {
                    if (layoutDirection != null) {
                        if (this.hasRelativeRules() && (this.mRulesChanged || layoutDirection != this.getLayoutDirection())) {
                            this.resolveRules(layoutDirection);
                            if (layoutDirection != this.getLayoutDirection()) {
                                this.setLayoutDirection(layoutDirection);
                            }
                        }
                    }
                    return this.mRules;
                }
                resolveLayoutDirection(layoutDirection) {
                    const isLayoutRtl = this.isLayoutRtl();
                    if (isLayoutRtl) {
                        if (this.mStart != LayoutParams.DEFAULT_MARGIN_RELATIVE)
                            this.mRight = this.mStart;
                        if (this.mEnd != LayoutParams.DEFAULT_MARGIN_RELATIVE)
                            this.mLeft = this.mEnd;
                    }
                    else {
                        if (this.mStart != LayoutParams.DEFAULT_MARGIN_RELATIVE)
                            this.mLeft = this.mStart;
                        if (this.mEnd != LayoutParams.DEFAULT_MARGIN_RELATIVE)
                            this.mRight = this.mEnd;
                    }
                    if (this.hasRelativeRules() && layoutDirection != this.getLayoutDirection()) {
                        this.resolveRules(layoutDirection);
                    }
                    super.resolveLayoutDirection(layoutDirection);
                }
            }
            RelativeLayout.LayoutParams = LayoutParams;
            class DependencyGraph {
                constructor() {
                    this.mNodes = new ArrayList();
                    this.mKeyNodes = new SparseMap();
                    this.mRoots = new ArrayDeque();
                }
                clear() {
                    const nodes = this.mNodes;
                    const count = nodes.size();
                    for (let i = 0; i < count; i++) {
                        nodes.get(i).release();
                    }
                    nodes.clear();
                    this.mKeyNodes.clear();
                    this.mRoots.clear();
                }
                add(view) {
                    const id = view.getId();
                    const node = DependencyGraph.Node.acquire(view);
                    if (id != View.NO_ID) {
                        this.mKeyNodes.put(id, node);
                    }
                    this.mNodes.add(node);
                }
                getSortedViews(sorted, rules) {
                    const roots = this.findRoots(rules);
                    let index = 0;
                    let node;
                    while ((node = roots.pollLast()) != null) {
                        const view = node.view;
                        const key = view.getId();
                        sorted[index++] = view;
                        const dependents = node.dependents;
                        const count = dependents.size();
                        for (let i = 0; i < count; i++) {
                            const dependent = dependents.keyAt(i);
                            const dependencies = dependent.dependencies;
                            dependencies.remove(key);
                            if (dependencies.size() == 0) {
                                roots.add(dependent);
                            }
                        }
                    }
                    if (index < sorted.length) {
                        throw Error(`new IllegalStateException("Circular dependencies cannot exist" + " in RelativeLayout")`);
                    }
                }
                findRoots(rulesFilter) {
                    const keyNodes = this.mKeyNodes;
                    const nodes = this.mNodes;
                    const count = nodes.size();
                    for (let i = 0; i < count; i++) {
                        const node = nodes.get(i);
                        node.dependents.clear();
                        node.dependencies.clear();
                    }
                    for (let i = 0; i < count; i++) {
                        const node = nodes.get(i);
                        const layoutParams = node.view.getLayoutParams();
                        const rules = layoutParams.mRules;
                        const rulesCount = rulesFilter.length;
                        for (let j = 0; j < rulesCount; j++) {
                            const rule = rules[rulesFilter[j]];
                            if (rule != null) {
                                const dependency = keyNodes.get(rule);
                                if (dependency == null || dependency == node) {
                                    continue;
                                }
                                dependency.dependents.put(node, this);
                                node.dependencies.put(rule, dependency);
                            }
                        }
                    }
                    const roots = this.mRoots;
                    roots.clear();
                    for (let i = 0; i < count; i++) {
                        const node = nodes.get(i);
                        if (node.dependencies.size() == 0)
                            roots.addLast(node);
                    }
                    return roots;
                }
            }
            RelativeLayout.DependencyGraph = DependencyGraph;
            (function (DependencyGraph) {
                class Node {
                    constructor() {
                        this.dependents = new ArrayMap();
                        this.dependencies = new SparseMap();
                    }
                    static acquire(view) {
                        let node = Node.sPool.acquire();
                        if (node == null) {
                            node = new Node();
                        }
                        node.view = view;
                        return node;
                    }
                    release() {
                        this.view = null;
                        this.dependents.clear();
                        this.dependencies.clear();
                        Node.sPool.release(this);
                    }
                }
                Node.POOL_LIMIT = 100;
                Node.sPool = new SynchronizedPool(Node.POOL_LIMIT);
                DependencyGraph.Node = Node;
            })(DependencyGraph = RelativeLayout.DependencyGraph || (RelativeLayout.DependencyGraph = {}));
        })(RelativeLayout = widget.RelativeLayout || (widget.RelativeLayout = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Matrix.ts"/>
///<reference path="../../android/graphics/RectF.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../androidui/image/NetDrawable.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Matrix = android.graphics.Matrix;
        var RectF = android.graphics.RectF;
        var View = android.view.View;
        var Integer = java.lang.Integer;
        class ImageView extends View {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mHaveFrame = false;
                this.mAdjustViewBounds = false;
                this.mMaxWidth = Integer.MAX_VALUE;
                this.mMaxHeight = Integer.MAX_VALUE;
                this.mAlpha = 255;
                this.mViewAlphaScale = 256;
                this.mColorMod = false;
                this.mDrawable = null;
                this.mState = null;
                this.mMergeState = false;
                this.mLevel = 0;
                this.mDrawableWidth = 0;
                this.mDrawableHeight = 0;
                this.mDrawMatrix = null;
                this.mTempSrc = new RectF();
                this.mTempDst = new RectF();
                this.mBaseline = -1;
                this.mBaselineAlignBottom = false;
                this.mAdjustViewBoundsCompat = false;
                this.initImageView();
                this._attrBinder.addAttr('src', (value) => {
                    this.setImageURI(value);
                }, () => {
                    return this.mUri;
                });
                this._attrBinder.addAttr('baselineAlignBottom', (value) => {
                    this.setBaselineAlignBottom(this._attrBinder.parseBoolean(value, this.mBaselineAlignBottom));
                });
                this._attrBinder.addAttr('baseline', (value) => {
                    this.setBaseline(this._attrBinder.parseNumber(value, this.mBaseline));
                }, () => {
                    return this.mBaseline;
                });
                this._attrBinder.addAttr('adjustViewBounds', (value) => {
                    this.setAdjustViewBounds(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('maxWidth', (value) => {
                    let baseValue = this.getParent() instanceof View ? this.getParent().getWidth() : 0;
                    this.setMaxWidth(this._attrBinder.parseNumber(value, this.mMaxWidth, baseValue));
                }, () => {
                    return this.mMaxWidth;
                });
                this._attrBinder.addAttr('maxHeight', (value) => {
                    let baseValue = this.getParent() instanceof View ? this.getParent().getHeight() : 0;
                    this.setMaxHeight(this._attrBinder.parseNumber(value, this.mMaxHeight, baseValue));
                }, () => {
                    return this.mMaxHeight;
                });
                this._attrBinder.addAttr('scaleType', (value) => {
                    this.setScaleType(ImageView.parseScaleType(value, this.mScaleType));
                }, () => {
                    return this.mScaleType.toString();
                });
                this._attrBinder.addAttr('drawableAlpha', (value) => {
                    this.setAlpha(this._attrBinder.parseNumber(value, this.mAlpha));
                }, () => {
                    return this.mAlpha;
                });
                this._attrBinder.addAttr('cropToPadding', (value) => {
                    this.setCropToPadding(this._attrBinder.parseBoolean(value, false));
                });
            }
            initImageView() {
                this.mMatrix = new Matrix();
                this.mScaleType = ImageView.ScaleType.FIT_CENTER;
            }
            verifyDrawable(dr) {
                return this.mDrawable == dr || super.verifyDrawable(dr);
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mDrawable != null)
                    this.mDrawable.jumpToCurrentState();
            }
            invalidateDrawable(dr) {
                if (dr == this.mDrawable) {
                    this.invalidate();
                }
                else {
                    super.invalidateDrawable(dr);
                }
            }
            drawableSizeChange(who) {
                if (who == this.mDrawable) {
                    this.resizeFromDrawable();
                }
                else {
                    super.drawableSizeChange(who);
                }
            }
            hasOverlappingRendering() {
                return (this.getBackground() != null && this.getBackground().getCurrent() != null);
            }
            getAdjustViewBounds() {
                return this.mAdjustViewBounds;
            }
            setAdjustViewBounds(adjustViewBounds) {
                this.mAdjustViewBounds = adjustViewBounds;
                if (adjustViewBounds) {
                    this.setScaleType(ImageView.ScaleType.FIT_CENTER);
                }
            }
            getMaxWidth() {
                return this.mMaxWidth;
            }
            setMaxWidth(maxWidth) {
                this.mMaxWidth = maxWidth;
            }
            getMaxHeight() {
                return this.mMaxHeight;
            }
            setMaxHeight(maxHeight) {
                this.mMaxHeight = maxHeight;
            }
            getDrawable() {
                return this.mDrawable;
            }
            setImageURI(uri) {
                if (this.mUri != uri) {
                    this.updateDrawable(null);
                    this.mUri = uri;
                    const oldWidth = this.mDrawableWidth;
                    const oldHeight = this.mDrawableHeight;
                    this.resolveUri();
                    if (oldWidth != this.mDrawableWidth || oldHeight != this.mDrawableHeight) {
                        this.requestLayout();
                    }
                    this.invalidate();
                }
            }
            setImageDrawable(drawable) {
                if (this.mDrawable != drawable) {
                    this.mUri = null;
                    const oldWidth = this.mDrawableWidth;
                    const oldHeight = this.mDrawableHeight;
                    this.updateDrawable(drawable);
                    if (oldWidth != this.mDrawableWidth || oldHeight != this.mDrawableHeight) {
                        this.requestLayout();
                    }
                    this.invalidate();
                }
            }
            setImageState(state, merge) {
                this.mState = state;
                this.mMergeState = merge;
                if (this.mDrawable != null) {
                    this.refreshDrawableState();
                    this.resizeFromDrawable();
                }
            }
            setSelected(selected) {
                super.setSelected(selected);
                this.resizeFromDrawable();
            }
            setImageLevel(level) {
                this.mLevel = level;
                if (this.mDrawable != null) {
                    this.mDrawable.setLevel(level);
                    this.resizeFromDrawable();
                }
            }
            setScaleType(scaleType) {
                if (scaleType == null) {
                    throw Error(`new NullPointerException()`);
                }
                if (this.mScaleType != scaleType) {
                    this.mScaleType = scaleType;
                    this.setWillNotCacheDrawing(this.mScaleType == ImageView.ScaleType.CENTER);
                    this.requestLayout();
                    this.invalidate();
                }
            }
            getScaleType() {
                return this.mScaleType;
            }
            getImageMatrix() {
                if (this.mDrawMatrix == null) {
                    return new Matrix(Matrix.IDENTITY_MATRIX);
                }
                return this.mDrawMatrix;
            }
            setImageMatrix(matrix) {
                if (matrix != null && matrix.isIdentity()) {
                    matrix = null;
                }
                if (matrix == null && !this.mMatrix.isIdentity() || matrix != null && !this.mMatrix.equals(matrix)) {
                    this.mMatrix.set(matrix);
                    this.configureBounds();
                    this.invalidate();
                }
            }
            getCropToPadding() {
                return this.mCropToPadding;
            }
            setCropToPadding(cropToPadding) {
                if (this.mCropToPadding != cropToPadding) {
                    this.mCropToPadding = cropToPadding;
                    this.requestLayout();
                    this.invalidate();
                }
            }
            resolveUri() {
                if (this.mDrawable != null) {
                    return;
                }
                let d = null;
                if (this.mUri != null) {
                    d = new androidui.image.NetDrawable(this.mUri);
                }
                else {
                    return;
                }
                this.updateDrawable(d);
            }
            onCreateDrawableState(extraSpace) {
                if (this.mState == null) {
                    return super.onCreateDrawableState(extraSpace);
                }
                else if (!this.mMergeState) {
                    return this.mState;
                }
                else {
                    return ImageView.mergeDrawableStates(super.onCreateDrawableState(extraSpace + this.mState.length), this.mState);
                }
            }
            updateDrawable(d) {
                if (this.mDrawable != null) {
                    this.mDrawable.setCallback(null);
                    this.unscheduleDrawable(this.mDrawable);
                }
                this.mDrawable = d;
                if (d != null) {
                    d.setCallback(this);
                    if (d.isStateful()) {
                        d.setState(this.getDrawableState());
                    }
                    d.setLevel(this.mLevel);
                    d.setVisible(this.getVisibility() == ImageView.VISIBLE, true);
                    this.mDrawableWidth = d.getIntrinsicWidth();
                    this.mDrawableHeight = d.getIntrinsicHeight();
                    this.applyColorMod();
                    this.configureBounds();
                }
                else {
                    this.mDrawableWidth = this.mDrawableHeight = -1;
                }
            }
            resizeFromDrawable() {
                let d = this.mDrawable;
                if (d != null) {
                    let w = d.getIntrinsicWidth();
                    if (w < 0)
                        w = this.mDrawableWidth;
                    let h = d.getIntrinsicHeight();
                    if (h < 0)
                        h = this.mDrawableHeight;
                    if (w != this.mDrawableWidth || h != this.mDrawableHeight) {
                        this.mDrawableWidth = w;
                        this.mDrawableHeight = h;
                        this.requestLayout();
                        return true;
                    }
                }
                return false;
            }
            static scaleTypeToScaleToFit(st) {
                return ImageView.sS2FArray[st - 1];
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                this.resolveUri();
                let w;
                let h;
                let desiredAspect = 0.0;
                let resizeWidth = false;
                let resizeHeight = false;
                const widthSpecMode = ImageView.MeasureSpec.getMode(widthMeasureSpec);
                const heightSpecMode = ImageView.MeasureSpec.getMode(heightMeasureSpec);
                if (this.mDrawable == null) {
                    this.mDrawableWidth = -1;
                    this.mDrawableHeight = -1;
                    w = h = 0;
                }
                else {
                    w = this.mDrawableWidth;
                    h = this.mDrawableHeight;
                    if (w <= 0)
                        w = 1;
                    if (h <= 0)
                        h = 1;
                    if (this.mAdjustViewBounds) {
                        resizeWidth = widthSpecMode != ImageView.MeasureSpec.EXACTLY;
                        resizeHeight = heightSpecMode != ImageView.MeasureSpec.EXACTLY;
                        desiredAspect = w / h;
                    }
                }
                let pleft = this.mPaddingLeft;
                let pright = this.mPaddingRight;
                let ptop = this.mPaddingTop;
                let pbottom = this.mPaddingBottom;
                let widthSize;
                let heightSize;
                if (resizeWidth || resizeHeight) {
                    widthSize = this.resolveAdjustedSize(w + pleft + pright, this.mMaxWidth, widthMeasureSpec);
                    heightSize = this.resolveAdjustedSize(h + ptop + pbottom, this.mMaxHeight, heightMeasureSpec);
                    if (desiredAspect != 0.0) {
                        let actualAspect = (widthSize - pleft - pright) / (heightSize - ptop - pbottom);
                        if (Math.abs(actualAspect - desiredAspect) > 0.0000001) {
                            let done = false;
                            if (resizeWidth) {
                                let newWidth = Math.floor((desiredAspect * (heightSize - ptop - pbottom))) + pleft + pright;
                                if (!resizeHeight && !this.mAdjustViewBoundsCompat) {
                                    widthSize = this.resolveAdjustedSize(newWidth, this.mMaxWidth, widthMeasureSpec);
                                }
                                if (newWidth <= widthSize) {
                                    widthSize = newWidth;
                                    done = true;
                                }
                            }
                            if (!done && resizeHeight) {
                                let newHeight = Math.floor(((widthSize - pleft - pright) / desiredAspect)) + ptop + pbottom;
                                if (!resizeWidth && !this.mAdjustViewBoundsCompat) {
                                    heightSize = this.resolveAdjustedSize(newHeight, this.mMaxHeight, heightMeasureSpec);
                                }
                                if (newHeight <= heightSize) {
                                    heightSize = newHeight;
                                }
                            }
                        }
                    }
                }
                else {
                    w += pleft + pright;
                    h += ptop + pbottom;
                    w = Math.max(w, this.getSuggestedMinimumWidth());
                    h = Math.max(h, this.getSuggestedMinimumHeight());
                    widthSize = ImageView.resolveSizeAndState(w, widthMeasureSpec, 0);
                    heightSize = ImageView.resolveSizeAndState(h, heightMeasureSpec, 0);
                }
                this.setMeasuredDimension(widthSize, heightSize);
            }
            resolveAdjustedSize(desiredSize, maxSize, measureSpec) {
                let result = desiredSize;
                let specMode = ImageView.MeasureSpec.getMode(measureSpec);
                let specSize = ImageView.MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case ImageView.MeasureSpec.UNSPECIFIED:
                        result = Math.min(desiredSize, maxSize);
                        break;
                    case ImageView.MeasureSpec.AT_MOST:
                        result = Math.min(Math.min(desiredSize, specSize), maxSize);
                        break;
                    case ImageView.MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result;
            }
            setFrame(l, t, r, b) {
                let changed = super.setFrame(l, t, r, b);
                this.mHaveFrame = true;
                this.configureBounds();
                return changed;
            }
            configureBounds() {
                if (this.mDrawable == null || !this.mHaveFrame) {
                    return;
                }
                let dwidth = this.mDrawableWidth;
                let dheight = this.mDrawableHeight;
                let vwidth = this.getWidth() - this.mPaddingLeft - this.mPaddingRight;
                let vheight = this.getHeight() - this.mPaddingTop - this.mPaddingBottom;
                let fits = (dwidth < 0 || vwidth == dwidth) && (dheight < 0 || vheight == dheight);
                if (dwidth <= 0 || dheight <= 0 || ImageView.ScaleType.FIT_XY == this.mScaleType) {
                    this.mDrawable.setBounds(0, 0, vwidth, vheight);
                    this.mDrawMatrix = null;
                }
                else {
                    this.mDrawable.setBounds(0, 0, dwidth, dheight);
                    if (ImageView.ScaleType.MATRIX == this.mScaleType) {
                        if (this.mMatrix.isIdentity()) {
                            this.mDrawMatrix = null;
                        }
                        else {
                            this.mDrawMatrix = this.mMatrix;
                        }
                    }
                    else if (fits) {
                        this.mDrawMatrix = null;
                    }
                    else if (ImageView.ScaleType.CENTER == this.mScaleType) {
                        this.mDrawMatrix = this.mMatrix;
                        this.mDrawMatrix.setTranslate(Math.floor(((vwidth - dwidth) * 0.5 + 0.5)), Math.floor(((vheight - dheight) * 0.5 + 0.5)));
                    }
                    else if (ImageView.ScaleType.CENTER_CROP == this.mScaleType) {
                        this.mDrawMatrix = this.mMatrix;
                        let scale;
                        let dx = 0, dy = 0;
                        if (dwidth * vheight > vwidth * dheight) {
                            scale = vheight / dheight;
                            dx = (vwidth - dwidth * scale) * 0.5;
                        }
                        else {
                            scale = vwidth / dwidth;
                            dy = (vheight - dheight * scale) * 0.5;
                        }
                        this.mDrawMatrix.setScale(scale, scale);
                        this.mDrawMatrix.postTranslate(Math.floor((dx + 0.5)), Math.floor((dy + 0.5)));
                    }
                    else if (ImageView.ScaleType.CENTER_INSIDE == this.mScaleType) {
                        this.mDrawMatrix = this.mMatrix;
                        let scale;
                        let dx;
                        let dy;
                        if (dwidth <= vwidth && dheight <= vheight) {
                            scale = 1.0;
                        }
                        else {
                            scale = Math.min(vwidth / dwidth, vheight / dheight);
                        }
                        dx = Math.floor(((vwidth - dwidth * scale) * 0.5 + 0.5));
                        dy = Math.floor(((vheight - dheight * scale) * 0.5 + 0.5));
                        this.mDrawMatrix.setScale(scale, scale);
                        this.mDrawMatrix.postTranslate(dx, dy);
                    }
                    else {
                        this.mTempSrc.set(0, 0, dwidth, dheight);
                        this.mTempDst.set(0, 0, vwidth, vheight);
                        this.mDrawMatrix = this.mMatrix;
                        this.mDrawMatrix.setRectToRect(this.mTempSrc, this.mTempDst, ImageView.scaleTypeToScaleToFit(this.mScaleType));
                    }
                }
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                let d = this.mDrawable;
                if (d != null && d.isStateful()) {
                    d.setState(this.getDrawableState());
                }
            }
            onDraw(canvas) {
                super.onDraw(canvas);
                if (this.mDrawable == null) {
                    return;
                }
                if (this.mDrawableWidth == 0 || this.mDrawableHeight == 0) {
                    return;
                }
                if (this.mDrawMatrix == null && this.mPaddingTop == 0 && this.mPaddingLeft == 0) {
                    this.mDrawable.draw(canvas);
                }
                else {
                    let saveCount = canvas.getSaveCount();
                    canvas.save();
                    if (this.mCropToPadding) {
                        const scrollX = this.mScrollX;
                        const scrollY = this.mScrollY;
                        canvas.clipRect(scrollX + this.mPaddingLeft, scrollY + this.mPaddingTop, scrollX + this.mRight - this.mLeft - this.mPaddingRight, scrollY + this.mBottom - this.mTop - this.mPaddingBottom);
                    }
                    canvas.translate(this.mPaddingLeft, this.mPaddingTop);
                    if (this.mDrawMatrix != null) {
                        canvas.concat(this.mDrawMatrix);
                    }
                    this.mDrawable.draw(canvas);
                    canvas.restoreToCount(saveCount);
                }
            }
            getBaseline() {
                if (this.mBaselineAlignBottom) {
                    return this.getMeasuredHeight();
                }
                else {
                    return this.mBaseline;
                }
            }
            setBaseline(baseline) {
                if (this.mBaseline != baseline) {
                    this.mBaseline = baseline;
                    this.requestLayout();
                }
            }
            setBaselineAlignBottom(aligned) {
                if (this.mBaselineAlignBottom != aligned) {
                    this.mBaselineAlignBottom = aligned;
                    this.requestLayout();
                }
            }
            getBaselineAlignBottom() {
                return this.mBaselineAlignBottom;
            }
            getImageAlpha() {
                return this.mAlpha;
            }
            setImageAlpha(alpha) {
                this.setAlpha(alpha);
            }
            setAlpha(alpha) {
                alpha &= 0xFF;
                if (this.mAlpha != alpha) {
                    this.mAlpha = alpha;
                    this.mColorMod = true;
                    this.applyColorMod();
                    this.invalidate();
                }
            }
            applyColorMod() {
                if (this.mDrawable != null && this.mColorMod) {
                    this.mDrawable = this.mDrawable.mutate();
                    this.mDrawable.setAlpha(this.mAlpha * this.mViewAlphaScale >> 8);
                }
            }
            setVisibility(visibility) {
                super.setVisibility(visibility);
                if (this.mDrawable != null) {
                    this.mDrawable.setVisible(visibility == ImageView.VISIBLE, false);
                }
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                if (this.mDrawable != null) {
                    this.mDrawable.setVisible(this.getVisibility() == ImageView.VISIBLE, false);
                }
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                if (this.mDrawable != null) {
                    this.mDrawable.setVisible(false, false);
                }
            }
            static parseScaleType(s, defaultType) {
                if (s == null)
                    return defaultType;
                s = s.toLowerCase();
                if (s === 'matrix'.toLowerCase())
                    return ImageView.ScaleType.MATRIX;
                if (s === 'fitXY'.toLowerCase())
                    return ImageView.ScaleType.FIT_XY;
                if (s === 'fitStart'.toLowerCase())
                    return ImageView.ScaleType.FIT_START;
                if (s === 'fitCenter'.toLowerCase())
                    return ImageView.ScaleType.FIT_CENTER;
                if (s === 'fitEnd'.toLowerCase())
                    return ImageView.ScaleType.FIT_END;
                if (s === 'center'.toLowerCase())
                    return ImageView.ScaleType.CENTER;
                if (s === 'centerCrop'.toLowerCase())
                    return ImageView.ScaleType.CENTER_CROP;
                if (s === 'centerInside'.toLowerCase())
                    return ImageView.ScaleType.CENTER_INSIDE;
                return defaultType;
            }
        }
        ImageView.sS2FArray = [Matrix.ScaleToFit.FILL, Matrix.ScaleToFit.START, Matrix.ScaleToFit.CENTER, Matrix.ScaleToFit.END];
        widget.ImageView = ImageView;
        (function (ImageView) {
            (function (ScaleType) {
                ScaleType[ScaleType["MATRIX"] = 0] = "MATRIX";
                ScaleType[ScaleType["FIT_XY"] = 1] = "FIT_XY";
                ScaleType[ScaleType["FIT_START"] = 2] = "FIT_START";
                ScaleType[ScaleType["FIT_CENTER"] = 3] = "FIT_CENTER";
                ScaleType[ScaleType["FIT_END"] = 4] = "FIT_END";
                ScaleType[ScaleType["CENTER"] = 5] = "CENTER";
                ScaleType[ScaleType["CENTER_CROP"] = 6] = "CENTER_CROP";
                ScaleType[ScaleType["CENTER_INSIDE"] = 7] = "CENTER_INSIDE";
            })(ImageView.ScaleType || (ImageView.ScaleType = {}));
            var ScaleType = ImageView.ScaleType;
        })(ImageView = widget.ImageView || (widget.ImageView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/28.
 */
///<reference path="ImageView.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        class ImageButton extends widget.ImageView {
            constructor(context, bindElement, defStyle = android.R.attr.imageButtonStyle) {
                super(context, bindElement, defStyle);
            }
        }
        widget.ImageButton = ImageButton;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/os/Trace.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var Trace = android.os.Trace;
        var Gravity = android.view.Gravity;
        var KeyEvent = android.view.KeyEvent;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Integer = java.lang.Integer;
        var AbsListView = android.widget.AbsListView;
        class GridView extends AbsListView {
            constructor(context, bindElement, defStyle = android.R.attr.gridViewStyle) {
                super(context, bindElement, null);
                this.mNumColumns = GridView.AUTO_FIT;
                this.mHorizontalSpacing = 0;
                this.mRequestedHorizontalSpacing = 0;
                this.mVerticalSpacing = 0;
                this.mStretchMode = GridView.STRETCH_COLUMN_WIDTH;
                this.mColumnWidth = 0;
                this.mRequestedColumnWidth = 0;
                this.mRequestedNumColumns = 0;
                this.mReferenceView = null;
                this.mReferenceViewInSelectedRow = null;
                this.mGravity = Gravity.LEFT;
                this.mTempRect = new Rect();
                this._attrBinder.addAttr('horizontalSpacing', (value) => {
                    this.setHorizontalSpacing(this._attrBinder.parseNumber(value, 0));
                });
                this._attrBinder.addAttr('verticalSpacing', (value) => {
                    this.setVerticalSpacing(this._attrBinder.parseNumber(value, 0));
                });
                this._attrBinder.addAttr('stretchMode', (value) => {
                    let strechMode = this._attrBinder.parseNumber(value, -1);
                    if (strechMode >= 0) {
                        this.setStretchMode(strechMode);
                    }
                });
                this._attrBinder.addAttr('columnWidth', (value) => {
                    let columnWidth = this._attrBinder.parseNumber(value, -1);
                    if (columnWidth > 0) {
                        this.setColumnWidth(columnWidth);
                    }
                });
                this._attrBinder.addAttr('numColumns', (value) => {
                    this.setNumColumns(this._attrBinder.parseNumber(value, 1));
                });
                this._attrBinder.addAttr('gravity', (value) => {
                    this.setNumColumns(this._attrBinder.parseNumber(value, 1));
                });
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
            }
            getAdapter() {
                return this.mAdapter;
            }
            setAdapter(adapter) {
                if (this.mAdapter != null && this.mDataSetObserver != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                }
                this.resetList();
                this.mRecycler.clear();
                this.mAdapter = adapter;
                this.mOldSelectedPosition = GridView.INVALID_POSITION;
                this.mOldSelectedRowId = GridView.INVALID_ROW_ID;
                super.setAdapter(adapter);
                if (this.mAdapter != null) {
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                    this.mDataChanged = true;
                    this.checkFocus();
                    this.mDataSetObserver = new AbsListView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    this.mRecycler.setViewTypeCount(this.mAdapter.getViewTypeCount());
                    let position;
                    if (this.mStackFromBottom) {
                        position = this.lookForSelectablePosition(this.mItemCount - 1, false);
                    }
                    else {
                        position = this.lookForSelectablePosition(0, true);
                    }
                    this.setSelectedPositionInt(position);
                    this.setNextSelectedPositionInt(position);
                    this.checkSelectionChanged();
                }
                else {
                    this.checkFocus();
                    this.checkSelectionChanged();
                }
                this.requestLayout();
            }
            lookForSelectablePosition(position, lookDown) {
                const adapter = this.mAdapter;
                if (adapter == null || this.isInTouchMode()) {
                    return GridView.INVALID_POSITION;
                }
                if (position < 0 || position >= this.mItemCount) {
                    return GridView.INVALID_POSITION;
                }
                return position;
            }
            fillGap(down) {
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                const count = this.getChildCount();
                if (down) {
                    let paddingTop = 0;
                    if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                        paddingTop = this.getListPaddingTop();
                    }
                    const startOffset = count > 0 ? this.getChildAt(count - 1).getBottom() + verticalSpacing : paddingTop;
                    let position = this.mFirstPosition + count;
                    if (this.mStackFromBottom) {
                        position += numColumns - 1;
                    }
                    this.fillDown(position, startOffset);
                    this.correctTooHigh(numColumns, verticalSpacing, this.getChildCount());
                }
                else {
                    let paddingBottom = 0;
                    if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                        paddingBottom = this.getListPaddingBottom();
                    }
                    const startOffset = count > 0 ? this.getChildAt(0).getTop() - verticalSpacing : this.getHeight() - paddingBottom;
                    let position = this.mFirstPosition;
                    if (!this.mStackFromBottom) {
                        position -= numColumns;
                    }
                    else {
                        position--;
                    }
                    this.fillUp(position, startOffset);
                    this.correctTooLow(numColumns, verticalSpacing, this.getChildCount());
                }
            }
            fillDown(pos, nextTop) {
                let selectedView = null;
                let end = (this.mBottom - this.mTop);
                if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                    end -= this.mListPadding.bottom;
                }
                while (nextTop < end && pos < this.mItemCount) {
                    let temp = this.makeRow(pos, nextTop, true);
                    if (temp != null) {
                        selectedView = temp;
                    }
                    nextTop = this.mReferenceView.getBottom() + this.mVerticalSpacing;
                    pos += this.mNumColumns;
                }
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            makeRow(startPos, y, flow) {
                const columnWidth = this.mColumnWidth;
                const horizontalSpacing = this.mHorizontalSpacing;
                const isLayoutRtl = this.isLayoutRtl();
                let last;
                let nextLeft;
                if (isLayoutRtl) {
                    nextLeft = this.getWidth() - this.mListPadding.right - columnWidth - ((this.mStretchMode == GridView.STRETCH_SPACING_UNIFORM) ? horizontalSpacing : 0);
                }
                else {
                    nextLeft = this.mListPadding.left + ((this.mStretchMode == GridView.STRETCH_SPACING_UNIFORM) ? horizontalSpacing : 0);
                }
                if (!this.mStackFromBottom) {
                    last = Math.min(startPos + this.mNumColumns, this.mItemCount);
                }
                else {
                    last = startPos + 1;
                    startPos = Math.max(0, startPos - this.mNumColumns + 1);
                    if (last - startPos < this.mNumColumns) {
                        const deltaLeft = (this.mNumColumns - (last - startPos)) * (columnWidth + horizontalSpacing);
                        nextLeft += (isLayoutRtl ? -1 : +1) * deltaLeft;
                    }
                }
                let selectedView = null;
                const hasFocus = this.shouldShowSelector();
                const inClick = this.touchModeDrawsInPressedState();
                const selectedPosition = this.mSelectedPosition;
                let child = null;
                for (let pos = startPos; pos < last; pos++) {
                    let selected = pos == selectedPosition;
                    const where = flow ? -1 : pos - startPos;
                    child = this.makeAndAddView(pos, y, flow, nextLeft, selected, where);
                    nextLeft += (isLayoutRtl ? -1 : +1) * columnWidth;
                    if (pos < last - 1) {
                        nextLeft += horizontalSpacing;
                    }
                    if (selected && (hasFocus || inClick)) {
                        selectedView = child;
                    }
                }
                this.mReferenceView = child;
                if (selectedView != null) {
                    this.mReferenceViewInSelectedRow = this.mReferenceView;
                }
                return selectedView;
            }
            fillUp(pos, nextBottom) {
                let selectedView = null;
                let end = 0;
                if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                    end = this.mListPadding.top;
                }
                while (nextBottom > end && pos >= 0) {
                    let temp = this.makeRow(pos, nextBottom, false);
                    if (temp != null) {
                        selectedView = temp;
                    }
                    nextBottom = this.mReferenceView.getTop() - this.mVerticalSpacing;
                    this.mFirstPosition = pos;
                    pos -= this.mNumColumns;
                }
                if (this.mStackFromBottom) {
                    this.mFirstPosition = Math.max(0, pos + 1);
                }
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            fillFromTop(nextTop) {
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mSelectedPosition);
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mItemCount - 1);
                if (this.mFirstPosition < 0) {
                    this.mFirstPosition = 0;
                }
                this.mFirstPosition -= this.mFirstPosition % this.mNumColumns;
                return this.fillDown(this.mFirstPosition, nextTop);
            }
            fillFromBottom(lastPosition, nextBottom) {
                lastPosition = Math.max(lastPosition, this.mSelectedPosition);
                lastPosition = Math.min(lastPosition, this.mItemCount - 1);
                const invertedPosition = this.mItemCount - 1 - lastPosition;
                lastPosition = this.mItemCount - 1 - (invertedPosition - (invertedPosition % this.mNumColumns));
                return this.fillUp(lastPosition, nextBottom);
            }
            fillSelection(childrenTop, childrenBottom) {
                const selectedPosition = this.reconcileSelectedPosition();
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                let rowStart;
                let rowEnd = -1;
                if (!this.mStackFromBottom) {
                    rowStart = selectedPosition - (selectedPosition % numColumns);
                }
                else {
                    const invertedSelection = this.mItemCount - 1 - selectedPosition;
                    rowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    rowStart = Math.max(0, rowEnd - numColumns + 1);
                }
                const fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart);
                const sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, topSelectionPixel, true);
                this.mFirstPosition = rowStart;
                const referenceView = this.mReferenceView;
                if (!this.mStackFromBottom) {
                    this.fillDown(rowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.pinToBottom(childrenBottom);
                    this.fillUp(rowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                }
                else {
                    const bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart);
                    const offset = bottomSelectionPixel - referenceView.getBottom();
                    this.offsetChildrenTopAndBottom(offset);
                    this.fillUp(rowStart - 1, referenceView.getTop() - verticalSpacing);
                    this.pinToTop(childrenTop);
                    this.fillDown(rowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                }
                return sel;
            }
            pinToTop(childrenTop) {
                if (this.mFirstPosition == 0) {
                    const top = this.getChildAt(0).getTop();
                    const offset = childrenTop - top;
                    if (offset < 0) {
                        this.offsetChildrenTopAndBottom(offset);
                    }
                }
            }
            pinToBottom(childrenBottom) {
                const count = this.getChildCount();
                if (this.mFirstPosition + count == this.mItemCount) {
                    const bottom = this.getChildAt(count - 1).getBottom();
                    const offset = childrenBottom - bottom;
                    if (offset > 0) {
                        this.offsetChildrenTopAndBottom(offset);
                    }
                }
            }
            findMotionRow(y) {
                const childCount = this.getChildCount();
                if (childCount > 0) {
                    const numColumns = this.mNumColumns;
                    if (!this.mStackFromBottom) {
                        for (let i = 0; i < childCount; i += numColumns) {
                            if (y <= this.getChildAt(i).getBottom()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                    else {
                        for (let i = childCount - 1; i >= 0; i -= numColumns) {
                            if (y >= this.getChildAt(i).getTop()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                }
                return GridView.INVALID_POSITION;
            }
            fillSpecific(position, top) {
                const numColumns = this.mNumColumns;
                let motionRowStart;
                let motionRowEnd = -1;
                if (!this.mStackFromBottom) {
                    motionRowStart = position - (position % numColumns);
                }
                else {
                    const invertedSelection = this.mItemCount - 1 - position;
                    motionRowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    motionRowStart = Math.max(0, motionRowEnd - numColumns + 1);
                }
                const temp = this.makeRow(this.mStackFromBottom ? motionRowEnd : motionRowStart, top, true);
                this.mFirstPosition = motionRowStart;
                const referenceView = this.mReferenceView;
                if (referenceView == null) {
                    return null;
                }
                const verticalSpacing = this.mVerticalSpacing;
                let above;
                let below;
                if (!this.mStackFromBottom) {
                    above = this.fillUp(motionRowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                    below = this.fillDown(motionRowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                    const childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooHigh(numColumns, verticalSpacing, childCount);
                    }
                }
                else {
                    below = this.fillDown(motionRowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                    above = this.fillUp(motionRowStart - 1, referenceView.getTop() - verticalSpacing);
                    const childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooLow(numColumns, verticalSpacing, childCount);
                    }
                }
                if (temp != null) {
                    return temp;
                }
                else if (above != null) {
                    return above;
                }
                else {
                    return below;
                }
            }
            correctTooHigh(numColumns, verticalSpacing, childCount) {
                const lastPosition = this.mFirstPosition + childCount - 1;
                if (lastPosition == this.mItemCount - 1 && childCount > 0) {
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let bottomOffset = end - lastBottom;
                    const firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    if (bottomOffset > 0 && (this.mFirstPosition > 0 || firstTop < this.mListPadding.top)) {
                        if (this.mFirstPosition == 0) {
                            bottomOffset = Math.min(bottomOffset, this.mListPadding.top - firstTop);
                        }
                        this.offsetChildrenTopAndBottom(bottomOffset);
                        if (this.mFirstPosition > 0) {
                            this.fillUp(this.mFirstPosition - (this.mStackFromBottom ? 1 : numColumns), firstChild.getTop() - verticalSpacing);
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            correctTooLow(numColumns, verticalSpacing, childCount) {
                if (this.mFirstPosition == 0 && childCount > 0) {
                    const firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    const start = this.mListPadding.top;
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let topOffset = firstTop - start;
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    const lastPosition = this.mFirstPosition + childCount - 1;
                    if (topOffset > 0 && (lastPosition < this.mItemCount - 1 || lastBottom > end)) {
                        if (lastPosition == this.mItemCount - 1) {
                            topOffset = Math.min(topOffset, lastBottom - end);
                        }
                        this.offsetChildrenTopAndBottom(-topOffset);
                        if (lastPosition < this.mItemCount - 1) {
                            this.fillDown(lastPosition + (!this.mStackFromBottom ? 1 : numColumns), lastChild.getBottom() + verticalSpacing);
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            fillFromSelection(selectedTop, childrenTop, childrenBottom) {
                const fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                let rowStart;
                let rowEnd = -1;
                if (!this.mStackFromBottom) {
                    rowStart = selectedPosition - (selectedPosition % numColumns);
                }
                else {
                    let invertedSelection = this.mItemCount - 1 - selectedPosition;
                    rowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    rowStart = Math.max(0, rowEnd - numColumns + 1);
                }
                let sel;
                let referenceView;
                let topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart);
                let bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart);
                sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, selectedTop, true);
                this.mFirstPosition = rowStart;
                referenceView = this.mReferenceView;
                this.adjustForTopFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                this.adjustForBottomFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                if (!this.mStackFromBottom) {
                    this.fillUp(rowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillDown(rowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                }
                else {
                    this.fillDown(rowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillUp(rowStart - 1, referenceView.getTop() - verticalSpacing);
                }
                return sel;
            }
            getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart) {
                let bottomSelectionPixel = childrenBottom;
                if (rowStart + numColumns - 1 < this.mItemCount - 1) {
                    bottomSelectionPixel -= fadingEdgeLength;
                }
                return bottomSelectionPixel;
            }
            getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart) {
                let topSelectionPixel = childrenTop;
                if (rowStart > 0) {
                    topSelectionPixel += fadingEdgeLength;
                }
                return topSelectionPixel;
            }
            adjustForBottomFadingEdge(childInSelectedRow, topSelectionPixel, bottomSelectionPixel) {
                if (childInSelectedRow.getBottom() > bottomSelectionPixel) {
                    let spaceAbove = childInSelectedRow.getTop() - topSelectionPixel;
                    let spaceBelow = childInSelectedRow.getBottom() - bottomSelectionPixel;
                    let offset = Math.min(spaceAbove, spaceBelow);
                    this.offsetChildrenTopAndBottom(-offset);
                }
            }
            adjustForTopFadingEdge(childInSelectedRow, topSelectionPixel, bottomSelectionPixel) {
                if (childInSelectedRow.getTop() < topSelectionPixel) {
                    let spaceAbove = topSelectionPixel - childInSelectedRow.getTop();
                    let spaceBelow = bottomSelectionPixel - childInSelectedRow.getBottom();
                    let offset = Math.min(spaceAbove, spaceBelow);
                    this.offsetChildrenTopAndBottom(offset);
                }
            }
            smoothScrollToPosition(position) {
                super.smoothScrollToPosition(position);
            }
            smoothScrollByOffset(offset) {
                super.smoothScrollByOffset(offset);
            }
            moveSelection(delta, childrenTop, childrenBottom) {
                const fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                let oldRowStart;
                let rowStart;
                let rowEnd = -1;
                if (!this.mStackFromBottom) {
                    oldRowStart = (selectedPosition - delta) - ((selectedPosition - delta) % numColumns);
                    rowStart = selectedPosition - (selectedPosition % numColumns);
                }
                else {
                    let invertedSelection = this.mItemCount - 1 - selectedPosition;
                    rowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    rowStart = Math.max(0, rowEnd - numColumns + 1);
                    invertedSelection = this.mItemCount - 1 - (selectedPosition - delta);
                    oldRowStart = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    oldRowStart = Math.max(0, oldRowStart - numColumns + 1);
                }
                const rowDelta = rowStart - oldRowStart;
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart);
                const bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart);
                this.mFirstPosition = rowStart;
                let sel;
                let referenceView;
                if (rowDelta > 0) {
                    const oldBottom = this.mReferenceViewInSelectedRow == null ? 0 : this.mReferenceViewInSelectedRow.getBottom();
                    sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, oldBottom + verticalSpacing, true);
                    referenceView = this.mReferenceView;
                    this.adjustForBottomFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                }
                else if (rowDelta < 0) {
                    const oldTop = this.mReferenceViewInSelectedRow == null ? 0 : this.mReferenceViewInSelectedRow.getTop();
                    sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, oldTop - verticalSpacing, false);
                    referenceView = this.mReferenceView;
                    this.adjustForTopFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                }
                else {
                    const oldTop = this.mReferenceViewInSelectedRow == null ? 0 : this.mReferenceViewInSelectedRow.getTop();
                    sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, oldTop, true);
                    referenceView = this.mReferenceView;
                }
                if (!this.mStackFromBottom) {
                    this.fillUp(rowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillDown(rowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                }
                else {
                    this.fillDown(rowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillUp(rowStart - 1, referenceView.getTop() - verticalSpacing);
                }
                return sel;
            }
            determineColumns(availableSpace) {
                const requestedHorizontalSpacing = this.mRequestedHorizontalSpacing;
                const stretchMode = this.mStretchMode;
                const requestedColumnWidth = this.mRequestedColumnWidth;
                let didNotInitiallyFit = false;
                if (this.mRequestedNumColumns == GridView.AUTO_FIT) {
                    if (requestedColumnWidth > 0) {
                        this.mNumColumns = (availableSpace + requestedHorizontalSpacing) / (requestedColumnWidth + requestedHorizontalSpacing);
                    }
                    else {
                        this.mNumColumns = 2;
                    }
                }
                else {
                    this.mNumColumns = this.mRequestedNumColumns;
                }
                if (this.mNumColumns <= 0) {
                    this.mNumColumns = 1;
                }
                switch (stretchMode) {
                    case GridView.NO_STRETCH:
                        this.mColumnWidth = requestedColumnWidth;
                        this.mHorizontalSpacing = requestedHorizontalSpacing;
                        break;
                    default:
                        let spaceLeftOver = availableSpace - (this.mNumColumns * requestedColumnWidth) - ((this.mNumColumns - 1) * requestedHorizontalSpacing);
                        if (spaceLeftOver < 0) {
                            didNotInitiallyFit = true;
                        }
                        switch (stretchMode) {
                            case GridView.STRETCH_COLUMN_WIDTH:
                                this.mColumnWidth = requestedColumnWidth + spaceLeftOver / this.mNumColumns;
                                this.mHorizontalSpacing = requestedHorizontalSpacing;
                                break;
                            case GridView.STRETCH_SPACING:
                                this.mColumnWidth = requestedColumnWidth;
                                if (this.mNumColumns > 1) {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver / (this.mNumColumns - 1);
                                }
                                else {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver;
                                }
                                break;
                            case GridView.STRETCH_SPACING_UNIFORM:
                                this.mColumnWidth = requestedColumnWidth;
                                if (this.mNumColumns > 1) {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver / (this.mNumColumns + 1);
                                }
                                else {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver;
                                }
                                break;
                        }
                        break;
                }
                return didNotInitiallyFit;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                let widthMode = GridView.MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = GridView.MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = GridView.MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = GridView.MeasureSpec.getSize(heightMeasureSpec);
                if (widthMode == GridView.MeasureSpec.UNSPECIFIED) {
                    if (this.mColumnWidth > 0) {
                        widthSize = this.mColumnWidth + this.mListPadding.left + this.mListPadding.right;
                    }
                    else {
                        widthSize = this.mListPadding.left + this.mListPadding.right;
                    }
                    widthSize += this.getVerticalScrollbarWidth();
                }
                let childWidth = widthSize - this.mListPadding.left - this.mListPadding.right;
                let didNotInitiallyFit = this.determineColumns(childWidth);
                let childHeight = 0;
                let childState = 0;
                this.mItemCount = this.mAdapter == null ? 0 : this.mAdapter.getCount();
                const count = this.mItemCount;
                if (count > 0) {
                    const child = this.obtainView(0, this.mIsScrap);
                    let p = child.getLayoutParams();
                    if (p == null) {
                        p = this.generateDefaultLayoutParams();
                        child.setLayoutParams(p);
                    }
                    p.viewType = this.mAdapter.getItemViewType(0);
                    p.forceAdd = true;
                    let childHeightSpec = GridView.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(0, GridView.MeasureSpec.UNSPECIFIED), 0, p.height);
                    let childWidthSpec = GridView.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(this.mColumnWidth, GridView.MeasureSpec.EXACTLY), 0, p.width);
                    child.measure(childWidthSpec, childHeightSpec);
                    childHeight = child.getMeasuredHeight();
                    childState = GridView.combineMeasuredStates(childState, child.getMeasuredState());
                    if (this.mRecycler.shouldRecycleViewType(p.viewType)) {
                        this.mRecycler.addScrapView(child, -1);
                    }
                }
                if (heightMode == GridView.MeasureSpec.UNSPECIFIED) {
                    heightSize = this.mListPadding.top + this.mListPadding.bottom + childHeight + this.getVerticalFadingEdgeLength() * 2;
                }
                if (heightMode == GridView.MeasureSpec.AT_MOST) {
                    let ourSize = this.mListPadding.top + this.mListPadding.bottom;
                    const numColumns = this.mNumColumns;
                    for (let i = 0; i < count; i += numColumns) {
                        ourSize += childHeight;
                        if (i + numColumns < count) {
                            ourSize += this.mVerticalSpacing;
                        }
                        if (ourSize >= heightSize) {
                            ourSize = heightSize;
                            break;
                        }
                    }
                    heightSize = ourSize;
                }
                if (widthMode == GridView.MeasureSpec.AT_MOST && this.mRequestedNumColumns != GridView.AUTO_FIT) {
                    let ourSize = (this.mRequestedNumColumns * this.mColumnWidth) + ((this.mRequestedNumColumns - 1) * this.mHorizontalSpacing) + this.mListPadding.left + this.mListPadding.right;
                    if (ourSize > widthSize || didNotInitiallyFit) {
                        widthSize |= GridView.MEASURED_STATE_TOO_SMALL;
                    }
                }
                this.setMeasuredDimension(widthSize, heightSize);
                this.mWidthMeasureSpec = widthMeasureSpec;
            }
            layoutChildren() {
                const blockLayoutRequests = this.mBlockLayoutRequests;
                if (!blockLayoutRequests) {
                    this.mBlockLayoutRequests = true;
                }
                try {
                    super.layoutChildren();
                    this.invalidate();
                    if (this.mAdapter == null) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    const childrenTop = this.mListPadding.top;
                    const childrenBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                    let childCount = this.getChildCount();
                    let index;
                    let delta = 0;
                    let sel;
                    let oldSel = null;
                    let oldFirst = null;
                    let newSel = null;
                    switch (this.mLayoutMode) {
                        case GridView.LAYOUT_SET_SELECTION:
                            index = this.mNextSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                newSel = this.getChildAt(index);
                            }
                            break;
                        case GridView.LAYOUT_FORCE_TOP:
                        case GridView.LAYOUT_FORCE_BOTTOM:
                        case GridView.LAYOUT_SPECIFIC:
                        case GridView.LAYOUT_SYNC:
                            break;
                        case GridView.LAYOUT_MOVE_SELECTION:
                            if (this.mNextSelectedPosition >= 0) {
                                delta = this.mNextSelectedPosition - this.mSelectedPosition;
                            }
                            break;
                        default:
                            index = this.mSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                oldSel = this.getChildAt(index);
                            }
                            oldFirst = this.getChildAt(0);
                    }
                    let dataChanged = this.mDataChanged;
                    if (dataChanged) {
                        this.handleDataChanged();
                    }
                    if (this.mItemCount == 0) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    this.setSelectedPositionInt(this.mNextSelectedPosition);
                    const firstPosition = this.mFirstPosition;
                    const recycleBin = this.mRecycler;
                    if (dataChanged) {
                        for (let i = 0; i < childCount; i++) {
                            recycleBin.addScrapView(this.getChildAt(i), firstPosition + i);
                        }
                    }
                    else {
                        recycleBin.fillActiveViews(childCount, firstPosition);
                    }
                    this.detachAllViewsFromParent();
                    recycleBin.removeSkippedScrap();
                    switch (this.mLayoutMode) {
                        case GridView.LAYOUT_SET_SELECTION:
                            if (newSel != null) {
                                sel = this.fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                            }
                            else {
                                sel = this.fillSelection(childrenTop, childrenBottom);
                            }
                            break;
                        case GridView.LAYOUT_FORCE_TOP:
                            this.mFirstPosition = 0;
                            sel = this.fillFromTop(childrenTop);
                            this.adjustViewsUpOrDown();
                            break;
                        case GridView.LAYOUT_FORCE_BOTTOM:
                            sel = this.fillUp(this.mItemCount - 1, childrenBottom);
                            this.adjustViewsUpOrDown();
                            break;
                        case GridView.LAYOUT_SPECIFIC:
                            sel = this.fillSpecific(this.mSelectedPosition, this.mSpecificTop);
                            break;
                        case GridView.LAYOUT_SYNC:
                            sel = this.fillSpecific(this.mSyncPosition, this.mSpecificTop);
                            break;
                        case GridView.LAYOUT_MOVE_SELECTION:
                            sel = this.moveSelection(delta, childrenTop, childrenBottom);
                            break;
                        default:
                            if (childCount == 0) {
                                if (!this.mStackFromBottom) {
                                    this.setSelectedPositionInt(this.mAdapter == null || this.isInTouchMode() ? GridView.INVALID_POSITION : 0);
                                    sel = this.fillFromTop(childrenTop);
                                }
                                else {
                                    const last = this.mItemCount - 1;
                                    this.setSelectedPositionInt(this.mAdapter == null || this.isInTouchMode() ? GridView.INVALID_POSITION : last);
                                    sel = this.fillFromBottom(last, childrenBottom);
                                }
                            }
                            else {
                                if (this.mSelectedPosition >= 0 && this.mSelectedPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                                }
                                else if (this.mFirstPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                                }
                                else {
                                    sel = this.fillSpecific(0, childrenTop);
                                }
                            }
                            break;
                    }
                    recycleBin.scrapActiveViews();
                    if (sel != null) {
                        this.positionSelector(GridView.INVALID_POSITION, sel);
                        this.mSelectedTop = sel.getTop();
                    }
                    else if (this.mTouchMode > GridView.TOUCH_MODE_DOWN && this.mTouchMode < GridView.TOUCH_MODE_SCROLL) {
                        let child = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                        if (child != null)
                            this.positionSelector(this.mMotionPosition, child);
                    }
                    else {
                        this.mSelectedTop = 0;
                        this.mSelectorRect.setEmpty();
                    }
                    this.mLayoutMode = GridView.LAYOUT_NORMAL;
                    this.mDataChanged = false;
                    if (this.mPositionScrollAfterLayout != null) {
                        this.post(this.mPositionScrollAfterLayout);
                        this.mPositionScrollAfterLayout = null;
                    }
                    this.mNeedSync = false;
                    this.setNextSelectedPositionInt(this.mSelectedPosition);
                    this.updateScrollIndicators();
                    if (this.mItemCount > 0) {
                        this.checkSelectionChanged();
                    }
                    this.invokeOnItemScrollListener();
                }
                finally {
                    if (!blockLayoutRequests) {
                        this.mBlockLayoutRequests = false;
                    }
                }
            }
            makeAndAddView(position, y, flow, childrenLeft, selected, where) {
                let child;
                if (!this.mDataChanged) {
                    child = this.mRecycler.getActiveView(position);
                    if (child != null) {
                        this.setupChild(child, position, y, flow, childrenLeft, selected, true, where);
                        return child;
                    }
                }
                child = this.obtainView(position, this.mIsScrap);
                this.setupChild(child, position, y, flow, childrenLeft, selected, this.mIsScrap[0], where);
                return child;
            }
            setupChild(child, position, y, flow, childrenLeft, selected, recycled, where) {
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setupGridItem");
                let isSelected = selected && this.shouldShowSelector();
                const updateChildSelected = isSelected != child.isSelected();
                const mode = this.mTouchMode;
                const isPressed = mode > GridView.TOUCH_MODE_DOWN && mode < GridView.TOUCH_MODE_SCROLL && this.mMotionPosition == position;
                const updateChildPressed = isPressed != child.isPressed();
                let needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();
                let p = child.getLayoutParams();
                if (p == null) {
                    p = this.generateDefaultLayoutParams();
                }
                p.viewType = this.mAdapter.getItemViewType(position);
                if (recycled && !p.forceAdd) {
                    this.attachViewToParent(child, where, p);
                }
                else {
                    p.forceAdd = false;
                    this.addViewInLayout(child, where, p, true);
                }
                if (updateChildSelected) {
                    child.setSelected(isSelected);
                    if (isSelected) {
                        this.requestFocus();
                    }
                }
                if (updateChildPressed) {
                    child.setPressed(isPressed);
                }
                if (this.mChoiceMode != GridView.CHOICE_MODE_NONE && this.mCheckStates != null) {
                    if (child['setChecked']) {
                        child.setChecked(this.mCheckStates.get(position));
                    }
                    else {
                        child.setActivated(this.mCheckStates.get(position));
                    }
                }
                if (needToMeasure) {
                    let childHeightSpec = ViewGroup.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(0, GridView.MeasureSpec.UNSPECIFIED), 0, p.height);
                    let childWidthSpec = ViewGroup.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(this.mColumnWidth, GridView.MeasureSpec.EXACTLY), 0, p.width);
                    child.measure(childWidthSpec, childHeightSpec);
                }
                else {
                    this.cleanupLayoutState(child);
                }
                const w = child.getMeasuredWidth();
                const h = child.getMeasuredHeight();
                let childLeft;
                const childTop = flow ? y : y - h;
                const absoluteGravity = this.mGravity;
                switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                    case Gravity.LEFT:
                        childLeft = childrenLeft;
                        break;
                    case Gravity.CENTER_HORIZONTAL:
                        childLeft = childrenLeft + ((this.mColumnWidth - w) / 2);
                        break;
                    case Gravity.RIGHT:
                        childLeft = childrenLeft + this.mColumnWidth - w;
                        break;
                    default:
                        childLeft = childrenLeft;
                        break;
                }
                if (needToMeasure) {
                    const childRight = childLeft + w;
                    const childBottom = childTop + h;
                    child.layout(childLeft, childTop, childRight, childBottom);
                }
                else {
                    child.offsetLeftAndRight(childLeft - child.getLeft());
                    child.offsetTopAndBottom(childTop - child.getTop());
                }
                if (this.mCachingStarted) {
                    child.setDrawingCacheEnabled(true);
                }
                if (recycled && (child.getLayoutParams().scrappedFromPosition) != position) {
                    child.jumpDrawablesToCurrentState();
                }
                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            }
            setSelection(position) {
                if (!this.isInTouchMode()) {
                    this.setNextSelectedPositionInt(position);
                }
                else {
                    this.mResurrectToPosition = position;
                }
                this.mLayoutMode = GridView.LAYOUT_SET_SELECTION;
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.requestLayout();
            }
            setSelectionInt(position) {
                let previousSelectedPosition = this.mNextSelectedPosition;
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.setNextSelectedPositionInt(position);
                this.layoutChildren();
                const next = this.mStackFromBottom ? this.mItemCount - 1 - this.mNextSelectedPosition : this.mNextSelectedPosition;
                const previous = this.mStackFromBottom ? this.mItemCount - 1 - previousSelectedPosition : previousSelectedPosition;
                const nextRow = next / this.mNumColumns;
                const previousRow = previous / this.mNumColumns;
                if (nextRow != previousRow) {
                    this.awakenScrollBars();
                }
            }
            onKeyDown(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            onKeyMultiple(keyCode, repeatCount, event) {
                return this.commonKey(keyCode, repeatCount, event);
            }
            onKeyUp(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            commonKey(keyCode, count, event) {
                if (this.mAdapter == null) {
                    return false;
                }
                if (this.mDataChanged) {
                    this.layoutChildren();
                }
                let handled = false;
                let action = event.getAction();
                if (action != KeyEvent.ACTION_UP) {
                    switch (keyCode) {
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_LEFT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_RIGHT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_UP);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_CENTER:
                        case KeyEvent.KEYCODE_ENTER:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled && event.getRepeatCount() == 0 && this.getChildCount() > 0) {
                                    this.keyPressed();
                                    handled = true;
                                }
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_PAGE_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_UP);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_PAGE_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_HOME:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_END:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_TAB:
                            if (false) {
                                if (event.hasNoModifiers()) {
                                    handled = this.resurrectSelectionIfNeeded() || this.sequenceScroll(GridView.FOCUS_FORWARD);
                                }
                                else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                    handled = this.resurrectSelectionIfNeeded() || this.sequenceScroll(GridView.FOCUS_BACKWARD);
                                }
                            }
                            break;
                    }
                }
                if (handled) {
                    return true;
                }
                switch (action) {
                    case KeyEvent.ACTION_DOWN:
                        return super.onKeyDown(keyCode, event);
                    case KeyEvent.ACTION_UP:
                        return super.onKeyUp(keyCode, event);
                    default:
                        return false;
                }
            }
            pageScroll(direction) {
                let nextPage = -1;
                if (direction == GridView.FOCUS_UP) {
                    nextPage = Math.max(0, this.mSelectedPosition - this.getChildCount());
                }
                else if (direction == GridView.FOCUS_DOWN) {
                    nextPage = Math.min(this.mItemCount - 1, this.mSelectedPosition + this.getChildCount());
                }
                if (nextPage >= 0) {
                    this.setSelectionInt(nextPage);
                    this.invokeOnItemScrollListener();
                    this.awakenScrollBars();
                    return true;
                }
                return false;
            }
            fullScroll(direction) {
                let moved = false;
                if (direction == GridView.FOCUS_UP) {
                    this.mLayoutMode = GridView.LAYOUT_SET_SELECTION;
                    this.setSelectionInt(0);
                    this.invokeOnItemScrollListener();
                    moved = true;
                }
                else if (direction == GridView.FOCUS_DOWN) {
                    this.mLayoutMode = GridView.LAYOUT_SET_SELECTION;
                    this.setSelectionInt(this.mItemCount - 1);
                    this.invokeOnItemScrollListener();
                    moved = true;
                }
                if (moved) {
                    this.awakenScrollBars();
                }
                return moved;
            }
            arrowScroll(direction) {
                const selectedPosition = this.mSelectedPosition;
                const numColumns = this.mNumColumns;
                let startOfRowPos;
                let endOfRowPos;
                let moved = false;
                if (!this.mStackFromBottom) {
                    startOfRowPos = Math.floor(selectedPosition / numColumns) * numColumns;
                    endOfRowPos = Math.min(startOfRowPos + numColumns - 1, this.mItemCount - 1);
                }
                else {
                    const invertedSelection = this.mItemCount - 1 - selectedPosition;
                    endOfRowPos = this.mItemCount - 1 - (invertedSelection / numColumns) * numColumns;
                    startOfRowPos = Math.max(0, endOfRowPos - numColumns + 1);
                }
                switch (direction) {
                    case GridView.FOCUS_UP:
                        if (startOfRowPos > 0) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.max(0, selectedPosition - numColumns));
                            moved = true;
                        }
                        break;
                    case GridView.FOCUS_DOWN:
                        if (endOfRowPos < this.mItemCount - 1) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.min(selectedPosition + numColumns, this.mItemCount - 1));
                            moved = true;
                        }
                        break;
                    case GridView.FOCUS_LEFT:
                        if (selectedPosition > startOfRowPos) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.max(0, selectedPosition - 1));
                            moved = true;
                        }
                        break;
                    case GridView.FOCUS_RIGHT:
                        if (selectedPosition < endOfRowPos) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.min(selectedPosition + 1, this.mItemCount - 1));
                            moved = true;
                        }
                        break;
                }
                if (moved) {
                    this.playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
                    this.invokeOnItemScrollListener();
                }
                if (moved) {
                    this.awakenScrollBars();
                }
                return moved;
            }
            sequenceScroll(direction) {
                let selectedPosition = this.mSelectedPosition;
                let numColumns = this.mNumColumns;
                let count = this.mItemCount;
                let startOfRow;
                let endOfRow;
                if (!this.mStackFromBottom) {
                    startOfRow = (selectedPosition / numColumns) * numColumns;
                    endOfRow = Math.min(startOfRow + numColumns - 1, count - 1);
                }
                else {
                    let invertedSelection = count - 1 - selectedPosition;
                    endOfRow = count - 1 - (invertedSelection / numColumns) * numColumns;
                    startOfRow = Math.max(0, endOfRow - numColumns + 1);
                }
                let moved = false;
                let showScroll = false;
                switch (direction) {
                    case GridView.FOCUS_FORWARD:
                        if (selectedPosition < count - 1) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(selectedPosition + 1);
                            moved = true;
                            showScroll = selectedPosition == endOfRow;
                        }
                        break;
                    case GridView.FOCUS_BACKWARD:
                        if (selectedPosition > 0) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(selectedPosition - 1);
                            moved = true;
                            showScroll = selectedPosition == startOfRow;
                        }
                        break;
                }
                if (moved) {
                    this.playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
                    this.invokeOnItemScrollListener();
                }
                if (showScroll) {
                    this.awakenScrollBars();
                }
                return moved;
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
                let closestChildIndex = -1;
                if (gainFocus && previouslyFocusedRect != null) {
                    previouslyFocusedRect.offset(this.mScrollX, this.mScrollY);
                    let otherRect = this.mTempRect;
                    let minDistance = Integer.MAX_VALUE;
                    const childCount = this.getChildCount();
                    for (let i = 0; i < childCount; i++) {
                        if (!this.isCandidateSelection(i, direction)) {
                            continue;
                        }
                        const other = this.getChildAt(i);
                        other.getDrawingRect(otherRect);
                        this.offsetDescendantRectToMyCoords(other, otherRect);
                        let distance = GridView.getDistance(previouslyFocusedRect, otherRect, direction);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestChildIndex = i;
                        }
                    }
                }
                if (closestChildIndex >= 0) {
                    this.setSelection(closestChildIndex + this.mFirstPosition);
                }
                else {
                    this.requestLayout();
                }
            }
            isCandidateSelection(childIndex, direction) {
                const count = this.getChildCount();
                const invertedIndex = count - 1 - childIndex;
                let rowStart;
                let rowEnd;
                if (!this.mStackFromBottom) {
                    rowStart = childIndex - (childIndex % this.mNumColumns);
                    rowEnd = Math.max(rowStart + this.mNumColumns - 1, count);
                }
                else {
                    rowEnd = count - 1 - (invertedIndex - (invertedIndex % this.mNumColumns));
                    rowStart = Math.max(0, rowEnd - this.mNumColumns + 1);
                }
                switch (direction) {
                    case View.FOCUS_RIGHT:
                        return childIndex == rowStart;
                    case View.FOCUS_DOWN:
                        return rowStart == 0;
                    case View.FOCUS_LEFT:
                        return childIndex == rowEnd;
                    case View.FOCUS_UP:
                        return rowEnd == count - 1;
                    case View.FOCUS_FORWARD:
                        return childIndex == rowStart && rowStart == 0;
                    case View.FOCUS_BACKWARD:
                        return childIndex == rowEnd && rowEnd == count - 1;
                    default:
                        throw Error(`new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, " + "FOCUS_FORWARD, FOCUS_BACKWARD}.")`);
                }
            }
            setGravity(gravity) {
                if (this.mGravity != gravity) {
                    this.mGravity = gravity;
                    this.requestLayoutIfNecessary();
                }
            }
            getGravity() {
                return this.mGravity;
            }
            setHorizontalSpacing(horizontalSpacing) {
                if (horizontalSpacing != this.mRequestedHorizontalSpacing) {
                    this.mRequestedHorizontalSpacing = horizontalSpacing;
                    this.requestLayoutIfNecessary();
                }
            }
            getHorizontalSpacing() {
                return this.mHorizontalSpacing;
            }
            getRequestedHorizontalSpacing() {
                return this.mRequestedHorizontalSpacing;
            }
            setVerticalSpacing(verticalSpacing) {
                if (verticalSpacing != this.mVerticalSpacing) {
                    this.mVerticalSpacing = verticalSpacing;
                    this.requestLayoutIfNecessary();
                }
            }
            getVerticalSpacing() {
                return this.mVerticalSpacing;
            }
            setStretchMode(stretchMode) {
                if (stretchMode != this.mStretchMode) {
                    this.mStretchMode = stretchMode;
                    this.requestLayoutIfNecessary();
                }
            }
            getStretchMode() {
                return this.mStretchMode;
            }
            setColumnWidth(columnWidth) {
                if (columnWidth != this.mRequestedColumnWidth) {
                    this.mRequestedColumnWidth = columnWidth;
                    this.requestLayoutIfNecessary();
                }
            }
            getColumnWidth() {
                return this.mColumnWidth;
            }
            getRequestedColumnWidth() {
                return this.mRequestedColumnWidth;
            }
            setNumColumns(numColumns) {
                if (numColumns != this.mRequestedNumColumns) {
                    this.mRequestedNumColumns = numColumns;
                    this.requestLayoutIfNecessary();
                }
            }
            getNumColumns() {
                return this.mNumColumns;
            }
            adjustViewsUpOrDown() {
                const childCount = this.getChildCount();
                if (childCount > 0) {
                    let delta;
                    let child;
                    if (!this.mStackFromBottom) {
                        child = this.getChildAt(0);
                        delta = child.getTop() - this.mListPadding.top;
                        if (this.mFirstPosition != 0) {
                            delta -= this.mVerticalSpacing;
                        }
                        if (delta < 0) {
                            delta = 0;
                        }
                    }
                    else {
                        child = this.getChildAt(childCount - 1);
                        delta = child.getBottom() - (this.getHeight() - this.mListPadding.bottom);
                        if (this.mFirstPosition + childCount < this.mItemCount) {
                            delta += this.mVerticalSpacing;
                        }
                        if (delta > 0) {
                            delta = 0;
                        }
                    }
                    if (delta != 0) {
                        this.offsetChildrenTopAndBottom(-delta);
                    }
                }
            }
            computeVerticalScrollExtent() {
                const count = this.getChildCount();
                if (count > 0) {
                    const numColumns = this.mNumColumns;
                    const rowCount = (count + numColumns - 1) / numColumns;
                    let extent = rowCount * 100;
                    let view = this.getChildAt(0);
                    const top = view.getTop();
                    let height = view.getHeight();
                    if (height > 0) {
                        extent += (top * 100) / height;
                    }
                    view = this.getChildAt(count - 1);
                    const bottom = view.getBottom();
                    height = view.getHeight();
                    if (height > 0) {
                        extent -= ((bottom - this.getHeight()) * 100) / height;
                    }
                    return extent;
                }
                return 0;
            }
            computeVerticalScrollOffset() {
                if (this.mFirstPosition >= 0 && this.getChildCount() > 0) {
                    const view = this.getChildAt(0);
                    const top = view.getTop();
                    let height = view.getHeight();
                    if (height > 0) {
                        const numColumns = this.mNumColumns;
                        const rowCount = (this.mItemCount + numColumns - 1) / numColumns;
                        const oddItemsOnFirstRow = this.isStackFromBottom() ? ((rowCount * numColumns) - this.mItemCount) : 0;
                        const whichRow = (this.mFirstPosition + oddItemsOnFirstRow) / numColumns;
                        return Math.max(whichRow * 100 - (top * 100) / height + Math.floor((this.mScrollY / this.getHeight() * rowCount * 100)), 0);
                    }
                }
                return 0;
            }
            computeVerticalScrollRange() {
                const numColumns = this.mNumColumns;
                const rowCount = (this.mItemCount + numColumns - 1) / numColumns;
                let result = Math.max(rowCount * 100, 0);
                if (this.mScrollY != 0) {
                    result += Math.abs(Math.floor((this.mScrollY / this.getHeight() * rowCount * 100)));
                }
                return result;
            }
        }
        GridView.NO_STRETCH = 0;
        GridView.STRETCH_SPACING = 1;
        GridView.STRETCH_COLUMN_WIDTH = 2;
        GridView.STRETCH_SPACING_UNIFORM = 3;
        GridView.AUTO_FIT = -1;
        widget.GridView = GridView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        var Comparable;
        (function (Comparable) {
            function isImpl(obj) {
                return obj && obj['compareTo'];
            }
            Comparable.isImpl = isImpl;
        })(Comparable = lang.Comparable || (lang.Comparable = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/**
 * Created by linfaxin on 15/11/28.
 */
///<reference path="List.ts"/>
///<reference path="ArrayList.ts"/>
///<reference path="Comparator.ts"/>
///<reference path="../lang/Comparable.ts"/>
var java;
(function (java) {
    var util;
    (function (util) {
        var Comparable = java.lang.Comparable;
        class Collections {
            static emptyList() {
                return Collections.EMPTY_LIST;
            }
            static sort(list, c) {
                if (c) {
                    list.sort((t1, t2) => {
                        return c.compare(t1, t2);
                    });
                }
                else {
                    list.sort((t1, t2) => {
                        if (Comparable.isImpl(t1) && Comparable.isImpl(t2)) {
                            return t1.compareTo(t2);
                        }
                        return 0;
                    });
                }
            }
        }
        Collections.EMPTY_LIST = new util.ArrayList();
        util.Collections = Collections;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/content/res/ColorStateList.ts"/>
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Color.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/animation/DecelerateInterpolator.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/util/Collections.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/ImageButton.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/R/layout.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Color = android.graphics.Color;
        var Paint = android.graphics.Paint;
        var Align = android.graphics.Paint.Align;
        var SparseArray = android.util.SparseArray;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var ViewConfiguration = android.view.ViewConfiguration;
        var DecelerateInterpolator = android.view.animation.DecelerateInterpolator;
        var Integer = java.lang.Integer;
        var LinearLayout = android.widget.LinearLayout;
        var OverScroller = android.widget.OverScroller;
        var R = android.R;
        class NumberPicker extends LinearLayout {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.SELECTOR_WHEEL_ITEM_COUNT = 3;
                this.SELECTOR_MIDDLE_ITEM_INDEX = Math.floor(this.SELECTOR_WHEEL_ITEM_COUNT / 2);
                this.mSelectionDividersDistance = 0;
                this.mMinHeight_ = NumberPicker.SIZE_UNSPECIFIED;
                this.mMaxHeight = NumberPicker.SIZE_UNSPECIFIED;
                this.mMinWidth_ = NumberPicker.SIZE_UNSPECIFIED;
                this.mMaxWidth = NumberPicker.SIZE_UNSPECIFIED;
                this.mTextSize = 0;
                this.mSelectorTextGapHeight = 0;
                this.mMinValue = 0;
                this.mMaxValue = 0;
                this.mValue = 0;
                this.mLongPressUpdateInterval = NumberPicker.DEFAULT_LONG_PRESS_UPDATE_INTERVAL;
                this.mSelectorIndexToStringCache = new SparseArray();
                this.mSelectorElementHeight = 0;
                this.mInitialScrollOffset = Integer.MIN_VALUE;
                this.mCurrentScrollOffset = 0;
                this.mPreviousScrollerY = 0;
                this.mLastDownEventY = 0;
                this.mLastDownEventTime = 0;
                this.mLastDownOrMoveEventY = 0;
                this.mMinimumFlingVelocity = 0;
                this.mMaximumFlingVelocity = 0;
                this.mSolidColor = 0;
                this.mSelectionDividerHeight = 0;
                this.mScrollState = NumberPicker.OnScrollListener.SCROLL_STATE_IDLE;
                this.mTopSelectionDividerTop = 0;
                this.mBottomSelectionDividerBottom = 0;
                this.mLastHoveredChildVirtualViewId = 0;
                this.mLastHandledDownDpadKeyCode = -1;
                this.mHasSelectorWheel = true;
                this._attrBinder.addAttr('solidColor', (value) => {
                    this.mSolidColor = this._attrBinder.parseColor(value) || 0;
                });
                this._attrBinder.addAttr('selectionDivider', (value) => {
                    this.mSelectionDivider = this._attrBinder.parseDrawable(value);
                });
                this._attrBinder.addAttr('selectionDividerHeight', (value) => {
                    const defSelectionDividerHeight = NumberPicker.UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT
                        * this.getResources().getDisplayMetrics().density;
                    this.mSelectionDividerHeight = this._attrBinder.parseNumber(value, defSelectionDividerHeight);
                });
                this._attrBinder.addAttr('selectionDividersDistance', (value) => {
                    const defSelectionDividerDistance = NumberPicker.UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE
                        * this.getResources().getDisplayMetrics().density;
                    this.mSelectionDividersDistance = this._attrBinder.parseNumber(value, defSelectionDividerDistance);
                });
                this._attrBinder.addAttr('internalMinHeight', (value) => {
                    this.mMinHeight_ = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('internalMaxHeight', (value) => {
                    this.mMaxHeight = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('internalMinWidth', (value) => {
                    this.mMinWidth_ = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('internalMaxWidth', (value) => {
                    this.mMaxWidth = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('internalMaxWidth', (value) => {
                    this.mMaxWidth = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('virtualButtonPressedDrawable', (value) => {
                    this.mVirtualButtonPressedDrawable = this._attrBinder.parseDrawable(value);
                });
                this._attrBinder.addAttr('textSize', (value) => {
                    this.mTextSize = this._attrBinder.parseNumber(value, this.mTextSize);
                    this.mSelectorWheelPaint.setTextSize(this.mTextSize);
                });
                this._attrBinder.addAttr('textColor', (value) => {
                    this.mSelectorWheelPaint.setColor(this._attrBinder.parseColor(value, this.mSelectorWheelPaint.getColor()));
                });
                this._attrBinder.addAttr('minValue', (value) => {
                    this.setMinValue(this._attrBinder.parseNumber(value, this.mMinValue));
                });
                this._attrBinder.addAttr('maxValue', (value) => {
                    this.setMaxValue(this._attrBinder.parseNumber(value, this.mMaxValue));
                });
                this._attrBinder.addAttr('itemCount', (value) => {
                    this.SELECTOR_WHEEL_ITEM_COUNT = this._attrBinder.parseNumber(value, this.SELECTOR_WHEEL_ITEM_COUNT);
                    this.SELECTOR_MIDDLE_ITEM_INDEX = Math.floor(this.SELECTOR_WHEEL_ITEM_COUNT / 2);
                    this.mSelectorIndices = new Array(this.SELECTOR_WHEEL_ITEM_COUNT);
                });
                this.mTextSize = Math.floor(16 * this.getResources().getDisplayMetrics().density);
                let paint = new Paint();
                paint.setAntiAlias(true);
                paint.setTextAlign(Align.CENTER);
                paint.setTextSize(this.mTextSize);
                paint.setColor(Color.DKGRAY);
                this.mSelectorWheelPaint = paint;
                this.mSelectorIndices = new Array(this.SELECTOR_WHEEL_ITEM_COUNT);
                this.applyDefaultAttributes(R.attr.numberPickerStyle);
                if (this.mMinHeight_ != NumberPicker.SIZE_UNSPECIFIED && this.mMaxHeight != NumberPicker.SIZE_UNSPECIFIED && this.mMinHeight_ > this.mMaxHeight) {
                    throw Error(`new IllegalArgumentException("minHeight > maxHeight")`);
                }
                if (this.mMinWidth_ != NumberPicker.SIZE_UNSPECIFIED && this.mMaxWidth != NumberPicker.SIZE_UNSPECIFIED && this.mMinWidth_ > this.mMaxWidth) {
                    throw Error(`new IllegalArgumentException("minWidth > maxWidth")`);
                }
                this.mComputeMaxWidth = (this.mMaxWidth == NumberPicker.SIZE_UNSPECIFIED);
                this.mPressedStateHelper = new NumberPicker.PressedStateHelper(this);
                this.setWillNotDraw(!this.mHasSelectorWheel);
                let configuration = ViewConfiguration.get();
                this.mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity() / NumberPicker.SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT;
                this.mFlingScroller = new OverScroller(null, true);
                this.mAdjustScroller = new OverScroller(new DecelerateInterpolator(2.5));
                this.updateInputTextView();
            }
            static getTwoDigitFormatter() {
                if (!NumberPicker.sTwoDigitFormatter) {
                    NumberPicker.sTwoDigitFormatter = new NumberPicker.TwoDigitFormatter();
                }
                return NumberPicker.sTwoDigitFormatter;
            }
            onLayout(changed, left, top, right, bottom) {
                if (!this.mHasSelectorWheel) {
                    super.onLayout(changed, left, top, right, bottom);
                    return;
                }
                const msrdWdth = this.getMeasuredWidth();
                const msrdHght = this.getMeasuredHeight();
                if (changed) {
                    this.initializeSelectorWheel();
                    this.initializeFadingEdges();
                    this.mTopSelectionDividerTop = (this.getHeight() - this.mSelectionDividersDistance) / 2 - this.mSelectionDividerHeight;
                    this.mBottomSelectionDividerBottom = this.mTopSelectionDividerTop + 2 * this.mSelectionDividerHeight + this.mSelectionDividersDistance;
                }
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                if (!this.mHasSelectorWheel) {
                    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                    return;
                }
                const newWidthMeasureSpec = this.makeMeasureSpec(widthMeasureSpec, this.mMaxWidth);
                const newHeightMeasureSpec = this.makeMeasureSpec(heightMeasureSpec, this.mMaxHeight);
                super.onMeasure(newWidthMeasureSpec, newHeightMeasureSpec);
                const widthSize = this.resolveSizeAndStateRespectingMinSize(this.mMinWidth_, this.getMeasuredWidth(), widthMeasureSpec);
                const heightSize = this.resolveSizeAndStateRespectingMinSize(this.mMinHeight_, this.getMeasuredHeight(), heightMeasureSpec);
                this.setMeasuredDimension(widthSize, heightSize);
            }
            moveToFinalScrollerPosition(scroller) {
                scroller.forceFinished(true);
                let amountToScroll = scroller.getFinalY() - scroller.getCurrY();
                let futureScrollOffset = (this.mCurrentScrollOffset + amountToScroll) % this.mSelectorElementHeight;
                let overshootAdjustment = this.mInitialScrollOffset - futureScrollOffset;
                if (overshootAdjustment != 0) {
                    if (Math.abs(overshootAdjustment) > this.mSelectorElementHeight / 2) {
                        if (overshootAdjustment > 0) {
                            overshootAdjustment -= this.mSelectorElementHeight;
                        }
                        else {
                            overshootAdjustment += this.mSelectorElementHeight;
                        }
                    }
                    amountToScroll += overshootAdjustment;
                    this.scrollBy(0, amountToScroll);
                    return true;
                }
                return false;
            }
            onInterceptTouchEvent(event) {
                if (!this.mHasSelectorWheel || !this.isEnabled()) {
                    return false;
                }
                const action = event.getActionMasked();
                switch (action) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            this.removeAllCallbacks();
                            this.mLastDownOrMoveEventY = this.mLastDownEventY = event.getY();
                            this.mLastDownEventTime = event.getEventTime();
                            this.mIngonreMoveEvents = false;
                            this.mShowSoftInputOnTap = false;
                            if (this.mLastDownEventY < this.mTopSelectionDividerTop) {
                                if (this.mScrollState == NumberPicker.OnScrollListener.SCROLL_STATE_IDLE) {
                                    this.mPressedStateHelper.buttonPressDelayed(NumberPicker.PressedStateHelper.BUTTON_DECREMENT);
                                }
                            }
                            else if (this.mLastDownEventY > this.mBottomSelectionDividerBottom) {
                                if (this.mScrollState == NumberPicker.OnScrollListener.SCROLL_STATE_IDLE) {
                                    this.mPressedStateHelper.buttonPressDelayed(NumberPicker.PressedStateHelper.BUTTON_INCREMENT);
                                }
                            }
                            this.getParent().requestDisallowInterceptTouchEvent(true);
                            if (!this.mFlingScroller.isFinished()) {
                                this.mFlingScroller.forceFinished(true);
                                this.mAdjustScroller.forceFinished(true);
                                this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_IDLE);
                            }
                            else if (!this.mAdjustScroller.isFinished()) {
                                this.mFlingScroller.forceFinished(true);
                                this.mAdjustScroller.forceFinished(true);
                            }
                            else if (this.mLastDownEventY < this.mTopSelectionDividerTop) {
                                this.hideSoftInput();
                                this.postChangeCurrentByOneFromLongPress(false, ViewConfiguration.getLongPressTimeout());
                            }
                            else if (this.mLastDownEventY > this.mBottomSelectionDividerBottom) {
                                this.hideSoftInput();
                                this.postChangeCurrentByOneFromLongPress(true, ViewConfiguration.getLongPressTimeout());
                            }
                            else {
                                this.mShowSoftInputOnTap = true;
                                this.postBeginSoftInputOnLongPressCommand();
                            }
                            return true;
                        }
                }
                return false;
            }
            onTouchEvent(event) {
                if (!this.isEnabled() || !this.mHasSelectorWheel) {
                    return false;
                }
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                this.mVelocityTracker.addMovement(event);
                let action = event.getActionMasked();
                switch (action) {
                    case MotionEvent.ACTION_MOVE:
                        {
                            if (this.mIngonreMoveEvents) {
                                break;
                            }
                            let currentMoveY = event.getY();
                            if (this.mScrollState != NumberPicker.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                                let deltaDownY = Math.floor(Math.abs(currentMoveY - this.mLastDownEventY));
                                if (deltaDownY > this.mTouchSlop) {
                                    this.removeAllCallbacks();
                                    this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                                }
                            }
                            else {
                                let deltaMoveY = Math.floor(((currentMoveY - this.mLastDownOrMoveEventY)));
                                this.scrollBy(0, deltaMoveY);
                                this.invalidate();
                            }
                            this.mLastDownOrMoveEventY = currentMoveY;
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        {
                            this.removeBeginSoftInputCommand();
                            this.removeChangeCurrentByOneFromLongPress();
                            this.mPressedStateHelper.cancel();
                            let velocityTracker = this.mVelocityTracker;
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumFlingVelocity);
                            let initialVelocity = Math.floor(velocityTracker.getYVelocity());
                            if (Math.abs(initialVelocity) > this.mMinimumFlingVelocity) {
                                this.fling(initialVelocity);
                                this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_FLING);
                            }
                            else {
                                let eventY = Math.floor(event.getY());
                                let deltaMoveY = Math.floor(Math.abs(eventY - this.mLastDownEventY));
                                let deltaTime = event.getEventTime() - this.mLastDownEventTime;
                                if (deltaMoveY <= this.mTouchSlop && deltaTime < ViewConfiguration.getTapTimeout()) {
                                    if (this.mShowSoftInputOnTap) {
                                        this.mShowSoftInputOnTap = false;
                                        this.showSoftInput();
                                    }
                                    else {
                                        let selectorIndexOffset = (eventY / this.mSelectorElementHeight) - this.SELECTOR_MIDDLE_ITEM_INDEX;
                                        if (selectorIndexOffset > 0) {
                                            this.changeValueByOne(true);
                                            this.mPressedStateHelper.buttonTapped(NumberPicker.PressedStateHelper.BUTTON_INCREMENT);
                                        }
                                        else if (selectorIndexOffset < 0) {
                                            this.changeValueByOne(false);
                                            this.mPressedStateHelper.buttonTapped(NumberPicker.PressedStateHelper.BUTTON_DECREMENT);
                                        }
                                    }
                                }
                                else {
                                    this.ensureScrollWheelAdjusted();
                                }
                                this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_IDLE);
                            }
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                        break;
                }
                return true;
            }
            dispatchTouchEvent(event) {
                const action = event.getActionMasked();
                switch (action) {
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        this.removeAllCallbacks();
                        break;
                }
                return super.dispatchTouchEvent(event);
            }
            dispatchKeyEvent(event) {
                const keyCode = event.getKeyCode();
                switch (keyCode) {
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_ENTER:
                        this.removeAllCallbacks();
                        break;
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        if (!this.mHasSelectorWheel) {
                            break;
                        }
                        switch (event.getAction()) {
                            case KeyEvent.ACTION_DOWN:
                                if (this.mWrapSelectorWheel || (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) ? this.getValue() < this.getMaxValue() : this.getValue() > this.getMinValue()) {
                                    this.requestFocus();
                                    this.mLastHandledDownDpadKeyCode = keyCode;
                                    this.removeAllCallbacks();
                                    if (this.mFlingScroller.isFinished()) {
                                        this.changeValueByOne(keyCode == KeyEvent.KEYCODE_DPAD_DOWN);
                                    }
                                    return true;
                                }
                                break;
                            case KeyEvent.ACTION_UP:
                                if (this.mLastHandledDownDpadKeyCode == keyCode) {
                                    this.mLastHandledDownDpadKeyCode = -1;
                                    return true;
                                }
                                break;
                        }
                }
                return super.dispatchKeyEvent(event);
            }
            computeScroll() {
                let scroller = this.mFlingScroller;
                if (scroller.isFinished()) {
                    scroller = this.mAdjustScroller;
                    if (scroller.isFinished()) {
                        return;
                    }
                }
                scroller.computeScrollOffset();
                let currentScrollerY = scroller.getCurrY();
                if (this.mPreviousScrollerY == 0) {
                    this.mPreviousScrollerY = scroller.getStartY();
                }
                this.scrollBy(0, currentScrollerY - this.mPreviousScrollerY);
                this.mPreviousScrollerY = currentScrollerY;
                if (scroller.isFinished()) {
                    this.onScrollerFinished(scroller);
                }
                else {
                    this.invalidate();
                }
            }
            setEnabled(enabled) {
                super.setEnabled(enabled);
                if (!this.mHasSelectorWheel) {
                }
                if (!this.mHasSelectorWheel) {
                }
            }
            scrollBy(x, y) {
                let selectorIndices = this.mSelectorIndices;
                if (!this.mWrapSelectorWheel && y > 0 && selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX] <= this.mMinValue) {
                    this.mCurrentScrollOffset = this.mInitialScrollOffset;
                    return;
                }
                if (!this.mWrapSelectorWheel && y < 0 && selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX] >= this.mMaxValue) {
                    this.mCurrentScrollOffset = this.mInitialScrollOffset;
                    return;
                }
                this.mCurrentScrollOffset += y;
                while (this.mCurrentScrollOffset - this.mInitialScrollOffset > this.mSelectorTextGapHeight) {
                    this.mCurrentScrollOffset -= this.mSelectorElementHeight;
                    this.decrementSelectorIndices(selectorIndices);
                    this.setValueInternal(selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX], true);
                    if (!this.mWrapSelectorWheel && selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX] <= this.mMinValue) {
                        this.mCurrentScrollOffset = this.mInitialScrollOffset;
                    }
                }
                while (this.mCurrentScrollOffset - this.mInitialScrollOffset < -this.mSelectorTextGapHeight) {
                    this.mCurrentScrollOffset += this.mSelectorElementHeight;
                    this.incrementSelectorIndices(selectorIndices);
                    this.setValueInternal(selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX], true);
                    if (!this.mWrapSelectorWheel && selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX] >= this.mMaxValue) {
                        this.mCurrentScrollOffset = this.mInitialScrollOffset;
                    }
                }
            }
            computeVerticalScrollOffset() {
                return this.mCurrentScrollOffset;
            }
            computeVerticalScrollRange() {
                return (this.mMaxValue - this.mMinValue + 1) * this.mSelectorElementHeight;
            }
            computeVerticalScrollExtent() {
                return this.getHeight();
            }
            getSolidColor() {
                return this.mSolidColor;
            }
            setOnValueChangedListener(onValueChangedListener) {
                this.mOnValueChangeListener = onValueChangedListener;
            }
            setOnScrollListener(onScrollListener) {
                this.mOnScrollListener = onScrollListener;
            }
            setFormatter(formatter) {
                if (formatter == this.mFormatter) {
                    return;
                }
                this.mFormatter = formatter;
                this.initializeSelectorWheelIndices();
                this.updateInputTextView();
            }
            setValue(value) {
                this.setValueInternal(value, false);
            }
            showSoftInput() {
            }
            hideSoftInput() {
            }
            tryComputeMaxWidth() {
                if (!this.mComputeMaxWidth) {
                    return;
                }
                let maxTextWidth = 0;
                if (this.mDisplayedValues == null) {
                    let maxDigitWidth = 0;
                    for (let i = 0; i <= 9; i++) {
                        const digitWidth = this.mSelectorWheelPaint.measureText(NumberPicker.formatNumberWithLocale(i));
                        if (digitWidth > maxDigitWidth) {
                            maxDigitWidth = digitWidth;
                        }
                    }
                    let numberOfDigits = 0;
                    let current = this.mMaxValue;
                    while (current > 0) {
                        numberOfDigits++;
                        current = current / 10;
                    }
                    maxTextWidth = Math.floor((numberOfDigits * maxDigitWidth));
                }
                else {
                    const valueCount = this.mDisplayedValues.length;
                    for (let i = 0; i < valueCount; i++) {
                        const textWidth = this.mSelectorWheelPaint.measureText(this.mDisplayedValues[i]);
                        if (textWidth > maxTextWidth) {
                            maxTextWidth = Math.floor(textWidth);
                        }
                    }
                }
                if (this.mMaxWidth != maxTextWidth) {
                    if (maxTextWidth > this.mMinWidth_) {
                        this.mMaxWidth = maxTextWidth;
                    }
                    else {
                        this.mMaxWidth = this.mMinWidth_;
                    }
                    this.invalidate();
                }
            }
            getWrapSelectorWheel() {
                return this.mWrapSelectorWheel;
            }
            setWrapSelectorWheel(wrapSelectorWheel) {
                const wrappingAllowed = (this.mMaxValue - this.mMinValue) >= this.mSelectorIndices.length;
                if ((!wrapSelectorWheel || wrappingAllowed) && wrapSelectorWheel != this.mWrapSelectorWheel) {
                    this.mWrapSelectorWheel = wrapSelectorWheel;
                }
            }
            setOnLongPressUpdateInterval(intervalMillis) {
                this.mLongPressUpdateInterval = intervalMillis;
            }
            getValue() {
                return this.mValue;
            }
            getMinValue() {
                return this.mMinValue;
            }
            setMinValue(minValue) {
                if (this.mMinValue == minValue) {
                    return;
                }
                if (minValue < 0) {
                    throw Error(`new IllegalArgumentException("minValue must be >= 0")`);
                }
                this.mMinValue = minValue;
                if (this.mMinValue > this.mValue) {
                    this.mValue = this.mMinValue;
                }
                let wrapSelectorWheel = this.mMaxValue - this.mMinValue > this.mSelectorIndices.length;
                this.setWrapSelectorWheel(wrapSelectorWheel);
                this.initializeSelectorWheelIndices();
                this.updateInputTextView();
                this.tryComputeMaxWidth();
                this.invalidate();
            }
            getMaxValue() {
                return this.mMaxValue;
            }
            setMaxValue(maxValue) {
                if (this.mMaxValue == maxValue) {
                    return;
                }
                if (maxValue < 0) {
                    throw Error(`new IllegalArgumentException("maxValue must be >= 0")`);
                }
                this.mMaxValue = maxValue;
                if (this.mMaxValue < this.mValue) {
                    this.mValue = this.mMaxValue;
                }
                let wrapSelectorWheel = this.mMaxValue - this.mMinValue > this.mSelectorIndices.length;
                this.setWrapSelectorWheel(wrapSelectorWheel);
                this.initializeSelectorWheelIndices();
                this.updateInputTextView();
                this.tryComputeMaxWidth();
                this.invalidate();
            }
            getDisplayedValues() {
                return this.mDisplayedValues;
            }
            setDisplayedValues(displayedValues) {
                if (this.mDisplayedValues == displayedValues) {
                    return;
                }
                this.mDisplayedValues = displayedValues;
                if (this.mDisplayedValues != null) {
                }
                else {
                }
                this.updateInputTextView();
                this.initializeSelectorWheelIndices();
                this.tryComputeMaxWidth();
            }
            getTopFadingEdgeStrength() {
                return NumberPicker.TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
            }
            getBottomFadingEdgeStrength() {
                return NumberPicker.TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.removeAllCallbacks();
            }
            onDraw(canvas) {
                if (!this.mHasSelectorWheel) {
                    super.onDraw(canvas);
                    return;
                }
                let x = (this.mRight - this.mLeft) / 2;
                let y = this.mCurrentScrollOffset;
                if (this.mVirtualButtonPressedDrawable != null && this.mScrollState == NumberPicker.OnScrollListener.SCROLL_STATE_IDLE) {
                    if (this.mDecrementVirtualButtonPressed) {
                        this.mVirtualButtonPressedDrawable.setState(NumberPicker.PRESSED_STATE_SET);
                        this.mVirtualButtonPressedDrawable.setBounds(0, 0, this.mRight, this.mTopSelectionDividerTop);
                        this.mVirtualButtonPressedDrawable.draw(canvas);
                    }
                    if (this.mIncrementVirtualButtonPressed) {
                        this.mVirtualButtonPressedDrawable.setState(NumberPicker.PRESSED_STATE_SET);
                        this.mVirtualButtonPressedDrawable.setBounds(0, this.mBottomSelectionDividerBottom, this.mRight, this.mBottom);
                        this.mVirtualButtonPressedDrawable.draw(canvas);
                    }
                }
                let selectorIndices = this.mSelectorIndices;
                for (let i = 0; i < selectorIndices.length; i++) {
                    let selectorIndex = selectorIndices[i];
                    let scrollSelectorValue = this.mSelectorIndexToStringCache.get(selectorIndex);
                    canvas.drawText(scrollSelectorValue, x, y, this.mSelectorWheelPaint);
                    y += this.mSelectorElementHeight;
                }
                if (this.mSelectionDivider != null) {
                    let topOfTopDivider = this.mTopSelectionDividerTop;
                    let bottomOfTopDivider = topOfTopDivider + this.mSelectionDividerHeight;
                    this.mSelectionDivider.setBounds(0, topOfTopDivider, this.mRight, bottomOfTopDivider);
                    this.mSelectionDivider.draw(canvas);
                    let bottomOfBottomDivider = this.mBottomSelectionDividerBottom;
                    let topOfBottomDivider = bottomOfBottomDivider - this.mSelectionDividerHeight;
                    this.mSelectionDivider.setBounds(0, topOfBottomDivider, this.mRight, bottomOfBottomDivider);
                    this.mSelectionDivider.draw(canvas);
                }
            }
            makeMeasureSpec(measureSpec, maxSize) {
                if (maxSize == NumberPicker.SIZE_UNSPECIFIED) {
                    return measureSpec;
                }
                const size = NumberPicker.MeasureSpec.getSize(measureSpec);
                const mode = NumberPicker.MeasureSpec.getMode(measureSpec);
                switch (mode) {
                    case NumberPicker.MeasureSpec.EXACTLY:
                        return measureSpec;
                    case NumberPicker.MeasureSpec.AT_MOST:
                        return NumberPicker.MeasureSpec.makeMeasureSpec(Math.min(size, maxSize), NumberPicker.MeasureSpec.EXACTLY);
                    case NumberPicker.MeasureSpec.UNSPECIFIED:
                        return NumberPicker.MeasureSpec.makeMeasureSpec(maxSize, NumberPicker.MeasureSpec.EXACTLY);
                    default:
                        throw Error(`new IllegalArgumentException("Unknown measure mode: " + mode)`);
                }
            }
            resolveSizeAndStateRespectingMinSize(minSize, measuredSize, measureSpec) {
                if (minSize != NumberPicker.SIZE_UNSPECIFIED) {
                    const desiredWidth = Math.max(minSize, measuredSize);
                    return NumberPicker.resolveSizeAndState(desiredWidth, measureSpec, 0);
                }
                else {
                    return measuredSize;
                }
            }
            initializeSelectorWheelIndices() {
                this.mSelectorIndexToStringCache.clear();
                let selectorIndices = this.mSelectorIndices;
                let current = this.getValue();
                for (let i = 0; i < this.mSelectorIndices.length; i++) {
                    let selectorIndex = Math.floor(current + (i - this.SELECTOR_MIDDLE_ITEM_INDEX));
                    if (this.mWrapSelectorWheel) {
                        selectorIndex = this.getWrappedSelectorIndex(selectorIndex);
                    }
                    selectorIndices[i] = selectorIndex;
                    this.ensureCachedScrollSelectorValue(selectorIndices[i]);
                }
            }
            setValueInternal(current, notifyChange) {
                if (this.mValue == current) {
                    return;
                }
                if (this.mWrapSelectorWheel) {
                    current = this.getWrappedSelectorIndex(current);
                }
                else {
                    current = Math.max(current, this.mMinValue);
                    current = Math.min(current, this.mMaxValue);
                }
                let previous = this.mValue;
                this.mValue = current;
                this.updateInputTextView();
                if (notifyChange) {
                    this.notifyChange(previous, current);
                }
                this.initializeSelectorWheelIndices();
                this.invalidate();
            }
            changeValueByOne(increment) {
                if (this.mHasSelectorWheel) {
                    if (!this.moveToFinalScrollerPosition(this.mFlingScroller)) {
                        this.moveToFinalScrollerPosition(this.mAdjustScroller);
                    }
                    this.mPreviousScrollerY = 0;
                    if (increment) {
                        this.mFlingScroller.startScroll(0, 0, 0, -this.mSelectorElementHeight, NumberPicker.SNAP_SCROLL_DURATION);
                    }
                    else {
                        this.mFlingScroller.startScroll(0, 0, 0, this.mSelectorElementHeight, NumberPicker.SNAP_SCROLL_DURATION);
                    }
                    this.invalidate();
                }
                else {
                    if (increment) {
                        this.setValueInternal(this.mValue + 1, true);
                    }
                    else {
                        this.setValueInternal(this.mValue - 1, true);
                    }
                }
            }
            initializeSelectorWheel() {
                this.initializeSelectorWheelIndices();
                let selectorIndices = this.mSelectorIndices;
                let totalTextHeight = selectorIndices.length * this.mTextSize;
                let totalTextGapHeight = (this.mBottom - this.mTop) - totalTextHeight;
                let textGapCount = selectorIndices.length;
                this.mSelectorTextGapHeight = Math.floor((totalTextGapHeight / textGapCount + 0.5));
                this.mSelectorElementHeight = this.mTextSize + this.mSelectorTextGapHeight;
                let editTextTextPosition = this.getHeight() / 2 + this.mTextSize / 2;
                this.mInitialScrollOffset = editTextTextPosition - (this.mSelectorElementHeight * this.SELECTOR_MIDDLE_ITEM_INDEX);
                this.mCurrentScrollOffset = this.mInitialScrollOffset;
                this.updateInputTextView();
            }
            initializeFadingEdges() {
                this.setVerticalFadingEdgeEnabled(true);
                this.setFadingEdgeLength((this.mBottom - this.mTop - this.mTextSize) / 2);
            }
            onScrollerFinished(scroller) {
                if (scroller == this.mFlingScroller) {
                    if (!this.ensureScrollWheelAdjusted()) {
                        this.updateInputTextView();
                    }
                    this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_IDLE);
                }
                else {
                    if (this.mScrollState != NumberPicker.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                        this.updateInputTextView();
                    }
                }
            }
            onScrollStateChange(scrollState) {
                if (this.mScrollState == scrollState) {
                    return;
                }
                this.mScrollState = scrollState;
                if (this.mOnScrollListener != null) {
                    this.mOnScrollListener.onScrollStateChange(this, scrollState);
                }
            }
            fling(velocityY) {
                this.mPreviousScrollerY = 0;
                if (velocityY > 0) {
                    this.mFlingScroller.fling(0, 0, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
                }
                else {
                    this.mFlingScroller.fling(0, Integer.MAX_VALUE, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
                }
                this.invalidate();
            }
            getWrappedSelectorIndex(selectorIndex) {
                if (selectorIndex > this.mMaxValue) {
                    return this.mMinValue + (selectorIndex - this.mMaxValue) % (this.mMaxValue - this.mMinValue) - 1;
                }
                else if (selectorIndex < this.mMinValue) {
                    return this.mMaxValue - (this.mMinValue - selectorIndex) % (this.mMaxValue - this.mMinValue) + 1;
                }
                return selectorIndex;
            }
            incrementSelectorIndices(selectorIndices) {
                for (let i = 0; i < selectorIndices.length - 1; i++) {
                    selectorIndices[i] = selectorIndices[i + 1];
                }
                let nextScrollSelectorIndex = selectorIndices[selectorIndices.length - 2] + 1;
                if (this.mWrapSelectorWheel && nextScrollSelectorIndex > this.mMaxValue) {
                    nextScrollSelectorIndex = this.mMinValue;
                }
                selectorIndices[selectorIndices.length - 1] = nextScrollSelectorIndex;
                this.ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
            }
            decrementSelectorIndices(selectorIndices) {
                for (let i = selectorIndices.length - 1; i > 0; i--) {
                    selectorIndices[i] = selectorIndices[i - 1];
                }
                let nextScrollSelectorIndex = selectorIndices[1] - 1;
                if (this.mWrapSelectorWheel && nextScrollSelectorIndex < this.mMinValue) {
                    nextScrollSelectorIndex = this.mMaxValue;
                }
                selectorIndices[0] = nextScrollSelectorIndex;
                this.ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
            }
            ensureCachedScrollSelectorValue(selectorIndex) {
                let cache = this.mSelectorIndexToStringCache;
                let scrollSelectorValue = cache.get(selectorIndex);
                if (scrollSelectorValue != null) {
                    return;
                }
                if (selectorIndex < this.mMinValue || selectorIndex > this.mMaxValue) {
                    scrollSelectorValue = "";
                }
                else {
                    if (this.mDisplayedValues != null) {
                        let displayedValueIndex = selectorIndex - this.mMinValue;
                        scrollSelectorValue = this.mDisplayedValues[displayedValueIndex];
                    }
                    else {
                        scrollSelectorValue = this.formatNumber(selectorIndex);
                    }
                }
                cache.put(selectorIndex, scrollSelectorValue);
            }
            formatNumber(value) {
                return (this.mFormatter != null) ? this.mFormatter.format(value) : NumberPicker.formatNumberWithLocale(value);
            }
            validateInputTextView(v) {
            }
            updateInputTextView() {
                return false;
            }
            notifyChange(previous, current) {
                if (this.mOnValueChangeListener != null) {
                    this.mOnValueChangeListener.onValueChange(this, previous, this.mValue);
                }
            }
            postChangeCurrentByOneFromLongPress(increment, delayMillis) {
                if (this.mChangeCurrentByOneFromLongPressCommand == null) {
                    this.mChangeCurrentByOneFromLongPressCommand = new NumberPicker.ChangeCurrentByOneFromLongPressCommand(this);
                }
                else {
                    this.removeCallbacks(this.mChangeCurrentByOneFromLongPressCommand);
                }
                this.mChangeCurrentByOneFromLongPressCommand.setStep(increment);
                this.postDelayed(this.mChangeCurrentByOneFromLongPressCommand, delayMillis);
            }
            removeChangeCurrentByOneFromLongPress() {
                if (this.mChangeCurrentByOneFromLongPressCommand != null) {
                    this.removeCallbacks(this.mChangeCurrentByOneFromLongPressCommand);
                }
            }
            postBeginSoftInputOnLongPressCommand() {
                if (this.mBeginSoftInputOnLongPressCommand == null) {
                    this.mBeginSoftInputOnLongPressCommand = new NumberPicker.BeginSoftInputOnLongPressCommand(this);
                }
                else {
                    this.removeCallbacks(this.mBeginSoftInputOnLongPressCommand);
                }
                this.postDelayed(this.mBeginSoftInputOnLongPressCommand, ViewConfiguration.getLongPressTimeout());
            }
            removeBeginSoftInputCommand() {
                if (this.mBeginSoftInputOnLongPressCommand != null) {
                    this.removeCallbacks(this.mBeginSoftInputOnLongPressCommand);
                }
            }
            removeAllCallbacks() {
                if (this.mChangeCurrentByOneFromLongPressCommand != null) {
                    this.removeCallbacks(this.mChangeCurrentByOneFromLongPressCommand);
                }
                if (this.mSetSelectionCommand != null) {
                    this.removeCallbacks(this.mSetSelectionCommand);
                }
                if (this.mBeginSoftInputOnLongPressCommand != null) {
                    this.removeCallbacks(this.mBeginSoftInputOnLongPressCommand);
                }
                this.mPressedStateHelper.cancel();
            }
            getSelectedPos(value) {
                if (this.mDisplayedValues == null) {
                    try {
                        return Integer.parseInt(value);
                    }
                    catch (e) {
                    }
                }
                else {
                    for (let i = 0; i < this.mDisplayedValues.length; i++) {
                        value = value.toLowerCase();
                        if (this.mDisplayedValues[i].toLowerCase().startsWith(value)) {
                            return this.mMinValue + i;
                        }
                    }
                    try {
                        return Integer.parseInt(value);
                    }
                    catch (e) {
                    }
                }
                return this.mMinValue;
            }
            postSetSelectionCommand(selectionStart, selectionEnd) {
                if (this.mSetSelectionCommand == null) {
                    this.mSetSelectionCommand = new NumberPicker.SetSelectionCommand(this);
                }
                else {
                    this.removeCallbacks(this.mSetSelectionCommand);
                }
                this.mSetSelectionCommand.mSelectionStart = selectionStart;
                this.mSetSelectionCommand.mSelectionEnd = selectionEnd;
                this.post(this.mSetSelectionCommand);
            }
            ensureScrollWheelAdjusted() {
                let deltaY = this.mInitialScrollOffset - this.mCurrentScrollOffset;
                if (deltaY != 0) {
                    this.mPreviousScrollerY = 0;
                    if (Math.abs(deltaY) > this.mSelectorElementHeight / 2) {
                        deltaY += (deltaY > 0) ? -this.mSelectorElementHeight : this.mSelectorElementHeight;
                    }
                    this.mAdjustScroller.startScroll(0, 0, 0, deltaY, NumberPicker.SELECTOR_ADJUSTMENT_DURATION_MILLIS);
                    this.invalidate();
                    return true;
                }
                return false;
            }
            static formatNumberWithLocale(value) {
                return value + '';
            }
        }
        NumberPicker.DEFAULT_LONG_PRESS_UPDATE_INTERVAL = 300;
        NumberPicker.SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT = 8;
        NumberPicker.SELECTOR_ADJUSTMENT_DURATION_MILLIS = 800;
        NumberPicker.SNAP_SCROLL_DURATION = 300;
        NumberPicker.TOP_AND_BOTTOM_FADING_EDGE_STRENGTH = 0.9;
        NumberPicker.UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT = 2;
        NumberPicker.UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE = 48;
        NumberPicker.SIZE_UNSPECIFIED = -1;
        widget.NumberPicker = NumberPicker;
        (function (NumberPicker) {
            class TwoDigitFormatter {
                format(value) {
                    let s = value + '';
                    if (s.length === 1)
                        s = '0' + s;
                    return s;
                }
            }
            NumberPicker.TwoDigitFormatter = TwoDigitFormatter;
            var OnScrollListener;
            (function (OnScrollListener) {
                OnScrollListener.SCROLL_STATE_IDLE = 0;
                OnScrollListener.SCROLL_STATE_TOUCH_SCROLL = 1;
                OnScrollListener.SCROLL_STATE_FLING = 2;
            })(OnScrollListener = NumberPicker.OnScrollListener || (NumberPicker.OnScrollListener = {}));
            class PressedStateHelper {
                constructor(arg) {
                    this.MODE_PRESS = 1;
                    this.MODE_TAPPED = 2;
                    this.mManagedButton = 0;
                    this.mMode = 0;
                    this._NumberPicker_this = arg;
                }
                cancel() {
                    this.mMode = 0;
                    this.mManagedButton = 0;
                    this._NumberPicker_this.removeCallbacks(this);
                    if (this._NumberPicker_this.mIncrementVirtualButtonPressed) {
                        this._NumberPicker_this.mIncrementVirtualButtonPressed = false;
                        this._NumberPicker_this.invalidate(0, this._NumberPicker_this.mBottomSelectionDividerBottom, this._NumberPicker_this.mRight, this._NumberPicker_this.mBottom);
                    }
                    if (this._NumberPicker_this.mDecrementVirtualButtonPressed) {
                        this._NumberPicker_this.mDecrementVirtualButtonPressed = false;
                        this._NumberPicker_this.invalidate(0, 0, this._NumberPicker_this.mRight, this._NumberPicker_this.mTopSelectionDividerTop);
                    }
                }
                buttonPressDelayed(button) {
                    this.cancel();
                    this.mMode = this.MODE_PRESS;
                    this.mManagedButton = button;
                    this._NumberPicker_this.postDelayed(this, ViewConfiguration.getTapTimeout());
                }
                buttonTapped(button) {
                    this.cancel();
                    this.mMode = this.MODE_TAPPED;
                    this.mManagedButton = button;
                    this._NumberPicker_this.post(this);
                }
                run() {
                    switch (this.mMode) {
                        case this.MODE_PRESS:
                            {
                                switch (this.mManagedButton) {
                                    case PressedStateHelper.BUTTON_INCREMENT:
                                        {
                                            this._NumberPicker_this.mIncrementVirtualButtonPressed = true;
                                            this._NumberPicker_this.invalidate(0, this._NumberPicker_this.mBottomSelectionDividerBottom, this._NumberPicker_this.mRight, this._NumberPicker_this.mBottom);
                                        }
                                        break;
                                    case PressedStateHelper.BUTTON_DECREMENT:
                                        {
                                            this._NumberPicker_this.mDecrementVirtualButtonPressed = true;
                                            this._NumberPicker_this.invalidate(0, 0, this._NumberPicker_this.mRight, this._NumberPicker_this.mTopSelectionDividerTop);
                                        }
                                }
                            }
                            break;
                        case this.MODE_TAPPED:
                            {
                                switch (this.mManagedButton) {
                                    case PressedStateHelper.BUTTON_INCREMENT:
                                        {
                                            if (!this._NumberPicker_this.mIncrementVirtualButtonPressed) {
                                                this._NumberPicker_this.postDelayed(this, ViewConfiguration.getPressedStateDuration());
                                            }
                                            this._NumberPicker_this.mIncrementVirtualButtonPressed = !this._NumberPicker_this.mIncrementVirtualButtonPressed;
                                            this._NumberPicker_this.invalidate(0, this._NumberPicker_this.mBottomSelectionDividerBottom, this._NumberPicker_this.mRight, this._NumberPicker_this.mBottom);
                                        }
                                        break;
                                    case PressedStateHelper.BUTTON_DECREMENT:
                                        {
                                            if (!this._NumberPicker_this.mDecrementVirtualButtonPressed) {
                                                this._NumberPicker_this.postDelayed(this, ViewConfiguration.getPressedStateDuration());
                                            }
                                            this._NumberPicker_this.mDecrementVirtualButtonPressed = !this._NumberPicker_this.mDecrementVirtualButtonPressed;
                                            this._NumberPicker_this.invalidate(0, 0, this._NumberPicker_this.mRight, this._NumberPicker_this.mTopSelectionDividerTop);
                                        }
                                }
                            }
                            break;
                    }
                }
            }
            PressedStateHelper.BUTTON_INCREMENT = 1;
            PressedStateHelper.BUTTON_DECREMENT = 2;
            NumberPicker.PressedStateHelper = PressedStateHelper;
            class SetSelectionCommand {
                constructor(arg) {
                    this.mSelectionStart = 0;
                    this.mSelectionEnd = 0;
                    this._NumberPicker_this = arg;
                }
                run() {
                }
            }
            NumberPicker.SetSelectionCommand = SetSelectionCommand;
            class ChangeCurrentByOneFromLongPressCommand {
                constructor(arg) {
                    this._NumberPicker_this = arg;
                }
                setStep(increment) {
                    this.mIncrement = increment;
                }
                run() {
                    this._NumberPicker_this.changeValueByOne(this.mIncrement);
                    this._NumberPicker_this.postDelayed(this, this._NumberPicker_this.mLongPressUpdateInterval);
                }
            }
            NumberPicker.ChangeCurrentByOneFromLongPressCommand = ChangeCurrentByOneFromLongPressCommand;
            class BeginSoftInputOnLongPressCommand {
                constructor(arg) {
                    this._NumberPicker_this = arg;
                }
                run() {
                    this._NumberPicker_this.showSoftInput();
                    this._NumberPicker_this.mIngonreMoveEvents = true;
                }
            }
            NumberPicker.BeginSoftInputOnLongPressCommand = BeginSoftInputOnLongPressCommand;
        })(NumberPicker = widget.NumberPicker || (widget.NumberPicker = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/content/res/Resources.ts"/>
///<reference path="../../../android/view/Gravity.ts"/>
///<reference path="../../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_6) {
            var Rect = android.graphics.Rect;
            var Gravity = android.view.Gravity;
            var Drawable = android.graphics.drawable.Drawable;
            class ClipDrawable extends Drawable {
                constructor(...args) {
                    super();
                    this.mTmpRect = new Rect();
                    if (args.length <= 1) {
                        this.mClipState = new ClipDrawable.ClipState(args[0], this);
                    }
                    else {
                        this.mClipState = new ClipDrawable.ClipState(null, this);
                        let drawable = args[0];
                        let gravity = args[1];
                        let orientation = args[2];
                        this.mClipState.mDrawable = drawable;
                        this.mClipState.mGravity = gravity;
                        this.mClipState.mOrientation = orientation;
                        if (drawable != null) {
                            drawable.setCallback(this);
                        }
                    }
                }
                drawableSizeChange(who) {
                    const callback = this.getCallback();
                    if (callback != null && callback.drawableSizeChange) {
                        callback.drawableSizeChange(this);
                    }
                }
                invalidateDrawable(who) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                getPadding(padding) {
                    return this.mClipState.mDrawable.getPadding(padding);
                }
                setVisible(visible, restart) {
                    this.mClipState.mDrawable.setVisible(visible, restart);
                    return super.setVisible(visible, restart);
                }
                setAlpha(alpha) {
                    this.mClipState.mDrawable.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mClipState.mDrawable.getAlpha();
                }
                getOpacity() {
                    return this.mClipState.mDrawable.getOpacity();
                }
                isStateful() {
                    return this.mClipState.mDrawable.isStateful();
                }
                onStateChange(state) {
                    return this.mClipState.mDrawable.setState(state);
                }
                onLevelChange(level) {
                    this.mClipState.mDrawable.setLevel(level);
                    this.invalidateSelf();
                    return true;
                }
                onBoundsChange(bounds) {
                    this.mClipState.mDrawable.setBounds(bounds);
                }
                draw(canvas) {
                    if (this.mClipState.mDrawable.getLevel() == 0) {
                        return;
                    }
                    const r = this.mTmpRect;
                    const bounds = this.getBounds();
                    let level = this.getLevel();
                    let w = bounds.width();
                    const iw = 0;
                    if ((this.mClipState.mOrientation & ClipDrawable.HORIZONTAL) != 0) {
                        w -= (w - iw) * (10000 - level) / 10000;
                    }
                    let h = bounds.height();
                    const ih = 0;
                    if ((this.mClipState.mOrientation & ClipDrawable.VERTICAL) != 0) {
                        h -= (h - ih) * (10000 - level) / 10000;
                    }
                    Gravity.apply(this.mClipState.mGravity, w, h, bounds, r);
                    if (w > 0 && h > 0) {
                        canvas.save();
                        canvas.clipRect(r);
                        this.mClipState.mDrawable.draw(canvas);
                        canvas.restore();
                    }
                }
                getIntrinsicWidth() {
                    return this.mClipState.mDrawable.getIntrinsicWidth();
                }
                getIntrinsicHeight() {
                    return this.mClipState.mDrawable.getIntrinsicHeight();
                }
                getConstantState() {
                    if (this.mClipState.canConstantState()) {
                        return this.mClipState;
                    }
                    return null;
                }
            }
            ClipDrawable.HORIZONTAL = 1;
            ClipDrawable.VERTICAL = 2;
            drawable_6.ClipDrawable = ClipDrawable;
            (function (ClipDrawable) {
                class ClipState {
                    constructor(orig, owner) {
                        this.mOrientation = 0;
                        this.mGravity = 0;
                        if (orig != null) {
                            this.mDrawable = orig.mDrawable.getConstantState().newDrawable();
                            this.mDrawable.setCallback(owner);
                            this.mOrientation = orig.mOrientation;
                            this.mGravity = orig.mGravity;
                            this.mCheckedConstantState = this.mCanConstantState = true;
                        }
                    }
                    newDrawable() {
                        return new ClipDrawable(this);
                    }
                    canConstantState() {
                        if (!this.mCheckedConstantState) {
                            this.mCanConstantState = this.mDrawable.getConstantState() != null;
                            this.mCheckedConstantState = true;
                        }
                        return this.mCanConstantState;
                    }
                }
                ClipDrawable.ClipState = ClipState;
            })(ClipDrawable = drawable_6.ClipDrawable || (drawable_6.ClipDrawable = {}));
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Animatable.ts"/>
///<reference path="../../android/graphics/drawable/AnimationDrawable.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/graphics/drawable/LayerDrawable.ts"/>
///<reference path="../../android/graphics/drawable/StateListDrawable.ts"/>
///<reference path="../../android/graphics/drawable/ClipDrawable.ts"/>
///<reference path="../../android/util/Pools.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/animation/AlphaAnimation.ts"/>
///<reference path="../../android/view/animation/Animation.ts"/>
///<reference path="../../android/view/animation/AnimationUtils.ts"/>
///<reference path="../../android/view/animation/Interpolator.ts"/>
///<reference path="../../android/view/animation/LinearInterpolator.ts"/>
///<reference path="../../android/view/animation/Transformation.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/R/id.ts"/>
///<reference path="../../androidui/image/NetDrawable.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Animatable = android.graphics.drawable.Animatable;
        var AnimationDrawable = android.graphics.drawable.AnimationDrawable;
        var LayerDrawable = android.graphics.drawable.LayerDrawable;
        var StateListDrawable = android.graphics.drawable.StateListDrawable;
        var ClipDrawable = android.graphics.drawable.ClipDrawable;
        var SynchronizedPool = android.util.Pools.SynchronizedPool;
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var AlphaAnimation = android.view.animation.AlphaAnimation;
        var Animation = android.view.animation.Animation;
        var LinearInterpolator = android.view.animation.LinearInterpolator;
        var Transformation = android.view.animation.Transformation;
        var ArrayList = java.util.ArrayList;
        var R = android.R;
        var NetDrawable = androidui.image.NetDrawable;
        class ProgressBar extends View {
            constructor(context, bindElement, defStyle = android.R.attr.progressBarStyle) {
                super(context, bindElement, null);
                this.mMinWidth = 0;
                this.mMaxWidth = 0;
                this.mMinHeight = 0;
                this.mMaxHeight = 0;
                this.mProgress = 0;
                this.mSecondaryProgress = 0;
                this.mMax = 0;
                this.mBehavior = 0;
                this.mDuration = 0;
                this.mMirrorForRtl = false;
                this.mRefreshData = new ArrayList();
                this.initProgressBar();
                const a = this._attrBinder;
                a.addAttr('progressDrawable', (value) => {
                    let drawable = a.parseDrawable(value);
                    if (drawable != null) {
                        drawable = this.tileify(drawable, false);
                        this.setProgressDrawable(drawable);
                    }
                }, () => {
                    return this.mProgressDrawable;
                });
                a.addAttr('indeterminateDuration', (value) => {
                    this.mDuration = Math.floor(a.parseNumber(value, this.mDuration));
                }, () => {
                    return this.mDuration;
                });
                a.addAttr('minWidth', (value) => {
                    this.mMinWidth = Math.floor(a.parseNumber(value, this.mMinWidth));
                }, () => {
                    return this.mMinWidth;
                });
                a.addAttr('maxWidth', (value) => {
                    this.mMaxWidth = Math.floor(a.parseNumber(value, this.mMaxWidth));
                }, () => {
                    return this.mMaxWidth;
                });
                a.addAttr('minHeight', (value) => {
                    this.mMinHeight = Math.floor(a.parseNumber(value, this.mMinHeight));
                }, () => {
                    return this.mMinHeight;
                });
                a.addAttr('maxHeight', (value) => {
                    this.mMaxHeight = Math.floor(a.parseNumber(value, this.mMaxHeight));
                }, () => {
                    return this.mMaxHeight;
                });
                a.addAttr('indeterminateBehavior', (value) => {
                    if (value + ''.toLowerCase() == 'cycle') {
                        this.mBehavior = Animation.REVERSE;
                    }
                    else {
                        this.mBehavior = Animation.RESTART;
                    }
                });
                a.addAttr('interpolator', (value) => {
                });
                a.addAttr('max', (value) => {
                    this.setMax(a.parseNumber(value, this.mMax));
                }, () => {
                    return this.mMax;
                });
                a.addAttr('progress', (value) => {
                    this.setProgress(a.parseNumber(value, this.mProgress));
                }, () => {
                    return this.mProgress;
                });
                a.addAttr('secondaryProgress', (value) => {
                    this.setSecondaryProgress(a.parseNumber(value, this.mSecondaryProgress));
                }, () => {
                    return this.mSecondaryProgress;
                });
                a.addAttr('indeterminateDrawable', (value) => {
                    let drawable = a.parseDrawable(value);
                    if (drawable != null) {
                        drawable = this.tileifyIndeterminate(drawable);
                        this.setIndeterminateDrawable(drawable);
                    }
                }, () => {
                    return this.mIndeterminateDrawable;
                });
                a.addAttr('indeterminateOnly', (value) => {
                    this.mOnlyIndeterminate = a.parseBoolean(value, this.mOnlyIndeterminate);
                    this.setIndeterminate(this.mOnlyIndeterminate || this.mIndeterminate);
                });
                a.addAttr('indeterminate', (value) => {
                    this.setIndeterminate(this.mOnlyIndeterminate || a.parseBoolean(value, this.mIndeterminate));
                });
                this.mNoInvalidate = true;
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
                this.mNoInvalidate = false;
                this.setIndeterminate(this.mOnlyIndeterminate || this.mIndeterminate);
            }
            tileify(drawable, clip) {
                if (drawable instanceof LayerDrawable) {
                    let background = drawable;
                    const N = background.getNumberOfLayers();
                    let outDrawables = new Array(N);
                    let drawableChange = false;
                    for (let i = 0; i < N; i++) {
                        let id = background.getId(i);
                        let orig = background.getDrawable(i);
                        outDrawables[i] = this.tileify(orig, (id == R.id.progress || id == R.id.secondaryProgress));
                        drawableChange = drawableChange || outDrawables[i] !== orig;
                    }
                    if (!drawableChange)
                        return background;
                    let newBg = new LayerDrawable(outDrawables);
                    for (let i = 0; i < N; i++) {
                        newBg.setId(i, background.getId(i));
                    }
                    return newBg;
                }
                else if (drawable instanceof StateListDrawable) {
                    let _in = drawable;
                    let out = new StateListDrawable();
                    let numStates = _in.getStateCount();
                    for (let i = 0; i < numStates; i++) {
                        out.addState(_in.getStateSet(i), this.tileify(_in.getStateDrawable(i), clip));
                    }
                    return out;
                }
                else if (drawable instanceof NetDrawable) {
                    const netDrawable = drawable;
                    if (this.mSampleTile == null) {
                        this.mSampleTile = netDrawable;
                    }
                    netDrawable.setTileMode(NetDrawable.TileMode.REPEAT, null);
                    return (clip) ? new ClipDrawable(netDrawable, Gravity.LEFT, ClipDrawable.HORIZONTAL) : netDrawable;
                }
                return drawable;
            }
            tileifyIndeterminate(drawable) {
                if (drawable instanceof AnimationDrawable) {
                    let background = drawable;
                    const N = background.getNumberOfFrames();
                    let newBg = new AnimationDrawable();
                    newBg.setOneShot(background.isOneShot());
                    for (let i = 0; i < N; i++) {
                        let frame = this.tileify(background.getFrame(i), true);
                        frame.setLevel(10000);
                        newBg.addFrame(frame, background.getDuration(i));
                    }
                    newBg.setLevel(10000);
                    drawable = newBg;
                }
                return drawable;
            }
            initProgressBar() {
                this.mMax = 100;
                this.mProgress = 0;
                this.mSecondaryProgress = 0;
                this.mIndeterminate = false;
                this.mOnlyIndeterminate = false;
                this.mDuration = 4000;
                this.mBehavior = AlphaAnimation.RESTART;
                this.mMinWidth = 24;
                this.mMaxWidth = 48;
                this.mMinHeight = 24;
                this.mMaxHeight = 48;
            }
            isIndeterminate() {
                return this.mIndeterminate;
            }
            setIndeterminate(indeterminate) {
                if ((!this.mOnlyIndeterminate || !this.mIndeterminate) && indeterminate != this.mIndeterminate) {
                    this.mIndeterminate = indeterminate;
                    if (indeterminate) {
                        this.mCurrentDrawable = this.mIndeterminateDrawable;
                        this.startAnimation();
                    }
                    else {
                        this.mCurrentDrawable = this.mProgressDrawable;
                        this.stopAnimation();
                    }
                }
            }
            getIndeterminateDrawable() {
                return this.mIndeterminateDrawable;
            }
            setIndeterminateDrawable(d) {
                if (d != null) {
                    d.setCallback(this);
                }
                this.mIndeterminateDrawable = d;
                if (this.mIndeterminate) {
                    this.mCurrentDrawable = d;
                    this.postInvalidate();
                }
            }
            getProgressDrawable() {
                return this.mProgressDrawable;
            }
            setProgressDrawable(d) {
                let needUpdate;
                if (this.mProgressDrawable != null && d != this.mProgressDrawable) {
                    this.mProgressDrawable.setCallback(null);
                    needUpdate = true;
                }
                else {
                    needUpdate = false;
                }
                if (d != null) {
                    d.setCallback(this);
                    let drawableHeight = d.getMinimumHeight();
                    if (this.mMaxHeight < drawableHeight) {
                        this.mMaxHeight = drawableHeight;
                        this.requestLayout();
                    }
                }
                this.mProgressDrawable = d;
                if (!this.mIndeterminate) {
                    this.mCurrentDrawable = d;
                    this.postInvalidate();
                }
                if (needUpdate) {
                    this.updateDrawableBounds(this.getWidth(), this.getHeight());
                    this.updateDrawableState();
                    this.doRefreshProgress(R.id.progress, this.mProgress, false, false);
                    this.doRefreshProgress(R.id.secondaryProgress, this.mSecondaryProgress, false, false);
                }
            }
            getCurrentDrawable() {
                return this.mCurrentDrawable;
            }
            verifyDrawable(who) {
                return who == this.mProgressDrawable || who == this.mIndeterminateDrawable || super.verifyDrawable(who);
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mProgressDrawable != null)
                    this.mProgressDrawable.jumpToCurrentState();
                if (this.mIndeterminateDrawable != null)
                    this.mIndeterminateDrawable.jumpToCurrentState();
            }
            postInvalidate() {
                if (!this.mNoInvalidate) {
                    super.postInvalidate();
                }
            }
            doRefreshProgress(id, progress, fromUser, callBackToApp) {
                let scale = this.mMax > 0 ? progress / this.mMax : 0;
                const d = this.mCurrentDrawable;
                if (d != null) {
                    let progressDrawable = null;
                    if (d instanceof LayerDrawable) {
                        progressDrawable = d.findDrawableByLayerId(id);
                    }
                    const level = Math.floor((scale * ProgressBar.MAX_LEVEL));
                    (progressDrawable != null ? progressDrawable : d).setLevel(level);
                }
                else {
                    this.invalidate();
                }
                if (callBackToApp && id == R.id.progress) {
                    this.onProgressRefresh(scale, fromUser);
                }
            }
            onProgressRefresh(scale, fromUser) {
            }
            refreshProgress(id, progress, fromUser) {
                this.doRefreshProgress(id, progress, fromUser, true);
            }
            setProgress(progress, fromUser = false) {
                if (this.mIndeterminate) {
                    return;
                }
                if (progress < 0) {
                    progress = 0;
                }
                if (progress > this.mMax) {
                    progress = this.mMax;
                }
                if (progress != this.mProgress) {
                    this.mProgress = progress;
                    this.refreshProgress(R.id.progress, this.mProgress, fromUser);
                }
            }
            setSecondaryProgress(secondaryProgress) {
                if (this.mIndeterminate) {
                    return;
                }
                if (secondaryProgress < 0) {
                    secondaryProgress = 0;
                }
                if (secondaryProgress > this.mMax) {
                    secondaryProgress = this.mMax;
                }
                if (secondaryProgress != this.mSecondaryProgress) {
                    this.mSecondaryProgress = secondaryProgress;
                    this.refreshProgress(R.id.secondaryProgress, this.mSecondaryProgress, false);
                }
            }
            getProgress() {
                return this.mIndeterminate ? 0 : this.mProgress;
            }
            getSecondaryProgress() {
                return this.mIndeterminate ? 0 : this.mSecondaryProgress;
            }
            getMax() {
                return this.mMax;
            }
            setMax(max) {
                if (max < 0) {
                    max = 0;
                }
                if (max != this.mMax) {
                    this.mMax = max;
                    this.postInvalidate();
                    if (this.mProgress > max) {
                        this.mProgress = max;
                    }
                    this.refreshProgress(R.id.progress, this.mProgress, false);
                }
            }
            incrementProgressBy(diff) {
                this.setProgress(this.mProgress + diff);
            }
            incrementSecondaryProgressBy(diff) {
                this.setSecondaryProgress(this.mSecondaryProgress + diff);
            }
            startAnimation() {
                if (this.getVisibility() != ProgressBar.VISIBLE) {
                    return;
                }
                if (Animatable.isImpl(this.mIndeterminateDrawable)) {
                    this.mShouldStartAnimationDrawable = true;
                    this.mHasAnimation = false;
                }
                else {
                    this.mHasAnimation = true;
                    if (this.mInterpolator == null) {
                        this.mInterpolator = new LinearInterpolator();
                    }
                    if (this.mTransformation == null) {
                        this.mTransformation = new Transformation();
                    }
                    else {
                        this.mTransformation.clear();
                    }
                    if (this.mAnimation == null) {
                        this.mAnimation = new AlphaAnimation(0.0, 1.0);
                    }
                    else {
                        this.mAnimation.reset();
                    }
                    this.mAnimation.setRepeatMode(this.mBehavior);
                    this.mAnimation.setRepeatCount(Animation.INFINITE);
                    this.mAnimation.setDuration(this.mDuration);
                    this.mAnimation.setInterpolator(this.mInterpolator);
                    this.mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
                }
                this.postInvalidate();
            }
            stopAnimation() {
                this.mHasAnimation = false;
                if (Animatable.isImpl(this.mIndeterminateDrawable)) {
                    this.mIndeterminateDrawable.stop();
                    this.mShouldStartAnimationDrawable = false;
                }
                this.postInvalidate();
            }
            setInterpolator(interpolator) {
                this.mInterpolator = interpolator;
            }
            getInterpolator() {
                return this.mInterpolator;
            }
            setVisibility(v) {
                if (this.getVisibility() != v) {
                    super.setVisibility(v);
                    if (this.mIndeterminate) {
                        if (v == ProgressBar.GONE || v == ProgressBar.INVISIBLE) {
                            this.stopAnimation();
                        }
                        else {
                            this.startAnimation();
                        }
                    }
                }
            }
            onVisibilityChanged(changedView, visibility) {
                super.onVisibilityChanged(changedView, visibility);
                if (this.mIndeterminate) {
                    if (visibility == ProgressBar.GONE || visibility == ProgressBar.INVISIBLE) {
                        this.stopAnimation();
                    }
                    else {
                        this.startAnimation();
                    }
                }
            }
            invalidateDrawable(dr) {
                if (!this.mInDrawing) {
                    if (this.verifyDrawable(dr)) {
                        const dirty = dr.getBounds();
                        const scrollX = this.mScrollX + this.mPaddingLeft;
                        const scrollY = this.mScrollY + this.mPaddingTop;
                        this.invalidate(dirty.left + scrollX, dirty.top + scrollY, dirty.right + scrollX, dirty.bottom + scrollY);
                    }
                    else {
                        super.invalidateDrawable(dr);
                    }
                }
            }
            onSizeChanged(w, h, oldw, oldh) {
                this.updateDrawableBounds(w, h);
            }
            updateDrawableBounds(w, h) {
                w -= this.mPaddingRight + this.mPaddingLeft;
                h -= this.mPaddingTop + this.mPaddingBottom;
                let right = w;
                let bottom = h;
                let top = 0;
                let left = 0;
                if (this.mIndeterminateDrawable != null) {
                    if (this.mOnlyIndeterminate && !(this.mIndeterminateDrawable instanceof AnimationDrawable)) {
                        const intrinsicWidth = this.mIndeterminateDrawable.getIntrinsicWidth();
                        const intrinsicHeight = this.mIndeterminateDrawable.getIntrinsicHeight();
                        const intrinsicAspect = intrinsicWidth / intrinsicHeight;
                        const boundAspect = w / h;
                        if (intrinsicAspect != boundAspect) {
                            if (boundAspect > intrinsicAspect) {
                                const width = Math.floor((h * intrinsicAspect));
                                left = (w - width) / 2;
                                right = left + width;
                            }
                            else {
                                const height = Math.floor((w * (1 / intrinsicAspect)));
                                top = (h - height) / 2;
                                bottom = top + height;
                            }
                        }
                    }
                    if (this.isLayoutRtl() && this.mMirrorForRtl) {
                        let tempLeft = left;
                        left = w - right;
                        right = w - tempLeft;
                    }
                    this.mIndeterminateDrawable.setBounds(left, top, right, bottom);
                }
                if (this.mProgressDrawable != null) {
                    this.mProgressDrawable.setBounds(0, 0, right, bottom);
                }
            }
            onDraw(canvas) {
                super.onDraw(canvas);
                let d = this.mCurrentDrawable;
                if (d != null) {
                    canvas.save();
                    if (this.isLayoutRtl() && this.mMirrorForRtl) {
                        canvas.translate(this.getWidth() - this.mPaddingRight, this.mPaddingTop);
                        canvas.scale(-1.0, 1.0);
                    }
                    else {
                        canvas.translate(this.mPaddingLeft, this.mPaddingTop);
                    }
                    let time = this.getDrawingTime();
                    if (this.mHasAnimation) {
                        this.mAnimation.getTransformation(time, this.mTransformation);
                        let scale = this.mTransformation.getAlpha();
                        try {
                            this.mInDrawing = true;
                            d.setLevel(Math.floor((scale * ProgressBar.MAX_LEVEL)));
                        }
                        finally {
                            this.mInDrawing = false;
                        }
                        this.postInvalidateOnAnimation();
                    }
                    d.draw(canvas);
                    canvas.restore();
                    if (this.mShouldStartAnimationDrawable && Animatable.isImpl(d)) {
                        d.start();
                        this.mShouldStartAnimationDrawable = false;
                    }
                }
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let d = this.mCurrentDrawable;
                let dw = 0;
                let dh = 0;
                if (d != null) {
                    dw = Math.max(this.mMinWidth, Math.min(this.mMaxWidth, d.getIntrinsicWidth()));
                    dh = Math.max(this.mMinHeight, Math.min(this.mMaxHeight, d.getIntrinsicHeight()));
                }
                this.updateDrawableState();
                dw += this.mPaddingLeft + this.mPaddingRight;
                dh += this.mPaddingTop + this.mPaddingBottom;
                this.setMeasuredDimension(ProgressBar.resolveSizeAndState(dw, widthMeasureSpec, 0), ProgressBar.resolveSizeAndState(dh, heightMeasureSpec, 0));
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                this.updateDrawableState();
            }
            updateDrawableState() {
                let state = this.getDrawableState();
                if (this.mProgressDrawable != null && this.mProgressDrawable.isStateful()) {
                    this.mProgressDrawable.setState(state);
                }
                if (this.mIndeterminateDrawable != null && this.mIndeterminateDrawable.isStateful()) {
                    this.mIndeterminateDrawable.setState(state);
                }
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                if (this.mIndeterminate) {
                    this.startAnimation();
                }
                if (this.mRefreshData != null) {
                    {
                        const count = this.mRefreshData.size();
                        for (let i = 0; i < count; i++) {
                            const rd = this.mRefreshData.get(i);
                            this.doRefreshProgress(rd.id, rd.progress, rd.fromUser, true);
                            rd.recycle();
                        }
                        this.mRefreshData.clear();
                    }
                }
                this.mAttached = true;
            }
            onDetachedFromWindow() {
                if (this.mIndeterminate) {
                    this.stopAnimation();
                }
                super.onDetachedFromWindow();
                this.mAttached = false;
            }
        }
        ProgressBar.MAX_LEVEL = 10000;
        ProgressBar.TIMEOUT_SEND_ACCESSIBILITY_EVENT = 200;
        widget.ProgressBar = ProgressBar;
        (function (ProgressBar) {
            class RefreshData {
                constructor() {
                    this.progress = 0;
                }
                static obtain(id, progress, fromUser) {
                    let rd = RefreshData.sPool.acquire();
                    if (rd == null) {
                        rd = new RefreshData();
                    }
                    rd.id = id;
                    rd.progress = progress;
                    rd.fromUser = fromUser;
                    return rd;
                }
                recycle() {
                    RefreshData.sPool.release(this);
                }
            }
            RefreshData.POOL_MAX = 24;
            RefreshData.sPool = new SynchronizedPool(RefreshData.POOL_MAX);
            ProgressBar.RefreshData = RefreshData;
        })(ProgressBar = widget.ProgressBar || (widget.ProgressBar = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var Button = android.widget.Button;
        class CompoundButton extends Button {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, null);
                this.mButtonResource = 0;
                this._attrBinder.addAttr('button', (value) => {
                    this.setButtonDrawable(this._attrBinder.parseDrawable(value));
                }, () => {
                    return this.mButtonDrawable;
                });
                this._attrBinder.addAttr('checked', (value) => {
                    this.setChecked(this._attrBinder.parseBoolean(value, this.isChecked()));
                }, () => {
                    return this.isChecked();
                });
                if (defStyle != null)
                    this.applyDefaultAttributes(defStyle);
            }
            toggle() {
                this.setChecked(!this.mChecked);
            }
            performClick() {
                this.toggle();
                return super.performClick();
            }
            isChecked() {
                return this.mChecked;
            }
            setChecked(checked) {
                if (this.mChecked != checked) {
                    this.mChecked = checked;
                    this.refreshDrawableState();
                    if (this.mBroadcasting) {
                        return;
                    }
                    this.mBroadcasting = true;
                    if (this.mOnCheckedChangeListener != null) {
                        this.mOnCheckedChangeListener.onCheckedChanged(this, this.mChecked);
                    }
                    if (this.mOnCheckedChangeWidgetListener != null) {
                        this.mOnCheckedChangeWidgetListener.onCheckedChanged(this, this.mChecked);
                    }
                    this.mBroadcasting = false;
                }
            }
            setOnCheckedChangeListener(listener) {
                this.mOnCheckedChangeListener = listener;
            }
            setOnCheckedChangeWidgetListener(listener) {
                this.mOnCheckedChangeWidgetListener = listener;
            }
            setButtonDrawable(d) {
                if (d != null) {
                    if (this.mButtonDrawable != null) {
                        this.mButtonDrawable.setCallback(null);
                        this.unscheduleDrawable(this.mButtonDrawable);
                    }
                    d.setCallback(this);
                    d.setVisible(this.getVisibility() == CompoundButton.VISIBLE, false);
                    this.mButtonDrawable = d;
                    this.setMinHeight(this.mButtonDrawable.getIntrinsicHeight());
                }
                this.refreshDrawableState();
            }
            getCompoundPaddingLeft() {
                let padding = super.getCompoundPaddingLeft();
                if (!this.isLayoutRtl()) {
                    const buttonDrawable = this.mButtonDrawable;
                    if (buttonDrawable != null) {
                        padding += buttonDrawable.getIntrinsicWidth();
                    }
                }
                return padding;
            }
            getCompoundPaddingRight() {
                let padding = super.getCompoundPaddingRight();
                if (this.isLayoutRtl()) {
                    const buttonDrawable = this.mButtonDrawable;
                    if (buttonDrawable != null) {
                        padding += buttonDrawable.getIntrinsicWidth();
                    }
                }
                return padding;
            }
            getHorizontalOffsetForDrawables() {
                const buttonDrawable = this.mButtonDrawable;
                return (buttonDrawable != null) ? buttonDrawable.getIntrinsicWidth() : 0;
            }
            onDraw(canvas) {
                super.onDraw(canvas);
                const buttonDrawable = this.mButtonDrawable;
                if (buttonDrawable != null) {
                    const verticalGravity = this.getGravity() & Gravity.VERTICAL_GRAVITY_MASK;
                    const drawableHeight = buttonDrawable.getIntrinsicHeight();
                    const drawableWidth = buttonDrawable.getIntrinsicWidth();
                    let top = 0;
                    switch (verticalGravity) {
                        case Gravity.BOTTOM:
                            top = this.getHeight() - drawableHeight;
                            break;
                        case Gravity.CENTER_VERTICAL:
                            top = (this.getHeight() - drawableHeight) / 2;
                            break;
                    }
                    let bottom = top + drawableHeight;
                    let left = this.isLayoutRtl() ? this.getWidth() - drawableWidth : 0;
                    let right = this.isLayoutRtl() ? this.getWidth() : drawableWidth;
                    buttonDrawable.setBounds(left, top, right, bottom);
                    buttonDrawable.draw(canvas);
                }
            }
            onCreateDrawableState(extraSpace) {
                const drawableState = super.onCreateDrawableState(extraSpace + 1);
                if (this.isChecked()) {
                    CompoundButton.mergeDrawableStates(drawableState, CompoundButton.CHECKED_STATE_SET);
                }
                return drawableState;
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if (this.mButtonDrawable != null) {
                    let myDrawableState = this.getDrawableState();
                    this.mButtonDrawable.setState(myDrawableState);
                    this.invalidate();
                }
            }
            drawableSizeChange(d) {
                if (d == this.mButtonDrawable) {
                    this.setButtonDrawable(d);
                    this.requestLayout();
                }
                else {
                    super.drawableSizeChange(d);
                }
            }
            verifyDrawable(who) {
                return super.verifyDrawable(who) || who == this.mButtonDrawable;
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mButtonDrawable != null)
                    this.mButtonDrawable.jumpToCurrentState();
            }
        }
        CompoundButton.CHECKED_STATE_SET = [View.VIEW_STATE_CHECKED];
        widget.CompoundButton = CompoundButton;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/CompoundButton.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var CompoundButton = android.widget.CompoundButton;
        class CheckBox extends CompoundButton {
            constructor(context, bindElement, defStyle = android.R.attr.checkboxStyle) {
                super(context, bindElement, defStyle);
            }
        }
        widget.CheckBox = CheckBox;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/CheckBox.ts"/>
///<reference path="../../android/widget/CompoundButton.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var CompoundButton = android.widget.CompoundButton;
        class RadioButton extends CompoundButton {
            constructor(context, bindElement, defStyle = android.R.attr.radiobuttonStyle) {
                super(context, bindElement, defStyle);
            }
            toggle() {
                if (!this.isChecked()) {
                    super.toggle();
                }
            }
        }
        widget.RadioButton = RadioButton;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/CompoundButton.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/RadioButton.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var LinearLayout = android.widget.LinearLayout;
        var RadioButton = android.widget.RadioButton;
        class RadioGroup extends LinearLayout {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mCheckedId = View.NO_ID;
                this.mProtectFromCheckedChange = false;
                this.setOrientation(RadioGroup.VERTICAL);
                this.init();
                this._attrBinder.addAttr('checkedButton', (value) => {
                    this.setCheckedId(value);
                });
            }
            init() {
                this.mChildOnCheckedChangeListener = new RadioGroup.CheckedStateTracker(this);
                this.mPassThroughListener = new RadioGroup.PassThroughHierarchyChangeListener(this);
                super.setOnHierarchyChangeListener(this.mPassThroughListener);
            }
            setOnHierarchyChangeListener(listener) {
                this.mPassThroughListener.mOnHierarchyChangeListener = listener;
            }
            onFinishInflate() {
                super.onFinishInflate();
                if (this.mCheckedId != null) {
                    this.mProtectFromCheckedChange = true;
                    this.setCheckedStateForView(this.mCheckedId, true);
                    this.mProtectFromCheckedChange = false;
                    this.setCheckedId(this.mCheckedId);
                }
            }
            addView(...args) {
                let child = args[0];
                if (child instanceof RadioButton) {
                    const button = child;
                    if (button.isChecked()) {
                        this.mProtectFromCheckedChange = true;
                        if (this.mCheckedId != null) {
                            this.setCheckedStateForView(this.mCheckedId, false);
                        }
                        this.mProtectFromCheckedChange = false;
                        this.setCheckedId(button.getId());
                    }
                }
                super.addView(...args);
            }
            check(id) {
                if (id != null && (id == this.mCheckedId)) {
                    return;
                }
                if (this.mCheckedId != null) {
                    this.setCheckedStateForView(this.mCheckedId, false);
                }
                if (id != null) {
                    this.setCheckedStateForView(id, true);
                }
                this.setCheckedId(id);
            }
            setCheckedId(id) {
                this.mCheckedId = id;
                if (this.mOnCheckedChangeListener != null) {
                    this.mOnCheckedChangeListener.onCheckedChanged(this, this.mCheckedId);
                }
            }
            setCheckedStateForView(viewId, checked) {
                let checkedView = this.findViewById(viewId);
                if (checkedView != null && checkedView instanceof RadioButton) {
                    checkedView.setChecked(checked);
                }
            }
            getCheckedRadioButtonId() {
                return this.mCheckedId;
            }
            clearCheck() {
                this.check(null);
            }
            setOnCheckedChangeListener(listener) {
                this.mOnCheckedChangeListener = listener;
            }
            checkLayoutParams(p) {
                return p instanceof RadioGroup.LayoutParams;
            }
            generateDefaultLayoutParams() {
                return new RadioGroup.LayoutParams(RadioGroup.LayoutParams.WRAP_CONTENT, RadioGroup.LayoutParams.WRAP_CONTENT);
            }
        }
        widget.RadioGroup = RadioGroup;
        (function (RadioGroup) {
            class LayoutParams extends LinearLayout.LayoutParams {
            }
            RadioGroup.LayoutParams = LayoutParams;
            class CheckedStateTracker {
                constructor(arg) {
                    this._RadioGroup_this = arg;
                }
                onCheckedChanged(buttonView, isChecked) {
                    if (this._RadioGroup_this.mProtectFromCheckedChange) {
                        return;
                    }
                    this._RadioGroup_this.mProtectFromCheckedChange = true;
                    if (this._RadioGroup_this.mCheckedId != null) {
                        this._RadioGroup_this.setCheckedStateForView(this._RadioGroup_this.mCheckedId, false);
                    }
                    this._RadioGroup_this.mProtectFromCheckedChange = false;
                    let id = buttonView.getId();
                    this._RadioGroup_this.setCheckedId(id);
                }
            }
            RadioGroup.CheckedStateTracker = CheckedStateTracker;
            class PassThroughHierarchyChangeListener {
                constructor(arg) {
                    this._RadioGroup_this = arg;
                }
                onChildViewAdded(parent, child) {
                    if (parent == this._RadioGroup_this && child instanceof RadioButton) {
                        let id = child.getId();
                        if (id == View.NO_ID) {
                            id = 'hash' + child.hashCode();
                            child.setId(id);
                        }
                        child.setOnCheckedChangeWidgetListener(this._RadioGroup_this.mChildOnCheckedChangeListener);
                    }
                    if (this.mOnHierarchyChangeListener != null) {
                        this.mOnHierarchyChangeListener.onChildViewAdded(parent, child);
                    }
                }
                onChildViewRemoved(parent, child) {
                    if (parent == this._RadioGroup_this && child instanceof RadioButton) {
                        child.setOnCheckedChangeWidgetListener(null);
                    }
                    if (this.mOnHierarchyChangeListener != null) {
                        this.mOnHierarchyChangeListener.onChildViewRemoved(parent, child);
                    }
                }
            }
            RadioGroup.PassThroughHierarchyChangeListener = PassThroughHierarchyChangeListener;
        })(RadioGroup = widget.RadioGroup || (widget.RadioGroup = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/content/Context.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Gravity = android.view.Gravity;
        var TextView = android.widget.TextView;
        var View = android.view.View;
        class CheckedTextView extends TextView {
            constructor(context, bindElement, defStyle = android.R.attr.checkedTextViewStyle) {
                super(context, bindElement, null);
                this.mCheckMarkResource = 0;
                this.mBasePadding = 0;
                this.mCheckMarkWidth = 0;
                this._attrBinder.addAttr('checkMark', (value) => {
                    this.setCheckMarkDrawable(this._attrBinder.parseDrawable(value));
                }, () => {
                    return this.getCheckMarkDrawable();
                });
                this._attrBinder.addAttr('checked', (value) => {
                    this.setChecked(this._attrBinder.parseBoolean(value, false));
                });
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
            }
            toggle() {
                this.setChecked(!this.mChecked);
            }
            isChecked() {
                return this.mChecked;
            }
            setChecked(checked) {
                if (this.mChecked != checked) {
                    this.mChecked = checked;
                    this.refreshDrawableState();
                }
            }
            setCheckMarkDrawable(d) {
                if (this.mCheckMarkDrawable != null) {
                    this.mCheckMarkDrawable.setCallback(null);
                    this.unscheduleDrawable(this.mCheckMarkDrawable);
                }
                this.mNeedRequestlayout = (d != this.mCheckMarkDrawable);
                if (d != null) {
                    d.setCallback(this);
                    d.setVisible(this.getVisibility() == CheckedTextView.VISIBLE, false);
                    d.setState(CheckedTextView.CHECKED_STATE_SET);
                    this.setMinHeight(d.getIntrinsicHeight());
                    this.mCheckMarkWidth = d.getIntrinsicWidth();
                    d.setState(this.getDrawableState());
                }
                else {
                    this.mCheckMarkWidth = 0;
                }
                this.mCheckMarkDrawable = d;
                this.resolvePadding();
            }
            getCheckMarkDrawable() {
                return this.mCheckMarkDrawable;
            }
            setPadding(left, top, right, bottom) {
                super.setPadding(left, top, right, bottom);
                this.setBasePadding(this.isLayoutRtl());
            }
            updatePadding() {
                let newPadding = (this.mCheckMarkDrawable != null) ? this.mCheckMarkWidth + this.mBasePadding : this.mBasePadding;
                if (this.isLayoutRtl()) {
                    this.mNeedRequestlayout = (this.mPaddingLeft != newPadding) || this.mNeedRequestlayout;
                    this.mPaddingLeft = newPadding;
                }
                else {
                    this.mNeedRequestlayout = (this.mPaddingRight != newPadding) || this.mNeedRequestlayout;
                    this.mPaddingRight = newPadding;
                }
                if (this.mNeedRequestlayout) {
                    this.requestLayout();
                    this.mNeedRequestlayout = false;
                }
            }
            setBasePadding(isLayoutRtl) {
                if (isLayoutRtl) {
                    this.mBasePadding = this.mPaddingLeft;
                }
                else {
                    this.mBasePadding = this.mPaddingRight;
                }
            }
            onDraw(canvas) {
                super.onDraw(canvas);
                const checkMarkDrawable = this.mCheckMarkDrawable;
                if (checkMarkDrawable != null) {
                    const verticalGravity = this.getGravity() & Gravity.VERTICAL_GRAVITY_MASK;
                    const height = checkMarkDrawable.getIntrinsicHeight();
                    let y = 0;
                    switch (verticalGravity) {
                        case Gravity.BOTTOM:
                            y = this.getHeight() - height;
                            break;
                        case Gravity.CENTER_VERTICAL:
                            y = (this.getHeight() - height) / 2;
                            break;
                    }
                    const isLayoutRtl = this.isLayoutRtl();
                    const width = this.getWidth();
                    const top = y;
                    const bottom = top + height;
                    let left;
                    let right;
                    if (isLayoutRtl) {
                        left = this.mBasePadding;
                        right = left + this.mCheckMarkWidth;
                    }
                    else {
                        right = width - this.mBasePadding;
                        left = right - this.mCheckMarkWidth;
                    }
                    checkMarkDrawable.setBounds(this.mScrollX + left, top, this.mScrollX + right, bottom);
                    checkMarkDrawable.draw(canvas);
                }
            }
            onCreateDrawableState(extraSpace) {
                const drawableState = super.onCreateDrawableState(extraSpace + 1);
                if (this.isChecked()) {
                    CheckedTextView.mergeDrawableStates(drawableState, CheckedTextView.CHECKED_STATE_SET);
                }
                return drawableState;
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if (this.mCheckMarkDrawable != null) {
                    let myDrawableState = this.getDrawableState();
                    this.mCheckMarkDrawable.setState(myDrawableState);
                    this.invalidate();
                }
            }
        }
        CheckedTextView.CHECKED_STATE_SET = [View.VIEW_STATE_CHECKED];
        widget.CheckedTextView = CheckedTextView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../android/widget/ProgressBar.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var Integer = java.lang.Integer;
        var ProgressBar = android.widget.ProgressBar;
        class AbsSeekBar extends ProgressBar {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, null);
                this.mThumbOffset = 0;
                this.mTouchProgressOffset = 0;
                this.mIsUserSeekable = true;
                this.mKeyProgressIncrement = 1;
                this.mDisabledAlpha = 0;
                this.mTouchDownX = 0;
                let a = this._attrBinder;
                a.addAttr('thumb', (value) => {
                    this.setThumb(a.parseDrawable(value));
                }, () => this.mThumb);
                a.addAttr('thumbOffset', (value) => {
                    this.setThumbOffset(a.parseNumber(value));
                }, () => this.mThumbOffset);
                a.addAttr('disabledAlpha', (value) => {
                    this.mDisabledAlpha = a.parseNumber(value, 0.5);
                }, () => this.mThumbOffset);
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
            }
            setThumb(thumb) {
                let needUpdate;
                if (this.mThumb != null && thumb != this.mThumb) {
                    this.mThumb.setCallback(null);
                    needUpdate = true;
                }
                else {
                    needUpdate = false;
                }
                if (thumb != null) {
                    thumb.setCallback(this);
                    this.mThumbOffset = thumb.getIntrinsicWidth() / 2;
                    if (needUpdate && (thumb.getIntrinsicWidth() != this.mThumb.getIntrinsicWidth() || thumb.getIntrinsicHeight() != this.mThumb.getIntrinsicHeight())) {
                        this.requestLayout();
                    }
                }
                this.mThumb = thumb;
                this.invalidate();
                if (needUpdate) {
                    this.updateThumbPos(this.getWidth(), this.getHeight());
                    if (thumb != null && thumb.isStateful()) {
                        let state = this.getDrawableState();
                        thumb.setState(state);
                    }
                }
            }
            getThumb() {
                return this.mThumb;
            }
            getThumbOffset() {
                return this.mThumbOffset;
            }
            setThumbOffset(thumbOffset) {
                this.mThumbOffset = thumbOffset;
                this.invalidate();
            }
            setKeyProgressIncrement(increment) {
                this.mKeyProgressIncrement = increment < 0 ? -increment : increment;
            }
            getKeyProgressIncrement() {
                return this.mKeyProgressIncrement;
            }
            setMax(max) {
                super.setMax(max);
                if ((this.mKeyProgressIncrement == 0) || (this.getMax() / this.mKeyProgressIncrement > 20)) {
                    this.setKeyProgressIncrement(Math.max(1, Math.round(this.getMax() / 20)));
                }
            }
            verifyDrawable(who) {
                return who == this.mThumb || super.verifyDrawable(who);
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mThumb != null)
                    this.mThumb.jumpToCurrentState();
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                let progressDrawable = this.getProgressDrawable();
                if (progressDrawable != null) {
                    progressDrawable.setAlpha(this.isEnabled() ? AbsSeekBar.NO_ALPHA : Math.floor((AbsSeekBar.NO_ALPHA * this.mDisabledAlpha)));
                }
                if (this.mThumb != null && this.mThumb.isStateful()) {
                    let state = this.getDrawableState();
                    this.mThumb.setState(state);
                }
            }
            onProgressRefresh(scale, fromUser) {
                super.onProgressRefresh(scale, fromUser);
                let thumb = this.mThumb;
                if (thumb != null) {
                    this.setThumbPos(this.getWidth(), thumb, scale, Integer.MIN_VALUE);
                    this.invalidate();
                }
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                this.updateThumbPos(w, h);
            }
            updateThumbPos(w, h) {
                let d = this.getCurrentDrawable();
                let thumb = this.mThumb;
                let thumbHeight = thumb == null ? 0 : thumb.getIntrinsicHeight();
                let trackHeight = Math.min(this.mMaxHeight, h - this.mPaddingTop - this.mPaddingBottom);
                let max = this.getMax();
                let scale = max > 0 ? this.getProgress() / max : 0;
                if (thumbHeight > trackHeight) {
                    if (thumb != null) {
                        this.setThumbPos(w, thumb, scale, 0);
                    }
                    let gapForCenteringTrack = (thumbHeight - trackHeight) / 2;
                    if (d != null) {
                        d.setBounds(0, gapForCenteringTrack, w - this.mPaddingRight - this.mPaddingLeft, h - this.mPaddingBottom - gapForCenteringTrack - this.mPaddingTop);
                    }
                }
                else {
                    if (d != null) {
                        d.setBounds(0, 0, w - this.mPaddingRight - this.mPaddingLeft, h - this.mPaddingBottom - this.mPaddingTop);
                    }
                    let gap = (trackHeight - thumbHeight) / 2;
                    if (thumb != null) {
                        this.setThumbPos(w, thumb, scale, gap);
                    }
                }
            }
            setThumbPos(w, thumb, scale, gap) {
                let available = w - this.mPaddingLeft - this.mPaddingRight;
                let thumbWidth = thumb.getIntrinsicWidth();
                let thumbHeight = thumb.getIntrinsicHeight();
                available -= thumbWidth;
                available += this.mThumbOffset * 2;
                let thumbPos = Math.floor((scale * available));
                let topBound, bottomBound;
                if (gap == Integer.MIN_VALUE) {
                    let oldBounds = thumb.getBounds();
                    topBound = oldBounds.top;
                    bottomBound = oldBounds.bottom;
                }
                else {
                    topBound = gap;
                    bottomBound = gap + thumbHeight;
                }
                const left = (this.isLayoutRtl() && this.mMirrorForRtl) ? available - thumbPos : thumbPos;
                thumb.setBounds(left, topBound, left + thumbWidth, bottomBound);
            }
            onDraw(canvas) {
                super.onDraw(canvas);
                if (this.mThumb != null) {
                    canvas.save();
                    canvas.translate(this.mPaddingLeft - this.mThumbOffset, this.mPaddingTop);
                    this.mThumb.draw(canvas);
                    canvas.restore();
                }
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let d = this.getCurrentDrawable();
                let thumbHeight = this.mThumb == null ? 0 : this.mThumb.getIntrinsicHeight();
                let dw = 0;
                let dh = 0;
                if (d != null) {
                    dw = Math.max(this.mMinWidth, Math.min(this.mMaxWidth, d.getIntrinsicWidth()));
                    dh = Math.max(this.mMinHeight, Math.min(this.mMaxHeight, d.getIntrinsicHeight()));
                    dh = Math.max(thumbHeight, dh);
                }
                dw += this.mPaddingLeft + this.mPaddingRight;
                dh += this.mPaddingTop + this.mPaddingBottom;
                this.setMeasuredDimension(AbsSeekBar.resolveSizeAndState(dw, widthMeasureSpec, 0), AbsSeekBar.resolveSizeAndState(dh, heightMeasureSpec, 0));
            }
            onTouchEvent(event) {
                if (!this.mIsUserSeekable || !this.isEnabled()) {
                    return false;
                }
                switch (event.getAction()) {
                    case MotionEvent.ACTION_DOWN:
                        if (this.isInScrollingContainer()) {
                            this.mTouchDownX = event.getX();
                        }
                        else {
                            this.setPressed(true);
                            if (this.mThumb != null) {
                                this.invalidate(this.mThumb.getBounds());
                            }
                            this.onStartTrackingTouch();
                            this.trackTouchEvent(event);
                            this.attemptClaimDrag();
                        }
                        break;
                    case MotionEvent.ACTION_MOVE:
                        if (this.mIsDragging) {
                            this.trackTouchEvent(event);
                        }
                        else {
                            const x = event.getX();
                            if (Math.abs(x - this.mTouchDownX) > this.mTouchSlop) {
                                this.setPressed(true);
                                if (this.mThumb != null) {
                                    this.invalidate(this.mThumb.getBounds());
                                }
                                this.onStartTrackingTouch();
                                this.trackTouchEvent(event);
                                this.attemptClaimDrag();
                            }
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        if (this.mIsDragging) {
                            this.trackTouchEvent(event);
                            this.onStopTrackingTouch();
                            this.setPressed(false);
                        }
                        else {
                            this.onStartTrackingTouch();
                            this.trackTouchEvent(event);
                            this.onStopTrackingTouch();
                        }
                        this.invalidate();
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        if (this.mIsDragging) {
                            this.onStopTrackingTouch();
                            this.setPressed(false);
                        }
                        this.invalidate();
                        break;
                }
                return true;
            }
            trackTouchEvent(event) {
                const width = this.getWidth();
                const available = width - this.mPaddingLeft - this.mPaddingRight;
                let x = Math.floor(event.getX());
                let scale;
                let progress = 0;
                if (this.isLayoutRtl() && this.mMirrorForRtl) {
                    if (x > width - this.mPaddingRight) {
                        scale = 0.0;
                    }
                    else if (x < this.mPaddingLeft) {
                        scale = 1.0;
                    }
                    else {
                        scale = (available - x + this.mPaddingLeft) / available;
                        progress = this.mTouchProgressOffset;
                    }
                }
                else {
                    if (x < this.mPaddingLeft) {
                        scale = 0.0;
                    }
                    else if (x > width - this.mPaddingRight) {
                        scale = 1.0;
                    }
                    else {
                        scale = (x - this.mPaddingLeft) / available;
                        progress = this.mTouchProgressOffset;
                    }
                }
                const max = this.getMax();
                progress += scale * max;
                this.setProgress(Math.floor(progress), true);
            }
            attemptClaimDrag() {
                if (this.mParent != null) {
                    this.mParent.requestDisallowInterceptTouchEvent(true);
                }
            }
            onStartTrackingTouch() {
                this.mIsDragging = true;
            }
            onStopTrackingTouch() {
                this.mIsDragging = false;
            }
            onKeyChange() {
            }
            onKeyDown(keyCode, event) {
                if (this.isEnabled()) {
                    let progress = this.getProgress();
                    switch (keyCode) {
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (progress <= 0)
                                break;
                            this.setProgress(progress - this.mKeyProgressIncrement, true);
                            this.onKeyChange();
                            return true;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (progress >= this.getMax())
                                break;
                            this.setProgress(progress + this.mKeyProgressIncrement, true);
                            this.onKeyChange();
                            return true;
                    }
                }
                return super.onKeyDown(keyCode, event);
            }
        }
        AbsSeekBar.NO_ALPHA = 0xFF;
        widget.AbsSeekBar = AbsSeekBar;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/AbsSeekBar.ts"/>
///<reference path="../../android/widget/ProgressBar.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var AbsSeekBar = android.widget.AbsSeekBar;
        class SeekBar extends AbsSeekBar {
            constructor(context, bindElement, defStyle = android.R.attr.seekBarStyle) {
                super(context, bindElement, defStyle);
            }
            onProgressRefresh(scale, fromUser) {
                super.onProgressRefresh(scale, fromUser);
                if (this.mOnSeekBarChangeListener != null) {
                    this.mOnSeekBarChangeListener.onProgressChanged(this, this.getProgress(), fromUser);
                }
            }
            setOnSeekBarChangeListener(l) {
                this.mOnSeekBarChangeListener = l;
            }
            onStartTrackingTouch() {
                super.onStartTrackingTouch();
                if (this.mOnSeekBarChangeListener != null) {
                    this.mOnSeekBarChangeListener.onStartTrackingTouch(this);
                }
            }
            onStopTrackingTouch() {
                super.onStopTrackingTouch();
                if (this.mOnSeekBarChangeListener != null) {
                    this.mOnSeekBarChangeListener.onStopTrackingTouch(this);
                }
            }
        }
        widget.SeekBar = SeekBar;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/AbsSeekBar.ts"/>
///<reference path="../../android/widget/ProgressBar.ts"/>
///<reference path="../../android/widget/SeekBar.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var AbsSeekBar = android.widget.AbsSeekBar;
        class RatingBar extends AbsSeekBar {
            constructor(context, bindElement, defStyle = android.R.attr.ratingBarStyle) {
                super(context, bindElement, null);
                this.mNumStars = 5;
                this.mProgressOnStartTracking = 0;
                const a = this._attrBinder;
                a.addAttr('numStars', (value) => {
                    this.setNumStars(a.parseNumber(value, this.mNumStars));
                }, () => this.mNumStars);
                a.addAttr('isIndicator', (value) => {
                    this.setIsIndicator(a.parseBoolean(value, !this.mIsUserSeekable));
                }, () => !this.mIsUserSeekable);
                a.addAttr('stepSize', (value) => {
                    this.setStepSize(a.parseNumber(value, 0.5));
                }, () => this.getStepSize());
                a.addAttr('rating', (value) => {
                    this.setRating(a.parseNumber(value, this.getRating()));
                }, () => this.getRating());
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
                this.mTouchProgressOffset = 1.1;
            }
            setOnRatingBarChangeListener(listener) {
                this.mOnRatingBarChangeListener = listener;
            }
            getOnRatingBarChangeListener() {
                return this.mOnRatingBarChangeListener;
            }
            setIsIndicator(isIndicator) {
                this.mIsUserSeekable = !isIndicator;
                this.setFocusable(!isIndicator);
            }
            isIndicator() {
                return !this.mIsUserSeekable;
            }
            setNumStars(numStars) {
                if (numStars <= 0) {
                    return;
                }
                let step = this.getStepSize();
                this.mNumStars = numStars;
                this.setStepSize(step);
                this.requestLayout();
            }
            getNumStars() {
                return this.mNumStars;
            }
            setRating(rating) {
                this.setProgress(Math.round(rating * this.getProgressPerStar()));
            }
            getRating() {
                return this.getProgress() / this.getProgressPerStar();
            }
            setStepSize(stepSize) {
                if (Number.isNaN(stepSize) || !Number.isFinite(stepSize) || stepSize <= 0) {
                    return;
                }
                const newMax = this.mNumStars / stepSize;
                let newProgress = Math.floor((newMax / this.getMax() * this.getProgress()));
                if (Number.isNaN(newProgress))
                    newProgress = 0;
                this.setMax(Math.floor(newMax));
                this.setProgress(newProgress);
            }
            getStepSize() {
                return this.getNumStars() / this.getMax();
            }
            getProgressPerStar() {
                if (this.mNumStars > 0) {
                    return 1 * this.getMax() / this.mNumStars;
                }
                else {
                    return 1;
                }
            }
            onProgressRefresh(scale, fromUser) {
                super.onProgressRefresh(scale, fromUser);
                this.updateSecondaryProgress(this.getProgress());
                if (!fromUser) {
                    this.dispatchRatingChange(false);
                }
            }
            updateSecondaryProgress(progress) {
                const ratio = this.getProgressPerStar();
                if (ratio > 0) {
                    const progressInStars = progress / ratio;
                    const secondaryProgress = Math.floor((Math.ceil(progressInStars) * ratio));
                    this.setSecondaryProgress(secondaryProgress);
                }
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                if (this.mSampleTile != null) {
                    const width = this.mSampleTile.getIntrinsicWidth() * this.mNumStars;
                    this.setMeasuredDimension(RatingBar.resolveSizeAndState(width, widthMeasureSpec, 0), this.getMeasuredHeight());
                }
            }
            onStartTrackingTouch() {
                this.mProgressOnStartTracking = this.getProgress();
                super.onStartTrackingTouch();
            }
            onStopTrackingTouch() {
                super.onStopTrackingTouch();
                if (this.getProgress() != this.mProgressOnStartTracking) {
                    this.dispatchRatingChange(true);
                }
            }
            onKeyChange() {
                super.onKeyChange();
                this.dispatchRatingChange(true);
            }
            dispatchRatingChange(fromUser) {
                if (this.mOnRatingBarChangeListener != null) {
                    this.mOnRatingBarChangeListener.onRatingChanged(this, this.getRating(), fromUser);
                }
            }
            setMax(max) {
                if (max <= 0) {
                    return;
                }
                super.setMax(max);
            }
        }
        widget.RatingBar = RatingBar;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/ExpandableListView.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../android/widget/ExpandableListView.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ArrayList = java.util.ArrayList;
        var ExpandableListView = android.widget.ExpandableListView;
        class ExpandableListPosition {
            constructor() {
                this.groupPos = 0;
                this.childPos = 0;
                this.flatListPos = 0;
                this.type = 0;
            }
            resetState() {
                this.groupPos = 0;
                this.childPos = 0;
                this.flatListPos = 0;
                this.type = 0;
            }
            getPackedPosition() {
                if (this.type == ExpandableListPosition.CHILD)
                    return ExpandableListView.getPackedPositionForChild(this.groupPos, this.childPos);
                else
                    return ExpandableListView.getPackedPositionForGroup(this.groupPos);
            }
            static obtainGroupPosition(groupPosition) {
                return ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPosition, 0, 0);
            }
            static obtainChildPosition(groupPosition, childPosition) {
                return ExpandableListPosition.obtain(ExpandableListPosition.CHILD, groupPosition, childPosition, 0);
            }
            static obtainPosition(packedPosition) {
                if (packedPosition == ExpandableListView.PACKED_POSITION_VALUE_NULL) {
                    return null;
                }
                let elp = ExpandableListPosition.getRecycledOrCreate();
                elp.groupPos = ExpandableListView.getPackedPositionGroup(packedPosition);
                if (ExpandableListView.getPackedPositionType(packedPosition) == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {
                    elp.type = ExpandableListPosition.CHILD;
                    elp.childPos = ExpandableListView.getPackedPositionChild(packedPosition);
                }
                else {
                    elp.type = ExpandableListPosition.GROUP;
                }
                return elp;
            }
            static obtain(type, groupPos, childPos, flatListPos) {
                let elp = ExpandableListPosition.getRecycledOrCreate();
                elp.type = type;
                elp.groupPos = groupPos;
                elp.childPos = childPos;
                elp.flatListPos = flatListPos;
                return elp;
            }
            static getRecycledOrCreate() {
                let elp;
                {
                    if (ExpandableListPosition.sPool.size() > 0) {
                        elp = ExpandableListPosition.sPool.remove(0);
                    }
                    else {
                        return new ExpandableListPosition();
                    }
                }
                elp.resetState();
                return elp;
            }
            recycle() {
                {
                    if (ExpandableListPosition.sPool.size() < ExpandableListPosition.MAX_POOL_SIZE) {
                        ExpandableListPosition.sPool.add(this);
                    }
                }
            }
        }
        ExpandableListPosition.MAX_POOL_SIZE = 5;
        ExpandableListPosition.sPool = new ArrayList(ExpandableListPosition.MAX_POOL_SIZE);
        ExpandableListPosition.CHILD = 1;
        ExpandableListPosition.GROUP = 2;
        widget.ExpandableListPosition = ExpandableListPosition;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/ExpandableListAdapter.ts"/>
///<reference path="../../android/widget/ExpandableListView.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var HeterogeneousExpandableList;
        (function (HeterogeneousExpandableList) {
            function isImpl(obj) {
                return obj && obj['getGroupType'] && obj['getChildType'] && obj['getGroupTypeCount'] && obj['getChildTypeCount'];
            }
            HeterogeneousExpandableList.isImpl = isImpl;
        })(HeterogeneousExpandableList = widget.HeterogeneousExpandableList || (widget.HeterogeneousExpandableList = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/os/SystemClock.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/util/Collections.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/Comparable.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/BaseAdapter.ts"/>
///<reference path="../../android/widget/ExpandableListAdapter.ts"/>
///<reference path="../../android/widget/ExpandableListPosition.ts"/>
///<reference path="../../android/widget/HeterogeneousExpandableList.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var DataSetObserver = android.database.DataSetObserver;
        var SystemClock = android.os.SystemClock;
        var ArrayList = java.util.ArrayList;
        var Collections = java.util.Collections;
        var Integer = java.lang.Integer;
        var AdapterView = android.widget.AdapterView;
        var BaseAdapter = android.widget.BaseAdapter;
        var ExpandableListPosition = android.widget.ExpandableListPosition;
        var HeterogeneousExpandableList = android.widget.HeterogeneousExpandableList;
        class ExpandableListConnector extends BaseAdapter {
            constructor(expandableListAdapter) {
                super();
                this.mTotalExpChildrenCount = 0;
                this.mMaxExpGroupCount = Integer.MAX_VALUE;
                this.mDataSetObserver = new ExpandableListConnector.MyDataSetObserver(this);
                this.mExpGroupMetadataList = new ArrayList();
                this.setExpandableListAdapter(expandableListAdapter);
            }
            setExpandableListAdapter(expandableListAdapter) {
                if (this.mExpandableListAdapter != null) {
                    this.mExpandableListAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                }
                this.mExpandableListAdapter = expandableListAdapter;
                expandableListAdapter.registerDataSetObserver(this.mDataSetObserver);
            }
            getUnflattenedPos(flPos) {
                const egml = this.mExpGroupMetadataList;
                const numExpGroups = egml.size();
                let leftExpGroupIndex = 0;
                let rightExpGroupIndex = numExpGroups - 1;
                let midExpGroupIndex = 0;
                let midExpGm;
                if (numExpGroups == 0) {
                    return ExpandableListConnector.PositionMetadata.obtain(flPos, ExpandableListPosition.GROUP, flPos, -1, null, 0);
                }
                while (leftExpGroupIndex <= rightExpGroupIndex) {
                    midExpGroupIndex = Math.floor((rightExpGroupIndex - leftExpGroupIndex) / 2 + leftExpGroupIndex);
                    midExpGm = egml.get(midExpGroupIndex);
                    if (flPos > midExpGm.lastChildFlPos) {
                        leftExpGroupIndex = midExpGroupIndex + 1;
                    }
                    else if (flPos < midExpGm.flPos) {
                        rightExpGroupIndex = midExpGroupIndex - 1;
                    }
                    else if (flPos == midExpGm.flPos) {
                        return ExpandableListConnector.PositionMetadata.obtain(flPos, ExpandableListPosition.GROUP, midExpGm.gPos, -1, midExpGm, midExpGroupIndex);
                    }
                    else if (flPos <= midExpGm.lastChildFlPos) {
                        const childPos = flPos - (midExpGm.flPos + 1);
                        return ExpandableListConnector.PositionMetadata.obtain(flPos, ExpandableListPosition.CHILD, midExpGm.gPos, childPos, midExpGm, midExpGroupIndex);
                    }
                }
                let insertPosition = 0;
                let groupPos = 0;
                if (leftExpGroupIndex > midExpGroupIndex) {
                    const leftExpGm = egml.get(leftExpGroupIndex - 1);
                    insertPosition = leftExpGroupIndex;
                    groupPos = (flPos - leftExpGm.lastChildFlPos) + leftExpGm.gPos;
                }
                else if (rightExpGroupIndex < midExpGroupIndex) {
                    const rightExpGm = egml.get(++rightExpGroupIndex);
                    insertPosition = rightExpGroupIndex;
                    groupPos = rightExpGm.gPos - (rightExpGm.flPos - flPos);
                }
                else {
                    throw Error(`new RuntimeException("Unknown state")`);
                }
                return ExpandableListConnector.PositionMetadata.obtain(flPos, ExpandableListPosition.GROUP, groupPos, -1, null, insertPosition);
            }
            getFlattenedPos(pos) {
                const egml = this.mExpGroupMetadataList;
                const numExpGroups = egml.size();
                let leftExpGroupIndex = 0;
                let rightExpGroupIndex = numExpGroups - 1;
                let midExpGroupIndex = 0;
                let midExpGm;
                if (numExpGroups == 0) {
                    return ExpandableListConnector.PositionMetadata.obtain(pos.groupPos, pos.type, pos.groupPos, pos.childPos, null, 0);
                }
                while (leftExpGroupIndex <= rightExpGroupIndex) {
                    midExpGroupIndex = Math.floor((rightExpGroupIndex - leftExpGroupIndex) / 2 + leftExpGroupIndex);
                    midExpGm = egml.get(midExpGroupIndex);
                    if (pos.groupPos > midExpGm.gPos) {
                        leftExpGroupIndex = midExpGroupIndex + 1;
                    }
                    else if (pos.groupPos < midExpGm.gPos) {
                        rightExpGroupIndex = midExpGroupIndex - 1;
                    }
                    else if (pos.groupPos == midExpGm.gPos) {
                        if (pos.type == ExpandableListPosition.GROUP) {
                            return ExpandableListConnector.PositionMetadata.obtain(midExpGm.flPos, pos.type, pos.groupPos, pos.childPos, midExpGm, midExpGroupIndex);
                        }
                        else if (pos.type == ExpandableListPosition.CHILD) {
                            return ExpandableListConnector.PositionMetadata.obtain(midExpGm.flPos + pos.childPos + 1, pos.type, pos.groupPos, pos.childPos, midExpGm, midExpGroupIndex);
                        }
                        else {
                            return null;
                        }
                    }
                }
                if (pos.type != ExpandableListPosition.GROUP) {
                    return null;
                }
                if (leftExpGroupIndex > midExpGroupIndex) {
                    const leftExpGm = egml.get(leftExpGroupIndex - 1);
                    const flPos = leftExpGm.lastChildFlPos + (pos.groupPos - leftExpGm.gPos);
                    return ExpandableListConnector.PositionMetadata.obtain(flPos, pos.type, pos.groupPos, pos.childPos, null, leftExpGroupIndex);
                }
                else if (rightExpGroupIndex < midExpGroupIndex) {
                    const rightExpGm = egml.get(++rightExpGroupIndex);
                    const flPos = rightExpGm.flPos - (rightExpGm.gPos - pos.groupPos);
                    return ExpandableListConnector.PositionMetadata.obtain(flPos, pos.type, pos.groupPos, pos.childPos, null, rightExpGroupIndex);
                }
                else {
                    return null;
                }
            }
            areAllItemsEnabled() {
                return this.mExpandableListAdapter.areAllItemsEnabled();
            }
            isEnabled(flatListPos) {
                const metadata = this.getUnflattenedPos(flatListPos);
                const pos = metadata.position;
                let retValue;
                if (pos.type == ExpandableListPosition.CHILD) {
                    retValue = this.mExpandableListAdapter.isChildSelectable(pos.groupPos, pos.childPos);
                }
                else {
                    retValue = true;
                }
                metadata.recycle();
                return retValue;
            }
            getCount() {
                return this.mExpandableListAdapter.getGroupCount() + this.mTotalExpChildrenCount;
            }
            getItem(flatListPos) {
                const posMetadata = this.getUnflattenedPos(flatListPos);
                let retValue;
                if (posMetadata.position.type == ExpandableListPosition.GROUP) {
                    retValue = this.mExpandableListAdapter.getGroup(posMetadata.position.groupPos);
                }
                else if (posMetadata.position.type == ExpandableListPosition.CHILD) {
                    retValue = this.mExpandableListAdapter.getChild(posMetadata.position.groupPos, posMetadata.position.childPos);
                }
                else {
                    throw Error(`new RuntimeException("Flat list position is of unknown type")`);
                }
                posMetadata.recycle();
                return retValue;
            }
            getItemId(flatListPos) {
                const posMetadata = this.getUnflattenedPos(flatListPos);
                const groupId = this.mExpandableListAdapter.getGroupId(posMetadata.position.groupPos);
                let retValue;
                if (posMetadata.position.type == ExpandableListPosition.GROUP) {
                    retValue = this.mExpandableListAdapter.getCombinedGroupId(groupId);
                }
                else if (posMetadata.position.type == ExpandableListPosition.CHILD) {
                    const childId = this.mExpandableListAdapter.getChildId(posMetadata.position.groupPos, posMetadata.position.childPos);
                    retValue = this.mExpandableListAdapter.getCombinedChildId(groupId, childId);
                }
                else {
                    throw Error(`new RuntimeException("Flat list position is of unknown type")`);
                }
                posMetadata.recycle();
                return retValue;
            }
            getView(flatListPos, convertView, parent) {
                const posMetadata = this.getUnflattenedPos(flatListPos);
                let retValue;
                if (posMetadata.position.type == ExpandableListPosition.GROUP) {
                    retValue = this.mExpandableListAdapter.getGroupView(posMetadata.position.groupPos, posMetadata.isExpanded(), convertView, parent);
                }
                else if (posMetadata.position.type == ExpandableListPosition.CHILD) {
                    const isLastChild = posMetadata.groupMetadata.lastChildFlPos == flatListPos;
                    retValue = this.mExpandableListAdapter.getChildView(posMetadata.position.groupPos, posMetadata.position.childPos, isLastChild, convertView, parent);
                }
                else {
                    throw Error(`new RuntimeException("Flat list position is of unknown type")`);
                }
                posMetadata.recycle();
                return retValue;
            }
            getItemViewType(flatListPos) {
                const metadata = this.getUnflattenedPos(flatListPos);
                const pos = metadata.position;
                let retValue;
                if (HeterogeneousExpandableList.isImpl(this.mExpandableListAdapter)) {
                    let adapter = this.mExpandableListAdapter;
                    if (pos.type == ExpandableListPosition.GROUP) {
                        retValue = adapter.getGroupType(pos.groupPos);
                    }
                    else {
                        const childType = adapter.getChildType(pos.groupPos, pos.childPos);
                        retValue = adapter.getGroupTypeCount() + childType;
                    }
                }
                else {
                    if (pos.type == ExpandableListPosition.GROUP) {
                        retValue = 0;
                    }
                    else {
                        retValue = 1;
                    }
                }
                metadata.recycle();
                return retValue;
            }
            getViewTypeCount() {
                if (HeterogeneousExpandableList.isImpl(this.mExpandableListAdapter)) {
                    let adapter = this.mExpandableListAdapter;
                    return adapter.getGroupTypeCount() + adapter.getChildTypeCount();
                }
                else {
                    return 2;
                }
            }
            hasStableIds() {
                return this.mExpandableListAdapter.hasStableIds();
            }
            refreshExpGroupMetadataList(forceChildrenCountRefresh, syncGroupPositions) {
                const egml = this.mExpGroupMetadataList;
                let egmlSize = egml.size();
                let curFlPos = 0;
                this.mTotalExpChildrenCount = 0;
                if (syncGroupPositions) {
                    let positionsChanged = false;
                    for (let i = egmlSize - 1; i >= 0; i--) {
                        let curGm = egml.get(i);
                        let newGPos = this.findGroupPosition(curGm.gId, curGm.gPos);
                        if (newGPos != curGm.gPos) {
                            if (newGPos == AdapterView.INVALID_POSITION) {
                                egml.remove(i);
                                egmlSize--;
                            }
                            curGm.gPos = newGPos;
                            if (!positionsChanged)
                                positionsChanged = true;
                        }
                    }
                    if (positionsChanged) {
                        Collections.sort(egml);
                    }
                }
                let gChildrenCount;
                let lastGPos = 0;
                for (let i = 0; i < egmlSize; i++) {
                    let curGm = egml.get(i);
                    if ((curGm.lastChildFlPos == ExpandableListConnector.GroupMetadata.REFRESH) || forceChildrenCountRefresh) {
                        gChildrenCount = this.mExpandableListAdapter.getChildrenCount(curGm.gPos);
                    }
                    else {
                        gChildrenCount = curGm.lastChildFlPos - curGm.flPos;
                    }
                    this.mTotalExpChildrenCount += gChildrenCount;
                    curFlPos += (curGm.gPos - lastGPos);
                    lastGPos = curGm.gPos;
                    curGm.flPos = curFlPos;
                    curFlPos += gChildrenCount;
                    curGm.lastChildFlPos = curFlPos;
                }
            }
            collapseGroup(groupPos) {
                let elGroupPos = ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPos, -1, -1);
                let pm = this.getFlattenedPos(elGroupPos);
                elGroupPos.recycle();
                if (pm == null)
                    return false;
                let retValue = this.collapseGroupWithMeta(pm);
                pm.recycle();
                return retValue;
            }
            collapseGroupWithMeta(posMetadata) {
                if (posMetadata.groupMetadata == null)
                    return false;
                this.mExpGroupMetadataList.remove(posMetadata.groupMetadata);
                this.refreshExpGroupMetadataList(false, false);
                this.notifyDataSetChanged();
                this.mExpandableListAdapter.onGroupCollapsed(posMetadata.groupMetadata.gPos);
                return true;
            }
            expandGroup(groupPos) {
                let elGroupPos = ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPos, -1, -1);
                let pm = this.getFlattenedPos(elGroupPos);
                elGroupPos.recycle();
                let retValue = this.expandGroupWithMeta(pm);
                pm.recycle();
                return retValue;
            }
            expandGroupWithMeta(posMetadata) {
                if (posMetadata.position.groupPos < 0) {
                    throw Error(`new RuntimeException("Need group")`);
                }
                if (this.mMaxExpGroupCount == 0)
                    return false;
                if (posMetadata.groupMetadata != null)
                    return false;
                if (this.mExpGroupMetadataList.size() >= this.mMaxExpGroupCount) {
                    let collapsedGm = this.mExpGroupMetadataList.get(0);
                    let collapsedIndex = this.mExpGroupMetadataList.indexOf(collapsedGm);
                    this.collapseGroup(collapsedGm.gPos);
                    if (posMetadata.groupInsertIndex > collapsedIndex) {
                        posMetadata.groupInsertIndex--;
                    }
                }
                let expandedGm = ExpandableListConnector.GroupMetadata.obtain(ExpandableListConnector.GroupMetadata.REFRESH, ExpandableListConnector.GroupMetadata.REFRESH, posMetadata.position.groupPos, this.mExpandableListAdapter.getGroupId(posMetadata.position.groupPos));
                this.mExpGroupMetadataList.add(posMetadata.groupInsertIndex, expandedGm);
                this.refreshExpGroupMetadataList(false, false);
                this.notifyDataSetChanged();
                this.mExpandableListAdapter.onGroupExpanded(expandedGm.gPos);
                return true;
            }
            isGroupExpanded(groupPosition) {
                let groupMetadata;
                for (let i = this.mExpGroupMetadataList.size() - 1; i >= 0; i--) {
                    groupMetadata = this.mExpGroupMetadataList.get(i);
                    if (groupMetadata.gPos == groupPosition) {
                        return true;
                    }
                }
                return false;
            }
            setMaxExpGroupCount(maxExpGroupCount) {
                this.mMaxExpGroupCount = maxExpGroupCount;
            }
            getAdapter() {
                return this.mExpandableListAdapter;
            }
            getExpandedGroupMetadataList() {
                return this.mExpGroupMetadataList;
            }
            setExpandedGroupMetadataList(expandedGroupMetadataList) {
                if ((expandedGroupMetadataList == null) || (this.mExpandableListAdapter == null)) {
                    return;
                }
                let numGroups = this.mExpandableListAdapter.getGroupCount();
                for (let i = expandedGroupMetadataList.size() - 1; i >= 0; i--) {
                    if (expandedGroupMetadataList.get(i).gPos >= numGroups) {
                        return;
                    }
                }
                this.mExpGroupMetadataList = expandedGroupMetadataList;
                this.refreshExpGroupMetadataList(true, false);
            }
            isEmpty() {
                let adapter = this.getAdapter();
                return adapter != null ? adapter.isEmpty() : true;
            }
            findGroupPosition(groupIdToMatch, seedGroupPosition) {
                let count = this.mExpandableListAdapter.getGroupCount();
                if (count == 0) {
                    return AdapterView.INVALID_POSITION;
                }
                if (groupIdToMatch == AdapterView.INVALID_ROW_ID) {
                    return AdapterView.INVALID_POSITION;
                }
                seedGroupPosition = Math.max(0, seedGroupPosition);
                seedGroupPosition = Math.min(count - 1, seedGroupPosition);
                let endTime = SystemClock.uptimeMillis() + AdapterView.SYNC_MAX_DURATION_MILLIS;
                let rowId;
                let first = seedGroupPosition;
                let last = seedGroupPosition;
                let next = false;
                let hitFirst;
                let hitLast;
                let adapter = this.getAdapter();
                if (adapter == null) {
                    return AdapterView.INVALID_POSITION;
                }
                while (SystemClock.uptimeMillis() <= endTime) {
                    rowId = adapter.getGroupId(seedGroupPosition);
                    if (rowId == groupIdToMatch) {
                        return seedGroupPosition;
                    }
                    hitLast = last == count - 1;
                    hitFirst = first == 0;
                    if (hitLast && hitFirst) {
                        break;
                    }
                    if (hitFirst || (next && !hitLast)) {
                        last++;
                        seedGroupPosition = last;
                        next = false;
                    }
                    else if (hitLast || (!next && !hitFirst)) {
                        first--;
                        seedGroupPosition = first;
                        next = true;
                    }
                }
                return AdapterView.INVALID_POSITION;
            }
        }
        widget.ExpandableListConnector = ExpandableListConnector;
        (function (ExpandableListConnector) {
            class MyDataSetObserver extends DataSetObserver {
                constructor(arg) {
                    super();
                    this._ExpandableListConnector_this = arg;
                }
                onChanged() {
                    this._ExpandableListConnector_this.refreshExpGroupMetadataList(true, true);
                    this._ExpandableListConnector_this.notifyDataSetChanged();
                }
                onInvalidated() {
                    this._ExpandableListConnector_this.refreshExpGroupMetadataList(true, true);
                    this._ExpandableListConnector_this.notifyDataSetInvalidated();
                }
            }
            ExpandableListConnector.MyDataSetObserver = MyDataSetObserver;
            class GroupMetadata {
                constructor() {
                    this.flPos = 0;
                    this.lastChildFlPos = 0;
                    this.gPos = 0;
                    this.gId = 0;
                }
                static obtain(flPos, lastChildFlPos, gPos, gId) {
                    let gm = new GroupMetadata();
                    gm.flPos = flPos;
                    gm.lastChildFlPos = lastChildFlPos;
                    gm.gPos = gPos;
                    gm.gId = gId;
                    return gm;
                }
                compareTo(another) {
                    if (another == null) {
                        throw Error(`new IllegalArgumentException()`);
                    }
                    return this.gPos - another.gPos;
                }
            }
            GroupMetadata.REFRESH = -1;
            ExpandableListConnector.GroupMetadata = GroupMetadata;
            class PositionMetadata {
                constructor() {
                    this.groupInsertIndex = 0;
                }
                resetState() {
                    if (this.position != null) {
                        this.position.recycle();
                        this.position = null;
                    }
                    this.groupMetadata = null;
                    this.groupInsertIndex = 0;
                }
                static obtain(flatListPos, type, groupPos, childPos, groupMetadata, groupInsertIndex) {
                    let pm = PositionMetadata.getRecycledOrCreate();
                    pm.position = ExpandableListPosition.obtain(type, groupPos, childPos, flatListPos);
                    pm.groupMetadata = groupMetadata;
                    pm.groupInsertIndex = groupInsertIndex;
                    return pm;
                }
                static getRecycledOrCreate() {
                    let pm;
                    {
                        if (PositionMetadata.sPool.size() > 0) {
                            pm = PositionMetadata.sPool.remove(0);
                        }
                        else {
                            return new PositionMetadata();
                        }
                    }
                    pm.resetState();
                    return pm;
                }
                recycle() {
                    this.resetState();
                    {
                        if (PositionMetadata.sPool.size() < PositionMetadata.MAX_POOL_SIZE) {
                            PositionMetadata.sPool.add(this);
                        }
                    }
                }
                isExpanded() {
                    return this.groupMetadata != null;
                }
            }
            PositionMetadata.MAX_POOL_SIZE = 5;
            PositionMetadata.sPool = new ArrayList(PositionMetadata.MAX_POOL_SIZE);
            ExpandableListConnector.PositionMetadata = PositionMetadata;
        })(ExpandableListConnector = widget.ExpandableListConnector || (widget.ExpandableListConnector = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/ExpandableListAdapter.ts"/>
///<reference path="../../android/widget/ExpandableListConnector.ts"/>
///<reference path="../../android/widget/ExpandableListPosition.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/R/attr.ts"/>
///<reference path="../../androidui/util/Long.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ExpandableListConnector = android.widget.ExpandableListConnector;
        var ExpandableListPosition = android.widget.ExpandableListPosition;
        var ListView = android.widget.ListView;
        var Long = goog.math.Long;
        class ExpandableListView extends ListView {
            constructor(context, bindElement, defStyle = android.R.attr.expandableListViewStyle) {
                super(context, bindElement, null);
                this.mIndicatorLeft = 0;
                this.mIndicatorRight = 0;
                this.mIndicatorStart = 0;
                this.mIndicatorEnd = 0;
                this.mChildIndicatorLeft = 0;
                this.mChildIndicatorRight = 0;
                this.mChildIndicatorStart = 0;
                this.mChildIndicatorEnd = 0;
                this.mIndicatorRect = new Rect();
                this._attrBinder.addAttr('groupIndicator', (value) => {
                    this.setGroupIndicator(this._attrBinder.parseDrawable(value));
                }, () => {
                    return this.mGroupIndicator;
                });
                this._attrBinder.addAttr('childIndicator', (value) => {
                    this.setChildIndicator(this._attrBinder.parseDrawable(value));
                }, () => {
                    return this.mChildIndicator;
                });
                this._attrBinder.addAttr('indicatorLeft', (value) => {
                    this.setIndicatorBounds(this._attrBinder.parseNumber(value, 0), this.mIndicatorRight);
                }, () => {
                    return this.mIndicatorLeft;
                });
                this._attrBinder.addAttr('indicatorRight', (value) => {
                    let num = this._attrBinder.parseNumber(value, 0);
                    if (num == 0 && this.mGroupIndicator != null) {
                        num = this.mIndicatorLeft + this.mGroupIndicator.getIntrinsicWidth();
                    }
                    this.setIndicatorBounds(this.mIndicatorLeft, num);
                }, () => {
                    return this.mIndicatorRight;
                });
                this._attrBinder.addAttr('childIndicatorLeft', (value) => {
                    this.setChildIndicatorBounds(this._attrBinder.parseNumber(value, ExpandableListView.CHILD_INDICATOR_INHERIT), this.mChildIndicatorRight);
                }, () => {
                    return this.mChildIndicatorLeft;
                });
                this._attrBinder.addAttr('childIndicatorRight', (value) => {
                    let num = this._attrBinder.parseNumber(value, ExpandableListView.CHILD_INDICATOR_INHERIT);
                    if (num == 0 && this.mChildIndicator != null) {
                        num = this.mChildIndicatorLeft + this.mChildIndicator.getIntrinsicWidth();
                    }
                    this.setIndicatorBounds(this.mChildIndicatorLeft, num);
                }, () => {
                    return this.mChildIndicatorRight;
                });
                this._attrBinder.addAttr('childDivider', (value) => {
                    this.setChildDivider(this._attrBinder.parseDrawable(value));
                });
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
            }
            isRtlCompatibilityMode() {
                return !this.hasRtlSupport();
            }
            hasRtlSupport() {
                return false;
            }
            onRtlPropertiesChanged(layoutDirection) {
                this.resolveIndicator();
                this.resolveChildIndicator();
            }
            resolveIndicator() {
                const isLayoutRtl = this.isLayoutRtl();
                if (isLayoutRtl) {
                    if (this.mIndicatorStart >= 0) {
                        this.mIndicatorRight = this.mIndicatorStart;
                    }
                    if (this.mIndicatorEnd >= 0) {
                        this.mIndicatorLeft = this.mIndicatorEnd;
                    }
                }
                else {
                    if (this.mIndicatorStart >= 0) {
                        this.mIndicatorLeft = this.mIndicatorStart;
                    }
                    if (this.mIndicatorEnd >= 0) {
                        this.mIndicatorRight = this.mIndicatorEnd;
                    }
                }
                if (this.mIndicatorRight == 0 && this.mGroupIndicator != null) {
                    this.mIndicatorRight = this.mIndicatorLeft + this.mGroupIndicator.getIntrinsicWidth();
                }
            }
            resolveChildIndicator() {
                const isLayoutRtl = this.isLayoutRtl();
                if (isLayoutRtl) {
                    if (this.mChildIndicatorStart >= ExpandableListView.CHILD_INDICATOR_INHERIT) {
                        this.mChildIndicatorRight = this.mChildIndicatorStart;
                    }
                    if (this.mChildIndicatorEnd >= ExpandableListView.CHILD_INDICATOR_INHERIT) {
                        this.mChildIndicatorLeft = this.mChildIndicatorEnd;
                    }
                }
                else {
                    if (this.mChildIndicatorStart >= ExpandableListView.CHILD_INDICATOR_INHERIT) {
                        this.mChildIndicatorLeft = this.mChildIndicatorStart;
                    }
                    if (this.mChildIndicatorEnd >= ExpandableListView.CHILD_INDICATOR_INHERIT) {
                        this.mChildIndicatorRight = this.mChildIndicatorEnd;
                    }
                }
            }
            dispatchDraw(canvas) {
                super.dispatchDraw(canvas);
                if ((this.mChildIndicator == null) && (this.mGroupIndicator == null)) {
                    return;
                }
                let saveCount = 0;
                const clipToPadding = (this.mGroupFlags & ExpandableListView.CLIP_TO_PADDING_MASK) == ExpandableListView.CLIP_TO_PADDING_MASK;
                if (clipToPadding) {
                    saveCount = canvas.save();
                    const scrollX = this.mScrollX;
                    const scrollY = this.mScrollY;
                    canvas.clipRect(scrollX + this.mPaddingLeft, scrollY + this.mPaddingTop, scrollX + this.mRight - this.mLeft - this.mPaddingRight, scrollY + this.mBottom - this.mTop - this.mPaddingBottom);
                }
                const headerViewsCount = this.getHeaderViewsCount();
                const lastChildFlPos = this.mItemCount - this.getFooterViewsCount() - headerViewsCount - 1;
                const myB = this.mBottom;
                let pos;
                let item;
                let indicator;
                let t, b;
                let lastItemType = ~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
                const indicatorRect = this.mIndicatorRect;
                const childCount = this.getChildCount();
                for (let i = 0, childFlPos = this.mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
                    if (childFlPos < 0) {
                        continue;
                    }
                    else if (childFlPos > lastChildFlPos) {
                        break;
                    }
                    item = this.getChildAt(i);
                    t = item.getTop();
                    b = item.getBottom();
                    if ((b < 0) || (t > myB))
                        continue;
                    pos = this.mConnector.getUnflattenedPos(childFlPos);
                    const isLayoutRtl = this.isLayoutRtl();
                    const width = this.getWidth();
                    if (pos.position.type != lastItemType) {
                        if (pos.position.type == ExpandableListPosition.CHILD) {
                            indicatorRect.left = (this.mChildIndicatorLeft == ExpandableListView.CHILD_INDICATOR_INHERIT) ? this.mIndicatorLeft : this.mChildIndicatorLeft;
                            indicatorRect.right = (this.mChildIndicatorRight == ExpandableListView.CHILD_INDICATOR_INHERIT) ? this.mIndicatorRight : this.mChildIndicatorRight;
                        }
                        else {
                            indicatorRect.left = this.mIndicatorLeft;
                            indicatorRect.right = this.mIndicatorRight;
                        }
                        if (isLayoutRtl) {
                            const temp = indicatorRect.left;
                            indicatorRect.left = width - indicatorRect.right;
                            indicatorRect.right = width - temp;
                            indicatorRect.left -= this.mPaddingRight;
                            indicatorRect.right -= this.mPaddingRight;
                        }
                        else {
                            indicatorRect.left += this.mPaddingLeft;
                            indicatorRect.right += this.mPaddingLeft;
                        }
                        lastItemType = pos.position.type;
                    }
                    if (indicatorRect.left != indicatorRect.right) {
                        if (this.mStackFromBottom) {
                            indicatorRect.top = t;
                            indicatorRect.bottom = b;
                        }
                        else {
                            indicatorRect.top = t;
                            indicatorRect.bottom = b;
                        }
                        indicator = this.getIndicator(pos);
                        if (indicator != null) {
                            indicator.setBounds(indicatorRect);
                            indicator.draw(canvas);
                        }
                    }
                    pos.recycle();
                }
                if (clipToPadding) {
                    canvas.restoreToCount(saveCount);
                }
            }
            getIndicator(pos) {
                let indicator;
                if (pos.position.type == ExpandableListPosition.GROUP) {
                    indicator = this.mGroupIndicator;
                    if (indicator != null && indicator.isStateful()) {
                        let isEmpty = (pos.groupMetadata == null) || (pos.groupMetadata.lastChildFlPos == pos.groupMetadata.flPos);
                        const stateSetIndex = (pos.isExpanded() ? 1 : 0) |
                            (isEmpty ? 2 : 0);
                        indicator.setState(ExpandableListView.GROUP_STATE_SETS[stateSetIndex]);
                    }
                }
                else {
                    indicator = this.mChildIndicator;
                    if (indicator != null && indicator.isStateful()) {
                        const stateSet = pos.position.flatListPos == pos.groupMetadata.lastChildFlPos ? ExpandableListView.CHILD_LAST_STATE_SET : ExpandableListView.EMPTY_STATE_SET;
                        indicator.setState(stateSet);
                    }
                }
                return indicator;
            }
            setChildDivider(childDivider) {
                this.mChildDivider = childDivider;
            }
            drawDivider(canvas, bounds, childIndex) {
                let flatListPosition = childIndex + this.mFirstPosition;
                if (flatListPosition >= 0) {
                    const adjustedPosition = this.getFlatPositionForConnector(flatListPosition);
                    let pos = this.mConnector.getUnflattenedPos(adjustedPosition);
                    if ((pos.position.type == ExpandableListPosition.CHILD) || (pos.isExpanded() && pos.groupMetadata.lastChildFlPos != pos.groupMetadata.flPos)) {
                        const divider = this.mChildDivider;
                        divider.setBounds(bounds);
                        divider.draw(canvas);
                        pos.recycle();
                        return;
                    }
                    pos.recycle();
                }
                super.drawDivider(canvas, bounds, flatListPosition);
            }
            setAdapter(adapter) {
                throw Error(`new RuntimeException("For ExpandableListView, use setAdapter(ExpandableListAdapter) instead of " + "setAdapter(ListAdapter)")`);
            }
            getAdapter() {
                return super.getAdapter();
            }
            setOnItemClickListener(l) {
                super.setOnItemClickListener(l);
            }
            setExpandableAdapter(adapter) {
                this.mExpandAdapter = adapter;
                if (adapter != null) {
                    this.mConnector = new ExpandableListConnector(adapter);
                }
                else {
                    this.mConnector = null;
                }
                super.setAdapter(this.mConnector);
            }
            getExpandableListAdapter() {
                return this.mExpandAdapter;
            }
            isHeaderOrFooterPosition(position) {
                const footerViewsStart = this.mItemCount - this.getFooterViewsCount();
                return (position < this.getHeaderViewsCount() || position >= footerViewsStart);
            }
            getFlatPositionForConnector(flatListPosition) {
                return flatListPosition - this.getHeaderViewsCount();
            }
            getAbsoluteFlatPosition(flatListPosition) {
                return flatListPosition + this.getHeaderViewsCount();
            }
            performItemClick(v, position, id) {
                if (this.isHeaderOrFooterPosition(position)) {
                    return super.performItemClick(v, position, id);
                }
                const adjustedPosition = this.getFlatPositionForConnector(position);
                return this.handleItemClick(v, adjustedPosition, id);
            }
            handleItemClick(v, position, id) {
                const posMetadata = this.mConnector.getUnflattenedPos(position);
                id = this.getChildOrGroupId(posMetadata.position);
                let returnValue;
                if (posMetadata.position.type == ExpandableListPosition.GROUP) {
                    if (this.mOnGroupClickListener != null) {
                        if (this.mOnGroupClickListener.onGroupClick(this, v, posMetadata.position.groupPos, id)) {
                            posMetadata.recycle();
                            return true;
                        }
                    }
                    if (posMetadata.isExpanded()) {
                        this.mConnector.collapseGroupWithMeta(posMetadata);
                        this.playSoundEffect(SoundEffectConstants.CLICK);
                        if (this.mOnGroupCollapseListener != null) {
                            this.mOnGroupCollapseListener.onGroupCollapse(posMetadata.position.groupPos);
                        }
                    }
                    else {
                        this.mConnector.expandGroupWithMeta(posMetadata);
                        this.playSoundEffect(SoundEffectConstants.CLICK);
                        if (this.mOnGroupExpandListener != null) {
                            this.mOnGroupExpandListener.onGroupExpand(posMetadata.position.groupPos);
                        }
                        const groupPos = posMetadata.position.groupPos;
                        const groupFlatPos = posMetadata.position.flatListPos;
                        const shiftedGroupPosition = groupFlatPos + this.getHeaderViewsCount();
                        this.smoothScrollToPosition(shiftedGroupPosition + this.mExpandAdapter.getChildrenCount(groupPos), shiftedGroupPosition);
                    }
                    returnValue = true;
                }
                else {
                    if (this.mOnChildClickListener != null) {
                        this.playSoundEffect(SoundEffectConstants.CLICK);
                        return this.mOnChildClickListener.onChildClick(this, v, posMetadata.position.groupPos, posMetadata.position.childPos, id);
                    }
                    returnValue = false;
                }
                posMetadata.recycle();
                return returnValue;
            }
            expandGroup(groupPos, animate = false) {
                let elGroupPos = ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPos, -1, -1);
                let pm = this.mConnector.getFlattenedPos(elGroupPos);
                elGroupPos.recycle();
                let retValue = this.mConnector.expandGroupWithMeta(pm);
                if (this.mOnGroupExpandListener != null) {
                    this.mOnGroupExpandListener.onGroupExpand(groupPos);
                }
                if (animate) {
                    const groupFlatPos = pm.position.flatListPos;
                    const shiftedGroupPosition = groupFlatPos + this.getHeaderViewsCount();
                    this.smoothScrollToPosition(shiftedGroupPosition + this.mExpandAdapter.getChildrenCount(groupPos), shiftedGroupPosition);
                }
                pm.recycle();
                return retValue;
            }
            collapseGroup(groupPos) {
                let retValue = this.mConnector.collapseGroup(groupPos);
                if (this.mOnGroupCollapseListener != null) {
                    this.mOnGroupCollapseListener.onGroupCollapse(groupPos);
                }
                return retValue;
            }
            setOnGroupCollapseListener(onGroupCollapseListener) {
                this.mOnGroupCollapseListener = onGroupCollapseListener;
            }
            setOnGroupExpandListener(onGroupExpandListener) {
                this.mOnGroupExpandListener = onGroupExpandListener;
            }
            setOnGroupClickListener(onGroupClickListener) {
                this.mOnGroupClickListener = onGroupClickListener;
            }
            setOnChildClickListener(onChildClickListener) {
                this.mOnChildClickListener = onChildClickListener;
            }
            getExpandableListPosition(flatListPosition) {
                if (this.isHeaderOrFooterPosition(flatListPosition)) {
                    return ExpandableListView.PACKED_POSITION_VALUE_NULL;
                }
                const adjustedPosition = this.getFlatPositionForConnector(flatListPosition);
                let pm = this.mConnector.getUnflattenedPos(adjustedPosition);
                let packedPos = pm.position.getPackedPosition();
                pm.recycle();
                return packedPos;
            }
            getFlatListPosition(packedPosition) {
                let elPackedPos = ExpandableListPosition.obtainPosition(packedPosition);
                let pm = this.mConnector.getFlattenedPos(elPackedPos);
                elPackedPos.recycle();
                const flatListPosition = pm.position.flatListPos;
                pm.recycle();
                return this.getAbsoluteFlatPosition(flatListPosition);
            }
            getSelectedPosition() {
                const selectedPos = this.getSelectedItemPosition();
                return this.getExpandableListPosition(selectedPos);
            }
            getSelectedId() {
                let packedPos = this.getSelectedPosition();
                if (packedPos == ExpandableListView.PACKED_POSITION_VALUE_NULL)
                    return -1;
                let groupPos = ExpandableListView.getPackedPositionGroup(packedPos);
                if (ExpandableListView.getPackedPositionType(packedPos) == ExpandableListView.PACKED_POSITION_TYPE_GROUP) {
                    return this.mExpandAdapter.getGroupId(groupPos);
                }
                else {
                    return this.mExpandAdapter.getChildId(groupPos, ExpandableListView.getPackedPositionChild(packedPos));
                }
            }
            setSelectedGroup(groupPosition) {
                let elGroupPos = ExpandableListPosition.obtainGroupPosition(groupPosition);
                let pm = this.mConnector.getFlattenedPos(elGroupPos);
                elGroupPos.recycle();
                const absoluteFlatPosition = this.getAbsoluteFlatPosition(pm.position.flatListPos);
                super.setSelection(absoluteFlatPosition);
                pm.recycle();
            }
            setSelectedChild(groupPosition, childPosition, shouldExpandGroup) {
                let elChildPos = ExpandableListPosition.obtainChildPosition(groupPosition, childPosition);
                let flatChildPos = this.mConnector.getFlattenedPos(elChildPos);
                if (flatChildPos == null) {
                    if (!shouldExpandGroup)
                        return false;
                    this.expandGroup(groupPosition);
                    flatChildPos = this.mConnector.getFlattenedPos(elChildPos);
                    if (flatChildPos == null) {
                        throw Error(`new IllegalStateException("Could not find child")`);
                    }
                }
                let absoluteFlatPosition = this.getAbsoluteFlatPosition(flatChildPos.position.flatListPos);
                super.setSelection(absoluteFlatPosition);
                elChildPos.recycle();
                flatChildPos.recycle();
                return true;
            }
            isGroupExpanded(groupPosition) {
                return this.mConnector.isGroupExpanded(groupPosition);
            }
            static getPackedPositionType(packedPosition) {
                if (packedPosition == ExpandableListView.PACKED_POSITION_VALUE_NULL) {
                    return ExpandableListView.PACKED_POSITION_TYPE_NULL;
                }
                return (Long.fromNumber(packedPosition).and(ExpandableListView.PACKED_POSITION_MASK_TYPE)).equals(ExpandableListView.PACKED_POSITION_MASK_TYPE)
                    ? ExpandableListView.PACKED_POSITION_TYPE_CHILD : ExpandableListView.PACKED_POSITION_TYPE_GROUP;
            }
            static getPackedPositionGroup(packedPosition) {
                if (packedPosition == ExpandableListView.PACKED_POSITION_VALUE_NULL)
                    return -1;
                return (Long.fromNumber(packedPosition).and(ExpandableListView.PACKED_POSITION_MASK_GROUP))
                    .shiftRight(ExpandableListView.PACKED_POSITION_SHIFT_GROUP).toNumber();
            }
            static getPackedPositionChild(packedPosition) {
                if (packedPosition == ExpandableListView.PACKED_POSITION_VALUE_NULL)
                    return -1;
                if ((Long.fromNumber(packedPosition).and(ExpandableListView.PACKED_POSITION_MASK_TYPE)).notEquals(ExpandableListView.PACKED_POSITION_MASK_TYPE))
                    return -1;
                return Long.fromNumber(packedPosition).and(ExpandableListView.PACKED_POSITION_MASK_CHILD).toNumber();
            }
            static getPackedPositionForChild(groupPosition, childPosition) {
                return Long.fromInt(ExpandableListView.PACKED_POSITION_TYPE_CHILD).shiftLeft(ExpandableListView.PACKED_POSITION_SHIFT_TYPE)
                    .or(Long.fromNumber(groupPosition).and(ExpandableListView.PACKED_POSITION_INT_MASK_GROUP).shiftLeft(ExpandableListView.PACKED_POSITION_SHIFT_GROUP))
                    .or(Long.fromNumber(childPosition).and(ExpandableListView.PACKED_POSITION_INT_MASK_CHILD)).toNumber();
            }
            static getPackedPositionForGroup(groupPosition) {
                return Long.fromInt(groupPosition).and(ExpandableListView.PACKED_POSITION_INT_MASK_GROUP)
                    .shiftLeft(ExpandableListView.PACKED_POSITION_SHIFT_GROUP).toNumber();
            }
            getChildOrGroupId(position) {
                if (position.type == ExpandableListPosition.CHILD) {
                    return this.mExpandAdapter.getChildId(position.groupPos, position.childPos);
                }
                else {
                    return this.mExpandAdapter.getGroupId(position.groupPos);
                }
            }
            setChildIndicator(childIndicator) {
                this.mChildIndicator = childIndicator;
            }
            setChildIndicatorBounds(left, right) {
                this.mChildIndicatorLeft = left;
                this.mChildIndicatorRight = right;
                this.resolveChildIndicator();
            }
            setChildIndicatorBoundsRelative(start, end) {
                this.mChildIndicatorStart = start;
                this.mChildIndicatorEnd = end;
                this.resolveChildIndicator();
            }
            setGroupIndicator(groupIndicator) {
                this.mGroupIndicator = groupIndicator;
                if (this.mIndicatorRight == 0 && this.mGroupIndicator != null) {
                    this.mIndicatorRight = this.mIndicatorLeft + this.mGroupIndicator.getIntrinsicWidth();
                }
            }
            setIndicatorBounds(left, right) {
                this.mIndicatorLeft = left;
                this.mIndicatorRight = right;
                this.resolveIndicator();
            }
            setIndicatorBoundsRelative(start, end) {
                this.mIndicatorStart = start;
                this.mIndicatorEnd = end;
                this.resolveIndicator();
            }
        }
        ExpandableListView.PACKED_POSITION_TYPE_GROUP = 0;
        ExpandableListView.PACKED_POSITION_TYPE_CHILD = 1;
        ExpandableListView.PACKED_POSITION_TYPE_NULL = 2;
        ExpandableListView.PACKED_POSITION_VALUE_NULL = 0x00000000FFFFFFFF;
        ExpandableListView.PACKED_POSITION_MASK_CHILD = Long.fromNumber(0x00000000FFFFFFFF);
        ExpandableListView.PACKED_POSITION_MASK_GROUP = Long.fromNumber(0x7FFFFFFF00000000);
        ExpandableListView.PACKED_POSITION_MASK_TYPE = Long.fromNumber(0x8000000000000000);
        ExpandableListView.PACKED_POSITION_SHIFT_GROUP = 32;
        ExpandableListView.PACKED_POSITION_SHIFT_TYPE = 63;
        ExpandableListView.PACKED_POSITION_INT_MASK_CHILD = Long.fromNumber(0xFFFFFFFF);
        ExpandableListView.PACKED_POSITION_INT_MASK_GROUP = Long.fromNumber(0x7FFFFFFF);
        ExpandableListView.CHILD_INDICATOR_INHERIT = -1;
        ExpandableListView.INDICATOR_UNDEFINED = -2;
        ExpandableListView.GROUP_EXPANDED_STATE_SET = [View.VIEW_STATE_EXPANDED];
        ExpandableListView.GROUP_EMPTY_STATE_SET = [View.VIEW_STATE_EMPTY];
        ExpandableListView.GROUP_EXPANDED_EMPTY_STATE_SET = [View.VIEW_STATE_EXPANDED, View.VIEW_STATE_EMPTY];
        ExpandableListView.GROUP_STATE_SETS = [
            ExpandableListView.EMPTY_STATE_SET,
            ExpandableListView.GROUP_EXPANDED_STATE_SET,
            ExpandableListView.GROUP_EMPTY_STATE_SET,
            ExpandableListView.GROUP_EXPANDED_EMPTY_STATE_SET];
        ExpandableListView.CHILD_LAST_STATE_SET = [View.VIEW_STATE_LAST];
        widget.ExpandableListView = ExpandableListView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/ExpandableListAdapter.ts"/>
///<reference path="../../android/widget/HeterogeneousExpandableList.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../androidui/util/Long.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var DataSetObservable = android.database.DataSetObservable;
        var Long = goog.math.Long;
        const _0x8000000000000000 = Long.fromNumber(0x8000000000000000);
        const _0x7FFFFFFF = Long.fromNumber(0x7FFFFFFF);
        const _0xFFFFFFFF = Long.fromNumber(0xFFFFFFFF);
        class BaseExpandableListAdapter {
            constructor() {
                this.mDataSetObservable = new DataSetObservable();
            }
            registerDataSetObserver(observer) {
                this.mDataSetObservable.registerObserver(observer);
            }
            unregisterDataSetObserver(observer) {
                this.mDataSetObservable.unregisterObserver(observer);
            }
            notifyDataSetInvalidated() {
                this.mDataSetObservable.notifyInvalidated();
            }
            notifyDataSetChanged() {
                this.mDataSetObservable.notifyChanged();
            }
            areAllItemsEnabled() {
                return true;
            }
            onGroupCollapsed(groupPosition) {
            }
            onGroupExpanded(groupPosition) {
            }
            getCombinedChildId(groupId, childId) {
                const _groupId = Long.fromNumber(groupId);
                const _childId = Long.fromNumber(childId);
                return _0x8000000000000000.or(_groupId.and(_0x7FFFFFFF).shiftLeft(32)).or(_childId.and(_0xFFFFFFFF)).toNumber();
            }
            getCombinedGroupId(groupId) {
                const _groupId = Long.fromNumber(groupId);
                return _groupId.add(_0x7FFFFFFF).shiftLeft(32).toNumber();
            }
            isEmpty() {
                return this.getGroupCount() == 0;
            }
            getChildType(groupPosition, childPosition) {
                return 0;
            }
            getChildTypeCount() {
                return 1;
            }
            getGroupType(groupPosition) {
                return 0;
            }
            getGroupTypeCount() {
                return 1;
            }
        }
        widget.BaseExpandableListAdapter = BaseExpandableListAdapter;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/content/Context.ts"/>
///<reference path="../../android/graphics/PixelFormat.ts"/>
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/LayoutInflater.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/WindowManager.ts"/>
///<reference path="../../android/view/Window.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Handler = android.os.Handler;
        var Log = android.util.Log;
        var Gravity = android.view.Gravity;
        var WindowManager = android.view.WindowManager;
        var Window = android.view.Window;
        class Toast {
            constructor(context) {
                this.mDuration = 0;
                this.mHandler = new Handler();
                this.mDelayHide = (() => {
                    const _this = this;
                    return {
                        run() {
                            _this.mTN.hide();
                        }
                    };
                })();
                this.mContext = context;
                this.mTN = new Toast.TN();
                this.mTN.mY = context.getResources().getDisplayMetrics().density * 64;
                this.mTN.mGravity = Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;
            }
            show() {
                if (this.mNextView == null) {
                    throw Error(`new RuntimeException("setView must have been called")`);
                }
                let tn = this.mTN;
                tn.mNextView = this.mNextView;
                tn.show();
                this.mHandler.removeCallbacks(this.mDelayHide);
                let showDuration = this.mDuration === Toast.LENGTH_LONG ? 3500 : (this.mDuration === Toast.LENGTH_SHORT ? 2000 : this.mDuration);
                this.mHandler.postDelayed(this.mDelayHide, showDuration);
            }
            cancel() {
                this.mTN.hide();
            }
            setView(view) {
                this.mNextView = view;
            }
            getView() {
                return this.mNextView;
            }
            setDuration(duration) {
                this.mDuration = duration;
            }
            getDuration() {
                return this.mDuration;
            }
            setGravity(gravity, xOffset, yOffset) {
                this.mTN.mGravity = gravity;
                this.mTN.mX = xOffset;
                this.mTN.mY = yOffset;
            }
            getGravity() {
                return this.mTN.mGravity;
            }
            getXOffset() {
                return this.mTN.mX;
            }
            getYOffset() {
                return this.mTN.mY;
            }
            static makeText(context, text, duration) {
                let result = new Toast(context);
                let inflate = context.getLayoutInflater();
                let v = inflate.inflate(android.R.layout.transient_notification, null);
                let tv = v.findViewById(android.R.id.message);
                tv.setMaxWidth(260 * context.getResources().getDisplayMetrics().density);
                tv.setText(text);
                result.mNextView = v;
                result.mDuration = duration;
                return result;
            }
            setText(s) {
                if (this.mNextView == null) {
                    throw Error(`new RuntimeException("This Toast was not created with Toast.makeText()")`);
                }
                let tv = this.mNextView.findViewById(android.R.id.message);
                if (tv == null) {
                    throw Error(`new RuntimeException("This Toast was not created with Toast.makeText()")`);
                }
                tv.setText(s);
            }
        }
        Toast.TAG = "Toast";
        Toast.localLOGV = false;
        Toast.LENGTH_SHORT = 0;
        Toast.LENGTH_LONG = 1;
        widget.Toast = Toast;
        (function (Toast) {
            class TN {
                constructor() {
                    this.mShow = (() => {
                        const _this = this;
                        class _Inner {
                            run() {
                                _this.handleShow();
                            }
                        }
                        return new _Inner();
                    })();
                    this.mHide = (() => {
                        const _this = this;
                        class _Inner {
                            run() {
                                _this.handleHide();
                                _this.mNextView = null;
                            }
                        }
                        return new _Inner();
                    })();
                    this.mHandler = new Handler();
                    this.mGravity = 0;
                    this.mX = 0;
                    this.mY = 0;
                }
                show() {
                    if (Toast.localLOGV)
                        Log.v(Toast.TAG, "SHOW: " + this);
                    this.mHandler.post(this.mShow);
                }
                hide() {
                    if (Toast.localLOGV)
                        Log.v(Toast.TAG, "HIDE: " + this);
                    this.mHandler.post(this.mHide);
                }
                handleShow() {
                    if (Toast.localLOGV)
                        Log.v(Toast.TAG, "HANDLE SHOW: " + this + " mView=" + this.mView + " mNextView=" + this.mNextView);
                    if (this.mView != this.mNextView) {
                        this.handleHide();
                        this.mView = this.mNextView;
                        if (!this.mWindow) {
                            this.mWindow = new Window(this.mView.getContext().getApplicationContext());
                            const params = this.mWindow.getAttributes();
                            params.height = WindowManager.LayoutParams.WRAP_CONTENT;
                            params.width = WindowManager.LayoutParams.WRAP_CONTENT;
                            params.dimAmount = 0;
                            params.type = WindowManager.LayoutParams.TYPE_TOAST;
                            params.setTitle("Toast");
                            params.leftMargin = params.rightMargin = 36 * this.mView.getContext().getResources().getDisplayMetrics().density;
                            params.flags =
                                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
                            this.mWindow.setFloating(true);
                            this.mWindow.setBackgroundColor(android.graphics.Color.TRANSPARENT);
                            this.mWindow.setWindowAnimations(android.R.anim.toast_enter, android.R.anim.toast_exit, null, null);
                        }
                        const params = this.mWindow.getAttributes();
                        this.mWindow.setContentView(this.mView);
                        let context = this.mView.getContext().getApplicationContext();
                        this.mWM = context.getWindowManager();
                        const gravity = Gravity.getAbsoluteGravity(this.mGravity);
                        params.gravity = gravity;
                        params.x = this.mX;
                        params.y = this.mY;
                        if (this.mWindow.getDecorView().getParent() != null) {
                            if (Toast.localLOGV)
                                Log.v(Toast.TAG, "REMOVE! " + this.mView + " in " + this);
                            this.mWM.removeWindow(this.mWindow);
                        }
                        if (Toast.localLOGV)
                            Log.v(Toast.TAG, "ADD! " + this.mView + " in " + this);
                        this.mWM.addWindow(this.mWindow);
                    }
                }
                handleHide() {
                    if (Toast.localLOGV)
                        Log.v(Toast.TAG, "HANDLE HIDE: " + this + " mView=" + this.mView);
                    if (this.mView != null) {
                        if (this.mView.getParent() != null) {
                            if (Toast.localLOGV)
                                Log.v(Toast.TAG, "REMOVE! " + this.mView + " in " + this);
                            this.mWM.removeWindow(this.mWindow);
                        }
                        this.mView = null;
                    }
                }
            }
            Toast.TN = TN;
        })(Toast = widget.Toast || (widget.Toast = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/KeyEvent.ts"/>
var android;
(function (android) {
    var content;
    (function (content) {
        var DialogInterface;
        (function (DialogInterface) {
            DialogInterface.BUTTON_POSITIVE = -1;
            DialogInterface.BUTTON_NEGATIVE = -2;
            DialogInterface.BUTTON_NEUTRAL = -3;
            DialogInterface.BUTTON1 = DialogInterface.BUTTON_POSITIVE;
            DialogInterface.BUTTON2 = DialogInterface.BUTTON_NEGATIVE;
            DialogInterface.BUTTON3 = DialogInterface.BUTTON_NEUTRAL;
        })(DialogInterface = content.DialogInterface || (content.DialogInterface = {}));
    })(content = android.content || (android.content = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/content/DialogInterface.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/os/Bundle.ts"/>
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/os/Message.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/LayoutInflater.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/Window.ts"/>
///<reference path="../../android/view/WindowManager.ts"/>
///<reference path="../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../android/app/Activity.ts"/>
///<reference path="../../android/app/Application.ts"/>
///<reference path="../../android/content/Context.ts"/>
var android;
(function (android) {
    var app;
    (function (app) {
        var Handler = android.os.Handler;
        var Message = android.os.Message;
        var Log = android.util.Log;
        var Gravity = android.view.Gravity;
        var KeyEvent = android.view.KeyEvent;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Window = android.view.Window;
        var WindowManager = android.view.WindowManager;
        var WeakReference = java.lang.ref.WeakReference;
        class Dialog {
            constructor(context, cancelable, cancelListener) {
                this.mCancelable = true;
                this.mCreated = false;
                this.mShowing = false;
                this.mCanceled = false;
                this.mHandler = new Handler();
                this.mDismissAction = (() => {
                    const _this = this;
                    class _Inner {
                        run() {
                            _this.dismissDialog();
                        }
                    }
                    return new _Inner();
                })();
                this.mContext = context;
                this.mWindowManager = context.getWindowManager();
                let w = new Window(context);
                w.setFloating(true);
                w.setDimAmount(0.7);
                w.setBackgroundColor(android.graphics.Color.TRANSPARENT);
                this.mWindow = w;
                let dm = context.getResources().getDisplayMetrics();
                let decor = w.getDecorView();
                decor.setMinimumWidth(dm.density * 280);
                decor.setMinimumHeight(dm.density * 20);
                const onMeasure = decor.onMeasure;
                decor.onMeasure = (widthMeasureSpec, heightMeasureSpec) => {
                    onMeasure.call(decor, widthMeasureSpec, heightMeasureSpec);
                    let width = decor.getMeasuredWidth();
                    if (width > 360 * dm.density) {
                        let widthSpec = View.MeasureSpec.makeMeasureSpec(360 * dm.density, View.MeasureSpec.EXACTLY);
                        onMeasure.call(decor, widthSpec, heightMeasureSpec);
                    }
                };
                let wp = w.getAttributes();
                wp.flags |= WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
                wp.height = wp.width = ViewGroup.LayoutParams.WRAP_CONTENT;
                wp.leftMargin = wp.rightMargin = wp.topMargin = wp.bottomMargin = dm.density * 16;
                w.setWindowAnimations(android.R.anim.dialog_enter, android.R.anim.dialog_exit, null, null);
                w.setChildWindowManager(this.mWindowManager);
                w.setGravity(Gravity.CENTER);
                w.setCallback(this);
                this.mListenersHandler = new Dialog.ListenersHandler(this);
                this.mCancelable = cancelable;
                this.setOnCancelListener(cancelListener);
            }
            getContext() {
                return this.mContext;
            }
            isShowing() {
                return this.mShowing;
            }
            show() {
                if (this.mShowing) {
                    if (this.mDecor != null) {
                        this.mDecor.setVisibility(View.VISIBLE);
                    }
                    return;
                }
                this.mCanceled = false;
                if (!this.mCreated) {
                    this.dispatchOnCreate(null);
                }
                this.onStart();
                this.mDecor = this.mWindow.getDecorView();
                try {
                    this.mWindowManager.addWindow(this.mWindow);
                    this.mShowing = true;
                    this.sendShowMessage();
                }
                finally {
                }
            }
            hide() {
                if (this.mDecor != null) {
                    this.mDecor.setVisibility(View.GONE);
                }
            }
            dismiss() {
                this.dismissDialog();
            }
            dismissDialog() {
                if (this.mDecor == null || !this.mShowing) {
                    return;
                }
                if (this.mWindow.isDestroyed()) {
                    Log.e(Dialog.TAG, "Tried to dismissDialog() but the Dialog's window was already destroyed!");
                    return;
                }
                try {
                    this.mWindowManager.removeWindow(this.mWindow);
                }
                finally {
                    this.mDecor = null;
                    this.onStop();
                    this.mShowing = false;
                    this.sendDismissMessage();
                }
            }
            sendDismissMessage() {
                if (this.mDismissMessage != null) {
                    Message.obtain(this.mDismissMessage).sendToTarget();
                }
            }
            sendShowMessage() {
                if (this.mShowMessage != null) {
                    Message.obtain(this.mShowMessage).sendToTarget();
                }
            }
            dispatchOnCreate(savedInstanceState) {
                if (!this.mCreated) {
                    this.onCreate(savedInstanceState);
                    this.mCreated = true;
                }
            }
            onCreate(savedInstanceState) {
            }
            onStart() {
            }
            onStop() {
            }
            getWindow() {
                return this.mWindow;
            }
            getCurrentFocus() {
                return this.mWindow != null ? this.mWindow.getCurrentFocus() : null;
            }
            findViewById(id) {
                return this.mWindow.findViewById(id);
            }
            setContentView(view, params) {
                this.mWindow.setContentView(view, params);
            }
            addContentView(view, params) {
                this.mWindow.addContentView(view, params);
            }
            setTitle(title) {
                this.mWindow.setTitle(title);
                this.mWindow.getAttributes().setTitle(title);
            }
            onKeyDown(keyCode, event) {
                if (keyCode == KeyEvent.KEYCODE_BACK) {
                    event.startTracking();
                    return true;
                }
                return false;
            }
            onKeyLongPress(keyCode, event) {
                return false;
            }
            onKeyUp(keyCode, event) {
                if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
                    this.onBackPressed();
                    return true;
                }
                return false;
            }
            onKeyMultiple(keyCode, repeatCount, event) {
                return false;
            }
            onBackPressed() {
                if (this.mCancelable) {
                    this.cancel();
                }
            }
            onTouchEvent(event) {
                if (this.mCancelable && this.mShowing && this.mWindow.shouldCloseOnTouch(this.mContext, event)) {
                    this.cancel();
                    return true;
                }
                return false;
            }
            onTrackballEvent(event) {
                return false;
            }
            onGenericMotionEvent(event) {
                return false;
            }
            onWindowAttributesChanged(params) {
                if (this.mDecor != null) {
                    this.mWindowManager.updateWindowLayout(this.mWindow, params);
                }
            }
            onContentChanged() {
            }
            onWindowFocusChanged(hasFocus) {
            }
            onAttachedToWindow() {
            }
            onDetachedFromWindow() {
            }
            dispatchKeyEvent(event) {
                if ((this.mOnKeyListener != null) && (this.mOnKeyListener.onKey(this, event.getKeyCode(), event))) {
                    return true;
                }
                if (this.mWindow.superDispatchKeyEvent(event)) {
                    return true;
                }
                return event.dispatch(this, this.mDecor != null ? this.mDecor.getKeyDispatcherState() : null, this);
            }
            dispatchTouchEvent(ev) {
                if (this.mWindow.superDispatchTouchEvent(ev)) {
                    return true;
                }
                return this.onTouchEvent(ev);
            }
            dispatchGenericMotionEvent(ev) {
                if (this.mWindow.superDispatchGenericMotionEvent(ev)) {
                    return true;
                }
                return this.onGenericMotionEvent(ev);
            }
            takeKeyEvents(get) {
                this.mWindow.takeKeyEvents(get);
            }
            getLayoutInflater() {
                return this.getWindow().getLayoutInflater();
            }
            setCancelable(flag) {
                this.mCancelable = flag;
            }
            setCanceledOnTouchOutside(cancel) {
                if (cancel && !this.mCancelable) {
                    this.mCancelable = true;
                }
                this.mWindow.setCloseOnTouchOutside(cancel);
            }
            cancel() {
                if (!this.mCanceled && this.mCancelMessage != null) {
                    this.mCanceled = true;
                    Message.obtain(this.mCancelMessage).sendToTarget();
                }
                this.dismiss();
            }
            setOnCancelListener(listener) {
                if (this.mCancelAndDismissTaken != null) {
                    throw Error(`new IllegalStateException("OnCancelListener is already taken by " + this.mCancelAndDismissTaken + " and can not be replaced.")`);
                }
                if (listener != null) {
                    this.mCancelMessage = this.mListenersHandler.obtainMessage(Dialog.CANCEL, listener);
                }
                else {
                    this.mCancelMessage = null;
                }
            }
            setCancelMessage(msg) {
                this.mCancelMessage = msg;
            }
            setOnDismissListener(listener) {
                if (this.mCancelAndDismissTaken != null) {
                    throw Error(`new IllegalStateException("OnDismissListener is already taken by " + this.mCancelAndDismissTaken + " and can not be replaced.")`);
                }
                if (listener != null) {
                    this.mDismissMessage = this.mListenersHandler.obtainMessage(Dialog.DISMISS, listener);
                }
                else {
                    this.mDismissMessage = null;
                }
            }
            setOnShowListener(listener) {
                if (listener != null) {
                    this.mShowMessage = this.mListenersHandler.obtainMessage(Dialog.SHOW, listener);
                }
                else {
                    this.mShowMessage = null;
                }
            }
            setDismissMessage(msg) {
                this.mDismissMessage = msg;
            }
            takeCancelAndDismissListeners(msg, cancel, dismiss) {
                if (this.mCancelAndDismissTaken != null) {
                    this.mCancelAndDismissTaken = null;
                }
                else if (this.mCancelMessage != null || this.mDismissMessage != null) {
                    return false;
                }
                this.setOnCancelListener(cancel);
                this.setOnDismissListener(dismiss);
                this.mCancelAndDismissTaken = msg;
                return true;
            }
            setOnKeyListener(onKeyListener) {
                this.mOnKeyListener = onKeyListener;
            }
        }
        Dialog.TAG = "Dialog";
        Dialog.DISMISS = 0x43;
        Dialog.CANCEL = 0x44;
        Dialog.SHOW = 0x45;
        Dialog.DIALOG_SHOWING_TAG = "android:dialogShowing";
        Dialog.DIALOG_HIERARCHY_TAG = "android:dialogHierarchy";
        app.Dialog = Dialog;
        (function (Dialog) {
            class ListenersHandler extends Handler {
                constructor(dialog) {
                    super();
                    this.mDialog = new WeakReference(dialog);
                }
                handleMessage(msg) {
                    switch (msg.what) {
                        case Dialog.DISMISS:
                            msg.obj.onDismiss(this.mDialog.get());
                            break;
                        case Dialog.CANCEL:
                            msg.obj.onCancel(this.mDialog.get());
                            break;
                        case Dialog.SHOW:
                            msg.obj.onShow(this.mDialog.get());
                            break;
                    }
                }
            }
            Dialog.ListenersHandler = ListenersHandler;
        })(Dialog = app.Dialog || (app.Dialog = {}));
    })(app = android.app || (android.app = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/view/LayoutInflater.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/util/Arrays.ts"/>
///<reference path="../../java/util/Collections.ts"/>
///<reference path="../../java/util/Comparator.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/BaseAdapter.ts"/>
///<reference path="../../android/widget/ImageView.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/content/Context.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Log = android.util.Log;
        var Arrays = java.util.Arrays;
        var Collections = java.util.Collections;
        var BaseAdapter = android.widget.BaseAdapter;
        class ArrayAdapter extends BaseAdapter {
            constructor(context, resource, textViewResourceId, objects) {
                super();
                this.mNotifyOnChange = true;
                this.init(context, resource, textViewResourceId, objects);
            }
            add(object) {
                {
                    this.mObjects.add(object);
                }
                if (this.mNotifyOnChange)
                    this.notifyDataSetChanged();
            }
            addAll(collection) {
                {
                    this.mObjects.addAll(collection);
                }
                if (this.mNotifyOnChange)
                    this.notifyDataSetChanged();
            }
            insert(object, index) {
                {
                    this.mObjects.add(index, object);
                }
                if (this.mNotifyOnChange)
                    this.notifyDataSetChanged();
            }
            remove(object) {
                {
                    this.mObjects.remove(object);
                }
                if (this.mNotifyOnChange)
                    this.notifyDataSetChanged();
            }
            clear() {
                {
                    this.mObjects.clear();
                }
                if (this.mNotifyOnChange)
                    this.notifyDataSetChanged();
            }
            sort(comparator) {
                {
                    Collections.sort(this.mObjects, comparator);
                }
                if (this.mNotifyOnChange)
                    this.notifyDataSetChanged();
            }
            notifyDataSetChanged() {
                super.notifyDataSetChanged();
                this.mNotifyOnChange = true;
            }
            setNotifyOnChange(notifyOnChange) {
                this.mNotifyOnChange = notifyOnChange;
            }
            init(context, resource, textViewResourceId, objects) {
                this.mContext = context;
                this.mInflater = context.getLayoutInflater();
                this.mResource = this.mDropDownResource = resource;
                if (objects instanceof Array)
                    objects = Arrays.asList(objects);
                this.mObjects = objects;
                this.mFieldId = textViewResourceId;
            }
            getContext() {
                return this.mContext;
            }
            getCount() {
                return this.mObjects.size();
            }
            getItem(position) {
                return this.mObjects.get(position);
            }
            getPosition(item) {
                return this.mObjects.indexOf(item);
            }
            getItemId(position) {
                return position;
            }
            getView(position, convertView, parent) {
                return this.createViewFromResource(position, convertView, parent, this.mResource);
            }
            createViewFromResource(position, convertView, parent, resource) {
                let view;
                let text;
                if (convertView == null) {
                    view = this.mInflater.inflate(this.mContext.getResources().getLayout(resource), parent, false);
                }
                else {
                    view = convertView;
                }
                try {
                    if (this.mFieldId == null) {
                        text = view;
                    }
                    else {
                        text = view.findViewById(this.mFieldId);
                    }
                }
                catch (e) {
                    Log.e("ArrayAdapter", "You must supply a resource ID for a TextView");
                    throw Error(`new IllegalStateException("ArrayAdapter requires the resource ID to be a TextView", e)`);
                }
                let item = this.getItem(position);
                if (typeof item === 'string') {
                    text.setText(item);
                }
                else {
                    text.setText(item.toString());
                }
                return view;
            }
            setDropDownViewResource(resource) {
                this.mDropDownResource = resource;
            }
            getDropDownView(position, convertView, parent) {
                return this.createViewFromResource(position, convertView, parent, this.mDropDownResource);
            }
        }
        widget.ArrayAdapter = ArrayAdapter;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/app/AlertDialog.ts"/>
///<reference path="../../android/content/DialogInterface.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/graphics/drawable/ColorDrawable.ts"/>
///<reference path="../../android/graphics/Color.ts"/>
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/os/Message.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/LayoutInflater.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/Window.ts"/>
///<reference path="../../android/view/WindowManager.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/ArrayAdapter.ts"/>
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/ImageView.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../android/app/AlertDialog.ts"/>
///<reference path="../../android/app/Dialog.ts"/>
///<reference path="../../android/content/Context.ts"/>
///<reference path="../../android/R/layout.ts"/>
///<reference path="../../android/R/id.ts"/>
var android;
(function (android) {
    var app;
    (function (app) {
        const MATCH_PARENT = android.view.ViewGroup.LayoutParams.MATCH_PARENT;
        var R = android.R;
        var DialogInterface = android.content.DialogInterface;
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var Color = android.graphics.Color;
        var Handler = android.os.Handler;
        var Message = android.os.Message;
        var TextUtils = android.text.TextUtils;
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var LayoutParams = android.view.ViewGroup.LayoutParams;
        var ArrayAdapter = android.widget.ArrayAdapter;
        var LinearLayout = android.widget.LinearLayout;
        var ListView = android.widget.ListView;
        var WeakReference = java.lang.ref.WeakReference;
        class AlertController {
            constructor(context, di, window) {
                this.mViewSpacingLeft = 0;
                this.mViewSpacingTop = 0;
                this.mViewSpacingRight = 0;
                this.mViewSpacingBottom = 0;
                this.mViewSpacingSpecified = false;
                this.mCheckedItem = -1;
                this.mButtonHandler = (() => {
                    const _this = this;
                    class _Inner {
                        onClick(v) {
                            let m = null;
                            if (v == _this.mButtonPositive && _this.mButtonPositiveMessage != null) {
                                m = Message.obtain(_this.mButtonPositiveMessage);
                            }
                            else if (v == _this.mButtonNegative && _this.mButtonNegativeMessage != null) {
                                m = Message.obtain(_this.mButtonNegativeMessage);
                            }
                            else if (v == _this.mButtonNeutral && _this.mButtonNeutralMessage != null) {
                                m = Message.obtain(_this.mButtonNeutralMessage);
                            }
                            if (m != null) {
                                m.sendToTarget();
                            }
                            _this.mHandler.obtainMessage(AlertController.ButtonHandler.MSG_DISMISS_DIALOG, _this.mDialogInterface).sendToTarget();
                        }
                    }
                    return new _Inner();
                })();
                this.mContext = context;
                this.mDialogInterface = di;
                this.mWindow = window;
                this.mHandler = new AlertController.ButtonHandler(di);
                this.mAlertDialogLayout = R.layout.alert_dialog;
                this.mListLayout = R.layout.select_dialog;
                this.mMultiChoiceItemLayout = R.layout.select_dialog_multichoice;
                this.mSingleChoiceItemLayout = R.layout.select_dialog_singlechoice;
                this.mListItemLayout = R.layout.select_dialog_item;
            }
            static shouldCenterSingleButton(context) {
                return true;
            }
            installContent() {
                let layout = this.mContext.getLayoutInflater().inflate(this.mAlertDialogLayout, this.mWindow.getContentParent(), false);
                this.mWindow.setContentView(layout);
                this.setupView();
            }
            setTitle(title) {
                this.mTitle = title;
                if (this.mTitleView != null) {
                    this.mTitleView.setText(title);
                }
            }
            setCustomTitle(customTitleView) {
                this.mCustomTitleView = customTitleView;
            }
            setMessage(message) {
                this.mMessage = message;
                if (this.mMessageView != null) {
                    this.mMessageView.setText(message);
                }
            }
            setView(view, viewSpacingLeft = 0, viewSpacingTop = 0, viewSpacingRight = 0, viewSpacingBottom = 0) {
                this.mView = view;
                if (!viewSpacingLeft && !viewSpacingTop && !viewSpacingRight && !viewSpacingBottom) {
                    this.mViewSpacingSpecified = false;
                }
                else {
                    this.mViewSpacingSpecified = true;
                    this.mViewSpacingLeft = viewSpacingLeft;
                    this.mViewSpacingTop = viewSpacingTop;
                    this.mViewSpacingRight = viewSpacingRight;
                    this.mViewSpacingBottom = viewSpacingBottom;
                }
            }
            setButton(whichButton, text, listener, msg) {
                if (msg == null && listener != null) {
                    msg = this.mHandler.obtainMessage(whichButton, listener);
                }
                switch (whichButton) {
                    case DialogInterface.BUTTON_POSITIVE:
                        this.mButtonPositiveText = text;
                        this.mButtonPositiveMessage = msg;
                        break;
                    case DialogInterface.BUTTON_NEGATIVE:
                        this.mButtonNegativeText = text;
                        this.mButtonNegativeMessage = msg;
                        break;
                    case DialogInterface.BUTTON_NEUTRAL:
                        this.mButtonNeutralText = text;
                        this.mButtonNeutralMessage = msg;
                        break;
                    default:
                        throw Error(`new IllegalArgumentException("Button does not exist")`);
                }
            }
            setIcon(icon) {
                this.mIcon = icon;
                if ((this.mIconView != null) && (this.mIcon != null)) {
                    this.mIconView.setImageDrawable(icon);
                }
            }
            setInverseBackgroundForced(forceInverseBackground) {
                this.mForceInverseBackground = forceInverseBackground;
            }
            getListView() {
                return this.mListView;
            }
            getButton(whichButton) {
                switch (whichButton) {
                    case DialogInterface.BUTTON_POSITIVE:
                        return this.mButtonPositive;
                    case DialogInterface.BUTTON_NEGATIVE:
                        return this.mButtonNegative;
                    case DialogInterface.BUTTON_NEUTRAL:
                        return this.mButtonNeutral;
                    default:
                        return null;
                }
            }
            onKeyDown(keyCode, event) {
                return this.mScrollView != null && this.mScrollView.executeKeyEvent(event);
            }
            onKeyUp(keyCode, event) {
                return this.mScrollView != null && this.mScrollView.executeKeyEvent(event);
            }
            setupView() {
                let contentPanel = this.mWindow.findViewById(R.id.contentPanel);
                this.setupContent(contentPanel);
                let hasButtons = this.setupButtons();
                let topPanel = this.mWindow.findViewById(R.id.topPanel);
                let hasTitle = this.setupTitle(topPanel);
                let buttonPanel = this.mWindow.findViewById(R.id.buttonPanel);
                if (!hasButtons) {
                    buttonPanel.setVisibility(View.GONE);
                    this.mWindow.setCloseOnTouchOutsideIfNotSet(true);
                }
                let customPanel = null;
                if (this.mView != null) {
                    customPanel = this.mWindow.findViewById(R.id.customPanel);
                    let custom = this.mWindow.findViewById(R.id.custom);
                    custom.addView(this.mView, new LayoutParams(MATCH_PARENT, MATCH_PARENT));
                    if (this.mViewSpacingSpecified) {
                        custom.setPadding(this.mViewSpacingLeft, this.mViewSpacingTop, this.mViewSpacingRight, this.mViewSpacingBottom);
                    }
                    if (this.mListView != null) {
                        customPanel.getLayoutParams().weight = 0;
                    }
                }
                else {
                    this.mWindow.findViewById(R.id.customPanel).setVisibility(View.GONE);
                }
                if (hasTitle) {
                    let divider = null;
                    if (this.mMessage != null || this.mView != null || this.mListView != null) {
                        divider = this.mWindow.findViewById(R.id.titleDivider);
                    }
                    else {
                        divider = this.mWindow.findViewById(R.id.titleDividerTop);
                    }
                    if (divider != null) {
                        divider.setVisibility(View.VISIBLE);
                    }
                }
                this.setBackground(topPanel, contentPanel, customPanel, hasButtons, hasTitle, buttonPanel);
            }
            setupTitle(topPanel) {
                let hasTitle = true;
                if (this.mCustomTitleView != null) {
                    let lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                    topPanel.addView(this.mCustomTitleView, 0, lp);
                    let titleTemplate = this.mWindow.findViewById(R.id.title_template);
                    titleTemplate.setVisibility(View.GONE);
                }
                else {
                    const hasTextTitle = !TextUtils.isEmpty(this.mTitle);
                    this.mIconView = this.mWindow.findViewById(R.id.icon);
                    if (hasTextTitle) {
                        this.mTitleView = this.mWindow.findViewById(R.id.alertTitle);
                        this.mTitleView.setText(this.mTitle);
                        if (this.mIcon != null) {
                            this.mIconView.setImageDrawable(this.mIcon);
                        }
                        else {
                            this.mTitleView.setPadding(this.mIconView.getPaddingLeft(), this.mIconView.getPaddingTop(), this.mIconView.getPaddingRight(), this.mIconView.getPaddingBottom());
                            this.mIconView.setVisibility(View.GONE);
                        }
                    }
                    else {
                        let titleTemplate = this.mWindow.findViewById(R.id.title_template);
                        titleTemplate.setVisibility(View.GONE);
                        this.mIconView.setVisibility(View.GONE);
                        topPanel.setVisibility(View.GONE);
                        hasTitle = false;
                    }
                }
                return hasTitle;
            }
            setupContent(contentPanel) {
                this.mScrollView = this.mWindow.findViewById(R.id.scrollView);
                this.mScrollView.setFocusable(false);
                this.mMessageView = this.mWindow.findViewById(R.id.message);
                if (this.mMessageView == null) {
                    return;
                }
                if (this.mMessage != null) {
                    this.mMessageView.setText(this.mMessage);
                }
                else {
                    this.mMessageView.setVisibility(View.GONE);
                    this.mScrollView.removeView(this.mMessageView);
                    if (this.mListView != null) {
                        contentPanel.removeView(this.mWindow.findViewById(R.id.scrollView));
                        contentPanel.addView(this.mListView, new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT));
                        contentPanel.setLayoutParams(new LinearLayout.LayoutParams(MATCH_PARENT, 0, 1.0));
                    }
                    else {
                        contentPanel.setVisibility(View.GONE);
                    }
                }
            }
            setupButtons() {
                let BIT_BUTTON_POSITIVE = 1;
                let BIT_BUTTON_NEGATIVE = 2;
                let BIT_BUTTON_NEUTRAL = 4;
                let whichButtons = 0;
                this.mButtonPositive = this.mWindow.findViewById(R.id.button1);
                this.mButtonPositive.setOnClickListener(this.mButtonHandler);
                if (TextUtils.isEmpty(this.mButtonPositiveText)) {
                    this.mButtonPositive.setVisibility(View.GONE);
                }
                else {
                    this.mButtonPositive.setText(this.mButtonPositiveText);
                    this.mButtonPositive.setVisibility(View.VISIBLE);
                    whichButtons = whichButtons | BIT_BUTTON_POSITIVE;
                }
                this.mButtonNegative = this.mWindow.findViewById(R.id.button2);
                this.mButtonNegative.setOnClickListener(this.mButtonHandler);
                if (TextUtils.isEmpty(this.mButtonNegativeText)) {
                    this.mButtonNegative.setVisibility(View.GONE);
                }
                else {
                    this.mButtonNegative.setText(this.mButtonNegativeText);
                    this.mButtonNegative.setVisibility(View.VISIBLE);
                    whichButtons = whichButtons | BIT_BUTTON_NEGATIVE;
                }
                this.mButtonNeutral = this.mWindow.findViewById(R.id.button3);
                this.mButtonNeutral.setOnClickListener(this.mButtonHandler);
                if (TextUtils.isEmpty(this.mButtonNeutralText)) {
                    this.mButtonNeutral.setVisibility(View.GONE);
                }
                else {
                    this.mButtonNeutral.setText(this.mButtonNeutralText);
                    this.mButtonNeutral.setVisibility(View.VISIBLE);
                    whichButtons = whichButtons | BIT_BUTTON_NEUTRAL;
                }
                if (AlertController.shouldCenterSingleButton(this.mContext)) {
                    if (whichButtons == BIT_BUTTON_POSITIVE) {
                        this.centerButton(this.mButtonPositive);
                    }
                    else if (whichButtons == BIT_BUTTON_NEGATIVE) {
                        this.centerButton(this.mButtonNegative);
                    }
                    else if (whichButtons == BIT_BUTTON_NEUTRAL) {
                        this.centerButton(this.mButtonNeutral);
                    }
                }
                return whichButtons != 0;
            }
            centerButton(button) {
                let params = button.getLayoutParams();
                params.gravity = Gravity.CENTER_HORIZONTAL;
                params.weight = 0.5;
                button.setLayoutParams(params);
                let leftSpacer = this.mWindow.findViewById(R.id.leftSpacer);
                if (leftSpacer != null) {
                    leftSpacer.setVisibility(View.VISIBLE);
                }
                let rightSpacer = this.mWindow.findViewById(R.id.rightSpacer);
                if (rightSpacer != null) {
                    rightSpacer.setVisibility(View.VISIBLE);
                }
            }
            setBackground(topPanel, contentPanel, customPanel, hasButtons, hasTitle, buttonPanel) {
                let fullDark = new ColorDrawable(Color.WHITE);
                let topDark = new ColorDrawable(Color.WHITE);
                let centerDark = new ColorDrawable(Color.WHITE);
                let bottomDark = new ColorDrawable(Color.WHITE);
                let fullBright = new ColorDrawable(Color.WHITE);
                let topBright = new ColorDrawable(Color.WHITE);
                let centerBright = new ColorDrawable(Color.WHITE);
                let bottomBright = new ColorDrawable(Color.WHITE);
                let bottomMedium = new ColorDrawable(Color.WHITE);
                let views = new Array(4);
                let light = new Array(4);
                let lastView = null;
                let lastLight = false;
                let pos = 0;
                if (hasTitle) {
                    views[pos] = topPanel;
                    light[pos] = false;
                    pos++;
                }
                views[pos] = (contentPanel.getVisibility() == View.GONE) ? null : contentPanel;
                light[pos] = this.mListView != null;
                pos++;
                if (customPanel != null) {
                    views[pos] = customPanel;
                    light[pos] = this.mForceInverseBackground;
                    pos++;
                }
                if (hasButtons) {
                    views[pos] = buttonPanel;
                    light[pos] = true;
                }
                let setView = false;
                for (pos = 0; pos < views.length; pos++) {
                    let v = views[pos];
                    if (v == null) {
                        continue;
                    }
                    if (lastView != null) {
                        if (!setView) {
                            lastView.setBackground(lastLight ? topBright : topDark);
                        }
                        else {
                            lastView.setBackground(lastLight ? centerBright : centerDark);
                        }
                        setView = true;
                    }
                    lastView = v;
                    lastLight = light[pos];
                }
                if (lastView != null) {
                    if (setView) {
                        lastView.setBackground(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
                    }
                    else {
                        lastView.setBackground(lastLight ? fullBright : fullDark);
                    }
                }
                if ((this.mListView != null) && (this.mAdapter != null)) {
                    this.mListView.setAdapter(this.mAdapter);
                    if (this.mCheckedItem > -1) {
                        this.mListView.setItemChecked(this.mCheckedItem, true);
                        this.mListView.setSelection(this.mCheckedItem);
                    }
                }
            }
        }
        app.AlertController = AlertController;
        (function (AlertController) {
            class ButtonHandler extends Handler {
                constructor(dialog) {
                    super();
                    this.mDialog = new WeakReference(dialog);
                }
                handleMessage(msg) {
                    switch (msg.what) {
                        case DialogInterface.BUTTON_POSITIVE:
                        case DialogInterface.BUTTON_NEGATIVE:
                        case DialogInterface.BUTTON_NEUTRAL:
                            msg.obj.onClick(this.mDialog.get(), msg.what);
                            break;
                        case ButtonHandler.MSG_DISMISS_DIALOG:
                            msg.obj.dismiss();
                    }
                }
            }
            ButtonHandler.MSG_DISMISS_DIALOG = 1;
            AlertController.ButtonHandler = ButtonHandler;
            class RecycleListView extends ListView {
                constructor(context, bindElement, defStyle) {
                    super(context, bindElement, defStyle);
                    this.mRecycleOnMeasure = true;
                }
                recycleOnMeasure() {
                    return this.mRecycleOnMeasure;
                }
            }
            AlertController.RecycleListView = RecycleListView;
            class AlertParams {
                constructor(context) {
                    this.mIconId = 0;
                    this.mViewSpacingLeft = 0;
                    this.mViewSpacingTop = 0;
                    this.mViewSpacingRight = 0;
                    this.mViewSpacingBottom = 0;
                    this.mViewSpacingSpecified = false;
                    this.mCheckedItem = -1;
                    this.mRecycleOnMeasure = true;
                    this.mContext = context;
                    this.mCancelable = true;
                    this.mInflater = context.getLayoutInflater();
                }
                apply(dialog) {
                    if (this.mCustomTitleView != null) {
                        dialog.setCustomTitle(this.mCustomTitleView);
                    }
                    else {
                        if (this.mTitle != null) {
                            dialog.setTitle(this.mTitle);
                        }
                        if (this.mIcon != null) {
                            dialog.setIcon(this.mIcon);
                        }
                    }
                    if (this.mMessage != null) {
                        dialog.setMessage(this.mMessage);
                    }
                    if (this.mPositiveButtonText != null) {
                        dialog.setButton(DialogInterface.BUTTON_POSITIVE, this.mPositiveButtonText, this.mPositiveButtonListener, null);
                    }
                    if (this.mNegativeButtonText != null) {
                        dialog.setButton(DialogInterface.BUTTON_NEGATIVE, this.mNegativeButtonText, this.mNegativeButtonListener, null);
                    }
                    if (this.mNeutralButtonText != null) {
                        dialog.setButton(DialogInterface.BUTTON_NEUTRAL, this.mNeutralButtonText, this.mNeutralButtonListener, null);
                    }
                    if (this.mForceInverseBackground) {
                        dialog.setInverseBackgroundForced(true);
                    }
                    if ((this.mItems != null) || (this.mAdapter != null)) {
                        this.createListView(dialog);
                    }
                    if (this.mView != null) {
                        if (this.mViewSpacingSpecified) {
                            dialog.setView(this.mView, this.mViewSpacingLeft, this.mViewSpacingTop, this.mViewSpacingRight, this.mViewSpacingBottom);
                        }
                        else {
                            dialog.setView(this.mView);
                        }
                    }
                }
                createListView(dialog) {
                    const listView = this.mInflater.inflate(dialog.mListLayout, null);
                    let adapter;
                    if (this.mIsMultiChoice) {
                        adapter = (() => {
                            const _this = this;
                            class _Inner extends ArrayAdapter {
                                getView(position, convertView, parent) {
                                    let view = super.getView(position, convertView, parent);
                                    if (_this.mCheckedItems != null) {
                                        let isItemChecked = _this.mCheckedItems[position];
                                        if (isItemChecked) {
                                            listView.setItemChecked(position, true);
                                        }
                                    }
                                    return view;
                                }
                            }
                            return new _Inner(this.mContext, dialog.mMultiChoiceItemLayout, R.id.text1, this.mItems);
                        })();
                    }
                    else {
                        let layout = this.mIsSingleChoice ? dialog.mSingleChoiceItemLayout : dialog.mListItemLayout;
                        adapter = (this.mAdapter != null) ? this.mAdapter : new ArrayAdapter(this.mContext, layout, R.id.text1, this.mItems);
                    }
                    if (this.mOnPrepareListViewListener != null) {
                        this.mOnPrepareListViewListener.onPrepareListView(listView);
                    }
                    dialog.mAdapter = adapter;
                    dialog.mCheckedItem = this.mCheckedItem;
                    const _this = this;
                    if (this.mOnClickListener != null) {
                        listView.setOnItemClickListener({
                            onItemClick(parent, v, position, id) {
                                _this.mOnClickListener.onClick(dialog.mDialogInterface, position);
                                if (!_this.mIsSingleChoice) {
                                    dialog.mDialogInterface.dismiss();
                                }
                            }
                        });
                    }
                    else if (this.mOnCheckboxClickListener != null) {
                        listView.setOnItemClickListener({
                            onItemClick(parent, v, position, id) {
                                if (_this.mCheckedItems != null) {
                                    _this.mCheckedItems[position] = listView.isItemChecked(position);
                                }
                                _this.mOnCheckboxClickListener.onClick(dialog.mDialogInterface, position, listView.isItemChecked(position));
                            }
                        });
                    }
                    if (this.mOnItemSelectedListener != null) {
                        listView.setOnItemSelectedListener(this.mOnItemSelectedListener);
                    }
                    if (this.mIsSingleChoice) {
                        listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
                    }
                    else if (this.mIsMultiChoice) {
                        listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
                    }
                    listView.mRecycleOnMeasure = this.mRecycleOnMeasure;
                    dialog.mListView = listView;
                }
            }
            AlertController.AlertParams = AlertParams;
        })(AlertController = app.AlertController || (app.AlertController = {}));
    })(app = android.app || (android.app = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/content/DialogInterface.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/os/Bundle.ts"/>
///<reference path="../../android/os/Message.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/WindowManager.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/app/Application.ts"/>
///<reference path="../../android/app/Dialog.ts"/>
///<reference path="../../android/app/AlertController.ts"/>
///<reference path="../../android/content/Context.ts"/>
var android;
(function (android) {
    var app;
    (function (app) {
        var Dialog = android.app.Dialog;
        class AlertDialog extends Dialog {
            constructor(context, cancelable, cancelListener) {
                super(context);
                this.setCancelable(cancelable);
                this.setOnCancelListener(cancelListener);
                this.mAlert = new app.AlertController(context, this, this.getWindow());
            }
            getButton(whichButton) {
                return this.mAlert.getButton(whichButton);
            }
            getListView() {
                return this.mAlert.getListView();
            }
            setTitle(title) {
                super.setTitle(title);
                this.mAlert.setTitle(title);
            }
            setCustomTitle(customTitleView) {
                this.mAlert.setCustomTitle(customTitleView);
            }
            setMessage(message) {
                this.mAlert.setMessage(message);
            }
            setView(view, viewSpacingLeft = 0, viewSpacingTop = 0, viewSpacingRight = 0, viewSpacingBottom = 0) {
                this.mAlert.setView(view, viewSpacingLeft, viewSpacingTop, viewSpacingRight, viewSpacingBottom);
            }
            setButton(whichButton, text, listener) {
                this.mAlert.setButton(whichButton, text, listener, null);
            }
            setIcon(icon) {
                this.mAlert.setIcon(icon);
            }
            onCreate(savedInstanceState) {
                super.onCreate(savedInstanceState);
                this.mAlert.installContent();
            }
            onKeyDown(keyCode, event) {
                if (this.mAlert.onKeyDown(keyCode, event))
                    return true;
                return super.onKeyDown(keyCode, event);
            }
            onKeyUp(keyCode, event) {
                if (this.mAlert.onKeyUp(keyCode, event))
                    return true;
                return super.onKeyUp(keyCode, event);
            }
        }
        AlertDialog.THEME_TRADITIONAL = 1;
        AlertDialog.THEME_HOLO_DARK = 2;
        AlertDialog.THEME_HOLO_LIGHT = 3;
        AlertDialog.THEME_DEVICE_DEFAULT_DARK = 4;
        AlertDialog.THEME_DEVICE_DEFAULT_LIGHT = 5;
        app.AlertDialog = AlertDialog;
        (function (AlertDialog) {
            class Builder {
                constructor(context) {
                    this.P = new app.AlertController.AlertParams(context);
                }
                getContext() {
                    return this.P.mContext;
                }
                setTitle(title) {
                    this.P.mTitle = title;
                    return this;
                }
                setCustomTitle(customTitleView) {
                    this.P.mCustomTitleView = customTitleView;
                    return this;
                }
                setMessage(message) {
                    this.P.mMessage = message;
                    return this;
                }
                setIcon(icon) {
                    this.P.mIcon = icon;
                    return this;
                }
                setPositiveButton(text, listener) {
                    this.P.mPositiveButtonText = text;
                    this.P.mPositiveButtonListener = listener;
                    return this;
                }
                setNegativeButton(text, listener) {
                    this.P.mNegativeButtonText = text;
                    this.P.mNegativeButtonListener = listener;
                    return this;
                }
                setNeutralButton(text, listener) {
                    this.P.mNeutralButtonText = text;
                    this.P.mNeutralButtonListener = listener;
                    return this;
                }
                setCancelable(cancelable) {
                    this.P.mCancelable = cancelable;
                    return this;
                }
                setOnCancelListener(onCancelListener) {
                    this.P.mOnCancelListener = onCancelListener;
                    return this;
                }
                setOnDismissListener(onDismissListener) {
                    this.P.mOnDismissListener = onDismissListener;
                    return this;
                }
                setOnKeyListener(onKeyListener) {
                    this.P.mOnKeyListener = onKeyListener;
                    return this;
                }
                setItems(items, listener) {
                    this.P.mItems = items;
                    this.P.mOnClickListener = listener;
                    return this;
                }
                setAdapter(adapter, listener) {
                    this.P.mAdapter = adapter;
                    this.P.mOnClickListener = listener;
                    return this;
                }
                setMultiChoiceItems(items, checkedItems, listener) {
                    this.P.mItems = items;
                    this.P.mOnCheckboxClickListener = listener;
                    this.P.mCheckedItems = checkedItems;
                    this.P.mIsMultiChoice = true;
                    return this;
                }
                setSingleChoiceItems(items, checkedItem, listener) {
                    this.P.mItems = items;
                    this.P.mOnClickListener = listener;
                    this.P.mCheckedItem = checkedItem;
                    this.P.mIsSingleChoice = true;
                    return this;
                }
                setSingleChoiceItemsWithAdapter(adapter, checkedItem, listener) {
                    this.P.mAdapter = adapter;
                    this.P.mOnClickListener = listener;
                    this.P.mCheckedItem = checkedItem;
                    this.P.mIsSingleChoice = true;
                    return this;
                }
                setOnItemSelectedListener(listener) {
                    this.P.mOnItemSelectedListener = listener;
                    return this;
                }
                setView(view, viewSpacingLeft = 0, viewSpacingTop = 0, viewSpacingRight = 0, viewSpacingBottom = 0) {
                    this.P.mView = view;
                    if (!viewSpacingLeft && !viewSpacingTop && !viewSpacingRight && !viewSpacingBottom) {
                        this.P.mViewSpacingSpecified = false;
                    }
                    else {
                        this.P.mViewSpacingSpecified = true;
                        this.P.mViewSpacingLeft = viewSpacingLeft;
                        this.P.mViewSpacingTop = viewSpacingTop;
                        this.P.mViewSpacingRight = viewSpacingRight;
                        this.P.mViewSpacingBottom = viewSpacingBottom;
                    }
                    return this;
                }
                setInverseBackgroundForced(useInverseBackground) {
                    this.P.mForceInverseBackground = useInverseBackground;
                    return this;
                }
                setRecycleOnMeasureEnabled(enabled) {
                    this.P.mRecycleOnMeasure = enabled;
                    return this;
                }
                create() {
                    const dialog = new AlertDialog(this.P.mContext);
                    this.P.apply(dialog.mAlert);
                    dialog.setCancelable(this.P.mCancelable);
                    if (this.P.mCancelable) {
                        dialog.setCanceledOnTouchOutside(true);
                    }
                    dialog.setOnCancelListener(this.P.mOnCancelListener);
                    dialog.setOnDismissListener(this.P.mOnDismissListener);
                    if (this.P.mOnKeyListener != null) {
                        dialog.setOnKeyListener(this.P.mOnKeyListener);
                    }
                    return dialog;
                }
                show() {
                    let dialog = this.create();
                    dialog.show();
                    return dialog;
                }
            }
            AlertDialog.Builder = Builder;
        })(AlertDialog = app.AlertDialog || (app.AlertDialog = {}));
    })(app = android.app || (android.app = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/ArrayAdapter.ts"/>
///<reference path="../../android/widget/Spinner.ts"/>
///<reference path="../../android/widget/SpinnerAdapter.ts"/>
///<reference path="../../android/content/Context.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var SparseArray = android.util.SparseArray;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var AdapterView = android.widget.AdapterView;
        var ArrayAdapter = android.widget.ArrayAdapter;
        class AbsSpinner extends AdapterView {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, null);
                this.mHeightMeasureSpec = 0;
                this.mWidthMeasureSpec = 0;
                this.mSelectionLeftPadding = 0;
                this.mSelectionTopPadding = 0;
                this.mSelectionRightPadding = 0;
                this.mSelectionBottomPadding = 0;
                this.mSpinnerPadding = new Rect();
                this.mRecycler = new AbsSpinner.RecycleBin(this);
                this.initAbsSpinner();
                let a = this._attrBinder;
                a.addAttr('entries', (value) => {
                    let entries = a.parseTextArray(value);
                    if (entries != null) {
                        let adapter = new ArrayAdapter(context, android.R.layout.simple_spinner_item, null, entries);
                        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                        this.setAdapter(adapter);
                    }
                });
                if (defStyle)
                    this.applyDefaultAttributes(defStyle);
            }
            initAbsSpinner() {
                this.setFocusable(true);
                this.setWillNotDraw(false);
            }
            setAdapter(adapter) {
                if (null != this.mAdapter) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                    this.resetList();
                }
                this.mAdapter = adapter;
                this.mOldSelectedPosition = AbsSpinner.INVALID_POSITION;
                this.mOldSelectedRowId = AbsSpinner.INVALID_ROW_ID;
                if (this.mAdapter != null) {
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                    this.checkFocus();
                    this.mDataSetObserver = new AdapterView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    let position = this.mItemCount > 0 ? 0 : AbsSpinner.INVALID_POSITION;
                    this.setSelectedPositionInt(position);
                    this.setNextSelectedPositionInt(position);
                    if (this.mItemCount == 0) {
                        this.checkSelectionChanged();
                    }
                }
                else {
                    this.checkFocus();
                    this.resetList();
                    this.checkSelectionChanged();
                }
                this.requestLayout();
            }
            resetList() {
                this.mDataChanged = false;
                this.mNeedSync = false;
                this.removeAllViewsInLayout();
                this.mOldSelectedPosition = AbsSpinner.INVALID_POSITION;
                this.mOldSelectedRowId = AbsSpinner.INVALID_ROW_ID;
                this.setSelectedPositionInt(AbsSpinner.INVALID_POSITION);
                this.setNextSelectedPositionInt(AbsSpinner.INVALID_POSITION);
                this.invalidate();
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let widthMode = AbsSpinner.MeasureSpec.getMode(widthMeasureSpec);
                let widthSize;
                let heightSize;
                this.mSpinnerPadding.left = this.mPaddingLeft > this.mSelectionLeftPadding ? this.mPaddingLeft : this.mSelectionLeftPadding;
                this.mSpinnerPadding.top = this.mPaddingTop > this.mSelectionTopPadding ? this.mPaddingTop : this.mSelectionTopPadding;
                this.mSpinnerPadding.right = this.mPaddingRight > this.mSelectionRightPadding ? this.mPaddingRight : this.mSelectionRightPadding;
                this.mSpinnerPadding.bottom = this.mPaddingBottom > this.mSelectionBottomPadding ? this.mPaddingBottom : this.mSelectionBottomPadding;
                if (this.mDataChanged) {
                    this.handleDataChanged();
                }
                let preferredHeight = 0;
                let preferredWidth = 0;
                let needsMeasuring = true;
                let selectedPosition = this.getSelectedItemPosition();
                if (selectedPosition >= 0 && this.mAdapter != null && selectedPosition < this.mAdapter.getCount()) {
                    let view = this.mRecycler.get(selectedPosition);
                    if (view == null) {
                        view = this.mAdapter.getView(selectedPosition, null, this);
                    }
                    if (view != null) {
                        this.mRecycler.put(selectedPosition, view);
                        if (view.getLayoutParams() == null) {
                            this.mBlockLayoutRequests = true;
                            view.setLayoutParams(this.generateDefaultLayoutParams());
                            this.mBlockLayoutRequests = false;
                        }
                        this.measureChild(view, widthMeasureSpec, heightMeasureSpec);
                        preferredHeight = this.getChildHeight(view) + this.mSpinnerPadding.top + this.mSpinnerPadding.bottom;
                        preferredWidth = this.getChildWidth(view) + this.mSpinnerPadding.left + this.mSpinnerPadding.right;
                        needsMeasuring = false;
                    }
                }
                if (needsMeasuring) {
                    preferredHeight = this.mSpinnerPadding.top + this.mSpinnerPadding.bottom;
                    if (widthMode == AbsSpinner.MeasureSpec.UNSPECIFIED) {
                        preferredWidth = this.mSpinnerPadding.left + this.mSpinnerPadding.right;
                    }
                }
                preferredHeight = Math.max(preferredHeight, this.getSuggestedMinimumHeight());
                preferredWidth = Math.max(preferredWidth, this.getSuggestedMinimumWidth());
                heightSize = AbsSpinner.resolveSizeAndState(preferredHeight, heightMeasureSpec, 0);
                widthSize = AbsSpinner.resolveSizeAndState(preferredWidth, widthMeasureSpec, 0);
                this.setMeasuredDimension(widthSize, heightSize);
                this.mHeightMeasureSpec = heightMeasureSpec;
                this.mWidthMeasureSpec = widthMeasureSpec;
            }
            getChildHeight(child) {
                return child.getMeasuredHeight();
            }
            getChildWidth(child) {
                return child.getMeasuredWidth();
            }
            generateDefaultLayoutParams() {
                return new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            }
            recycleAllViews() {
                const childCount = this.getChildCount();
                const recycleBin = this.mRecycler;
                const position = this.mFirstPosition;
                for (let i = 0; i < childCount; i++) {
                    let v = this.getChildAt(i);
                    let index = position + i;
                    recycleBin.put(index, v);
                }
            }
            setSelection(position, animate) {
                if (arguments.length === 1) {
                    this.setNextSelectedPositionInt(position);
                    this.requestLayout();
                    this.invalidate();
                }
                else {
                    let shouldAnimate = animate && this.mFirstPosition <= position && position <= this.mFirstPosition + this.getChildCount() - 1;
                    this.setSelectionInt(position, shouldAnimate);
                }
            }
            setSelectionInt(position, animate) {
                if (position != this.mOldSelectedPosition) {
                    this.mBlockLayoutRequests = true;
                    let delta = position - this.mSelectedPosition;
                    this.setNextSelectedPositionInt(position);
                    this.layoutSpinner(delta, animate);
                    this.mBlockLayoutRequests = false;
                }
            }
            getSelectedView() {
                if (this.mItemCount > 0 && this.mSelectedPosition >= 0) {
                    return this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                }
                else {
                    return null;
                }
            }
            requestLayout() {
                if (!this.mBlockLayoutRequests) {
                    super.requestLayout();
                }
            }
            getAdapter() {
                return this.mAdapter;
            }
            getCount() {
                return this.mItemCount;
            }
            pointToPosition(x, y) {
                let frame = this.mTouchFrame;
                if (frame == null) {
                    this.mTouchFrame = new Rect();
                    frame = this.mTouchFrame;
                }
                const count = this.getChildCount();
                for (let i = count - 1; i >= 0; i--) {
                    let child = this.getChildAt(i);
                    if (child.getVisibility() == View.VISIBLE) {
                        child.getHitRect(frame);
                        if (frame.contains(x, y)) {
                            return this.mFirstPosition + i;
                        }
                    }
                }
                return AbsSpinner.INVALID_POSITION;
            }
        }
        widget.AbsSpinner = AbsSpinner;
        (function (AbsSpinner) {
            class RecycleBin {
                constructor(arg) {
                    this.mScrapHeap = new SparseArray();
                    this._AbsSpinner_this = arg;
                }
                put(position, v) {
                    this.mScrapHeap.put(position, v);
                }
                get(position) {
                    let result = this.mScrapHeap.get(position);
                    if (result != null) {
                        this.mScrapHeap.delete(position);
                    }
                    else {
                    }
                    return result;
                }
                clear() {
                    const scrapHeap = this.mScrapHeap;
                    const count = scrapHeap.size();
                    for (let i = 0; i < count; i++) {
                        const view = scrapHeap.valueAt(i);
                        if (view != null) {
                            this._AbsSpinner_this.removeDetachedView(view, true);
                        }
                    }
                    scrapHeap.clear();
                }
            }
            AbsSpinner.RecycleBin = RecycleBin;
        })(AbsSpinner = widget.AbsSpinner || (widget.AbsSpinner = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/content/Context.ts"/>
///<reference path="../../android/graphics/PixelFormat.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/graphics/drawable/StateListDrawable.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewTreeObserver.ts"/>
///<reference path="../../android/view/Window.ts"/>
///<reference path="../../android/view/WindowManager.ts"/>
///<reference path="../../android/view/animation/Animation.ts"/>
///<reference path="../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/Spinner.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/R/attr.ts"/>
///<reference path="../../android/R/anim.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var R = android.R;
        var Context = android.content.Context;
        var Rect = android.graphics.Rect;
        var Gravity = android.view.Gravity;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var WindowManager = android.view.WindowManager;
        var Window = android.view.Window;
        var WeakReference = java.lang.ref.WeakReference;
        class PopupWindow {
            constructor(...args) {
                this.mInputMethodMode = PopupWindow.INPUT_METHOD_FROM_FOCUSABLE;
                this.mTouchable = true;
                this.mOutsideTouchable = false;
                this.mSplitTouchEnabled = -1;
                this.mAllowScrollingAnchorParent = true;
                this.mDrawingLocation = [0, 0];
                this.mScreenLocation = [0, 0];
                this.mTempRect = new Rect();
                this.mWindowLayoutType = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;
                this.mDefaultDropdownAboveEnterAnimation = R.anim.grow_fade_in_from_bottom;
                this.mDefaultDropdownBelowEnterAnimation = R.anim.grow_fade_in;
                this.mDefaultDropdownAboveExitAnimation = R.anim.shrink_fade_out_from_bottom;
                this.mDefaultDropdownBelowExitAnimation = R.anim.shrink_fade_out;
                this.mOnScrollChangedListener = (() => {
                    const _this = this;
                    class _Inner {
                        onScrollChanged() {
                            let anchor = _this.mAnchor != null ? _this.mAnchor.get() : null;
                            if (anchor != null && _this.mPopupView != null) {
                                let p = _this.mPopupView.getLayoutParams();
                                _this.updateAboveAnchor(_this.findDropDownPosition(anchor, p, _this.mAnchorXoff, _this.mAnchorYoff, _this.mAnchoredGravity));
                                _this.update(p.x, p.y, -1, -1, true);
                            }
                        }
                    }
                    return new _Inner();
                })();
                if (args[0] instanceof Context) {
                    let context = args[0];
                    let styleAttr = args.length == 1 ? R.attr.popupWindowStyle : args[1];
                    this.mContext = context;
                    this.mWindowManager = context.getWindowManager();
                    this.mPopupWindow = new Window(context);
                    this.mPopupWindow.setCallback(this);
                    this.mBackground = styleAttr.popupBackground;
                    this.mEnterAnimation = styleAttr.popupEnterAnimation;
                    this.mExitAnimation = styleAttr.popupExitAnimation;
                }
                else {
                    let [contentView = null, width = 0, height = 0, focusable = false] = args;
                    if (contentView != null) {
                        this.mContext = contentView.getContext();
                        this.mWindowManager = this.mContext.getWindowManager();
                        this.mPopupWindow = new Window(this.mContext);
                        this.mPopupWindow.setCallback(this);
                    }
                    this.setContentView(contentView);
                    this.setWidth(width);
                    this.setHeight(height);
                    this.setFocusable(focusable);
                }
            }
            getBackground() {
                return this.mBackground;
            }
            setBackgroundDrawable(background) {
                this.mBackground = background;
            }
            getEnterAnimation() {
                return this.mEnterAnimation;
            }
            getExitAnimation() {
                return this.mExitAnimation;
            }
            setWindowAnimation(enterAnimation, exitAnimation) {
                this.mEnterAnimation = enterAnimation;
                this.mExitAnimation = exitAnimation;
            }
            getContentView() {
                return this.mContentView;
            }
            setContentView(contentView) {
                if (this.isShowing()) {
                    return;
                }
                this.mContentView = contentView;
                if (this.mContext == null && this.mContentView != null) {
                    this.mContext = this.mContentView.getContext();
                }
                if (this.mWindowManager == null && this.mContentView != null) {
                    this.mWindowManager = this.mContext.getWindowManager();
                }
                if (this.mPopupWindow == null && this.mContext != null) {
                    this.mPopupWindow = new Window(this.mContext);
                    this.mPopupWindow.setCallback(this);
                }
            }
            setTouchInterceptor(l) {
                this.mTouchInterceptor = l;
            }
            isFocusable() {
                return this.mFocusable;
            }
            setFocusable(focusable) {
                this.mFocusable = focusable;
            }
            getInputMethodMode() {
                return this.mInputMethodMode;
            }
            setInputMethodMode(mode) {
                this.mInputMethodMode = mode;
            }
            isTouchable() {
                return this.mTouchable;
            }
            setTouchable(touchable) {
                this.mTouchable = touchable;
            }
            isOutsideTouchable() {
                return this.mOutsideTouchable;
            }
            setOutsideTouchable(touchable) {
                this.mOutsideTouchable = touchable;
            }
            setClipToScreenEnabled(enabled) {
                this.mClipToScreen = enabled;
            }
            setAllowScrollingAnchorParent(enabled) {
                this.mAllowScrollingAnchorParent = enabled;
            }
            isSplitTouchEnabled() {
                if (this.mSplitTouchEnabled < 0 && this.mContext != null) {
                    return true;
                }
                return this.mSplitTouchEnabled == 1;
            }
            setSplitTouchEnabled(enabled) {
                this.mSplitTouchEnabled = enabled ? 1 : 0;
            }
            setWindowLayoutType(layoutType) {
                this.mWindowLayoutType = layoutType;
            }
            getWindowLayoutType() {
                return this.mWindowLayoutType;
            }
            setTouchModal(touchModal) {
                this.mNotTouchModal = !touchModal;
            }
            setWindowLayoutMode(widthSpec, heightSpec) {
                this.mWidthMode = widthSpec;
                this.mHeightMode = heightSpec;
            }
            getHeight() {
                return this.mHeight;
            }
            setHeight(height) {
                this.mHeight = height;
            }
            getWidth() {
                return this.mWidth;
            }
            setWidth(width) {
                this.mWidth = width;
            }
            isShowing() {
                return this.mIsShowing;
            }
            showAtLocation(parent, gravity, x, y) {
                if (this.isShowing() || this.mContentView == null) {
                    return;
                }
                this.unregisterForScrollChanged();
                this.mIsShowing = true;
                this.mIsDropdown = false;
                let p = this.createPopupLayout();
                p.enterAnimation = this.computeWindowEnterAnimation();
                p.exitAnimation = this.computeWindowExitAnimation();
                this.preparePopup(p);
                if (gravity == Gravity.NO_GRAVITY) {
                    gravity = Gravity.TOP | Gravity.START;
                }
                p.gravity = gravity;
                p.x = x;
                p.y = y;
                if (this.mHeightMode < 0)
                    p.height = this.mLastHeight = this.mHeightMode;
                if (this.mWidthMode < 0)
                    p.width = this.mLastWidth = this.mWidthMode;
                this.invokePopup(p);
            }
            showAsDropDown(anchor, xoff = 0, yoff = 0, gravity = PopupWindow.DEFAULT_ANCHORED_GRAVITY) {
                if (this.isShowing() || this.mContentView == null) {
                    return;
                }
                this.registerForScrollChanged(anchor, xoff, yoff, gravity);
                this.mIsShowing = true;
                this.mIsDropdown = true;
                let p = this.createPopupLayout();
                this.preparePopup(p);
                this.updateAboveAnchor(this.findDropDownPosition(anchor, p, xoff, yoff, gravity));
                if (this.mHeightMode < 0)
                    p.height = this.mLastHeight = this.mHeightMode;
                if (this.mWidthMode < 0)
                    p.width = this.mLastWidth = this.mWidthMode;
                p.enterAnimation = this.computeWindowEnterAnimation();
                p.exitAnimation = this.computeWindowExitAnimation();
                this.invokePopup(p);
            }
            updateAboveAnchor(aboveAnchor) {
                if (aboveAnchor != this.mAboveAnchor) {
                    this.mAboveAnchor = aboveAnchor;
                    if (this.mBackground != null) {
                        if (this.mAboveAnchorBackgroundDrawable != null) {
                            if (this.mAboveAnchor) {
                                this.mPopupView.setBackgroundDrawable(this.mAboveAnchorBackgroundDrawable);
                            }
                            else {
                                this.mPopupView.setBackgroundDrawable(this.mBelowAnchorBackgroundDrawable);
                            }
                        }
                        else {
                            this.mPopupView.refreshDrawableState();
                        }
                    }
                }
            }
            isAboveAnchor() {
                return this.mAboveAnchor;
            }
            preparePopup(p) {
                if (this.mContentView == null || this.mContext == null || this.mWindowManager == null) {
                    throw Error(`new IllegalStateException("You must specify a valid content view by " + "calling setContentView() before attempting to show the popup.")`);
                }
                this.mPopupWindow.setContentView(this.mContentView);
                this.mPopupWindow.setFloating(true);
                this.mPopupWindow.setBackgroundColor(android.graphics.Color.TRANSPARENT);
                this.mPopupWindow.setDimAmount(0);
                this.mPopupView = this.mPopupWindow.getDecorView();
                if (this.mBackground != null) {
                    this.mPopupView.setBackground(this.mBackground);
                }
                this.mPopupViewInitialLayoutDirectionInherited = false;
                this.mPopupWidth = p.width;
                this.mPopupHeight = p.height;
            }
            invokePopup(p) {
                this.setLayoutDirectionFromAnchor();
                this.mWindowManager.addWindow(this.mPopupWindow);
            }
            setLayoutDirectionFromAnchor() {
                if (this.mAnchor != null) {
                    let anchor = this.mAnchor.get();
                    if (anchor != null && this.mPopupViewInitialLayoutDirectionInherited) {
                        this.mPopupView.setLayoutDirection(anchor.getLayoutDirection());
                    }
                }
            }
            createPopupLayout() {
                let p = this.mPopupWindow.getAttributes();
                p.gravity = Gravity.START | Gravity.TOP;
                p.width = this.mLastWidth = this.mWidth;
                p.height = this.mLastHeight = this.mHeight;
                p.flags = this.computeFlags(p.flags);
                p.type = this.mWindowLayoutType;
                p.setTitle("PopupWindow");
                return p;
            }
            computeFlags(curFlags) {
                curFlags &= ~(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
                    WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE |
                    WindowManager.LayoutParams.FLAG_SPLIT_TOUCH);
                if (!this.mFocusable) {
                    curFlags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
                }
                if (!this.mTouchable) {
                    curFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
                }
                if (this.mOutsideTouchable) {
                    curFlags |= WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
                }
                if (this.isSplitTouchEnabled()) {
                    curFlags |= WindowManager.LayoutParams.FLAG_SPLIT_TOUCH;
                }
                if (this.mNotTouchModal) {
                    curFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;
                }
                return curFlags;
            }
            computeWindowEnterAnimation() {
                if (this.mEnterAnimation == null) {
                    if (this.mIsDropdown) {
                        return this.mAboveAnchor ? this.mDefaultDropdownAboveEnterAnimation : this.mDefaultDropdownBelowEnterAnimation;
                    }
                    return null;
                }
                return this.mEnterAnimation;
            }
            computeWindowExitAnimation() {
                if (this.mExitAnimation == null) {
                    if (this.mIsDropdown) {
                        return this.mAboveAnchor ? this.mDefaultDropdownAboveExitAnimation : this.mDefaultDropdownBelowExitAnimation;
                    }
                    return null;
                }
                return this.mExitAnimation;
            }
            findDropDownPosition(anchor, p, xoff, yoff, gravity) {
                const anchorHeight = anchor.getHeight();
                anchor.getLocationInWindow(this.mDrawingLocation);
                p.x = this.mDrawingLocation[0] + xoff;
                p.y = this.mDrawingLocation[1] + anchorHeight + yoff;
                const hgrav = Gravity.getAbsoluteGravity(gravity, anchor.getLayoutDirection()) & Gravity.HORIZONTAL_GRAVITY_MASK;
                if (hgrav == Gravity.RIGHT) {
                    p.x -= this.mPopupWidth - anchor.getWidth();
                }
                let onTop = false;
                p.gravity = Gravity.LEFT | Gravity.TOP;
                anchor.getLocationOnScreen(this.mScreenLocation);
                const displayFrame = new Rect();
                anchor.getWindowVisibleDisplayFrame(displayFrame);
                let screenY = this.mScreenLocation[1] + anchorHeight + yoff;
                const root = anchor.getRootView();
                if (screenY + this.mPopupHeight > displayFrame.bottom || p.x + this.mPopupWidth - root.getWidth() > 0) {
                    if (this.mAllowScrollingAnchorParent) {
                        let scrollX = anchor.getScrollX();
                        let scrollY = anchor.getScrollY();
                        let r = new Rect(scrollX, scrollY, scrollX + this.mPopupWidth + xoff, scrollY + this.mPopupHeight + anchor.getHeight() + yoff);
                        anchor.requestRectangleOnScreen(r, true);
                    }
                    anchor.getLocationInWindow(this.mDrawingLocation);
                    p.x = this.mDrawingLocation[0] + xoff;
                    p.y = this.mDrawingLocation[1] + anchor.getHeight() + yoff;
                    if (hgrav == Gravity.RIGHT) {
                        p.x -= this.mPopupWidth - anchor.getWidth();
                    }
                    anchor.getLocationOnScreen(this.mScreenLocation);
                    onTop = (displayFrame.bottom - this.mScreenLocation[1] - anchor.getHeight() - yoff) < (this.mScreenLocation[1] - yoff - displayFrame.top);
                    if (onTop) {
                        p.gravity = Gravity.LEFT | Gravity.BOTTOM;
                        p.y = root.getHeight() - this.mDrawingLocation[1] + yoff;
                    }
                    else {
                        p.y = this.mDrawingLocation[1] + anchor.getHeight() + yoff;
                    }
                }
                if (this.mClipToScreen) {
                    const displayFrameWidth = displayFrame.right - displayFrame.left;
                    let right = p.x + p.width;
                    if (right > displayFrameWidth) {
                        p.x -= right - displayFrameWidth;
                    }
                    if (p.x < displayFrame.left) {
                        p.x = displayFrame.left;
                        p.width = Math.min(p.width, displayFrameWidth);
                    }
                    if (onTop) {
                        let popupTop = this.mScreenLocation[1] + yoff - this.mPopupHeight;
                        if (popupTop < 0) {
                            p.y += popupTop;
                        }
                    }
                    else {
                        p.y = Math.max(p.y, displayFrame.top);
                    }
                }
                p.gravity |= Gravity.DISPLAY_CLIP_VERTICAL;
                return onTop;
            }
            getMaxAvailableHeight(anchor, yOffset = 0, ignoreBottomDecorations = false) {
                const displayFrame = new Rect();
                anchor.getWindowVisibleDisplayFrame(displayFrame);
                const anchorPos = this.mDrawingLocation;
                anchor.getLocationOnScreen(anchorPos);
                let bottomEdge = displayFrame.bottom;
                if (ignoreBottomDecorations) {
                    let res = anchor.getContext().getResources();
                    bottomEdge = res.getDisplayMetrics().heightPixels;
                }
                const distanceToBottom = bottomEdge - (anchorPos[1] + anchor.getHeight()) - yOffset;
                const distanceToTop = anchorPos[1] - displayFrame.top + yOffset;
                let returnedHeight = Math.max(distanceToBottom, distanceToTop);
                if (this.mBackground != null) {
                    this.mBackground.getPadding(this.mTempRect);
                    returnedHeight -= this.mTempRect.top + this.mTempRect.bottom;
                }
                return returnedHeight;
            }
            dismiss() {
                if (this.isShowing() && this.mPopupView != null) {
                    this.mIsShowing = false;
                    this.unregisterForScrollChanged();
                    try {
                        this.mWindowManager.removeWindow(this.mPopupWindow);
                    }
                    finally {
                        if (this.mPopupView != this.mContentView && this.mPopupView instanceof ViewGroup) {
                            this.mPopupView.removeView(this.mContentView);
                        }
                        this.mPopupView = null;
                        if (this.mOnDismissListener != null) {
                            this.mOnDismissListener.onDismiss();
                        }
                    }
                }
            }
            setOnDismissListener(onDismissListener) {
                this.mOnDismissListener = onDismissListener;
            }
            update(...args) {
                if (args.length == 0) {
                    this._update();
                }
                else if (args.length == 2) {
                    this._update_w_h(args[0], args[1]);
                }
                else if (args.length == 3) {
                    this._update_a_w_h(args[0], args[1], args[2]);
                }
                else if (args.length == 4) {
                    this._update_x_y_w_h_f(args[0], args[1], args[2], args[3]);
                }
                else if (args.length == 5) {
                    if (args[0] instanceof View)
                        this._update_a_x_y_w_h(args[0], args[1], args[2], args[3], args[4]);
                    else
                        this._update_x_y_w_h_f(args[0], args[1], args[2], args[3], args[4]);
                }
            }
            _update() {
                if (!this.isShowing() || this.mContentView == null) {
                    return;
                }
                let p = this.mPopupView.getLayoutParams();
                let update = false;
                const enterAnim = this.computeWindowEnterAnimation();
                const exitAnim = this.computeWindowExitAnimation();
                if (enterAnim != p.enterAnimation) {
                    p.enterAnimation = enterAnim;
                    update = true;
                }
                if (exitAnim != p.exitAnimation) {
                    p.exitAnimation = exitAnim;
                    update = true;
                }
                const newFlags = this.computeFlags(p.flags);
                if (newFlags != p.flags) {
                    p.flags = newFlags;
                    update = true;
                }
                if (update) {
                    this.setLayoutDirectionFromAnchor();
                    this.mWindowManager.updateWindowLayout(this.mPopupWindow, p);
                }
            }
            _update_w_h(width, height) {
                let p = this.mPopupView.getLayoutParams();
                this.update(p.x, p.y, width, height, false);
            }
            _update_x_y_w_h_f(x, y, width, height, force = false) {
                if (width != -1) {
                    this.mLastWidth = width;
                    this.setWidth(width);
                }
                if (height != -1) {
                    this.mLastHeight = height;
                    this.setHeight(height);
                }
                if (!this.isShowing() || this.mContentView == null) {
                    return;
                }
                let p = this.mPopupView.getLayoutParams();
                let update = force;
                const finalWidth = this.mWidthMode < 0 ? this.mWidthMode : this.mLastWidth;
                if (width != -1 && p.width != finalWidth) {
                    p.width = this.mLastWidth = finalWidth;
                    update = true;
                }
                const finalHeight = this.mHeightMode < 0 ? this.mHeightMode : this.mLastHeight;
                if (height != -1 && p.height != finalHeight) {
                    p.height = this.mLastHeight = finalHeight;
                    update = true;
                }
                if (p.x != x) {
                    p.x = x;
                    update = true;
                }
                if (p.y != y) {
                    p.y = y;
                    update = true;
                }
                const enterAnim = this.computeWindowEnterAnimation();
                const exitAnim = this.computeWindowExitAnimation();
                if (enterAnim != p.enterAnimation) {
                    p.enterAnimation = enterAnim;
                    update = true;
                }
                if (exitAnim != p.exitAnimation) {
                    p.exitAnimation = exitAnim;
                    update = true;
                }
                const newFlags = this.computeFlags(p.flags);
                if (newFlags != p.flags) {
                    p.flags = newFlags;
                    update = true;
                }
                if (update) {
                    this.setLayoutDirectionFromAnchor();
                    this.mWindowManager.updateWindowLayout(this.mPopupWindow, p);
                }
            }
            _update_a_w_h(anchor, width, height) {
                this._update_all_args(anchor, false, 0, 0, true, width, height, this.mAnchoredGravity);
            }
            _update_a_x_y_w_h(anchor, xoff, yoff, width, height) {
                this._update_all_args(anchor, true, xoff, yoff, true, width, height, this.mAnchoredGravity);
            }
            _update_all_args(anchor, updateLocation, xoff, yoff, updateDimension, width, height, gravity) {
                if (!this.isShowing() || this.mContentView == null) {
                    return;
                }
                let oldAnchor = this.mAnchor;
                const needsUpdate = updateLocation && (this.mAnchorXoff != xoff || this.mAnchorYoff != yoff);
                if (oldAnchor == null || oldAnchor.get() != anchor || (needsUpdate && !this.mIsDropdown)) {
                    this.registerForScrollChanged(anchor, xoff, yoff, gravity);
                }
                else if (needsUpdate) {
                    this.mAnchorXoff = xoff;
                    this.mAnchorYoff = yoff;
                    this.mAnchoredGravity = gravity;
                }
                let p = this.mPopupView.getLayoutParams();
                if (updateDimension) {
                    if (width == -1) {
                        width = this.mPopupWidth;
                    }
                    else {
                        this.mPopupWidth = width;
                    }
                    if (height == -1) {
                        height = this.mPopupHeight;
                    }
                    else {
                        this.mPopupHeight = height;
                    }
                }
                let x = p.x;
                let y = p.y;
                if (updateLocation) {
                    this.updateAboveAnchor(this.findDropDownPosition(anchor, p, xoff, yoff, gravity));
                }
                else {
                    this.updateAboveAnchor(this.findDropDownPosition(anchor, p, this.mAnchorXoff, this.mAnchorYoff, this.mAnchoredGravity));
                }
                this.update(p.x, p.y, width, height, x != p.x || y != p.y);
            }
            unregisterForScrollChanged() {
                let anchorRef = this.mAnchor;
                let anchor = null;
                if (anchorRef != null) {
                    anchor = anchorRef.get();
                }
                if (anchor != null) {
                    let vto = anchor.getViewTreeObserver();
                    vto.removeOnScrollChangedListener(this.mOnScrollChangedListener);
                }
                this.mAnchor = null;
            }
            registerForScrollChanged(anchor, xoff, yoff, gravity) {
                this.unregisterForScrollChanged();
                this.mAnchor = new WeakReference(anchor);
                let vto = anchor.getViewTreeObserver();
                if (vto != null) {
                    vto.addOnScrollChangedListener(this.mOnScrollChangedListener);
                }
                this.mAnchorXoff = xoff;
                this.mAnchorYoff = yoff;
                this.mAnchoredGravity = gravity;
            }
            onTouchEvent(event) {
                const x = Math.floor(event.getX());
                const y = Math.floor(event.getY());
                if ((event.getAction() == MotionEvent.ACTION_DOWN) && ((x < 0) || (x >= this.mPopupView.getWidth()) || (y < 0) || (y >= this.mPopupView.getHeight()))) {
                    this.dismiss();
                    return true;
                }
                else if (event.getAction() == MotionEvent.ACTION_OUTSIDE) {
                    this.dismiss();
                    return true;
                }
                else if (this.mPopupView) {
                    return this.mPopupView.onTouchEvent(event);
                }
                return false;
            }
            onGenericMotionEvent(event) {
                return false;
            }
            onWindowAttributesChanged(params) {
                if (this.mPopupWindow != null) {
                    this.mWindowManager.updateWindowLayout(this.mPopupWindow, params);
                }
            }
            onContentChanged() {
            }
            onWindowFocusChanged(hasFocus) {
            }
            onAttachedToWindow() {
            }
            onDetachedFromWindow() {
            }
            dispatchKeyEvent(event) {
                if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
                    if (this.mPopupView.getKeyDispatcherState() == null) {
                        return this.mPopupWindow.superDispatchKeyEvent(event);
                    }
                    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                        let state = this.mPopupView.getKeyDispatcherState();
                        if (state != null) {
                            state.startTracking(event, this);
                        }
                        return true;
                    }
                    else if (event.getAction() == KeyEvent.ACTION_UP) {
                        let state = this.mPopupView.getKeyDispatcherState();
                        if (state != null && state.isTracking(event) && !event.isCanceled()) {
                            this.dismiss();
                            return true;
                        }
                    }
                    return this.mPopupWindow.superDispatchKeyEvent(event);
                }
                else {
                    return this.mPopupWindow.superDispatchKeyEvent(event);
                }
            }
            dispatchTouchEvent(ev) {
                if (this.mTouchInterceptor != null && this.mTouchInterceptor.onTouch(this.mPopupView, ev)) {
                    return true;
                }
                if (this.mPopupWindow.superDispatchTouchEvent(ev)) {
                    return true;
                }
                return this.onTouchEvent(ev);
            }
            dispatchGenericMotionEvent(ev) {
                if (this.mPopupWindow.superDispatchGenericMotionEvent(ev)) {
                    return true;
                }
                return this.onGenericMotionEvent(ev);
            }
        }
        PopupWindow.INPUT_METHOD_FROM_FOCUSABLE = 0;
        PopupWindow.INPUT_METHOD_NEEDED = 1;
        PopupWindow.INPUT_METHOD_NOT_NEEDED = 2;
        PopupWindow.DEFAULT_ANCHORED_GRAVITY = Gravity.TOP | Gravity.START;
        widget.PopupWindow = PopupWindow;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 16/1/15.
 */
///<reference path="OverScroller.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        class Scroller extends widget.OverScroller {
        }
        widget.Scroller = Scroller;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/animation/AccelerateDecelerateInterpolator.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/PopupWindow.ts"/>
///<reference path="../../android/widget/Scroller.ts"/>
///<reference path="../../android/widget/Spinner.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/content/Context.ts"/>
///<reference path="../../android/view/animation/Animation.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../android/R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var DataSetObserver = android.database.DataSetObserver;
        var Rect = android.graphics.Rect;
        var Handler = android.os.Handler;
        var Log = android.util.Log;
        var Gravity = android.view.Gravity;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var View = android.view.View;
        var MeasureSpec = android.view.View.MeasureSpec;
        var ViewConfiguration = android.view.ViewConfiguration;
        var ViewGroup = android.view.ViewGroup;
        var Integer = java.lang.Integer;
        var AbsListView = android.widget.AbsListView;
        var LinearLayout = android.widget.LinearLayout;
        var ListView = android.widget.ListView;
        var PopupWindow = android.widget.PopupWindow;
        var TextView = android.widget.TextView;
        class ListPopupWindow {
            constructor(context, styleAttr = android.R.attr.listPopupWindowStyle) {
                this.mDropDownHeight = ViewGroup.LayoutParams.WRAP_CONTENT;
                this.mDropDownWidth = ViewGroup.LayoutParams.WRAP_CONTENT;
                this.mDropDownHorizontalOffset = 0;
                this.mDropDownVerticalOffset = 0;
                this.mDropDownGravity = Gravity.NO_GRAVITY;
                this.mDropDownAlwaysVisible = false;
                this.mForceIgnoreOutsideTouch = false;
                this.mListItemExpandMaximum = Integer.MAX_VALUE;
                this.mPromptPosition = ListPopupWindow.POSITION_PROMPT_ABOVE;
                this.mResizePopupRunnable = new ListPopupWindow.ResizePopupRunnable(this);
                this.mTouchInterceptor = new ListPopupWindow.PopupTouchInterceptor(this);
                this.mScrollListener = new ListPopupWindow.PopupScrollListener(this);
                this.mHideSelector = new ListPopupWindow.ListSelectorHider(this);
                this.mHandler = new Handler();
                this.mTempRect = new Rect();
                this.mLayoutDirection = 0;
                this.mContext = context;
                this.mPopup = new PopupWindow(context, styleAttr);
                this.mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                this.mLayoutDirection = View.LAYOUT_DIRECTION_LTR;
            }
            setAdapter(adapter) {
                if (this.mObserver == null) {
                    this.mObserver = new ListPopupWindow.PopupDataSetObserver(this);
                }
                else if (this.mAdapter != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mObserver);
                }
                this.mAdapter = adapter;
                if (this.mAdapter != null) {
                    adapter.registerDataSetObserver(this.mObserver);
                }
                if (this.mDropDownList != null) {
                    this.mDropDownList.setAdapter(this.mAdapter);
                }
            }
            setPromptPosition(position) {
                this.mPromptPosition = position;
            }
            getPromptPosition() {
                return this.mPromptPosition;
            }
            setModal(modal) {
                this.mModal = true;
                this.mPopup.setFocusable(modal);
            }
            isModal() {
                return this.mModal;
            }
            setForceIgnoreOutsideTouch(forceIgnoreOutsideTouch) {
                this.mForceIgnoreOutsideTouch = forceIgnoreOutsideTouch;
            }
            setDropDownAlwaysVisible(dropDownAlwaysVisible) {
                this.mDropDownAlwaysVisible = dropDownAlwaysVisible;
            }
            isDropDownAlwaysVisible() {
                return this.mDropDownAlwaysVisible;
            }
            getBackground() {
                return this.mPopup.getBackground();
            }
            setBackgroundDrawable(d) {
                this.mPopup.setBackgroundDrawable(d);
            }
            setWindowAnimation(enterAnimation, exitAnimation) {
                this.mPopup.setWindowAnimation(enterAnimation, exitAnimation);
            }
            getEnterAnimation() {
                return this.mPopup.mEnterAnimation;
            }
            getExitAnimation() {
                return this.mPopup.mExitAnimation;
            }
            getAnchorView() {
                return this.mDropDownAnchorView;
            }
            setAnchorView(anchor) {
                this.mDropDownAnchorView = anchor;
            }
            getHorizontalOffset() {
                return this.mDropDownHorizontalOffset;
            }
            setHorizontalOffset(offset) {
                this.mDropDownHorizontalOffset = offset;
            }
            getVerticalOffset() {
                if (!this.mDropDownVerticalOffsetSet) {
                    return 0;
                }
                return this.mDropDownVerticalOffset;
            }
            setVerticalOffset(offset) {
                this.mDropDownVerticalOffset = offset;
                this.mDropDownVerticalOffsetSet = true;
            }
            setDropDownGravity(gravity) {
                this.mDropDownGravity = gravity;
            }
            getWidth() {
                return this.mDropDownWidth;
            }
            setWidth(width) {
                this.mDropDownWidth = width;
            }
            setContentWidth(width) {
                let popupBackground = this.mPopup.getBackground();
                if (popupBackground != null) {
                    popupBackground.getPadding(this.mTempRect);
                    this.mDropDownWidth = this.mTempRect.left + this.mTempRect.right + width;
                }
                else {
                    this.setWidth(width);
                }
            }
            getHeight() {
                return this.mDropDownHeight;
            }
            setHeight(height) {
                this.mDropDownHeight = height;
            }
            setOnItemClickListener(clickListener) {
                this.mItemClickListener = clickListener;
            }
            setOnItemSelectedListener(selectedListener) {
                this.mItemSelectedListener = selectedListener;
            }
            setPromptView(prompt) {
                let showing = this.isShowing();
                if (showing) {
                    this.removePromptView();
                }
                this.mPromptView = prompt;
                if (showing) {
                    this.show();
                }
            }
            postShow() {
                this.mHandler.post(this.mShowDropDownRunnable);
            }
            show() {
                let height = this.buildDropDown();
                let widthSpec = 0;
                let heightSpec = 0;
                let noInputMethod = this.isInputMethodNotNeeded();
                this.mPopup.setAllowScrollingAnchorParent(!noInputMethod);
                if (this.mPopup.isShowing()) {
                    if (this.mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
                        widthSpec = -1;
                    }
                    else if (this.mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                        widthSpec = this.getAnchorView().getWidth();
                    }
                    else {
                        widthSpec = this.mDropDownWidth;
                    }
                    if (this.mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
                        heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
                        if (noInputMethod) {
                            this.mPopup.setWindowLayoutMode(this.mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0, 0);
                        }
                        else {
                            this.mPopup.setWindowLayoutMode(this.mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0, ViewGroup.LayoutParams.MATCH_PARENT);
                        }
                    }
                    else if (this.mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                        heightSpec = height;
                    }
                    else {
                        heightSpec = this.mDropDownHeight;
                    }
                    this.mPopup.setOutsideTouchable(!this.mForceIgnoreOutsideTouch && !this.mDropDownAlwaysVisible);
                    this.mPopup.update(this.getAnchorView(), this.mDropDownHorizontalOffset, this.mDropDownVerticalOffset, widthSpec, heightSpec);
                }
                else {
                    if (this.mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
                        widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
                    }
                    else {
                        if (this.mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            this.mPopup.setWidth(this.getAnchorView().getWidth());
                        }
                        else {
                            this.mPopup.setWidth(this.mDropDownWidth);
                        }
                    }
                    if (this.mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
                        heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
                    }
                    else {
                        if (this.mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            this.mPopup.setHeight(height);
                        }
                        else {
                            this.mPopup.setHeight(this.mDropDownHeight);
                        }
                    }
                    this.mPopup.setWindowLayoutMode(widthSpec, heightSpec);
                    this.mPopup.setClipToScreenEnabled(true);
                    this.mPopup.setOutsideTouchable(!this.mForceIgnoreOutsideTouch && !this.mDropDownAlwaysVisible);
                    this.mPopup.setTouchInterceptor(this.mTouchInterceptor);
                    this.mPopup.showAsDropDown(this.getAnchorView(), this.mDropDownHorizontalOffset, this.mDropDownVerticalOffset, this.mDropDownGravity);
                    this.mDropDownList.setSelection(ListView.INVALID_POSITION);
                    if (!this.mModal || this.mDropDownList.isInTouchMode()) {
                        this.clearListSelection();
                    }
                    if (!this.mModal) {
                        this.mHandler.post(this.mHideSelector);
                    }
                }
            }
            dismiss() {
                this.mPopup.dismiss();
                this.removePromptView();
                this.mPopup.setContentView(null);
                this.mDropDownList = null;
                this.mHandler.removeCallbacks(this.mResizePopupRunnable);
            }
            setOnDismissListener(listener) {
                this.mPopup.setOnDismissListener(listener);
            }
            removePromptView() {
                if (this.mPromptView != null) {
                    const parent = this.mPromptView.getParent();
                    if (parent instanceof ViewGroup) {
                        const group = parent;
                        group.removeView(this.mPromptView);
                    }
                }
            }
            setInputMethodMode(mode) {
                this.mPopup.setInputMethodMode(mode);
            }
            getInputMethodMode() {
                return this.mPopup.getInputMethodMode();
            }
            setSelection(position) {
                let list = this.mDropDownList;
                if (this.isShowing() && list != null) {
                    list.mListSelectionHidden = false;
                    list.setSelection(position);
                    if (list.getChoiceMode() != ListView.CHOICE_MODE_NONE) {
                        list.setItemChecked(position, true);
                    }
                }
            }
            clearListSelection() {
                const list = this.mDropDownList;
                if (list != null) {
                    list.mListSelectionHidden = true;
                    list.hideSelector();
                    list.requestLayout();
                }
            }
            isShowing() {
                return this.mPopup.isShowing();
            }
            isInputMethodNotNeeded() {
                return this.mPopup.getInputMethodMode() == ListPopupWindow.INPUT_METHOD_NOT_NEEDED;
            }
            performItemClick(position) {
                if (this.isShowing()) {
                    if (this.mItemClickListener != null) {
                        const list = this.mDropDownList;
                        const child = list.getChildAt(position - list.getFirstVisiblePosition());
                        const adapter = list.getAdapter();
                        this.mItemClickListener.onItemClick(list, child, position, adapter.getItemId(position));
                    }
                    return true;
                }
                return false;
            }
            getSelectedItem() {
                if (!this.isShowing()) {
                    return null;
                }
                return this.mDropDownList.getSelectedItem();
            }
            getSelectedItemPosition() {
                if (!this.isShowing()) {
                    return ListView.INVALID_POSITION;
                }
                return this.mDropDownList.getSelectedItemPosition();
            }
            getSelectedItemId() {
                if (!this.isShowing()) {
                    return ListView.INVALID_ROW_ID;
                }
                return this.mDropDownList.getSelectedItemId();
            }
            getSelectedView() {
                if (!this.isShowing()) {
                    return null;
                }
                return this.mDropDownList.getSelectedView();
            }
            getListView() {
                return this.mDropDownList;
            }
            setListItemExpandMax(max) {
                this.mListItemExpandMaximum = max;
            }
            onKeyDown(keyCode, event) {
                if (this.isShowing()) {
                    if (keyCode != KeyEvent.KEYCODE_SPACE && (this.mDropDownList.getSelectedItemPosition() >= 0 || !KeyEvent.isConfirmKey(keyCode))) {
                        let curIndex = this.mDropDownList.getSelectedItemPosition();
                        let consumed;
                        const below = !this.mPopup.isAboveAnchor();
                        const adapter = this.mAdapter;
                        let allEnabled;
                        let firstItem = Integer.MAX_VALUE;
                        let lastItem = Integer.MIN_VALUE;
                        if (adapter != null) {
                            allEnabled = adapter.areAllItemsEnabled();
                            firstItem = allEnabled ? 0 : this.mDropDownList.lookForSelectablePosition(0, true);
                            lastItem = allEnabled ? adapter.getCount() - 1 : this.mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
                        }
                        if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                            this.clearListSelection();
                            this.mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                            this.show();
                            return true;
                        }
                        else {
                            this.mDropDownList.mListSelectionHidden = false;
                        }
                        consumed = this.mDropDownList.onKeyDown(keyCode, event);
                        if (ListPopupWindow.DEBUG)
                            Log.v(ListPopupWindow.TAG, "Key down: code=" + keyCode + " list consumed=" + consumed);
                        if (consumed) {
                            this.mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                            this.mDropDownList.requestFocusFromTouch();
                            this.show();
                            switch (keyCode) {
                                case KeyEvent.KEYCODE_ENTER:
                                case KeyEvent.KEYCODE_DPAD_CENTER:
                                case KeyEvent.KEYCODE_DPAD_DOWN:
                                case KeyEvent.KEYCODE_DPAD_UP:
                                    return true;
                            }
                        }
                        else {
                            if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                                if (curIndex == lastItem) {
                                    return true;
                                }
                            }
                            else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            onKeyUp(keyCode, event) {
                if (this.isShowing() && this.mDropDownList.getSelectedItemPosition() >= 0) {
                    let consumed = this.mDropDownList.onKeyUp(keyCode, event);
                    if (consumed && KeyEvent.isConfirmKey(keyCode)) {
                        this.dismiss();
                    }
                    return consumed;
                }
                return false;
            }
            onKeyPreIme(keyCode, event) {
                if (keyCode == KeyEvent.KEYCODE_BACK && this.isShowing()) {
                    const anchorView = this.mDropDownAnchorView;
                    if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                        let state = anchorView.getKeyDispatcherState();
                        if (state != null) {
                            state.startTracking(event, this);
                        }
                        return true;
                    }
                    else if (event.getAction() == KeyEvent.ACTION_UP) {
                        let state = anchorView.getKeyDispatcherState();
                        if (state != null) {
                            state.handleUpEvent(event);
                        }
                        if (event.isTracking() && !event.isCanceled()) {
                            this.dismiss();
                            return true;
                        }
                    }
                }
                return false;
            }
            createDragToOpenListener(src) {
                return (() => {
                    const _this = this;
                    class _Inner extends ListPopupWindow.ForwardingListener {
                        getPopup() {
                            return _this;
                        }
                    }
                    return new _Inner(src);
                })();
            }
            buildDropDown() {
                let dropDownView;
                let otherHeights = 0;
                if (this.mDropDownList == null) {
                    let context = this.mContext;
                    this.mShowDropDownRunnable = (() => {
                        const _this = this;
                        class _Inner {
                            run() {
                                let view = _this.getAnchorView();
                                if (view != null && view.isAttachedToWindow()) {
                                    _this.show();
                                }
                            }
                        }
                        return new _Inner();
                    })();
                    this.mDropDownList = new ListPopupWindow.DropDownListView(context, !this.mModal);
                    if (this.mDropDownListHighlight != null) {
                        this.mDropDownList.setSelector(this.mDropDownListHighlight);
                    }
                    this.mDropDownList.setAdapter(this.mAdapter);
                    this.mDropDownList.setOnItemClickListener(this.mItemClickListener);
                    this.mDropDownList.setFocusable(true);
                    this.mDropDownList.setFocusableInTouchMode(true);
                    this.mDropDownList.setOnItemSelectedListener((() => {
                        const _this = this;
                        class _Inner {
                            onItemSelected(parent, view, position, id) {
                                if (position != -1) {
                                    let dropDownList = _this.mDropDownList;
                                    if (dropDownList != null) {
                                        dropDownList.mListSelectionHidden = false;
                                    }
                                }
                            }
                            onNothingSelected(parent) {
                            }
                        }
                        return new _Inner();
                    })());
                    this.mDropDownList.setOnScrollListener(this.mScrollListener);
                    if (this.mItemSelectedListener != null) {
                        this.mDropDownList.setOnItemSelectedListener(this.mItemSelectedListener);
                    }
                    dropDownView = this.mDropDownList;
                    let hintView = this.mPromptView;
                    if (hintView != null) {
                        let hintContainer = new LinearLayout(context);
                        hintContainer.setOrientation(LinearLayout.VERTICAL);
                        let hintParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0);
                        switch (this.mPromptPosition) {
                            case ListPopupWindow.POSITION_PROMPT_BELOW:
                                hintContainer.addView(dropDownView, hintParams);
                                hintContainer.addView(hintView);
                                break;
                            case ListPopupWindow.POSITION_PROMPT_ABOVE:
                                hintContainer.addView(hintView);
                                hintContainer.addView(dropDownView, hintParams);
                                break;
                            default:
                                Log.e(ListPopupWindow.TAG, "Invalid hint position " + this.mPromptPosition);
                                break;
                        }
                        let widthSpec = MeasureSpec.makeMeasureSpec(this.mDropDownWidth, MeasureSpec.AT_MOST);
                        let heightSpec = MeasureSpec.UNSPECIFIED;
                        hintView.measure(widthSpec, heightSpec);
                        hintParams = hintView.getLayoutParams();
                        otherHeights = hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
                        dropDownView = hintContainer;
                    }
                    this.mPopup.setContentView(dropDownView);
                }
                else {
                    dropDownView = this.mPopup.getContentView();
                    const view = this.mPromptView;
                    if (view != null) {
                        let hintParams = view.getLayoutParams();
                        otherHeights = view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
                    }
                }
                let padding = 0;
                let background = this.mPopup.getBackground();
                if (background != null) {
                    background.getPadding(this.mTempRect);
                    padding = this.mTempRect.top + this.mTempRect.bottom;
                    if (!this.mDropDownVerticalOffsetSet) {
                        this.mDropDownVerticalOffset = -this.mTempRect.top;
                    }
                }
                else {
                    this.mTempRect.setEmpty();
                }
                let ignoreBottomDecorations = this.mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
                const maxHeight = this.mPopup.getMaxAvailableHeight(this.getAnchorView(), this.mDropDownVerticalOffset, ignoreBottomDecorations);
                if (this.mDropDownAlwaysVisible || this.mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
                    return maxHeight + padding;
                }
                let childWidthSpec;
                switch (this.mDropDownWidth) {
                    case ViewGroup.LayoutParams.WRAP_CONTENT:
                        childWidthSpec = MeasureSpec.makeMeasureSpec(this.mContext.getResources().getDisplayMetrics().widthPixels - (this.mTempRect.left + this.mTempRect.right), MeasureSpec.AT_MOST);
                        break;
                    case ViewGroup.LayoutParams.MATCH_PARENT:
                        childWidthSpec = MeasureSpec.makeMeasureSpec(this.mContext.getResources().getDisplayMetrics().widthPixels - (this.mTempRect.left + this.mTempRect.right), MeasureSpec.EXACTLY);
                        break;
                    default:
                        childWidthSpec = MeasureSpec.makeMeasureSpec(this.mDropDownWidth, MeasureSpec.EXACTLY);
                        break;
                }
                const listContent = this.mDropDownList.measureHeightOfChildren(childWidthSpec, 0, ListView.NO_POSITION, maxHeight - otherHeights, -1);
                if (listContent > 0)
                    otherHeights += padding;
                return listContent + otherHeights;
            }
        }
        ListPopupWindow.TAG = "ListPopupWindow";
        ListPopupWindow.DEBUG = false;
        ListPopupWindow.EXPAND_LIST_TIMEOUT = 250;
        ListPopupWindow.POSITION_PROMPT_ABOVE = 0;
        ListPopupWindow.POSITION_PROMPT_BELOW = 1;
        ListPopupWindow.MATCH_PARENT = ViewGroup.LayoutParams.MATCH_PARENT;
        ListPopupWindow.WRAP_CONTENT = ViewGroup.LayoutParams.WRAP_CONTENT;
        ListPopupWindow.INPUT_METHOD_FROM_FOCUSABLE = PopupWindow.INPUT_METHOD_FROM_FOCUSABLE;
        ListPopupWindow.INPUT_METHOD_NEEDED = PopupWindow.INPUT_METHOD_NEEDED;
        ListPopupWindow.INPUT_METHOD_NOT_NEEDED = PopupWindow.INPUT_METHOD_NOT_NEEDED;
        widget.ListPopupWindow = ListPopupWindow;
        (function (ListPopupWindow) {
            class ForwardingListener {
                constructor(src) {
                    this.mScaledTouchSlop = 0;
                    this.mTapTimeout = 0;
                    this.mActivePointerId = 0;
                    this.mSrc = src;
                    this.mScaledTouchSlop = ViewConfiguration.get(src.getContext()).getScaledTouchSlop();
                    this.mTapTimeout = ViewConfiguration.getTapTimeout();
                    src.addOnAttachStateChangeListener(this);
                }
                onTouch(v, event) {
                    const wasForwarding = this.mForwarding;
                    let forwarding;
                    if (wasForwarding) {
                        forwarding = this.onTouchForwarded(event) || !this.onForwardingStopped();
                    }
                    else {
                        forwarding = this.onTouchObserved(event) && this.onForwardingStarted();
                    }
                    this.mForwarding = forwarding;
                    return forwarding || wasForwarding;
                }
                onViewAttachedToWindow(v) {
                }
                onViewDetachedFromWindow(v) {
                    this.mForwarding = false;
                    this.mActivePointerId = MotionEvent.INVALID_POINTER_ID;
                    if (this.mDisallowIntercept != null) {
                        this.mSrc.removeCallbacks(this.mDisallowIntercept);
                    }
                }
                onForwardingStarted() {
                    const popup = this.getPopup();
                    if (popup != null && !popup.isShowing()) {
                        popup.show();
                    }
                    return true;
                }
                onForwardingStopped() {
                    const popup = this.getPopup();
                    if (popup != null && popup.isShowing()) {
                        popup.dismiss();
                    }
                    return true;
                }
                onTouchObserved(srcEvent) {
                    const src = this.mSrc;
                    if (!src.isEnabled()) {
                        return false;
                    }
                    const actionMasked = srcEvent.getActionMasked();
                    switch (actionMasked) {
                        case MotionEvent.ACTION_DOWN:
                            this.mActivePointerId = srcEvent.getPointerId(0);
                            if (this.mDisallowIntercept == null) {
                                this.mDisallowIntercept = new ForwardingListener.DisallowIntercept(this);
                            }
                            src.postDelayed(this.mDisallowIntercept, this.mTapTimeout);
                            break;
                        case MotionEvent.ACTION_MOVE:
                            const activePointerIndex = srcEvent.findPointerIndex(this.mActivePointerId);
                            if (activePointerIndex >= 0) {
                                const x = srcEvent.getX(activePointerIndex);
                                const y = srcEvent.getY(activePointerIndex);
                                if (!src.pointInView(x, y, this.mScaledTouchSlop)) {
                                    if (this.mDisallowIntercept != null) {
                                        src.removeCallbacks(this.mDisallowIntercept);
                                    }
                                    src.getParent().requestDisallowInterceptTouchEvent(true);
                                    return true;
                                }
                            }
                            break;
                        case MotionEvent.ACTION_CANCEL:
                        case MotionEvent.ACTION_UP:
                            if (this.mDisallowIntercept != null) {
                                src.removeCallbacks(this.mDisallowIntercept);
                            }
                            break;
                    }
                    return false;
                }
                onTouchForwarded(srcEvent) {
                    return false;
                }
            }
            ListPopupWindow.ForwardingListener = ForwardingListener;
            (function (ForwardingListener) {
                class DisallowIntercept {
                    constructor(arg) {
                        this._ForwardingListener_this = arg;
                    }
                    run() {
                        const parent = this._ForwardingListener_this.mSrc.getParent();
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                ForwardingListener.DisallowIntercept = DisallowIntercept;
            })(ForwardingListener = ListPopupWindow.ForwardingListener || (ListPopupWindow.ForwardingListener = {}));
            class DropDownListView extends ListView {
                constructor(context, hijackFocus) {
                    super(context, null, android.R.attr.dropDownListViewStyle);
                    this.mHijackFocus = hijackFocus;
                    this.setCacheColorHint(0);
                }
                onForwardedEvent(event, activePointerId) {
                    let handledEvent = true;
                    let clearPressedItem = false;
                    const actionMasked = event.getActionMasked();
                    switch (actionMasked) {
                        case MotionEvent.ACTION_CANCEL:
                            handledEvent = false;
                            break;
                        case MotionEvent.ACTION_UP:
                            handledEvent = false;
                        case MotionEvent.ACTION_MOVE:
                            const activeIndex = event.findPointerIndex(activePointerId);
                            if (activeIndex < 0) {
                                handledEvent = false;
                                break;
                            }
                            const x = Math.floor(event.getX(activeIndex));
                            const y = Math.floor(event.getY(activeIndex));
                            const position = this.pointToPosition(x, y);
                            if (position == DropDownListView.INVALID_POSITION) {
                                clearPressedItem = true;
                                break;
                            }
                            const child = this.getChildAt(position - this.getFirstVisiblePosition());
                            this.setPressedItem(child, position);
                            handledEvent = true;
                            if (actionMasked == MotionEvent.ACTION_UP) {
                                this.clickPressedItem(child, position);
                            }
                            break;
                    }
                    if (!handledEvent || clearPressedItem) {
                        this.clearPressedItem();
                    }
                    return handledEvent;
                }
                clickPressedItem(child, position) {
                    const id = this.getItemIdAtPosition(position);
                    this.performItemClick(child, position, id);
                }
                clearPressedItem() {
                    this.mDrawsInPressedState = false;
                    this.setPressed(false);
                    this.updateSelectorState();
                }
                setPressedItem(child, position) {
                    this.mDrawsInPressedState = true;
                    this.setPressed(true);
                    this.layoutChildren();
                    this.setSelectedPositionInt(position);
                    this.positionSelector(position, child);
                    this.refreshDrawableState();
                }
                touchModeDrawsInPressedState() {
                    return this.mDrawsInPressedState || super.touchModeDrawsInPressedState();
                }
                obtainView(position, isScrap) {
                    let view = super.obtainView(position, isScrap);
                    if (view instanceof TextView) {
                        view.setHorizontallyScrolling(true);
                    }
                    return view;
                }
                isInTouchMode() {
                    return (this.mHijackFocus && this.mListSelectionHidden) || super.isInTouchMode();
                }
                hasWindowFocus() {
                    return this.mHijackFocus || super.hasWindowFocus();
                }
                isFocused() {
                    return this.mHijackFocus || super.isFocused();
                }
                hasFocus() {
                    return this.mHijackFocus || super.hasFocus();
                }
            }
            DropDownListView.CLICK_ANIM_DURATION = 150;
            DropDownListView.CLICK_ANIM_ALPHA = 0x80;
            ListPopupWindow.DropDownListView = DropDownListView;
            class PopupDataSetObserver extends DataSetObserver {
                constructor(arg) {
                    super();
                    this._ListPopupWindow_this = arg;
                }
                onChanged() {
                    if (this._ListPopupWindow_this.isShowing()) {
                        this._ListPopupWindow_this.show();
                    }
                }
                onInvalidated() {
                    this._ListPopupWindow_this.dismiss();
                }
            }
            ListPopupWindow.PopupDataSetObserver = PopupDataSetObserver;
            class ListSelectorHider {
                constructor(arg) {
                    this._ListPopupWindow_this = arg;
                }
                run() {
                    this._ListPopupWindow_this.clearListSelection();
                }
            }
            ListPopupWindow.ListSelectorHider = ListSelectorHider;
            class ResizePopupRunnable {
                constructor(arg) {
                    this._ListPopupWindow_this = arg;
                }
                run() {
                    if (this._ListPopupWindow_this.mDropDownList != null && this._ListPopupWindow_this.mDropDownList.getCount() > this._ListPopupWindow_this.mDropDownList.getChildCount() && this._ListPopupWindow_this.mDropDownList.getChildCount() <= this._ListPopupWindow_this.mListItemExpandMaximum) {
                        this._ListPopupWindow_this.mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                        this._ListPopupWindow_this.show();
                    }
                }
            }
            ListPopupWindow.ResizePopupRunnable = ResizePopupRunnable;
            class PopupTouchInterceptor {
                constructor(arg) {
                    this._ListPopupWindow_this = arg;
                }
                onTouch(v, event) {
                    const action = event.getAction();
                    const x = Math.floor(event.getX());
                    const y = Math.floor(event.getY());
                    if (action == MotionEvent.ACTION_DOWN && this._ListPopupWindow_this.mPopup != null && this._ListPopupWindow_this.mPopup.isShowing() && (x >= 0 && x < this._ListPopupWindow_this.mPopup.getWidth() && y >= 0 && y < this._ListPopupWindow_this.mPopup.getHeight())) {
                        this._ListPopupWindow_this.mHandler.postDelayed(this._ListPopupWindow_this.mResizePopupRunnable, ListPopupWindow.EXPAND_LIST_TIMEOUT);
                    }
                    else if (action == MotionEvent.ACTION_UP) {
                        this._ListPopupWindow_this.mHandler.removeCallbacks(this._ListPopupWindow_this.mResizePopupRunnable);
                    }
                    return false;
                }
            }
            ListPopupWindow.PopupTouchInterceptor = PopupTouchInterceptor;
            class PopupScrollListener {
                constructor(arg) {
                    this._ListPopupWindow_this = arg;
                }
                onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount) {
                }
                onScrollStateChanged(view, scrollState) {
                    if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL
                        && !this._ListPopupWindow_this.isInputMethodNotNeeded() && this._ListPopupWindow_this.mPopup.getContentView() != null) {
                        this._ListPopupWindow_this.mHandler.removeCallbacks(this._ListPopupWindow_this.mResizePopupRunnable);
                        this._ListPopupWindow_this.mResizePopupRunnable.run();
                    }
                }
            }
            ListPopupWindow.PopupScrollListener = PopupScrollListener;
        })(ListPopupWindow = widget.ListPopupWindow || (widget.ListPopupWindow = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/app/AlertDialog.ts"/>
///<reference path="../../android/content/DialogInterface.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewTreeObserver.ts"/>
///<reference path="../../android/widget/AbsSpinner.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListPopupWindow.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/PopupWindow.ts"/>
///<reference path="../../android/widget/SpinnerAdapter.ts"/>
///<reference path="../../android/content/Context.ts"/>
///<reference path="../../android/R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var AlertDialog = android.app.AlertDialog;
        var Rect = android.graphics.Rect;
        var Log = android.util.Log;
        var Gravity = android.view.Gravity;
        var ViewGroup = android.view.ViewGroup;
        var ForwardingListener = android.widget.ListPopupWindow.ForwardingListener;
        var AbsSpinner = android.widget.AbsSpinner;
        var ListAdapter = android.widget.ListAdapter;
        var ListPopupWindow = android.widget.ListPopupWindow;
        var ListView = android.widget.ListView;
        var R = android.R;
        class Spinner extends AbsSpinner {
            constructor(context, bindElement, defStyle = R.attr.spinnerStyle, mode = Spinner.MODE_THEME) {
                super(context, bindElement, null);
                this.mDropDownWidth = 0;
                this.mGravity = 0;
                this.mTempRect = new Rect();
                let a = this._attrBinder;
                if (mode == Spinner.MODE_THEME) {
                    mode = Spinner.MODE_DROPDOWN;
                }
                switch (mode) {
                    case Spinner.MODE_DIALOG:
                        {
                            this.mPopup = new Spinner.DialogPopup(this);
                            break;
                        }
                    case Spinner.MODE_DROPDOWN:
                        {
                            const popup = new Spinner.DropdownPopup(context, defStyle, this);
                            a.addAttr('dropDownWidth', (value) => {
                                this.mDropDownWidth = a.parseNumber(value, ViewGroup.LayoutParams.WRAP_CONTENT);
                            });
                            a.addAttr('popupBackground', (value) => {
                                popup.setBackgroundDrawable(a.parseDrawable(value));
                            });
                            a.addAttr('dropDownVerticalOffset', (value) => {
                                const verticalOffset = a.parseNumber(value, 0);
                                if (verticalOffset != 0) {
                                    popup.setVerticalOffset(verticalOffset);
                                }
                            });
                            a.addAttr('dropDownHorizontalOffset', (value) => {
                                const horizontalOffset = a.parseNumber(value, 0);
                                if (horizontalOffset != 0) {
                                    popup.setHorizontalOffset(horizontalOffset);
                                }
                            });
                            this.mPopup = popup;
                            this.mForwardingListener = (() => {
                                const _this = this;
                                class _Inner extends ForwardingListener {
                                    getPopup() {
                                        return popup;
                                    }
                                    onForwardingStarted() {
                                        if (!_this.mPopup.isShowing()) {
                                            _this.mPopup.showPopup(_this.getTextDirection(), _this.getTextAlignment());
                                        }
                                        return true;
                                    }
                                }
                                return new _Inner(this);
                            })();
                            break;
                        }
                }
                a.addAttr('gravity', (value) => {
                    this.mGravity = a.parseNumber(value, Gravity.CENTER);
                });
                a.addAttr('prompt', (value) => {
                    this.mGravity = a.parseNumber(value, Gravity.CENTER);
                    this.mPopup.setPromptText(a.parseString(value));
                });
                a.addAttr('disableChildrenWhenDisabled', (value) => {
                    this.mDisableChildrenWhenDisabled = a.parseBoolean(value, false);
                });
                if (defStyle != null)
                    this.applyDefaultAttributes(defStyle);
                if (this.mTempAdapter != null) {
                    this.mPopup.setAdapter(this.mTempAdapter);
                    this.mTempAdapter = null;
                }
            }
            setPopupBackgroundDrawable(background) {
                if (!(this.mPopup instanceof Spinner.DropdownPopup)) {
                    Log.e(Spinner.TAG, "setPopupBackgroundDrawable: incompatible spinner mode; ignoring...");
                    return;
                }
                this.mPopup.setBackgroundDrawable(background);
            }
            getPopupBackground() {
                return this.mPopup.getBackground();
            }
            setDropDownVerticalOffset(pixels) {
                this.mPopup.setVerticalOffset(pixels);
            }
            getDropDownVerticalOffset() {
                return this.mPopup.getVerticalOffset();
            }
            setDropDownHorizontalOffset(pixels) {
                this.mPopup.setHorizontalOffset(pixels);
            }
            getDropDownHorizontalOffset() {
                return this.mPopup.getHorizontalOffset();
            }
            setDropDownWidth(pixels) {
                if (!(this.mPopup instanceof Spinner.DropdownPopup)) {
                    Log.e(Spinner.TAG, "Cannot set dropdown width for MODE_DIALOG, ignoring");
                    return;
                }
                this.mDropDownWidth = pixels;
            }
            getDropDownWidth() {
                return this.mDropDownWidth;
            }
            setEnabled(enabled) {
                super.setEnabled(enabled);
                if (this.mDisableChildrenWhenDisabled) {
                    const count = this.getChildCount();
                    for (let i = 0; i < count; i++) {
                        this.getChildAt(i).setEnabled(enabled);
                    }
                }
            }
            setGravity(gravity) {
                if (this.mGravity != gravity) {
                    if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == 0) {
                        gravity |= Gravity.START;
                    }
                    this.mGravity = gravity;
                    this.requestLayout();
                }
            }
            getGravity() {
                return this.mGravity;
            }
            setAdapter(adapter) {
                super.setAdapter(adapter);
                this.mRecycler.clear();
                if (this.mPopup != null) {
                    this.mPopup.setAdapter(new Spinner.DropDownAdapter(adapter));
                }
                else {
                    this.mTempAdapter = new Spinner.DropDownAdapter(adapter);
                }
            }
            getBaseline() {
                let child = null;
                if (this.getChildCount() > 0) {
                    child = this.getChildAt(0);
                }
                else if (this.mAdapter != null && this.mAdapter.getCount() > 0) {
                    child = this.makeView(0, false);
                    this.mRecycler.put(0, child);
                }
                if (child != null) {
                    const childBaseline = child.getBaseline();
                    return childBaseline >= 0 ? child.getTop() + childBaseline : -1;
                }
                else {
                    return -1;
                }
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                if (this.mPopup != null && this.mPopup.isShowing()) {
                    this.mPopup.dismiss();
                }
            }
            setOnItemClickListener(l) {
                throw Error(`new RuntimeException("setOnItemClickListener cannot be used with a spinner.")`);
            }
            setOnItemClickListenerInt(l) {
                super.setOnItemClickListener(l);
            }
            onTouchEvent(event) {
                if (this.mForwardingListener != null && this.mForwardingListener.onTouch(this, event)) {
                    return true;
                }
                return super.onTouchEvent(event);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                if (this.mPopup != null && Spinner.MeasureSpec.getMode(widthMeasureSpec) == Spinner.MeasureSpec.AT_MOST) {
                    const measuredWidth = this.getMeasuredWidth();
                    this.setMeasuredDimension(Math.min(Math.max(measuredWidth, this.measureContentWidth(this.getAdapter(), this.getBackground())), Spinner.MeasureSpec.getSize(widthMeasureSpec)), this.getMeasuredHeight());
                }
            }
            onLayout(changed, l, t, r, b) {
                super.onLayout(changed, l, t, r, b);
                this.mInLayout = true;
                this.layoutSpinner(0, false);
                this.mInLayout = false;
            }
            layoutSpinner(delta, animate) {
                let childrenLeft = this.mSpinnerPadding.left;
                let childrenWidth = this.mRight - this.mLeft - this.mSpinnerPadding.left - this.mSpinnerPadding.right;
                if (this.mDataChanged) {
                    this.handleDataChanged();
                }
                if (this.mItemCount == 0) {
                    this.resetList();
                    return;
                }
                if (this.mNextSelectedPosition >= 0) {
                    this.setSelectedPositionInt(this.mNextSelectedPosition);
                }
                this.recycleAllViews();
                this.removeAllViewsInLayout();
                this.mFirstPosition = this.mSelectedPosition;
                if (this.mAdapter != null) {
                    let sel = this.makeView(this.mSelectedPosition, true);
                    let width = sel.getMeasuredWidth();
                    let selectedOffset = childrenLeft;
                    const layoutDirection = this.getLayoutDirection();
                    const absoluteGravity = Gravity.getAbsoluteGravity(this.mGravity, layoutDirection);
                    switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                        case Gravity.CENTER_HORIZONTAL:
                            selectedOffset = childrenLeft + (childrenWidth / 2) - (width / 2);
                            break;
                        case Gravity.RIGHT:
                            selectedOffset = childrenLeft + childrenWidth - width;
                            break;
                    }
                    sel.offsetLeftAndRight(selectedOffset);
                }
                this.mRecycler.clear();
                this.invalidate();
                this.checkSelectionChanged();
                this.mDataChanged = false;
                this.mNeedSync = false;
                this.setNextSelectedPositionInt(this.mSelectedPosition);
            }
            makeView(position, addChild) {
                let child;
                if (!this.mDataChanged) {
                    child = this.mRecycler.get(position);
                    if (child != null) {
                        this.setUpChild(child, addChild);
                        return child;
                    }
                }
                child = this.mAdapter.getView(position, null, this);
                this.setUpChild(child, addChild);
                return child;
            }
            setUpChild(child, addChild) {
                let lp = child.getLayoutParams();
                if (lp == null) {
                    lp = this.generateDefaultLayoutParams();
                }
                if (addChild) {
                    this.addViewInLayout(child, 0, lp);
                }
                child.setSelected(this.hasFocus());
                if (this.mDisableChildrenWhenDisabled) {
                    child.setEnabled(this.isEnabled());
                }
                let childHeightSpec = ViewGroup.getChildMeasureSpec(this.mHeightMeasureSpec, this.mSpinnerPadding.top + this.mSpinnerPadding.bottom, lp.height);
                let childWidthSpec = ViewGroup.getChildMeasureSpec(this.mWidthMeasureSpec, this.mSpinnerPadding.left + this.mSpinnerPadding.right, lp.width);
                child.measure(childWidthSpec, childHeightSpec);
                let childLeft;
                let childRight;
                let childTop = this.mSpinnerPadding.top + ((this.getMeasuredHeight() - this.mSpinnerPadding.bottom - this.mSpinnerPadding.top - child.getMeasuredHeight()) / 2);
                let childBottom = childTop + child.getMeasuredHeight();
                let width = child.getMeasuredWidth();
                childLeft = 0;
                childRight = childLeft + width;
                child.layout(childLeft, childTop, childRight, childBottom);
            }
            performClick() {
                let handled = super.performClick();
                if (!handled) {
                    handled = true;
                    if (!this.mPopup.isShowing()) {
                        this.mPopup.showPopup(this.getTextDirection(), this.getTextAlignment());
                    }
                }
                return handled;
            }
            onClick(dialog, which) {
                this.setSelection(which);
                dialog.dismiss();
            }
            setPrompt(prompt) {
                this.mPopup.setPromptText(prompt);
            }
            getPrompt() {
                return this.mPopup.getHintText();
            }
            measureContentWidth(adapter, background) {
                if (adapter == null) {
                    return 0;
                }
                let width = 0;
                let itemView = null;
                let itemType = 0;
                const widthMeasureSpec = Spinner.MeasureSpec.makeMeasureSpec(0, Spinner.MeasureSpec.UNSPECIFIED);
                const heightMeasureSpec = Spinner.MeasureSpec.makeMeasureSpec(0, Spinner.MeasureSpec.UNSPECIFIED);
                let start = Math.max(0, this.getSelectedItemPosition());
                const end = Math.min(adapter.getCount(), start + Spinner.MAX_ITEMS_MEASURED);
                const count = end - start;
                start = Math.max(0, start - (Spinner.MAX_ITEMS_MEASURED - count));
                for (let i = start; i < end; i++) {
                    const positionType = adapter.getItemViewType(i);
                    if (positionType != itemType) {
                        itemType = positionType;
                        itemView = null;
                    }
                    itemView = adapter.getView(i, itemView, this);
                    if (itemView.getLayoutParams() == null) {
                        itemView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
                    }
                    itemView.measure(widthMeasureSpec, heightMeasureSpec);
                    width = Math.max(width, itemView.getMeasuredWidth());
                }
                if (background != null) {
                    background.getPadding(this.mTempRect);
                    width += this.mTempRect.left + this.mTempRect.right;
                }
                return width;
            }
        }
        Spinner.TAG = "Spinner";
        Spinner.MAX_ITEMS_MEASURED = 15;
        Spinner.MODE_DIALOG = 0;
        Spinner.MODE_DROPDOWN = 1;
        Spinner.MODE_THEME = -1;
        widget.Spinner = Spinner;
        (function (Spinner) {
            class DropDownAdapter {
                constructor(adapter) {
                    this.mAdapter = adapter;
                    if (ListAdapter.isImpl(adapter)) {
                        this.mListAdapter = adapter;
                    }
                }
                getCount() {
                    return this.mAdapter == null ? 0 : this.mAdapter.getCount();
                }
                getItem(position) {
                    return this.mAdapter == null ? null : this.mAdapter.getItem(position);
                }
                getItemId(position) {
                    return this.mAdapter == null ? -1 : this.mAdapter.getItemId(position);
                }
                getView(position, convertView, parent) {
                    return this.getDropDownView(position, convertView, parent);
                }
                getDropDownView(position, convertView, parent) {
                    return (this.mAdapter == null) ? null : this.mAdapter.getDropDownView(position, convertView, parent);
                }
                hasStableIds() {
                    return this.mAdapter != null && this.mAdapter.hasStableIds();
                }
                registerDataSetObserver(observer) {
                    if (this.mAdapter != null) {
                        this.mAdapter.registerDataSetObserver(observer);
                    }
                }
                unregisterDataSetObserver(observer) {
                    if (this.mAdapter != null) {
                        this.mAdapter.unregisterDataSetObserver(observer);
                    }
                }
                areAllItemsEnabled() {
                    const adapter = this.mListAdapter;
                    if (adapter != null) {
                        return adapter.areAllItemsEnabled();
                    }
                    else {
                        return true;
                    }
                }
                isEnabled(position) {
                    const adapter = this.mListAdapter;
                    if (adapter != null) {
                        return adapter.isEnabled(position);
                    }
                    else {
                        return true;
                    }
                }
                getItemViewType(position) {
                    return 0;
                }
                getViewTypeCount() {
                    return 1;
                }
                isEmpty() {
                    return this.getCount() == 0;
                }
            }
            Spinner.DropDownAdapter = DropDownAdapter;
            class DialogPopup {
                constructor(arg) {
                    this._Spinner_this = arg;
                }
                dismiss() {
                    this.mPopup.dismiss();
                    this.mPopup = null;
                }
                isShowing() {
                    return this.mPopup != null ? this.mPopup.isShowing() : false;
                }
                setAdapter(adapter) {
                    this.mListAdapter = adapter;
                }
                setPromptText(hintText) {
                    this.mPrompt = hintText;
                }
                getHintText() {
                    return this.mPrompt;
                }
                showPopup(textDirection, textAlignment) {
                    if (this.mListAdapter == null) {
                        return;
                    }
                    let builder = new AlertDialog.Builder(this._Spinner_this.getContext());
                    if (this.mPrompt != null) {
                        builder.setTitle(this.mPrompt);
                    }
                    this.mPopup = builder.setSingleChoiceItemsWithAdapter(this.mListAdapter, this._Spinner_this.getSelectedItemPosition(), this).create();
                    const listView = this.mPopup.getListView();
                    listView.setTextDirection(textDirection);
                    listView.setTextAlignment(textAlignment);
                    this.mPopup.show();
                }
                onClick(dialog, which) {
                    this._Spinner_this.setSelection(which);
                    if (this._Spinner_this.mOnItemClickListener != null) {
                        this._Spinner_this.performItemClick(null, which, this.mListAdapter.getItemId(which));
                    }
                    this.dismiss();
                }
                setBackgroundDrawable(bg) {
                    Log.e(Spinner.TAG, "Cannot set popup background for MODE_DIALOG, ignoring");
                }
                setVerticalOffset(px) {
                    Log.e(Spinner.TAG, "Cannot set vertical offset for MODE_DIALOG, ignoring");
                }
                setHorizontalOffset(px) {
                    Log.e(Spinner.TAG, "Cannot set horizontal offset for MODE_DIALOG, ignoring");
                }
                getBackground() {
                    return null;
                }
                getVerticalOffset() {
                    return 0;
                }
                getHorizontalOffset() {
                    return 0;
                }
            }
            Spinner.DialogPopup = DialogPopup;
            class DropdownPopup extends ListPopupWindow {
                constructor(context, defStyleRes, arg) {
                    super(context, defStyleRes);
                    this._Spinner_this = arg;
                    this.setAnchorView(this._Spinner_this);
                    this.setModal(true);
                    this.setPromptPosition(DropdownPopup.POSITION_PROMPT_ABOVE);
                    this.setOnItemClickListener((() => {
                        const _this = this;
                        class _Inner {
                            onItemClick(parent, v, position, id) {
                                _this._Spinner_this.setSelection(position);
                                if (_this._Spinner_this.mOnItemClickListener != null) {
                                    _this._Spinner_this.performItemClick(v, position, _this.mAdapter.getItemId(position));
                                }
                                _this.dismiss();
                            }
                        }
                        return new _Inner();
                    })());
                }
                setAdapter(adapter) {
                    super.setAdapter(adapter);
                }
                getHintText() {
                    return this.mHintText;
                }
                setPromptText(hintText) {
                    this.mHintText = hintText;
                }
                computeContentWidth() {
                    const background = this.getBackground();
                    let hOffset = 0;
                    if (background != null) {
                        background.getPadding(this._Spinner_this.mTempRect);
                        hOffset = this._Spinner_this.isLayoutRtl() ? this._Spinner_this.mTempRect.right : -this._Spinner_this.mTempRect.left;
                    }
                    else {
                        this._Spinner_this.mTempRect.left = this._Spinner_this.mTempRect.right = 0;
                    }
                    const spinnerPaddingLeft = this._Spinner_this.getPaddingLeft();
                    const spinnerPaddingRight = this._Spinner_this.getPaddingRight();
                    const spinnerWidth = this._Spinner_this.getWidth();
                    if (this._Spinner_this.mDropDownWidth == DropdownPopup.WRAP_CONTENT) {
                        let contentWidth = this._Spinner_this.measureContentWidth(this.mAdapter, this.getBackground());
                        const contentWidthLimit = this._Spinner_this.mContext.getResources().getDisplayMetrics().widthPixels - this._Spinner_this.mTempRect.left - this._Spinner_this.mTempRect.right;
                        if (contentWidth > contentWidthLimit) {
                            contentWidth = contentWidthLimit;
                        }
                        this.setContentWidth(Math.max(contentWidth, spinnerWidth - spinnerPaddingLeft - spinnerPaddingRight));
                    }
                    else if (this._Spinner_this.mDropDownWidth == DropdownPopup.MATCH_PARENT) {
                        this.setContentWidth(spinnerWidth - spinnerPaddingLeft - spinnerPaddingRight);
                    }
                    else {
                        this.setContentWidth(this._Spinner_this.mDropDownWidth);
                    }
                    if (this._Spinner_this.isLayoutRtl()) {
                        hOffset += spinnerWidth - spinnerPaddingRight - this.getWidth();
                    }
                    else {
                        hOffset += spinnerPaddingLeft;
                    }
                    this.setHorizontalOffset(hOffset);
                }
                showPopup(textDirection, textAlignment) {
                    const wasShowing = this.isShowing();
                    this.computeContentWidth();
                    this.setInputMethodMode(ListPopupWindow.INPUT_METHOD_NOT_NEEDED);
                    super.show();
                    const listView = this.getListView();
                    listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
                    listView.setTextDirection(textDirection);
                    listView.setTextAlignment(textAlignment);
                    this.setSelection(this._Spinner_this.getSelectedItemPosition());
                    if (wasShowing) {
                        return;
                    }
                    const vto = this._Spinner_this.getViewTreeObserver();
                    if (vto != null) {
                        const layoutListener = (() => {
                            const _this = this;
                            class _Inner {
                                onGlobalLayout() {
                                    if (!_this._Spinner_this.isVisibleToUser()) {
                                        _this.dismiss();
                                    }
                                    else {
                                        _this.computeContentWidth();
                                        _this.show();
                                    }
                                }
                            }
                            return new _Inner();
                        })();
                        vto.addOnGlobalLayoutListener(layoutListener);
                        this.setOnDismissListener((() => {
                            const _this = this;
                            class _Inner {
                                onDismiss() {
                                    const vto = _this._Spinner_this.getViewTreeObserver();
                                    if (vto != null) {
                                        vto.removeOnGlobalLayoutListener(layoutListener);
                                    }
                                }
                            }
                            return new _Inner();
                        })());
                    }
                }
            }
            Spinner.DropdownPopup = DropdownPopup;
        })(Spinner = widget.Spinner || (widget.Spinner = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/view/animation/Animation.ts"/>
///<reference path="../../../android/view/animation/Transformation.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            var Animation = android.view.animation.Animation;
            class RotateAnimation extends Animation {
                constructor(fromDegrees, toDegrees, pivotXType = RotateAnimation.ABSOLUTE, pivotXValue = 0, pivotYType = RotateAnimation.ABSOLUTE, pivotYValue = 0) {
                    super();
                    this.mFromDegrees = 0;
                    this.mToDegrees = 0;
                    this.mPivotXType = RotateAnimation.ABSOLUTE;
                    this.mPivotYType = RotateAnimation.ABSOLUTE;
                    this.mPivotXValue = 0.0;
                    this.mPivotYValue = 0.0;
                    this.mPivotX = 0;
                    this.mPivotY = 0;
                    this.mFromDegrees = fromDegrees;
                    this.mToDegrees = toDegrees;
                    this.mPivotXValue = pivotXValue;
                    this.mPivotXType = pivotXType;
                    this.mPivotYValue = pivotYValue;
                    this.mPivotYType = pivotYType;
                    this.initializePivotPoint();
                }
                initializePivotPoint() {
                    if (this.mPivotXType == RotateAnimation.ABSOLUTE) {
                        this.mPivotX = this.mPivotXValue;
                    }
                    if (this.mPivotYType == RotateAnimation.ABSOLUTE) {
                        this.mPivotY = this.mPivotYValue;
                    }
                }
                applyTransformation(interpolatedTime, t) {
                    let degrees = this.mFromDegrees + ((this.mToDegrees - this.mFromDegrees) * interpolatedTime);
                    let scale = this.getScaleFactor();
                    if (this.mPivotX == 0.0 && this.mPivotY == 0.0) {
                        t.getMatrix().setRotate(degrees);
                    }
                    else {
                        t.getMatrix().setRotate(degrees, this.mPivotX * scale, this.mPivotY * scale);
                    }
                }
                initialize(width, height, parentWidth, parentHeight) {
                    super.initialize(width, height, parentWidth, parentHeight);
                    this.mPivotX = this.resolveSize(this.mPivotXType, this.mPivotXValue, width, parentWidth);
                    this.mPivotY = this.resolveSize(this.mPivotYType, this.mPivotYValue, height, parentHeight);
                }
            }
            animation.RotateAnimation = RotateAnimation;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="../../../database/DataSetObservable.ts"/>
///<reference path="../../../database/Observable.ts"/>
///<reference path="../../../database/DataSetObserver.ts"/>
///<reference path="../../../view/ViewGroup.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var view;
            (function (view_7) {
                var DataSetObservable = android.database.DataSetObservable;
                class PagerAdapter {
                    constructor() {
                        this.mObservable = new DataSetObservable();
                    }
                    startUpdate(container) {
                    }
                    instantiateItem(container, position) {
                        throw new Error("Required method instantiateItem was not overridden");
                    }
                    destroyItem(container, position, object) {
                        throw new Error("Required method destroyItem was not overridden");
                    }
                    setPrimaryItem(container, position, object) {
                    }
                    finishUpdate(container) {
                    }
                    getItemPosition(object) {
                        return PagerAdapter.POSITION_UNCHANGED;
                    }
                    notifyDataSetChanged() {
                        this.mObservable.notifyChanged();
                    }
                    registerDataSetObserver(observer) {
                        this.mObservable.registerObserver(observer);
                    }
                    unregisterDataSetObserver(observer) {
                        this.mObservable.unregisterObserver(observer);
                    }
                    getPageTitle(position) {
                        return null;
                    }
                    getPageWidth(position) {
                        return 1;
                    }
                }
                PagerAdapter.POSITION_UNCHANGED = -1;
                PagerAdapter.POSITION_NONE = -2;
                view_7.PagerAdapter = PagerAdapter;
            })(view = v4.view || (v4.view = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="../../../view/View.ts"/>
///<reference path="../../../view/VelocityTracker.ts"/>
///<reference path="../../../widget/OverScroller.ts"/>
///<reference path="../../../view/ViewGroup.ts"/>
///<reference path="../../../view/MotionEvent.ts"/>
///<reference path="../../../view/animation/Interpolator.ts"/>
///<reference path="../../../../java/util/ArrayList.ts"/>
///<reference path="../../../database/DataSetObservable.ts"/>
///<reference path="../../../database/Observable.ts"/>
///<reference path="../../../database/DataSetObserver.ts"/>
///<reference path="PagerAdapter.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var view;
            (function (view_8) {
                var View = android.view.View;
                var Gravity = android.view.Gravity;
                var MeasureSpec = View.MeasureSpec;
                var OverScroller = android.widget.OverScroller;
                var ViewGroup = android.view.ViewGroup;
                var ArrayList = java.util.ArrayList;
                var Rect = android.graphics.Rect;
                var PagerAdapter = android.support.v4.view.PagerAdapter;
                var DataSetObserver = android.database.DataSetObserver;
                var VelocityTracker = android.view.VelocityTracker;
                var ViewConfiguration = android.view.ViewConfiguration;
                var Resources = android.content.res.Resources;
                var Log = android.util.Log;
                var MotionEvent = android.view.MotionEvent;
                var KeyEvent = android.view.KeyEvent;
                const TAG = "ViewPager";
                const DEBUG = false;
                const SymbolDecor = Symbol();
                class ViewPager extends ViewGroup {
                    constructor(context, bindElement, defStyle) {
                        super(context, bindElement, defStyle);
                        this.mExpectedAdapterCount = 0;
                        this.mItems = new ArrayList();
                        this.mTempItem = new ItemInfo();
                        this.mTempRect = new Rect();
                        this.mCurItem = 0;
                        this.mRestoredCurItem = -1;
                        this.mPageMargin = 0;
                        this.mTopPageBounds = 0;
                        this.mBottomPageBounds = 0;
                        this.mFirstOffset = -Number.MAX_VALUE;
                        this.mLastOffset = Number.MAX_VALUE;
                        this.mChildWidthMeasureSpec = 0;
                        this.mChildHeightMeasureSpec = 0;
                        this.mInLayout = false;
                        this.mScrollingCacheEnabled = false;
                        this.mPopulatePending = false;
                        this.mOffscreenPageLimit = ViewPager.DEFAULT_OFFSCREEN_PAGES;
                        this.mIsBeingDragged = false;
                        this.mIsUnableToDrag = false;
                        this.mDefaultGutterSize = 0;
                        this.mGutterSize = 0;
                        this.mLastMotionX = 0;
                        this.mLastMotionY = 0;
                        this.mInitialMotionX = 0;
                        this.mInitialMotionY = 0;
                        this.mActivePointerId = ViewPager.INVALID_POINTER;
                        this.mMinimumVelocity = 0;
                        this.mMaximumVelocity = 0;
                        this.mFlingDistance = 0;
                        this.mCloseEnough = 0;
                        this.mFakeDragging = false;
                        this.mFakeDragBeginTime = 0;
                        this.mFirstLayout = true;
                        this.mNeedCalculatePageOffsets = false;
                        this.mCalledSuper = false;
                        this.mDecorChildCount = 0;
                        this.mDrawingOrder = 0;
                        this.mEndScrollRunnable = (() => {
                            let ViewPager_this = this;
                            class InnerClass {
                                run() {
                                    ViewPager_this.setScrollState(ViewPager.SCROLL_STATE_IDLE);
                                    ViewPager_this.populate();
                                }
                            }
                            return new InnerClass();
                        })();
                        this.mScrollState = ViewPager.SCROLL_STATE_IDLE;
                        this.initViewPager();
                    }
                    initViewPager() {
                        this.setWillNotDraw(false);
                        this.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
                        this.setFocusable(true);
                        this.mScroller = new OverScroller(ViewPager.sInterpolator);
                        let density = Resources.getDisplayMetrics().density;
                        this.mTouchSlop = ViewConfiguration.get().getScaledPagingTouchSlop();
                        this.mMinimumVelocity = Math.floor(ViewPager.MIN_FLING_VELOCITY * density);
                        this.mMaximumVelocity = ViewConfiguration.get().getScaledMaximumFlingVelocity();
                        this.mFlingDistance = Math.floor(ViewPager.MIN_DISTANCE_FOR_FLING * density);
                        this.mCloseEnough = Math.floor(ViewPager.CLOSE_ENOUGH * density);
                        this.mDefaultGutterSize = Math.floor(ViewPager.DEFAULT_GUTTER_SIZE * density);
                    }
                    onDetachedFromWindow() {
                        this.removeCallbacks(this.mEndScrollRunnable);
                        super.onDetachedFromWindow();
                    }
                    setScrollState(newState) {
                        if (this.mScrollState == newState) {
                            return;
                        }
                        this.mScrollState = newState;
                        if (this.mPageTransformer != null) {
                            this.enableLayers(newState != ViewPager.SCROLL_STATE_IDLE);
                        }
                        this.dispatchOnScrollStateChanged(newState);
                    }
                    setAdapter(adapter) {
                        if (this.mAdapter != null) {
                            this.mAdapter.unregisterDataSetObserver(this.mObserver);
                            this.mAdapter.startUpdate(this);
                            for (let i = 0; i < this.mItems.size(); i++) {
                                const ii = this.mItems.get(i);
                                this.mAdapter.destroyItem(this, ii.position, ii.object);
                            }
                            this.mAdapter.finishUpdate(this);
                            this.mItems.clear();
                            this.removeNonDecorViews();
                            this.mCurItem = 0;
                            this.scrollTo(0, 0);
                        }
                        const oldAdapter = this.mAdapter;
                        this.mAdapter = adapter;
                        this.mExpectedAdapterCount = 0;
                        if (this.mAdapter != null) {
                            if (this.mObserver == null) {
                                this.mObserver = new PagerObserver(this);
                            }
                            this.mAdapter.registerDataSetObserver(this.mObserver);
                            this.mPopulatePending = false;
                            const wasFirstLayout = this.mFirstLayout;
                            this.mFirstLayout = true;
                            this.mExpectedAdapterCount = this.mAdapter.getCount();
                            if (this.mRestoredCurItem >= 0) {
                                this.setCurrentItemInternal(this.mRestoredCurItem, false, true);
                                this.mRestoredCurItem = -1;
                            }
                            else if (!wasFirstLayout) {
                                this.populate();
                            }
                            else {
                                this.requestLayout();
                            }
                        }
                        if (this.mAdapterChangeListener != null && oldAdapter != adapter) {
                            this.mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);
                        }
                    }
                    removeNonDecorViews() {
                        for (let i = 0; i < this.getChildCount(); i++) {
                            const child = this.getChildAt(i);
                            const lp = child.getLayoutParams();
                            if (!lp.isDecor) {
                                this.removeViewAt(i);
                                i--;
                            }
                        }
                    }
                    getAdapter() {
                        return this.mAdapter;
                    }
                    setOnAdapterChangeListener(listener) {
                        this.mAdapterChangeListener = listener;
                    }
                    getClientWidth() {
                        return this.getMeasuredWidth() - this.getPaddingLeft() - this.getPaddingRight();
                    }
                    setCurrentItem(item, smoothScroll = !this.mFirstLayout) {
                        this.mPopulatePending = false;
                        this.setCurrentItemInternal(item, smoothScroll, false);
                    }
                    getCurrentItem() {
                        return this.mCurItem;
                    }
                    setCurrentItemInternal(item, smoothScroll, always, velocity = 0) {
                        if (this.mAdapter == null || this.mAdapter.getCount() <= 0) {
                            this.setScrollingCacheEnabled(false);
                            return;
                        }
                        if (!always && this.mCurItem == item && this.mItems.size() != 0) {
                            this.setScrollingCacheEnabled(false);
                            return;
                        }
                        if (item < 0) {
                            item = 0;
                        }
                        else if (item >= this.mAdapter.getCount()) {
                            item = this.mAdapter.getCount() - 1;
                        }
                        const pageLimit = this.mOffscreenPageLimit;
                        if (item > (this.mCurItem + pageLimit) || item < (this.mCurItem - pageLimit)) {
                            for (let i = 0; i < this.mItems.size(); i++) {
                                this.mItems.get(i).scrolling = true;
                            }
                        }
                        const dispatchSelected = this.mCurItem != item;
                        if (this.mFirstLayout) {
                            this.mCurItem = item;
                            if (dispatchSelected) {
                                this.dispatchOnPageSelected(item);
                            }
                            this.requestLayout();
                        }
                        else {
                            this.populate(item);
                            this.scrollToItem(item, smoothScroll, velocity, dispatchSelected);
                        }
                    }
                    scrollToItem(item, smoothScroll, velocity, dispatchSelected) {
                        const curInfo = this.infoForPosition(item);
                        let destX = 0;
                        if (curInfo != null) {
                            const width = this.getClientWidth();
                            destX = Math.floor(width * Math.max(this.mFirstOffset, Math.min(curInfo.offset, this.mLastOffset)));
                        }
                        if (smoothScroll) {
                            this.smoothScrollTo(destX, 0, velocity);
                            if (dispatchSelected) {
                                this.dispatchOnPageSelected(item);
                            }
                        }
                        else {
                            if (dispatchSelected) {
                                this.dispatchOnPageSelected(item);
                            }
                            this.completeScroll(false);
                            this.scrollTo(destX, 0);
                            this.pageScrolled(destX);
                        }
                    }
                    setOnPageChangeListener(listener) {
                        this.mOnPageChangeListener = listener;
                    }
                    addOnPageChangeListener(listener) {
                        if (this.mOnPageChangeListeners == null) {
                            this.mOnPageChangeListeners = new ArrayList();
                        }
                        this.mOnPageChangeListeners.add(listener);
                    }
                    removeOnPageChangeListener(listener) {
                        if (this.mOnPageChangeListeners != null) {
                            this.mOnPageChangeListeners.remove(listener);
                        }
                    }
                    clearOnPageChangeListeners() {
                        if (this.mOnPageChangeListeners != null) {
                            this.mOnPageChangeListeners.clear();
                        }
                    }
                    setPageTransformer(reverseDrawingOrder, transformer) {
                        const hasTransformer = transformer != null;
                        const needsPopulate = hasTransformer != (this.mPageTransformer != null);
                        this.mPageTransformer = transformer;
                        this.setChildrenDrawingOrderEnabledCompat(hasTransformer);
                        if (hasTransformer) {
                            this.mDrawingOrder = reverseDrawingOrder ? ViewPager.DRAW_ORDER_REVERSE : ViewPager.DRAW_ORDER_FORWARD;
                        }
                        else {
                            this.mDrawingOrder = ViewPager.DRAW_ORDER_DEFAULT;
                        }
                        if (needsPopulate)
                            this.populate();
                    }
                    setChildrenDrawingOrderEnabledCompat(enable = true) {
                        this.setChildrenDrawingOrderEnabled(enable);
                    }
                    getChildDrawingOrder(childCount, i) {
                        const index = this.mDrawingOrder == ViewPager.DRAW_ORDER_REVERSE ? childCount - 1 - i : i;
                        const result = this.mDrawingOrderedChildren.get(index).getLayoutParams().childIndex;
                        return result;
                    }
                    setInternalPageChangeListener(listener) {
                        let oldListener = this.mInternalPageChangeListener;
                        this.mInternalPageChangeListener = listener;
                        return oldListener;
                    }
                    getOffscreenPageLimit() {
                        return this.mOffscreenPageLimit;
                    }
                    setOffscreenPageLimit(limit) {
                        if (limit < ViewPager.DEFAULT_OFFSCREEN_PAGES) {
                            Log.w(TAG, "Requested offscreen page limit " + limit + " too small; defaulting to " +
                                ViewPager.DEFAULT_OFFSCREEN_PAGES);
                            limit = ViewPager.DEFAULT_OFFSCREEN_PAGES;
                        }
                        if (limit != this.mOffscreenPageLimit) {
                            this.mOffscreenPageLimit = limit;
                            this.populate();
                        }
                    }
                    setPageMargin(marginPixels) {
                        const oldMargin = this.mPageMargin;
                        this.mPageMargin = marginPixels;
                        const width = this.getWidth();
                        this.recomputeScrollPosition(width, width, marginPixels, oldMargin);
                        this.requestLayout();
                    }
                    getPageMargin() {
                        return this.mPageMargin;
                    }
                    setPageMarginDrawable(d) {
                        this.mMarginDrawable = d;
                        if (d != null)
                            this.refreshDrawableState();
                        this.setWillNotDraw(d == null);
                        this.invalidate();
                    }
                    verifyDrawable(who) {
                        return super.verifyDrawable(who) || who == this.mMarginDrawable;
                    }
                    drawableStateChanged() {
                        super.drawableStateChanged();
                        const d = this.mMarginDrawable;
                        if (d != null && d.isStateful()) {
                            d.setState(this.getDrawableState());
                        }
                    }
                    distanceInfluenceForSnapDuration(f) {
                        f -= 0.5;
                        f *= 0.3 * Math.PI / 2.0;
                        return Math.sin(f);
                    }
                    smoothScrollTo(x, y, velocity = 0) {
                        if (this.getChildCount() == 0) {
                            this.setScrollingCacheEnabled(false);
                            return;
                        }
                        let sx = this.getScrollX();
                        let sy = this.getScrollY();
                        let dx = x - sx;
                        let dy = y - sy;
                        if (dx == 0 && dy == 0) {
                            this.completeScroll(false);
                            this.populate();
                            this.setScrollState(ViewPager.SCROLL_STATE_IDLE);
                            return;
                        }
                        this.setScrollingCacheEnabled(true);
                        this.setScrollState(ViewPager.SCROLL_STATE_SETTLING);
                        const width = this.getClientWidth();
                        const halfWidth = width / 2;
                        const distanceRatio = Math.min(1, 1.0 * Math.abs(dx) / width);
                        const distance = halfWidth + halfWidth *
                            this.distanceInfluenceForSnapDuration(distanceRatio);
                        let duration = 0;
                        velocity = Math.abs(velocity);
                        if (velocity > 0) {
                            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
                        }
                        else {
                            const pageWidth = width * this.mAdapter.getPageWidth(this.mCurItem);
                            const pageDelta = Math.abs(dx) / (pageWidth + this.mPageMargin);
                            duration = Math.floor((pageDelta + 1) * 100);
                        }
                        duration = Math.min(duration, ViewPager.MAX_SETTLE_DURATION);
                        this.mScroller.startScroll(sx, sy, dx, dy, duration);
                        this.postInvalidateOnAnimation();
                    }
                    addNewItem(position, index) {
                        let ii = new ItemInfo();
                        ii.position = position;
                        ii.object = this.mAdapter.instantiateItem(this, position);
                        ii.widthFactor = this.mAdapter.getPageWidth(position);
                        if (index < 0 || index >= this.mItems.size()) {
                            this.mItems.add(ii);
                        }
                        else {
                            this.mItems.add(index, ii);
                        }
                        return ii;
                    }
                    dataSetChanged() {
                        // This method only gets called if our observer is attached, so mAdapter is non-null.
                        const adapterCount = this.mAdapter.getCount();
                        this.mExpectedAdapterCount = adapterCount;
                        let needPopulate = this.mItems.size() < this.mOffscreenPageLimit * 2 + 1 &&
                            this.mItems.size() < adapterCount;
                        let newCurrItem = this.mCurItem;
                        let isUpdating = false;
                        for (let i = 0; i < this.mItems.size(); i++) {
                            const ii = this.mItems.get(i);
                            const newPos = this.mAdapter.getItemPosition(ii.object);
                            if (newPos == PagerAdapter.POSITION_UNCHANGED) {
                                continue;
                            }
                            if (newPos == PagerAdapter.POSITION_NONE) {
                                this.mItems.remove(i);
                                i--;
                                if (!isUpdating) {
                                    this.mAdapter.startUpdate(this);
                                    isUpdating = true;
                                }
                                this.mAdapter.destroyItem(this, ii.position, ii.object);
                                needPopulate = true;
                                if (this.mCurItem == ii.position) {
                                    newCurrItem = Math.max(0, Math.min(this.mCurItem, adapterCount - 1));
                                    needPopulate = true;
                                }
                                continue;
                            }
                            if (ii.position != newPos) {
                                if (ii.position == this.mCurItem) {
                                    newCurrItem = newPos;
                                }
                                ii.position = newPos;
                                needPopulate = true;
                            }
                        }
                        if (isUpdating) {
                            this.mAdapter.finishUpdate(this);
                        }
                        this.mItems.sort(ViewPager.COMPARATOR);
                        if (needPopulate) {
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                const lp = child.getLayoutParams();
                                if (!lp.isDecor) {
                                    lp.widthFactor = 0;
                                }
                            }
                            this.setCurrentItemInternal(newCurrItem, false, true);
                            this.requestLayout();
                        }
                    }
                    populate(newCurrentItem = this.mCurItem) {
                        let oldCurInfo = null;
                        let focusDirection = View.FOCUS_FORWARD;
                        if (this.mCurItem != newCurrentItem) {
                            focusDirection = this.mCurItem < newCurrentItem ? View.FOCUS_RIGHT : View.FOCUS_LEFT;
                            oldCurInfo = this.infoForPosition(this.mCurItem);
                            this.mCurItem = newCurrentItem;
                        }
                        if (this.mAdapter == null) {
                            this.sortChildDrawingOrder();
                            return;
                        }
                        if (this.mPopulatePending) {
                            if (DEBUG)
                                Log.i(TAG, "populate is pending, skipping for now...");
                            this.sortChildDrawingOrder();
                            return;
                        }
                        if (!this.isAttachedToWindow()) {
                            return;
                        }
                        this.mAdapter.startUpdate(this);
                        const pageLimit = this.mOffscreenPageLimit;
                        const startPos = Math.max(0, this.mCurItem - pageLimit);
                        const N = this.mAdapter.getCount();
                        const endPos = Math.min(N - 1, this.mCurItem + pageLimit);
                        if (N != this.mExpectedAdapterCount) {
                            throw new Error("The application's PagerAdapter changed the adapter's" +
                                " contents without calling PagerAdapter#notifyDataSetChanged!" +
                                " Expected adapter item count: " + this.mExpectedAdapterCount + ", found: " + N +
                                " Pager id: " + this.getId() +
                                " Pager class: " + this.constructor.name +
                                " Problematic adapter: " + this.mAdapter.constructor.name);
                        }
                        let curIndex = -1;
                        let curItem = null;
                        for (curIndex = 0; curIndex < this.mItems.size(); curIndex++) {
                            const ii = this.mItems.get(curIndex);
                            if (ii.position >= this.mCurItem) {
                                if (ii.position == this.mCurItem)
                                    curItem = ii;
                                break;
                            }
                        }
                        if (curItem == null && N > 0) {
                            curItem = this.addNewItem(this.mCurItem, curIndex);
                        }
                        if (curItem != null) {
                            let extraWidthLeft = 0;
                            let itemIndex = curIndex - 1;
                            let ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                            const clientWidth = this.getClientWidth();
                            const leftWidthNeeded = clientWidth <= 0 ? 0 :
                                2 - curItem.widthFactor + this.getPaddingLeft() / clientWidth;
                            for (let pos = this.mCurItem - 1; pos >= 0; pos--) {
                                if (extraWidthLeft >= leftWidthNeeded && pos < startPos) {
                                    if (ii == null) {
                                        break;
                                    }
                                    if (pos == ii.position && !ii.scrolling) {
                                        this.mItems.remove(itemIndex);
                                        this.mAdapter.destroyItem(this, pos, ii.object);
                                        if (DEBUG) {
                                            Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                                " view: " + ii.object);
                                        }
                                        itemIndex--;
                                        curIndex--;
                                        ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                                    }
                                }
                                else if (ii != null && pos == ii.position) {
                                    extraWidthLeft += ii.widthFactor;
                                    itemIndex--;
                                    ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                                }
                                else {
                                    ii = this.addNewItem(pos, itemIndex + 1);
                                    extraWidthLeft += ii.widthFactor;
                                    curIndex++;
                                    ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                                }
                            }
                            let extraWidthRight = curItem.widthFactor;
                            itemIndex = curIndex + 1;
                            if (extraWidthRight < 2) {
                                ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                const rightWidthNeeded = clientWidth <= 0 ? 0 :
                                    this.getPaddingRight() / clientWidth + 2;
                                for (let pos = this.mCurItem + 1; pos < N; pos++) {
                                    if (extraWidthRight >= rightWidthNeeded && pos > endPos) {
                                        if (ii == null) {
                                            break;
                                        }
                                        if (pos == ii.position && !ii.scrolling) {
                                            this.mItems.remove(itemIndex);
                                            this.mAdapter.destroyItem(this, pos, ii.object);
                                            if (DEBUG) {
                                                Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                                    " view: " + ii.object);
                                            }
                                            ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                        }
                                    }
                                    else if (ii != null && pos == ii.position) {
                                        extraWidthRight += ii.widthFactor;
                                        itemIndex++;
                                        ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                    }
                                    else {
                                        ii = this.addNewItem(pos, itemIndex);
                                        itemIndex++;
                                        extraWidthRight += ii.widthFactor;
                                        ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                    }
                                }
                            }
                            this.calculatePageOffsets(curItem, curIndex, oldCurInfo);
                        }
                        if (DEBUG) {
                            Log.i(TAG, "Current page list:");
                            for (let i = 0; i < this.mItems.size(); i++) {
                                Log.i(TAG, "#" + i + ": page " + this.mItems.get(i).position);
                            }
                        }
                        this.mAdapter.setPrimaryItem(this, this.mCurItem, curItem != null ? curItem.object : null);
                        this.mAdapter.finishUpdate(this);
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const child = this.getChildAt(i);
                            const lp = child.getLayoutParams();
                            lp.childIndex = i;
                            if (!lp.isDecor && lp.widthFactor == 0) {
                                const ii = this.infoForChild(child);
                                if (ii != null) {
                                    lp.widthFactor = ii.widthFactor;
                                    lp.position = ii.position;
                                }
                            }
                        }
                        this.sortChildDrawingOrder();
                        if (this.hasFocus()) {
                            let currentFocused = this.findFocus();
                            let ii = currentFocused != null ? this.infoForAnyChild(currentFocused) : null;
                            if (ii == null || ii.position != this.mCurItem) {
                                for (let i = 0; i < this.getChildCount(); i++) {
                                    let child = this.getChildAt(i);
                                    ii = this.infoForChild(child);
                                    if (ii != null && ii.position == this.mCurItem) {
                                        if (child.requestFocus(focusDirection)) {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    sortChildDrawingOrder() {
                        if (this.mDrawingOrder != ViewPager.DRAW_ORDER_DEFAULT) {
                            if (this.mDrawingOrderedChildren == null) {
                                this.mDrawingOrderedChildren = new ArrayList();
                            }
                            else {
                                this.mDrawingOrderedChildren.clear();
                            }
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                this.mDrawingOrderedChildren.add(child);
                            }
                            this.mDrawingOrderedChildren.sort(ViewPager.sPositionComparator);
                        }
                    }
                    calculatePageOffsets(curItem, curIndex, oldCurInfo) {
                        const N = this.mAdapter.getCount();
                        const width = this.getClientWidth();
                        const marginOffset = width > 0 ? this.mPageMargin / width : 0;
                        if (oldCurInfo != null) {
                            const oldCurPosition = oldCurInfo.position;
                            if (oldCurPosition < curItem.position) {
                                let itemIndex = 0;
                                let ii = null;
                                let offset = oldCurInfo.offset + oldCurInfo.widthFactor + marginOffset;
                                for (let pos = oldCurPosition + 1; pos <= curItem.position && itemIndex < this.mItems.size(); pos++) {
                                    ii = this.mItems.get(itemIndex);
                                    while (pos > ii.position && itemIndex < this.mItems.size() - 1) {
                                        itemIndex++;
                                        ii = this.mItems.get(itemIndex);
                                    }
                                    while (pos < ii.position) {
                                        offset += this.mAdapter.getPageWidth(pos) + marginOffset;
                                        pos++;
                                    }
                                    ii.offset = offset;
                                    offset += ii.widthFactor + marginOffset;
                                }
                            }
                            else if (oldCurPosition > curItem.position) {
                                let itemIndex = this.mItems.size() - 1;
                                let ii = null;
                                let offset = oldCurInfo.offset;
                                for (let pos = oldCurPosition - 1; pos >= curItem.position && itemIndex >= 0; pos--) {
                                    ii = this.mItems.get(itemIndex);
                                    while (pos < ii.position && itemIndex > 0) {
                                        itemIndex--;
                                        ii = this.mItems.get(itemIndex);
                                    }
                                    while (pos > ii.position) {
                                        offset -= this.mAdapter.getPageWidth(pos) + marginOffset;
                                        pos--;
                                    }
                                    offset -= ii.widthFactor + marginOffset;
                                    ii.offset = offset;
                                }
                            }
                        }
                        const itemCount = this.mItems.size();
                        let offset = curItem.offset;
                        let pos = curItem.position - 1;
                        this.mFirstOffset = curItem.position == 0 ? curItem.offset : -Number.MAX_VALUE;
                        this.mLastOffset = curItem.position == N - 1 ?
                            curItem.offset + curItem.widthFactor - 1 : Number.MAX_VALUE;
                        for (let i = curIndex - 1; i >= 0; i--, pos--) {
                            const ii = this.mItems.get(i);
                            while (pos > ii.position) {
                                offset -= this.mAdapter.getPageWidth(pos--) + marginOffset;
                            }
                            offset -= ii.widthFactor + marginOffset;
                            ii.offset = offset;
                            if (ii.position == 0)
                                this.mFirstOffset = offset;
                        }
                        offset = curItem.offset + curItem.widthFactor + marginOffset;
                        pos = curItem.position + 1;
                        for (let i = curIndex + 1; i < itemCount; i++, pos++) {
                            const ii = this.mItems.get(i);
                            while (pos < ii.position) {
                                offset += this.mAdapter.getPageWidth(pos++) + marginOffset;
                            }
                            if (ii.position == N - 1) {
                                this.mLastOffset = offset + ii.widthFactor - 1;
                            }
                            ii.offset = offset;
                            offset += ii.widthFactor + marginOffset;
                        }
                        this.mNeedCalculatePageOffsets = false;
                    }
                    addView(...args) {
                        if (args.length === 3 && args[2] instanceof ViewGroup.LayoutParams) {
                            this._addViewOverride(args[0], args[1], args[2]);
                        }
                        else {
                            super.addView(...args);
                        }
                    }
                    _addViewOverride(child, index, params) {
                        if (!this.checkLayoutParams(params)) {
                            params = this.generateLayoutParams(params);
                        }
                        const lp = params;
                        lp.isDecor = lp.isDecor || ViewPager.isImplDecor(child);
                        if (this.mInLayout) {
                            if (lp != null && lp.isDecor) {
                                throw new Error("Cannot add pager decor view during layout");
                            }
                            lp.needsMeasure = true;
                            this.addViewInLayout(child, index, params);
                        }
                        else {
                            super.addView(child, index, params);
                        }
                        if (ViewPager.USE_CACHE) {
                            if (child.getVisibility() != View.GONE) {
                                child.setDrawingCacheEnabled(this.mScrollingCacheEnabled);
                            }
                            else {
                                child.setDrawingCacheEnabled(false);
                            }
                        }
                    }
                    removeView(view) {
                        if (this.mInLayout) {
                            this.removeViewInLayout(view);
                        }
                        else {
                            super.removeView(view);
                        }
                    }
                    infoForChild(child) {
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            if (this.mAdapter.isViewFromObject(child, ii.object)) {
                                return ii;
                            }
                        }
                        return null;
                    }
                    infoForAnyChild(child) {
                        let parent;
                        while ((parent = child.getParent()) != this) {
                            if (parent == null || !(parent instanceof View)) {
                                return null;
                            }
                            child = parent;
                        }
                        return this.infoForChild(child);
                    }
                    infoForPosition(position) {
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            if (ii.position == position) {
                                return ii;
                            }
                        }
                        return null;
                    }
                    onAttachedToWindow() {
                        super.onAttachedToWindow();
                        this.mFirstLayout = true;
                    }
                    onMeasure(widthMeasureSpec, heightMeasureSpec) {
                        this.setMeasuredDimension(ViewPager.getDefaultSize(0, widthMeasureSpec), ViewPager.getDefaultSize(0, heightMeasureSpec));
                        const measuredWidth = this.getMeasuredWidth();
                        const maxGutterSize = measuredWidth / 10;
                        this.mGutterSize = Math.min(maxGutterSize, this.mDefaultGutterSize);
                        let childWidthSize = measuredWidth - this.getPaddingLeft() - this.getPaddingRight();
                        let childHeightSize = this.getMeasuredHeight() - this.getPaddingTop() - this.getPaddingBottom();
                        let size = this.getChildCount();
                        for (let i = 0; i < size; ++i) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                const lp = child.getLayoutParams();
                                if (lp != null && lp.isDecor) {
                                    const hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                                    const vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
                                    let widthMode = MeasureSpec.AT_MOST;
                                    let heightMode = MeasureSpec.AT_MOST;
                                    let consumeVertical = vgrav == Gravity.TOP || vgrav == Gravity.BOTTOM;
                                    let consumeHorizontal = hgrav == Gravity.LEFT || hgrav == Gravity.RIGHT;
                                    if (consumeVertical) {
                                        widthMode = MeasureSpec.EXACTLY;
                                    }
                                    else if (consumeHorizontal) {
                                        heightMode = MeasureSpec.EXACTLY;
                                    }
                                    let widthSize = childWidthSize;
                                    let heightSize = childHeightSize;
                                    if (lp.width != ViewPager.LayoutParams.WRAP_CONTENT) {
                                        widthMode = MeasureSpec.EXACTLY;
                                        if (lp.width != ViewPager.LayoutParams.FILL_PARENT) {
                                            widthSize = lp.width;
                                        }
                                    }
                                    if (lp.height != ViewPager.LayoutParams.WRAP_CONTENT) {
                                        heightMode = MeasureSpec.EXACTLY;
                                        if (lp.height != ViewPager.LayoutParams.FILL_PARENT) {
                                            heightSize = lp.height;
                                        }
                                    }
                                    const widthSpec = MeasureSpec.makeMeasureSpec(widthSize, widthMode);
                                    const heightSpec = MeasureSpec.makeMeasureSpec(heightSize, heightMode);
                                    child.measure(widthSpec, heightSpec);
                                    if (consumeVertical) {
                                        childHeightSize -= child.getMeasuredHeight();
                                    }
                                    else if (consumeHorizontal) {
                                        childWidthSize -= child.getMeasuredWidth();
                                    }
                                }
                            }
                        }
                        this.mChildWidthMeasureSpec = MeasureSpec.makeMeasureSpec(childWidthSize, MeasureSpec.EXACTLY);
                        this.mChildHeightMeasureSpec = MeasureSpec.makeMeasureSpec(childHeightSize, MeasureSpec.EXACTLY);
                        this.mInLayout = true;
                        this.populate();
                        this.mInLayout = false;
                        size = this.getChildCount();
                        for (let i = 0; i < size; ++i) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                if (DEBUG)
                                    Log.v(TAG, "Measuring #" + i + " " + child
                                        + ": " + this.mChildWidthMeasureSpec);
                                const lp = child.getLayoutParams();
                                if (lp == null || !lp.isDecor) {
                                    const widthSpec = MeasureSpec.makeMeasureSpec((childWidthSize * lp.widthFactor), MeasureSpec.EXACTLY);
                                    child.measure(widthSpec, this.mChildHeightMeasureSpec);
                                }
                            }
                        }
                    }
                    onSizeChanged(w, h, oldw, oldh) {
                        super.onSizeChanged(w, h, oldw, oldh);
                        if (w != oldw) {
                            this.recomputeScrollPosition(w, oldw, this.mPageMargin, this.mPageMargin);
                        }
                    }
                    recomputeScrollPosition(width, oldWidth, margin, oldMargin) {
                        if (oldWidth > 0 && !this.mItems.isEmpty()) {
                            const widthWithMargin = width - this.getPaddingLeft() - this.getPaddingRight() + margin;
                            const oldWidthWithMargin = oldWidth - this.getPaddingLeft() - this.getPaddingRight()
                                + oldMargin;
                            const xpos = this.getScrollX();
                            const pageOffset = xpos / oldWidthWithMargin;
                            const newOffsetPixels = Math.floor(pageOffset * widthWithMargin);
                            this.scrollTo(newOffsetPixels, this.getScrollY());
                            if (!this.mScroller.isFinished()) {
                                const newDuration = this.mScroller.getDuration() - this.mScroller.timePassed();
                                let targetInfo = this.infoForPosition(this.mCurItem);
                                this.mScroller.startScroll(newOffsetPixels, 0, Math.floor(targetInfo.offset * width), 0, newDuration);
                            }
                        }
                        else {
                            const ii = this.infoForPosition(this.mCurItem);
                            const scrollOffset = ii != null ? Math.min(ii.offset, this.mLastOffset) : 0;
                            const scrollPos = Math.floor(scrollOffset *
                                (width - this.getPaddingLeft() - this.getPaddingRight()));
                            if (scrollPos != this.getScrollX()) {
                                this.completeScroll(false);
                                this.scrollTo(scrollPos, this.getScrollY());
                            }
                        }
                    }
                    onLayout(changed, l, t, r, b) {
                        const count = this.getChildCount();
                        let width = r - l;
                        let height = b - t;
                        let paddingLeft = this.getPaddingLeft();
                        let paddingTop = this.getPaddingTop();
                        let paddingRight = this.getPaddingRight();
                        let paddingBottom = this.getPaddingBottom();
                        const scrollX = this.getScrollX();
                        let decorCount = 0;
                        for (let i = 0; i < count; i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                const lp = child.getLayoutParams();
                                let childLeft = 0;
                                let childTop = 0;
                                if (lp.isDecor) {
                                    const hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                                    const vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
                                    switch (hgrav) {
                                        default:
                                            childLeft = paddingLeft;
                                            break;
                                        case Gravity.LEFT:
                                            childLeft = paddingLeft;
                                            paddingLeft += child.getMeasuredWidth();
                                            break;
                                        case Gravity.CENTER_HORIZONTAL:
                                            childLeft = Math.max((width - child.getMeasuredWidth()) / 2, paddingLeft);
                                            break;
                                        case Gravity.RIGHT:
                                            childLeft = width - paddingRight - child.getMeasuredWidth();
                                            paddingRight += child.getMeasuredWidth();
                                            break;
                                    }
                                    switch (vgrav) {
                                        default:
                                            childTop = paddingTop;
                                            break;
                                        case Gravity.TOP:
                                            childTop = paddingTop;
                                            paddingTop += child.getMeasuredHeight();
                                            break;
                                        case Gravity.CENTER_VERTICAL:
                                            childTop = Math.max((height - child.getMeasuredHeight()) / 2, paddingTop);
                                            break;
                                        case Gravity.BOTTOM:
                                            childTop = height - paddingBottom - child.getMeasuredHeight();
                                            paddingBottom += child.getMeasuredHeight();
                                            break;
                                    }
                                    childLeft += scrollX;
                                    child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + child.getMeasuredHeight());
                                    decorCount++;
                                }
                            }
                        }
                        const childWidth = width - paddingLeft - paddingRight;
                        for (let i = 0; i < count; i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                const lp = child.getLayoutParams();
                                let ii;
                                if (!lp.isDecor && (ii = this.infoForChild(child)) != null) {
                                    let loff = Math.floor(childWidth * ii.offset);
                                    let childLeft = paddingLeft + loff;
                                    let childTop = paddingTop;
                                    if (lp.needsMeasure) {
                                        lp.needsMeasure = false;
                                        const widthSpec = MeasureSpec.makeMeasureSpec(Math.floor(childWidth * lp.widthFactor), MeasureSpec.EXACTLY);
                                        const heightSpec = MeasureSpec.makeMeasureSpec(Math.floor(height - paddingTop - paddingBottom), MeasureSpec.EXACTLY);
                                        child.measure(widthSpec, heightSpec);
                                    }
                                    if (DEBUG)
                                        Log.v(TAG, "Positioning #" + i + " " + child + " f=" + ii.object
                                            + ":" + childLeft + "," + childTop + " " + child.getMeasuredWidth()
                                            + "x" + child.getMeasuredHeight());
                                    child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + child.getMeasuredHeight());
                                }
                            }
                        }
                        this.mTopPageBounds = paddingTop;
                        this.mBottomPageBounds = height - paddingBottom;
                        this.mDecorChildCount = decorCount;
                        if (this.mFirstLayout) {
                            this.scrollToItem(this.mCurItem, false, 0, false);
                        }
                        this.mFirstLayout = false;
                    }
                    computeScroll() {
                        if (!this.mScroller.isFinished() && this.mScroller.computeScrollOffset()) {
                            let oldX = this.getScrollX();
                            let oldY = this.getScrollY();
                            let x = this.mScroller.getCurrX();
                            let y = this.mScroller.getCurrY();
                            if (oldX != x || oldY != y) {
                                this.scrollTo(x, y);
                                if (!this.pageScrolled(x)) {
                                    this.mScroller.abortAnimation();
                                    this.scrollTo(0, y);
                                }
                            }
                            this.postInvalidateOnAnimation();
                            return;
                        }
                        this.completeScroll(true);
                    }
                    pageScrolled(xpos) {
                        if (this.mItems.size() == 0) {
                            this.mCalledSuper = false;
                            this.onPageScrolled(0, 0, 0);
                            if (!this.mCalledSuper) {
                                throw new Error("onPageScrolled did not call superclass implementation");
                            }
                            return false;
                        }
                        const ii = this.infoForCurrentScrollPosition();
                        const width = this.getClientWidth();
                        const widthWithMargin = width + this.mPageMargin;
                        const marginOffset = this.mPageMargin / width;
                        const currentPage = ii.position;
                        const pageOffset = ((xpos / width) - ii.offset) / (ii.widthFactor + marginOffset);
                        const offsetPixels = Math.floor(pageOffset * widthWithMargin);
                        this.mCalledSuper = false;
                        this.onPageScrolled(currentPage, pageOffset, offsetPixels);
                        if (!this.mCalledSuper) {
                            throw new Error("onPageScrolled did not call superclass implementation");
                        }
                        return true;
                    }
                    onPageScrolled(position, offset, offsetPixels) {
                        if (this.mDecorChildCount > 0) {
                            const scrollX = this.getScrollX();
                            let paddingLeft = this.getPaddingLeft();
                            let paddingRight = this.getPaddingRight();
                            const width = this.getWidth();
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                const lp = child.getLayoutParams();
                                if (!lp.isDecor)
                                    continue;
                                const hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                                let childLeft = 0;
                                switch (hgrav) {
                                    default:
                                        childLeft = paddingLeft;
                                        break;
                                    case Gravity.LEFT:
                                        childLeft = paddingLeft;
                                        paddingLeft += child.getWidth();
                                        break;
                                    case Gravity.CENTER_HORIZONTAL:
                                        childLeft = Math.max((width - child.getMeasuredWidth()) / 2, paddingLeft);
                                        break;
                                    case Gravity.RIGHT:
                                        childLeft = width - paddingRight - child.getMeasuredWidth();
                                        paddingRight += child.getMeasuredWidth();
                                        break;
                                }
                                childLeft += scrollX;
                                const childOffset = childLeft - child.getLeft();
                                if (childOffset != 0) {
                                    child.offsetLeftAndRight(childOffset);
                                }
                            }
                        }
                        this.dispatchOnPageScrolled(position, offset, offsetPixels);
                        if (this.mPageTransformer != null) {
                            const scrollX = this.getScrollX();
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                const lp = child.getLayoutParams();
                                if (lp.isDecor)
                                    continue;
                                const transformPos = (child.getLeft() - scrollX) / this.getClientWidth();
                                this.mPageTransformer.transformPage(child, transformPos);
                            }
                        }
                        this.mCalledSuper = true;
                    }
                    dispatchOnPageScrolled(position, offset, offsetPixels) {
                        if (this.mOnPageChangeListener != null) {
                            this.mOnPageChangeListener.onPageScrolled(position, offset, offsetPixels);
                        }
                        if (this.mOnPageChangeListeners != null) {
                            for (let i = 0, z = this.mOnPageChangeListeners.size(); i < z; i++) {
                                let listener = this.mOnPageChangeListeners.get(i);
                                if (listener != null) {
                                    listener.onPageScrolled(position, offset, offsetPixels);
                                }
                            }
                        }
                        if (this.mInternalPageChangeListener != null) {
                            this.mInternalPageChangeListener.onPageScrolled(position, offset, offsetPixels);
                        }
                    }
                    dispatchOnPageSelected(position) {
                        if (this.mOnPageChangeListener != null) {
                            this.mOnPageChangeListener.onPageSelected(position);
                        }
                        if (this.mOnPageChangeListeners != null) {
                            for (let i = 0, z = this.mOnPageChangeListeners.size(); i < z; i++) {
                                let listener = this.mOnPageChangeListeners.get(i);
                                if (listener != null) {
                                    listener.onPageSelected(position);
                                }
                            }
                        }
                        if (this.mInternalPageChangeListener != null) {
                            this.mInternalPageChangeListener.onPageSelected(position);
                        }
                    }
                    dispatchOnScrollStateChanged(state) {
                        if (this.mOnPageChangeListener != null) {
                            this.mOnPageChangeListener.onPageScrollStateChanged(state);
                        }
                        if (this.mOnPageChangeListeners != null) {
                            for (let i = 0, z = this.mOnPageChangeListeners.size(); i < z; i++) {
                                let listener = this.mOnPageChangeListeners.get(i);
                                if (listener != null) {
                                    listener.onPageScrollStateChanged(state);
                                }
                            }
                        }
                        if (this.mInternalPageChangeListener != null) {
                            this.mInternalPageChangeListener.onPageScrollStateChanged(state);
                        }
                    }
                    completeScroll(postEvents) {
                        let needPopulate = this.mScrollState == ViewPager.SCROLL_STATE_SETTLING;
                        if (needPopulate) {
                            this.setScrollingCacheEnabled(false);
                            this.mScroller.abortAnimation();
                            let oldX = this.getScrollX();
                            let oldY = this.getScrollY();
                            let x = this.mScroller.getCurrX();
                            let y = this.mScroller.getCurrY();
                            if (oldX != x || oldY != y) {
                                this.scrollTo(x, y);
                                if (x != oldX) {
                                    this.pageScrolled(x);
                                }
                            }
                        }
                        this.mPopulatePending = false;
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            if (ii.scrolling) {
                                needPopulate = true;
                                ii.scrolling = false;
                            }
                        }
                        if (needPopulate) {
                            if (postEvents) {
                                this.postOnAnimation(this.mEndScrollRunnable);
                            }
                            else {
                                this.mEndScrollRunnable.run();
                            }
                        }
                    }
                    isGutterDrag(x, dx) {
                        return (x < this.mGutterSize && dx > 0) || (x > this.getWidth() - this.mGutterSize && dx < 0);
                    }
                    enableLayers(enable) {
                    }
                    onInterceptTouchEvent(ev) {
                        /*
                         * This method JUST determines whether we want to intercept the motion.
                         * If we return true, onMotionEvent will be called and we do the actual
                         * scrolling there.
                         */
                        const action = ev.getAction() & MotionEvent.ACTION_MASK;
                        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
                            if (DEBUG)
                                Log.v(TAG, "Intercept done!");
                            this.resetTouch();
                            return false;
                        }
                        if (action != MotionEvent.ACTION_DOWN) {
                            if (this.mIsBeingDragged) {
                                if (DEBUG)
                                    Log.v(TAG, "Intercept returning true!");
                                return true;
                            }
                            if (this.mIsUnableToDrag) {
                                if (DEBUG)
                                    Log.v(TAG, "Intercept returning false!");
                                return false;
                            }
                        }
                        switch (action) {
                            case MotionEvent.ACTION_MOVE: {
                                const activePointerId = this.mActivePointerId;
                                if (activePointerId == ViewPager.INVALID_POINTER) {
                                    break;
                                }
                                const pointerIndex = ev.findPointerIndex(activePointerId);
                                const x = ev.getX(pointerIndex);
                                const dx = x - this.mLastMotionX;
                                const xDiff = Math.abs(dx);
                                const y = ev.getY(pointerIndex);
                                const yDiff = Math.abs(y - this.mInitialMotionY);
                                if (DEBUG)
                                    Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);
                                if (dx != 0 && !this.isGutterDrag(this.mLastMotionX, dx) &&
                                    this.canScroll(this, false, Math.floor(dx), Math.floor(x), Math.floor(y))) {
                                    this.mLastMotionX = x;
                                    this.mLastMotionY = y;
                                    this.mIsUnableToDrag = true;
                                    return false;
                                }
                                if (xDiff > this.mTouchSlop && xDiff * 0.5 > yDiff) {
                                    if (DEBUG)
                                        Log.v(TAG, "Starting drag!");
                                    this.mIsBeingDragged = true;
                                    this.requestParentDisallowInterceptTouchEvent(true);
                                    this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                                    this.mLastMotionX = dx > 0 ? this.mInitialMotionX + this.mTouchSlop :
                                        this.mInitialMotionX - this.mTouchSlop;
                                    this.mLastMotionY = y;
                                    this.setScrollingCacheEnabled(true);
                                }
                                else if (yDiff > this.mTouchSlop) {
                                    if (DEBUG)
                                        Log.v(TAG, "Starting unable to drag!");
                                    this.mIsUnableToDrag = true;
                                }
                                if (this.mIsBeingDragged) {
                                    if (this.performDrag(x)) {
                                        this.postInvalidateOnAnimation();
                                    }
                                }
                                break;
                            }
                            case MotionEvent.ACTION_DOWN: {
                                this.mLastMotionX = this.mInitialMotionX = ev.getX();
                                this.mLastMotionY = this.mInitialMotionY = ev.getY();
                                this.mActivePointerId = ev.getPointerId(0);
                                this.mIsUnableToDrag = false;
                                this.mScroller.computeScrollOffset();
                                if (this.mScrollState == ViewPager.SCROLL_STATE_SETTLING &&
                                    Math.abs(this.mScroller.getFinalX() - this.mScroller.getCurrX()) > this.mCloseEnough) {
                                    this.mScroller.abortAnimation();
                                    this.mPopulatePending = false;
                                    this.populate();
                                    this.mIsBeingDragged = true;
                                    this.requestParentDisallowInterceptTouchEvent(true);
                                    this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                                }
                                else {
                                    this.completeScroll(false);
                                    this.mIsBeingDragged = false;
                                }
                                if (DEBUG)
                                    Log.v(TAG, "Down at " + this.mLastMotionX + "," + this.mLastMotionY
                                        + " mIsBeingDragged=" + this.mIsBeingDragged
                                        + "mIsUnableToDrag=" + this.mIsUnableToDrag);
                                break;
                            }
                            case MotionEvent.ACTION_POINTER_UP:
                                this.onSecondaryPointerUp(ev);
                                break;
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        return this.mIsBeingDragged;
                    }
                    onTouchEvent(ev) {
                        if (this.mFakeDragging) {
                            return true;
                        }
                        if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
                            return false;
                        }
                        if (this.mAdapter == null || this.mAdapter.getCount() == 0) {
                            return false;
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        const action = ev.getAction();
                        let needsInvalidate = false;
                        switch (action & MotionEvent.ACTION_MASK) {
                            case MotionEvent.ACTION_DOWN: {
                                this.mScroller.abortAnimation();
                                this.mPopulatePending = false;
                                this.populate();
                                this.mLastMotionX = this.mInitialMotionX = ev.getX();
                                this.mLastMotionY = this.mInitialMotionY = ev.getY();
                                this.mActivePointerId = ev.getPointerId(0);
                                break;
                            }
                            case MotionEvent.ACTION_MOVE:
                                if (!this.mIsBeingDragged) {
                                    const pointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    if (pointerIndex == -1) {
                                        needsInvalidate = this.resetTouch();
                                        break;
                                    }
                                    const x = ev.getX(pointerIndex);
                                    const xDiff = Math.abs(x - this.mLastMotionX);
                                    const y = ev.getY(pointerIndex);
                                    const yDiff = Math.abs(y - this.mLastMotionY);
                                    if (DEBUG)
                                        Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);
                                    if (xDiff > this.mTouchSlop && xDiff > yDiff) {
                                        if (DEBUG)
                                            Log.v(TAG, "Starting drag!");
                                        this.mIsBeingDragged = true;
                                        this.requestParentDisallowInterceptTouchEvent(true);
                                        this.mLastMotionX = x - this.mInitialMotionX > 0 ? this.mInitialMotionX + this.mTouchSlop :
                                            this.mInitialMotionX - this.mTouchSlop;
                                        this.mLastMotionY = y;
                                        this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                                        this.setScrollingCacheEnabled(true);
                                        let parent = this.getParent();
                                        if (parent != null) {
                                            parent.requestDisallowInterceptTouchEvent(true);
                                        }
                                    }
                                }
                                if (this.mIsBeingDragged) {
                                    const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    const x = ev.getX(activePointerIndex);
                                    needsInvalidate = needsInvalidate || this.performDrag(x);
                                }
                                break;
                            case MotionEvent.ACTION_UP:
                                if (this.mIsBeingDragged) {
                                    const velocityTracker = this.mVelocityTracker;
                                    velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                                    let initialVelocity = velocityTracker.getXVelocity(this.mActivePointerId);
                                    this.mPopulatePending = true;
                                    const width = this.getClientWidth();
                                    const scrollX = this.getScrollX();
                                    const ii = this.infoForCurrentScrollPosition();
                                    const currentPage = ii.position;
                                    const pageOffset = ((scrollX / width) - ii.offset) / ii.widthFactor;
                                    const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    const x = ev.getX(activePointerIndex);
                                    const totalDelta = (x - this.mInitialMotionX);
                                    let nextPage = this.determineTargetPage(currentPage, pageOffset, initialVelocity, totalDelta);
                                    this.setCurrentItemInternal(nextPage, true, true, initialVelocity);
                                    needsInvalidate = this.resetTouch();
                                }
                                break;
                            case MotionEvent.ACTION_CANCEL:
                                if (this.mIsBeingDragged) {
                                    this.scrollToItem(this.mCurItem, true, 0, false);
                                    needsInvalidate = this.resetTouch();
                                }
                                break;
                            case MotionEvent.ACTION_POINTER_DOWN: {
                                const index = ev.getActionIndex();
                                const x = ev.getX(index);
                                this.mLastMotionX = x;
                                this.mActivePointerId = ev.getPointerId(index);
                                break;
                            }
                            case MotionEvent.ACTION_POINTER_UP:
                                this.onSecondaryPointerUp(ev);
                                this.mLastMotionX = ev.getX(ev.findPointerIndex(this.mActivePointerId));
                                break;
                        }
                        if (needsInvalidate) {
                            this.postInvalidateOnAnimation();
                        }
                        return true;
                    }
                    resetTouch() {
                        let needsInvalidate = false;
                        this.mActivePointerId = ViewPager.INVALID_POINTER;
                        this.endDrag();
                        return needsInvalidate;
                    }
                    requestParentDisallowInterceptTouchEvent(disallowIntercept) {
                        const parent = this.getParent();
                        if (parent != null) {
                            parent.requestDisallowInterceptTouchEvent(disallowIntercept);
                        }
                    }
                    performDrag(x) {
                        let needsInvalidate = false;
                        const deltaX = this.mLastMotionX - x;
                        this.mLastMotionX = x;
                        let oldScrollX = this.getScrollX();
                        let scrollX = oldScrollX + deltaX;
                        const width = this.getClientWidth();
                        let leftBound = width * this.mFirstOffset;
                        let rightBound = width * this.mLastOffset;
                        let leftAbsolute = true;
                        let rightAbsolute = true;
                        const firstItem = this.mItems.get(0);
                        const lastItem = this.mItems.get(this.mItems.size() - 1);
                        if (firstItem.position != 0) {
                            leftAbsolute = false;
                            leftBound = firstItem.offset * width;
                        }
                        if (lastItem.position != this.mAdapter.getCount() - 1) {
                            rightAbsolute = false;
                            rightBound = lastItem.offset * width;
                        }
                        if (scrollX < leftBound) {
                            if (leftAbsolute) {
                                let over = leftBound - scrollX;
                                needsInvalidate = false;
                            }
                            scrollX -= deltaX / 2;
                        }
                        else if (scrollX > rightBound) {
                            if (rightAbsolute) {
                                let over = scrollX - rightBound;
                                needsInvalidate = false;
                            }
                            scrollX -= deltaX / 2;
                        }
                        this.mLastMotionX += scrollX - Math.floor(scrollX);
                        this.scrollTo(scrollX, this.getScrollY());
                        this.pageScrolled(scrollX);
                        return needsInvalidate;
                    }
                    infoForCurrentScrollPosition() {
                        const width = this.getClientWidth();
                        const scrollOffset = width > 0 ? this.getScrollX() / width : 0;
                        const marginOffset = width > 0 ? this.mPageMargin / width : 0;
                        let lastPos = -1;
                        let lastOffset = 0;
                        let lastWidth = 0;
                        let first = true;
                        let lastItem = null;
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            let offset;
                            if (!first && ii.position != lastPos + 1) {
                                ii = this.mTempItem;
                                ii.offset = lastOffset + lastWidth + marginOffset;
                                ii.position = lastPos + 1;
                                ii.widthFactor = this.mAdapter.getPageWidth(ii.position);
                                i--;
                            }
                            offset = ii.offset;
                            const leftBound = offset;
                            const rightBound = offset + ii.widthFactor + marginOffset;
                            if (first || scrollOffset >= leftBound) {
                                if (scrollOffset < rightBound || i == this.mItems.size() - 1) {
                                    return ii;
                                }
                            }
                            else {
                                return lastItem;
                            }
                            first = false;
                            lastPos = ii.position;
                            lastOffset = offset;
                            lastWidth = ii.widthFactor;
                            lastItem = ii;
                        }
                        return lastItem;
                    }
                    determineTargetPage(currentPage, pageOffset, velocity, deltaX) {
                        let targetPage;
                        if (Math.abs(deltaX) > this.mFlingDistance && Math.abs(velocity) > this.mMinimumVelocity) {
                            targetPage = velocity > 0 ? currentPage : currentPage + 1;
                        }
                        else {
                            const truncator = currentPage >= this.mCurItem ? 0.4 : 0.6;
                            targetPage = Math.floor(currentPage + pageOffset + truncator);
                        }
                        if (this.mItems.size() > 0) {
                            const firstItem = this.mItems.get(0);
                            const lastItem = this.mItems.get(this.mItems.size() - 1);
                            targetPage = Math.max(firstItem.position, Math.min(targetPage, lastItem.position));
                        }
                        return targetPage;
                    }
                    draw(canvas) {
                        super.draw(canvas);
                        let needsInvalidate = false;
                        if (needsInvalidate) {
                            this.postInvalidateOnAnimation();
                        }
                    }
                    onDraw(canvas) {
                        super.onDraw(canvas);
                        if (this.mPageMargin > 0 && this.mMarginDrawable != null && this.mItems.size() > 0 && this.mAdapter != null) {
                            const scrollX = this.getScrollX();
                            const width = this.getWidth();
                            const marginOffset = this.mPageMargin / width;
                            let itemIndex = 0;
                            let ii = this.mItems.get(0);
                            let offset = ii.offset;
                            const itemCount = this.mItems.size();
                            const firstPos = ii.position;
                            const lastPos = this.mItems.get(itemCount - 1).position;
                            for (let pos = firstPos; pos < lastPos; pos++) {
                                while (pos > ii.position && itemIndex < itemCount) {
                                    ii = this.mItems.get(++itemIndex);
                                }
                                let drawAt;
                                if (pos == ii.position) {
                                    drawAt = (ii.offset + ii.widthFactor) * width;
                                    offset = ii.offset + ii.widthFactor + marginOffset;
                                }
                                else {
                                    let widthFactor = this.mAdapter.getPageWidth(pos);
                                    drawAt = (offset + widthFactor) * width;
                                    offset += widthFactor + marginOffset;
                                }
                                if (drawAt + this.mPageMargin > scrollX) {
                                    this.mMarginDrawable.setBounds(drawAt, this.mTopPageBounds, drawAt + this.mPageMargin, this.mBottomPageBounds);
                                    this.mMarginDrawable.draw(canvas);
                                }
                                if (drawAt > scrollX + width) {
                                    break;
                                }
                            }
                        }
                    }
                    beginFakeDrag() {
                        if (this.mIsBeingDragged) {
                            return false;
                        }
                        this.mFakeDragging = true;
                        this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                        this.mInitialMotionX = this.mLastMotionX = 0;
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        else {
                            this.mVelocityTracker.clear();
                        }
                        const time = android.os.SystemClock.uptimeMillis();
                        const ev = MotionEvent.obtainWithAction(time, time, MotionEvent.ACTION_DOWN, 0, 0, 0);
                        this.mVelocityTracker.addMovement(ev);
                        ev.recycle();
                        this.mFakeDragBeginTime = time;
                        return true;
                    }
                    endFakeDrag() {
                        if (!this.mFakeDragging) {
                            throw new Error("No fake drag in progress. Call beginFakeDrag first.");
                        }
                        const velocityTracker = this.mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                        let initialVelocity = Math.floor(velocityTracker.getXVelocity(this.mActivePointerId));
                        this.mPopulatePending = true;
                        const width = this.getClientWidth();
                        const scrollX = this.getScrollX();
                        const ii = this.infoForCurrentScrollPosition();
                        const currentPage = ii.position;
                        const pageOffset = ((scrollX / width) - ii.offset) / ii.widthFactor;
                        const totalDelta = Math.floor(this.mLastMotionX - this.mInitialMotionX);
                        let nextPage = this.determineTargetPage(currentPage, pageOffset, initialVelocity, totalDelta);
                        this.setCurrentItemInternal(nextPage, true, true, initialVelocity);
                        this.endDrag();
                        this.mFakeDragging = false;
                    }
                    fakeDragBy(xOffset) {
                        if (!this.mFakeDragging) {
                            throw new Error("No fake drag in progress. Call beginFakeDrag first.");
                        }
                        this.mLastMotionX += xOffset;
                        let oldScrollX = this.getScrollX();
                        let scrollX = oldScrollX - xOffset;
                        const width = this.getClientWidth();
                        let leftBound = width * this.mFirstOffset;
                        let rightBound = width * this.mLastOffset;
                        const firstItem = this.mItems.get(0);
                        const lastItem = this.mItems.get(this.mItems.size() - 1);
                        if (firstItem.position != 0) {
                            leftBound = firstItem.offset * width;
                        }
                        if (lastItem.position != this.mAdapter.getCount() - 1) {
                            rightBound = lastItem.offset * width;
                        }
                        if (scrollX < leftBound) {
                            scrollX = leftBound;
                        }
                        else if (scrollX > rightBound) {
                            scrollX = rightBound;
                        }
                        this.mLastMotionX += scrollX - Math.floor(scrollX);
                        this.scrollTo(Math.floor(scrollX), this.getScrollY());
                        this.pageScrolled(Math.floor(scrollX));
                        const time = android.os.SystemClock.uptimeMillis();
                        const ev = MotionEvent.obtainWithAction(this.mFakeDragBeginTime, time, MotionEvent.ACTION_MOVE, this.mLastMotionX, 0, 0);
                        this.mVelocityTracker.addMovement(ev);
                        ev.recycle();
                    }
                    isFakeDragging() {
                        return this.mFakeDragging;
                    }
                    onSecondaryPointerUp(ev) {
                        const pointerIndex = ev.getActionIndex();
                        const pointerId = ev.getPointerId(pointerIndex);
                        if (pointerId == this.mActivePointerId) {
                            const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                            this.mLastMotionX = ev.getX(newPointerIndex);
                            this.mActivePointerId = ev.getPointerId(newPointerIndex);
                            if (this.mVelocityTracker != null) {
                                this.mVelocityTracker.clear();
                            }
                        }
                    }
                    endDrag() {
                        this.mIsBeingDragged = false;
                        this.mIsUnableToDrag = false;
                        if (this.mVelocityTracker != null) {
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                    }
                    setScrollingCacheEnabled(enabled) {
                        if (this.mScrollingCacheEnabled != enabled) {
                            this.mScrollingCacheEnabled = enabled;
                            if (ViewPager.USE_CACHE) {
                                const size = this.getChildCount();
                                for (let i = 0; i < size; ++i) {
                                    const child = this.getChildAt(i);
                                    if (child.getVisibility() != View.GONE) {
                                        child.setDrawingCacheEnabled(enabled);
                                    }
                                }
                            }
                        }
                    }
                    canScrollHorizontally(direction) {
                        if (this.mAdapter == null) {
                            return false;
                        }
                        const width = this.getClientWidth();
                        const scrollX = this.getScrollX();
                        if (direction < 0) {
                            return (scrollX > (width * this.mFirstOffset));
                        }
                        else if (direction > 0) {
                            return (scrollX < (width * this.mLastOffset));
                        }
                        else {
                            return false;
                        }
                    }
                    canScroll(v, checkV, dx, x, y) {
                        if (v instanceof ViewGroup) {
                            const group = v;
                            const scrollX = v.getScrollX();
                            const scrollY = v.getScrollY();
                            const count = group.getChildCount();
                            for (let i = count - 1; i >= 0; i--) {
                                const child = group.getChildAt(i);
                                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&
                                    y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&
                                    this.canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {
                                    return true;
                                }
                            }
                        }
                        return checkV && v.canScrollHorizontally(-dx);
                    }
                    dispatchKeyEvent(event) {
                        return super.dispatchKeyEvent(event) || this.executeKeyEvent(event);
                    }
                    executeKeyEvent(event) {
                        let handled = false;
                        if (event.getAction() == KeyEvent.ACTION_DOWN) {
                            switch (event.getKeyCode()) {
                                case KeyEvent.KEYCODE_DPAD_LEFT:
                                    handled = this.arrowScroll(View.FOCUS_LEFT);
                                    break;
                                case KeyEvent.KEYCODE_DPAD_RIGHT:
                                    handled = this.arrowScroll(View.FOCUS_RIGHT);
                                    break;
                                case KeyEvent.KEYCODE_TAB:
                                    if (event.isShiftPressed()) {
                                        handled = this.arrowScroll(View.FOCUS_BACKWARD);
                                    }
                                    else {
                                        handled = this.arrowScroll(View.FOCUS_FORWARD);
                                    }
                                    break;
                            }
                        }
                        return handled;
                    }
                    arrowScroll(direction) {
                        let currentFocused = this.findFocus();
                        if (currentFocused == this) {
                            currentFocused = null;
                        }
                        else if (currentFocused != null) {
                            let isChild = false;
                            for (let parent = currentFocused.getParent(); parent instanceof ViewGroup; parent = parent.getParent()) {
                                if (parent == this) {
                                    isChild = true;
                                    break;
                                }
                            }
                            if (!isChild) {
                                const sb = new java.lang.StringBuilder();
                                sb.append(currentFocused.toString());
                                for (let parent = currentFocused.getParent(); parent instanceof ViewGroup; parent = parent.getParent()) {
                                    sb.append(" => ").append(parent.toString());
                                }
                                Log.e(TAG, "arrowScroll tried to find focus based on non-child " +
                                    "current focused view " + sb.toString());
                                currentFocused = null;
                            }
                        }
                        let handled = false;
                        let nextFocused = android.view.FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
                        if (nextFocused != null && nextFocused != currentFocused) {
                            if (direction == View.FOCUS_LEFT) {
                                const nextLeft = this.getChildRectInPagerCoordinates(this.mTempRect, nextFocused).left;
                                const currLeft = this.getChildRectInPagerCoordinates(this.mTempRect, currentFocused).left;
                                if (currentFocused != null && nextLeft >= currLeft) {
                                    handled = this.pageLeft();
                                }
                                else {
                                    handled = nextFocused.requestFocus();
                                }
                            }
                            else if (direction == View.FOCUS_RIGHT) {
                                const nextLeft = this.getChildRectInPagerCoordinates(this.mTempRect, nextFocused).left;
                                const currLeft = this.getChildRectInPagerCoordinates(this.mTempRect, currentFocused).left;
                                if (currentFocused != null && nextLeft <= currLeft) {
                                    handled = this.pageRight();
                                }
                                else {
                                    handled = nextFocused.requestFocus();
                                }
                            }
                        }
                        else if (direction == View.FOCUS_LEFT || direction == View.FOCUS_BACKWARD) {
                            handled = this.pageLeft();
                        }
                        else if (direction == View.FOCUS_RIGHT || direction == View.FOCUS_FORWARD) {
                            handled = this.pageRight();
                        }
                        return handled;
                    }
                    getChildRectInPagerCoordinates(outRect, child) {
                        if (outRect == null) {
                            outRect = new Rect();
                        }
                        if (child == null) {
                            outRect.set(0, 0, 0, 0);
                            return outRect;
                        }
                        outRect.left = child.getLeft();
                        outRect.right = child.getRight();
                        outRect.top = child.getTop();
                        outRect.bottom = child.getBottom();
                        let parent = child.getParent();
                        while (parent instanceof ViewGroup && parent != this) {
                            const group = parent;
                            outRect.left += group.getLeft();
                            outRect.right += group.getRight();
                            outRect.top += group.getTop();
                            outRect.bottom += group.getBottom();
                            parent = group.getParent();
                        }
                        return outRect;
                    }
                    pageLeft() {
                        if (this.mCurItem > 0) {
                            this.setCurrentItem(this.mCurItem - 1, true);
                            return true;
                        }
                        return false;
                    }
                    pageRight() {
                        if (this.mAdapter != null && this.mCurItem < (this.mAdapter.getCount() - 1)) {
                            this.setCurrentItem(this.mCurItem + 1, true);
                            return true;
                        }
                        return false;
                    }
                    addFocusables(views, direction, focusableMode) {
                        const focusableCount = views.size();
                        const descendantFocusability = this.getDescendantFocusability();
                        if (descendantFocusability != ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                            for (let i = 0; i < this.getChildCount(); i++) {
                                const child = this.getChildAt(i);
                                if (child.getVisibility() == View.VISIBLE) {
                                    let ii = this.infoForChild(child);
                                    if (ii != null && ii.position == this.mCurItem) {
                                        child.addFocusables(views, direction, focusableMode);
                                    }
                                }
                            }
                        }
                        if (descendantFocusability != ViewGroup.FOCUS_AFTER_DESCENDANTS ||
                            (focusableCount == views.size())) {
                            if (!this.isFocusable()) {
                                return;
                            }
                            if ((focusableMode & ViewGroup.FOCUSABLES_TOUCH_MODE) == ViewGroup.FOCUSABLES_TOUCH_MODE &&
                                this.isInTouchMode() && !this.isFocusableInTouchMode()) {
                                return;
                            }
                            if (views != null) {
                                views.add(this);
                            }
                        }
                    }
                    addTouchables(views) {
                        for (let i = 0; i < this.getChildCount(); i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() == View.VISIBLE) {
                                let ii = this.infoForChild(child);
                                if (ii != null && ii.position == this.mCurItem) {
                                    child.addTouchables(views);
                                }
                            }
                        }
                    }
                    onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                        let index;
                        let increment;
                        let end;
                        let count = this.getChildCount();
                        if ((direction & View.FOCUS_FORWARD) != 0) {
                            index = 0;
                            increment = 1;
                            end = count;
                        }
                        else {
                            index = count - 1;
                            increment = -1;
                            end = -1;
                        }
                        for (let i = index; i != end; i += increment) {
                            let child = this.getChildAt(i);
                            if (child.getVisibility() == View.VISIBLE) {
                                let ii = this.infoForChild(child);
                                if (ii != null && ii.position == this.mCurItem) {
                                    if (child.requestFocus(direction, previouslyFocusedRect)) {
                                        return true;
                                    }
                                }
                            }
                        }
                        return false;
                    }
                    generateDefaultLayoutParams() {
                        return new ViewPager.LayoutParams();
                    }
                    generateLayoutParams(p) {
                        return this.generateDefaultLayoutParams();
                    }
                    checkLayoutParams(p) {
                        return p instanceof ViewPager.LayoutParams && super.checkLayoutParams(p);
                    }
                    static isImplDecor(view) {
                        return view[SymbolDecor] || view.constructor[SymbolDecor];
                    }
                    static setClassImplDecor(clazz) {
                        clazz[SymbolDecor] = true;
                    }
                }
                ViewPager.COMPARATOR = (lhs, rhs) => {
                    return lhs.position - rhs.position;
                };
                ViewPager.USE_CACHE = false;
                ViewPager.DEFAULT_OFFSCREEN_PAGES = 1;
                ViewPager.MAX_SETTLE_DURATION = 600;
                ViewPager.MIN_DISTANCE_FOR_FLING = 25;
                ViewPager.DEFAULT_GUTTER_SIZE = 16;
                ViewPager.MIN_FLING_VELOCITY = 400;
                ViewPager.sInterpolator = {
                    getInterpolation(t) {
                        t -= 1.0;
                        return t * t * t * t * t + 1.0;
                    }
                };
                ViewPager.INVALID_POINTER = -1;
                ViewPager.CLOSE_ENOUGH = 2;
                ViewPager.DRAW_ORDER_DEFAULT = 0;
                ViewPager.DRAW_ORDER_FORWARD = 1;
                ViewPager.DRAW_ORDER_REVERSE = 2;
                ViewPager.sPositionComparator = (lhs, rhs) => {
                    let llp = lhs.getLayoutParams();
                    let rlp = rhs.getLayoutParams();
                    if (llp.isDecor != rlp.isDecor) {
                        return llp.isDecor ? 1 : -1;
                    }
                    return llp.position - rlp.position;
                };
                ViewPager.SCROLL_STATE_IDLE = 0;
                ViewPager.SCROLL_STATE_DRAGGING = 1;
                ViewPager.SCROLL_STATE_SETTLING = 2;
                view_8.ViewPager = ViewPager;
                (function (ViewPager) {
                    class SimpleOnPageChangeListener {
                        onPageScrolled(position, positionOffset, positionOffsetPixels) {
                        }
                        onPageSelected(position) {
                        }
                        onPageScrollStateChanged(state) {
                        }
                    }
                    ViewPager.SimpleOnPageChangeListener = SimpleOnPageChangeListener;
                    class LayoutParams extends ViewGroup.LayoutParams {
                        constructor() {
                            super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
                            this.isDecor = false;
                            this.gravity = 0;
                            this.widthFactor = 0;
                            this.needsMeasure = false;
                            this.position = 0;
                            this.childIndex = 0;
                            this._attrBinder.addAttr('gravity', (value) => {
                                this.gravity = this._attrBinder.parseGravity(value, this.gravity);
                            }, () => {
                                return this.gravity;
                            });
                        }
                    }
                    ViewPager.LayoutParams = LayoutParams;
                })(ViewPager = view_8.ViewPager || (view_8.ViewPager = {}));
                class ItemInfo {
                    constructor() {
                        this.position = 0;
                        this.scrolling = false;
                        this.widthFactor = 0;
                        this.offset = 0;
                    }
                }
                class PagerObserver extends DataSetObserver {
                    constructor(viewPager) {
                        super();
                        this.ViewPager_this = viewPager;
                    }
                    onChanged() {
                        this.ViewPager_this.dataSetChanged();
                    }
                    onInvalidated() {
                        this.ViewPager_this.dataSetChanged();
                    }
                }
            })(view = v4.view || (v4.view = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../../android/view/MotionEvent.ts"/>
///<reference path="../../../../android/view/VelocityTracker.ts"/>
///<reference path="../../../../android/view/View.ts"/>
///<reference path="../../../../android/view/ViewConfiguration.ts"/>
///<reference path="../../../../android/view/ViewGroup.ts"/>
///<reference path="../../../../android/widget/OverScroller.ts"/>
///<reference path="../../../../android/view/animation/Interpolator.ts"/>
///<reference path="../../../../java/lang/System.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var widget;
            (function (widget) {
                var MotionEvent = android.view.MotionEvent;
                var VelocityTracker = android.view.VelocityTracker;
                var ViewConfiguration = android.view.ViewConfiguration;
                var ViewGroup = android.view.ViewGroup;
                var OverScroller = android.widget.OverScroller;
                var System = java.lang.System;
                class ViewDragHelper {
                    constructor(forParent, cb) {
                        this.mDragState = 0;
                        this.mTouchSlop = 0;
                        this.mActivePointerId = ViewDragHelper.INVALID_POINTER;
                        this.mPointersDown = 0;
                        this.mMaxVelocity = 0;
                        this.mMinVelocity = 0;
                        this.mEdgeSize = 0;
                        this.mTrackingEdges = 0;
                        this.mSetIdleRunnable = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.setDragState(ViewDragHelper.STATE_IDLE);
                                }
                            }
                            return new _Inner();
                        })();
                        if (forParent == null) {
                            throw Error(`new IllegalArgumentException("Parent view may not be null")`);
                        }
                        if (cb == null) {
                            throw Error(`new IllegalArgumentException("Callback may not be null")`);
                        }
                        this.mParentView = forParent;
                        this.mCallback = cb;
                        const vc = ViewConfiguration.get();
                        const density = android.content.res.Resources.getDisplayMetrics().density;
                        this.mEdgeSize = Math.floor((ViewDragHelper.EDGE_SIZE * density + 0.5));
                        this.mTouchSlop = vc.getScaledTouchSlop();
                        this.mMaxVelocity = vc.getScaledMaximumFlingVelocity();
                        this.mMinVelocity = vc.getScaledMinimumFlingVelocity();
                        this.mScroller = new OverScroller(ViewDragHelper.sInterpolator);
                    }
                    static create(...args) {
                        if (args.length === 2)
                            return new ViewDragHelper(args[0], args[1]);
                        else if (args.length === 3) {
                            let [forParent, sensitivity, cb] = args;
                            const helper = ViewDragHelper.create(forParent, cb);
                            helper.mTouchSlop = Math.floor((helper.mTouchSlop * (1 / sensitivity)));
                            return helper;
                        }
                    }
                    setMinVelocity(minVel) {
                        this.mMinVelocity = minVel;
                    }
                    getMinVelocity() {
                        return this.mMinVelocity;
                    }
                    getViewDragState() {
                        return this.mDragState;
                    }
                    setEdgeTrackingEnabled(edgeFlags) {
                        this.mTrackingEdges = edgeFlags;
                    }
                    getEdgeSize() {
                        return this.mEdgeSize;
                    }
                    captureChildView(childView, activePointerId) {
                        if (childView.getParent() != this.mParentView) {
                            throw Error(`new IllegalArgumentException("captureChildView: parameter must be a descendant " + "of the ViewDragHelper's tracked parent view (" + this.mParentView + ")")`);
                        }
                        this.mCapturedView = childView;
                        this.mActivePointerId = activePointerId;
                        this.mCallback.onViewCaptured(childView, activePointerId);
                        this.setDragState(ViewDragHelper.STATE_DRAGGING);
                    }
                    getCapturedView() {
                        return this.mCapturedView;
                    }
                    getActivePointerId() {
                        return this.mActivePointerId;
                    }
                    getTouchSlop() {
                        return this.mTouchSlop;
                    }
                    cancel() {
                        this.mActivePointerId = ViewDragHelper.INVALID_POINTER;
                        this.clearMotionHistory();
                        if (this.mVelocityTracker != null) {
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                    }
                    abort() {
                        this.cancel();
                        if (this.mDragState == ViewDragHelper.STATE_SETTLING) {
                            const oldX = this.mScroller.getCurrX();
                            const oldY = this.mScroller.getCurrY();
                            this.mScroller.abortAnimation();
                            const newX = this.mScroller.getCurrX();
                            const newY = this.mScroller.getCurrY();
                            this.mCallback.onViewPositionChanged(this.mCapturedView, newX, newY, newX - oldX, newY - oldY);
                        }
                        this.setDragState(ViewDragHelper.STATE_IDLE);
                    }
                    smoothSlideViewTo(child, finalLeft, finalTop) {
                        this.mCapturedView = child;
                        this.mActivePointerId = ViewDragHelper.INVALID_POINTER;
                        return this.forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);
                    }
                    settleCapturedViewAt(finalLeft, finalTop) {
                        if (!this.mReleaseInProgress) {
                            throw Error(`new IllegalStateException("Cannot settleCapturedViewAt outside of a call to " + "Callback#onViewReleased")`);
                        }
                        return this.forceSettleCapturedViewAt(finalLeft, finalTop, Math.floor(this.mVelocityTracker.getXVelocity(this.mActivePointerId)), Math.floor(this.mVelocityTracker.getYVelocity(this.mActivePointerId)));
                    }
                    forceSettleCapturedViewAt(finalLeft, finalTop, xvel, yvel) {
                        const startLeft = this.mCapturedView.getLeft();
                        const startTop = this.mCapturedView.getTop();
                        const dx = finalLeft - startLeft;
                        const dy = finalTop - startTop;
                        if (dx == 0 && dy == 0) {
                            this.mScroller.abortAnimation();
                            this.setDragState(ViewDragHelper.STATE_IDLE);
                            return false;
                        }
                        const duration = this.computeSettleDuration(this.mCapturedView, dx, dy, xvel, yvel);
                        this.mScroller.startScroll(startLeft, startTop, dx, dy, duration);
                        this.setDragState(ViewDragHelper.STATE_SETTLING);
                        return true;
                    }
                    computeSettleDuration(child, dx, dy, xvel, yvel) {
                        xvel = this.clampMag(xvel, Math.floor(this.mMinVelocity), Math.floor(this.mMaxVelocity));
                        yvel = this.clampMag(yvel, Math.floor(this.mMinVelocity), Math.floor(this.mMaxVelocity));
                        const absDx = Math.abs(dx);
                        const absDy = Math.abs(dy);
                        const absXVel = Math.abs(xvel);
                        const absYVel = Math.abs(yvel);
                        const addedVel = absXVel + absYVel;
                        const addedDistance = absDx + absDy;
                        const xweight = xvel != 0 ? absXVel / addedVel : absDx / addedDistance;
                        const yweight = yvel != 0 ? absYVel / addedVel : absDy / addedDistance;
                        let xduration = this.computeAxisDuration(dx, xvel, this.mCallback.getViewHorizontalDragRange(child));
                        let yduration = this.computeAxisDuration(dy, yvel, this.mCallback.getViewVerticalDragRange(child));
                        return Math.floor((xduration * xweight + yduration * yweight));
                    }
                    computeAxisDuration(delta, velocity, motionRange) {
                        if (delta == 0) {
                            return 0;
                        }
                        const width = this.mParentView.getWidth();
                        const halfWidth = width / 2;
                        const distanceRatio = Math.min(1, Math.abs(delta) / width);
                        const distance = halfWidth + halfWidth * this.distanceInfluenceForSnapDuration(distanceRatio);
                        let duration;
                        velocity = Math.abs(velocity);
                        if (velocity > 0) {
                            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
                        }
                        else {
                            const range = Math.abs(delta) / motionRange;
                            duration = Math.floor(((range + 1) * ViewDragHelper.BASE_SETTLE_DURATION));
                        }
                        return Math.min(duration, ViewDragHelper.MAX_SETTLE_DURATION);
                    }
                    clampMag(value, absMin, absMax) {
                        const absValue = Math.abs(value);
                        if (absValue < absMin)
                            return 0;
                        if (absValue > absMax)
                            return value > 0 ? absMax : -absMax;
                        return value;
                    }
                    distanceInfluenceForSnapDuration(f) {
                        f -= 0.5;
                        f *= 0.3 * Math.PI / 2.0;
                        return Math.sin(f);
                    }
                    flingCapturedView(minLeft, minTop, maxLeft, maxTop) {
                        if (!this.mReleaseInProgress) {
                            throw Error(`new IllegalStateException("Cannot flingCapturedView outside of a call to " + "Callback#onViewReleased")`);
                        }
                        this.mScroller.fling(this.mCapturedView.getLeft(), this.mCapturedView.getTop(), Math.floor(this.mVelocityTracker.getXVelocity(this.mActivePointerId)), Math.floor(this.mVelocityTracker.getYVelocity(this.mActivePointerId)), minLeft, maxLeft, minTop, maxTop);
                        this.setDragState(ViewDragHelper.STATE_SETTLING);
                    }
                    continueSettling(deferCallbacks) {
                        if (this.mDragState == ViewDragHelper.STATE_SETTLING) {
                            let keepGoing = this.mScroller.computeScrollOffset();
                            const x = this.mScroller.getCurrX();
                            const y = this.mScroller.getCurrY();
                            const dx = x - this.mCapturedView.getLeft();
                            const dy = y - this.mCapturedView.getTop();
                            if (dx != 0) {
                                this.mCapturedView.offsetLeftAndRight(dx);
                            }
                            if (dy != 0) {
                                this.mCapturedView.offsetTopAndBottom(dy);
                            }
                            if (dx != 0 || dy != 0) {
                                this.mCallback.onViewPositionChanged(this.mCapturedView, x, y, dx, dy);
                            }
                            if (keepGoing && x == this.mScroller.getFinalX() && y == this.mScroller.getFinalY()) {
                                this.mScroller.abortAnimation();
                                keepGoing = this.mScroller.isFinished();
                            }
                            if (!keepGoing) {
                                if (deferCallbacks) {
                                    this.mParentView.post(this.mSetIdleRunnable);
                                }
                                else {
                                    this.setDragState(ViewDragHelper.STATE_IDLE);
                                }
                            }
                        }
                        return this.mDragState == ViewDragHelper.STATE_SETTLING;
                    }
                    dispatchViewReleased(xvel, yvel) {
                        this.mReleaseInProgress = true;
                        this.mCallback.onViewReleased(this.mCapturedView, xvel, yvel);
                        this.mReleaseInProgress = false;
                        if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                            this.setDragState(ViewDragHelper.STATE_IDLE);
                        }
                    }
                    clearMotionHistory(pointerId) {
                        if (this.mInitialMotionX == null) {
                            return;
                        }
                        if (pointerId == null) {
                            this.mInitialMotionX = [];
                            this.mInitialMotionY = [];
                            this.mLastMotionX = [];
                            this.mLastMotionY = [];
                            this.mInitialEdgesTouched = [];
                            this.mEdgeDragsInProgress = [];
                            this.mEdgeDragsLocked = [];
                            this.mPointersDown = 0;
                        }
                        else {
                            this.mInitialMotionX[pointerId] = 0;
                            this.mInitialMotionY[pointerId] = 0;
                            this.mLastMotionX[pointerId] = 0;
                            this.mLastMotionY[pointerId] = 0;
                            this.mInitialEdgesTouched[pointerId] = 0;
                            this.mEdgeDragsInProgress[pointerId] = 0;
                            this.mEdgeDragsLocked[pointerId] = 0;
                            this.mPointersDown &= ~(1 << pointerId);
                        }
                    }
                    ensureMotionHistorySizeForId(pointerId) {
                        if (this.mInitialMotionX == null || this.mInitialMotionX.length <= pointerId) {
                            let imx = new Array(pointerId + 1);
                            let imy = new Array(pointerId + 1);
                            let lmx = new Array(pointerId + 1);
                            let lmy = new Array(pointerId + 1);
                            let iit = new Array(pointerId + 1);
                            let edip = new Array(pointerId + 1);
                            let edl = new Array(pointerId + 1);
                            if (this.mInitialMotionX != null) {
                                System.arraycopy(this.mInitialMotionX, 0, imx, 0, this.mInitialMotionX.length);
                                System.arraycopy(this.mInitialMotionY, 0, imy, 0, this.mInitialMotionY.length);
                                System.arraycopy(this.mLastMotionX, 0, lmx, 0, this.mLastMotionX.length);
                                System.arraycopy(this.mLastMotionY, 0, lmy, 0, this.mLastMotionY.length);
                                System.arraycopy(this.mInitialEdgesTouched, 0, iit, 0, this.mInitialEdgesTouched.length);
                                System.arraycopy(this.mEdgeDragsInProgress, 0, edip, 0, this.mEdgeDragsInProgress.length);
                                System.arraycopy(this.mEdgeDragsLocked, 0, edl, 0, this.mEdgeDragsLocked.length);
                            }
                            this.mInitialMotionX = imx;
                            this.mInitialMotionY = imy;
                            this.mLastMotionX = lmx;
                            this.mLastMotionY = lmy;
                            this.mInitialEdgesTouched = iit;
                            this.mEdgeDragsInProgress = edip;
                            this.mEdgeDragsLocked = edl;
                        }
                    }
                    saveInitialMotion(x, y, pointerId) {
                        this.ensureMotionHistorySizeForId(pointerId);
                        this.mInitialMotionX[pointerId] = this.mLastMotionX[pointerId] = x;
                        this.mInitialMotionY[pointerId] = this.mLastMotionY[pointerId] = y;
                        this.mInitialEdgesTouched[pointerId] = this.getEdgesTouched(Math.floor(x), Math.floor(y));
                        this.mPointersDown |= 1 << pointerId;
                    }
                    saveLastMotion(ev) {
                        const pointerCount = ev.getPointerCount();
                        for (let i = 0; i < pointerCount; i++) {
                            const pointerId = ev.getPointerId(i);
                            const x = ev.getX(i);
                            const y = ev.getY(i);
                            this.mLastMotionX[pointerId] = x;
                            this.mLastMotionY[pointerId] = y;
                        }
                    }
                    isPointerDown(pointerId) {
                        return (this.mPointersDown & 1 << pointerId) != 0;
                    }
                    setDragState(state) {
                        if (this.mDragState != state) {
                            this.mDragState = state;
                            this.mCallback.onViewDragStateChanged(state);
                            if (state == ViewDragHelper.STATE_IDLE) {
                                this.mCapturedView = null;
                            }
                        }
                    }
                    tryCaptureViewForDrag(toCapture, pointerId) {
                        if (toCapture == this.mCapturedView && this.mActivePointerId == pointerId) {
                            return true;
                        }
                        if (toCapture != null && this.mCallback.tryCaptureView(toCapture, pointerId)) {
                            this.mActivePointerId = pointerId;
                            this.captureChildView(toCapture, pointerId);
                            return true;
                        }
                        return false;
                    }
                    canScroll(v, checkV, dx, dy, x, y) {
                        if (v instanceof ViewGroup) {
                            const group = v;
                            const scrollX = v.getScrollX();
                            const scrollY = v.getScrollY();
                            const count = group.getChildCount();
                            for (let i = count - 1; i >= 0; i--) {
                                const child = group.getChildAt(i);
                                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight()
                                    && y + scrollY >= child.getTop() && y + scrollY < child.getBottom()
                                    && this.canScroll(child, true, dx, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {
                                    return true;
                                }
                            }
                        }
                        return checkV && (v.canScrollHorizontally(-dx) || v.canScrollVertically(-dy));
                    }
                    shouldInterceptTouchEvent(ev) {
                        const action = ev.getActionMasked();
                        const actionIndex = ev.getActionIndex();
                        if (action == MotionEvent.ACTION_DOWN) {
                            this.cancel();
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        switch (action) {
                            case MotionEvent.ACTION_DOWN:
                                {
                                    const x = ev.getX();
                                    const y = ev.getY();
                                    const pointerId = ev.getPointerId(0);
                                    this.saveInitialMotion(x, y, pointerId);
                                    const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                    if (toCapture == this.mCapturedView && this.mDragState == ViewDragHelper.STATE_SETTLING) {
                                        this.tryCaptureViewForDrag(toCapture, pointerId);
                                    }
                                    const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                    if ((edgesTouched & this.mTrackingEdges) != 0) {
                                        this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_DOWN:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    const x = ev.getX(actionIndex);
                                    const y = ev.getY(actionIndex);
                                    this.saveInitialMotion(x, y, pointerId);
                                    if (this.mDragState == ViewDragHelper.STATE_IDLE) {
                                        const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                        if ((edgesTouched & this.mTrackingEdges) != 0) {
                                            this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                        }
                                    }
                                    else if (this.mDragState == ViewDragHelper.STATE_SETTLING) {
                                        const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                        if (toCapture == this.mCapturedView) {
                                            this.tryCaptureViewForDrag(toCapture, pointerId);
                                        }
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_MOVE:
                                {
                                    const pointerCount = ev.getPointerCount();
                                    for (let i = 0; i < pointerCount; i++) {
                                        const pointerId = ev.getPointerId(i);
                                        const x = ev.getX(i);
                                        const y = ev.getY(i);
                                        const dx = x - this.mInitialMotionX[pointerId];
                                        const dy = y - this.mInitialMotionY[pointerId];
                                        this.reportNewEdgeDrags(dx, dy, pointerId);
                                        if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                            break;
                                        }
                                        const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                        if (toCapture != null && this.checkTouchSlop(toCapture, dx, dy) && this.tryCaptureViewForDrag(toCapture, pointerId)) {
                                            break;
                                        }
                                    }
                                    this.saveLastMotion(ev);
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_UP:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    this.clearMotionHistory(pointerId);
                                    break;
                                }
                            case MotionEvent.ACTION_UP:
                            case MotionEvent.ACTION_CANCEL:
                                {
                                    this.cancel();
                                    break;
                                }
                        }
                        return this.mDragState == ViewDragHelper.STATE_DRAGGING;
                    }
                    processTouchEvent(ev) {
                        const action = ev.getActionMasked();
                        const actionIndex = ev.getActionIndex();
                        if (action == MotionEvent.ACTION_DOWN) {
                            this.cancel();
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        switch (action) {
                            case MotionEvent.ACTION_DOWN:
                                {
                                    const x = ev.getX();
                                    const y = ev.getY();
                                    const pointerId = ev.getPointerId(0);
                                    const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                    this.saveInitialMotion(x, y, pointerId);
                                    this.tryCaptureViewForDrag(toCapture, pointerId);
                                    const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                    if ((edgesTouched & this.mTrackingEdges) != 0) {
                                        this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_DOWN:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    const x = ev.getX(actionIndex);
                                    const y = ev.getY(actionIndex);
                                    this.saveInitialMotion(x, y, pointerId);
                                    if (this.mDragState == ViewDragHelper.STATE_IDLE) {
                                        const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                        this.tryCaptureViewForDrag(toCapture, pointerId);
                                        const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                        if ((edgesTouched & this.mTrackingEdges) != 0) {
                                            this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                        }
                                    }
                                    else if (this.isCapturedViewUnder(Math.floor(x), Math.floor(y))) {
                                        this.tryCaptureViewForDrag(this.mCapturedView, pointerId);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_MOVE:
                                {
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                        const index = ev.findPointerIndex(this.mActivePointerId);
                                        const x = ev.getX(index);
                                        const y = ev.getY(index);
                                        const idx = Math.floor((x - this.mLastMotionX[this.mActivePointerId]));
                                        const idy = Math.floor((y - this.mLastMotionY[this.mActivePointerId]));
                                        this.dragTo(this.mCapturedView.getLeft() + idx, this.mCapturedView.getTop() + idy, idx, idy);
                                        this.saveLastMotion(ev);
                                    }
                                    else {
                                        const pointerCount = ev.getPointerCount();
                                        for (let i = 0; i < pointerCount; i++) {
                                            const pointerId = ev.getPointerId(i);
                                            const x = ev.getX(i);
                                            const y = ev.getY(i);
                                            const dx = x - this.mInitialMotionX[pointerId];
                                            const dy = y - this.mInitialMotionY[pointerId];
                                            this.reportNewEdgeDrags(dx, dy, pointerId);
                                            if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                                break;
                                            }
                                            const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                            if (this.checkTouchSlop(toCapture, dx, dy) && this.tryCaptureViewForDrag(toCapture, pointerId)) {
                                                break;
                                            }
                                        }
                                        this.saveLastMotion(ev);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_UP:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING && pointerId == this.mActivePointerId) {
                                        let newActivePointer = ViewDragHelper.INVALID_POINTER;
                                        const pointerCount = ev.getPointerCount();
                                        for (let i = 0; i < pointerCount; i++) {
                                            const id = ev.getPointerId(i);
                                            if (id == this.mActivePointerId) {
                                                continue;
                                            }
                                            const x = ev.getX(i);
                                            const y = ev.getY(i);
                                            if (this.findTopChildUnder(Math.floor(x), Math.floor(y)) == this.mCapturedView && this.tryCaptureViewForDrag(this.mCapturedView, id)) {
                                                newActivePointer = this.mActivePointerId;
                                                break;
                                            }
                                        }
                                        if (newActivePointer == ViewDragHelper.INVALID_POINTER) {
                                            this.releaseViewForPointerUp();
                                        }
                                    }
                                    this.clearMotionHistory(pointerId);
                                    break;
                                }
                            case MotionEvent.ACTION_UP:
                                {
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                        this.releaseViewForPointerUp();
                                    }
                                    this.cancel();
                                    break;
                                }
                            case MotionEvent.ACTION_CANCEL:
                                {
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                        this.dispatchViewReleased(0, 0);
                                    }
                                    this.cancel();
                                    break;
                                }
                        }
                    }
                    reportNewEdgeDrags(dx, dy, pointerId) {
                        let dragsStarted = 0;
                        if (this.checkNewEdgeDrag(dx, dy, pointerId, ViewDragHelper.EDGE_LEFT)) {
                            dragsStarted |= ViewDragHelper.EDGE_LEFT;
                        }
                        if (this.checkNewEdgeDrag(dy, dx, pointerId, ViewDragHelper.EDGE_TOP)) {
                            dragsStarted |= ViewDragHelper.EDGE_TOP;
                        }
                        if (this.checkNewEdgeDrag(dx, dy, pointerId, ViewDragHelper.EDGE_RIGHT)) {
                            dragsStarted |= ViewDragHelper.EDGE_RIGHT;
                        }
                        if (this.checkNewEdgeDrag(dy, dx, pointerId, ViewDragHelper.EDGE_BOTTOM)) {
                            dragsStarted |= ViewDragHelper.EDGE_BOTTOM;
                        }
                        if (dragsStarted != 0) {
                            this.mEdgeDragsInProgress[pointerId] |= dragsStarted;
                            this.mCallback.onEdgeDragStarted(dragsStarted, pointerId);
                        }
                    }
                    checkNewEdgeDrag(delta, odelta, pointerId, edge) {
                        const absDelta = Math.abs(delta);
                        const absODelta = Math.abs(odelta);
                        if ((this.mInitialEdgesTouched[pointerId] & edge) != edge || (this.mTrackingEdges & edge) == 0 || (this.mEdgeDragsLocked[pointerId] & edge) == edge || (this.mEdgeDragsInProgress[pointerId] & edge) == edge || (absDelta <= this.mTouchSlop && absODelta <= this.mTouchSlop)) {
                            return false;
                        }
                        if (absDelta < absODelta * 0.5 && this.mCallback.onEdgeLock(edge)) {
                            this.mEdgeDragsLocked[pointerId] |= edge;
                            return false;
                        }
                        return (this.mEdgeDragsInProgress[pointerId] & edge) == 0 && absDelta > this.mTouchSlop;
                    }
                    checkTouchSlop(...args) {
                        if (args.length === 1)
                            return this._checkTouchSlop_1(args[0]);
                        if (args.length === 2)
                            return this._checkTouchSlop_2(args[0], args[1]);
                        if (args.length === 3)
                            return this._checkTouchSlop_3(args[0], args[1], args[2]);
                        return false;
                    }
                    _checkTouchSlop_3(child, dx, dy) {
                        if (child == null) {
                            return false;
                        }
                        const checkHorizontal = this.mCallback.getViewHorizontalDragRange(child) > 0;
                        const checkVertical = this.mCallback.getViewVerticalDragRange(child) > 0;
                        if (checkHorizontal && checkVertical) {
                            return dx * dx + dy * dy > this.mTouchSlop * this.mTouchSlop;
                        }
                        else if (checkHorizontal) {
                            return Math.abs(dx) > this.mTouchSlop;
                        }
                        else if (checkVertical) {
                            return Math.abs(dy) > this.mTouchSlop;
                        }
                        return false;
                    }
                    _checkTouchSlop_1(directions) {
                        const count = this.mInitialMotionX.length;
                        for (let i = 0; i < count; i++) {
                            if (this.checkTouchSlop(directions, i)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    _checkTouchSlop_2(directions, pointerId) {
                        if (!this.isPointerDown(pointerId)) {
                            return false;
                        }
                        const checkHorizontal = (directions & ViewDragHelper.DIRECTION_HORIZONTAL) == ViewDragHelper.DIRECTION_HORIZONTAL;
                        const checkVertical = (directions & ViewDragHelper.DIRECTION_VERTICAL) == ViewDragHelper.DIRECTION_VERTICAL;
                        const dx = this.mLastMotionX[pointerId] - this.mInitialMotionX[pointerId];
                        const dy = this.mLastMotionY[pointerId] - this.mInitialMotionY[pointerId];
                        if (checkHorizontal && checkVertical) {
                            return dx * dx + dy * dy > this.mTouchSlop * this.mTouchSlop;
                        }
                        else if (checkHorizontal) {
                            return Math.abs(dx) > this.mTouchSlop;
                        }
                        else if (checkVertical) {
                            return Math.abs(dy) > this.mTouchSlop;
                        }
                        return false;
                    }
                    isEdgeTouched(edges, pointerId) {
                        if (pointerId == null) {
                            const count = this.mInitialEdgesTouched.length;
                            for (let i = 0; i < count; i++) {
                                if (this.isEdgeTouched(edges, i)) {
                                    return true;
                                }
                            }
                        }
                        return this.isPointerDown(pointerId) && (this.mInitialEdgesTouched[pointerId] & edges) != 0;
                    }
                    releaseViewForPointerUp() {
                        this.mVelocityTracker.computeCurrentVelocity(1000, this.mMaxVelocity);
                        const xvel = this.clampMag(this.mVelocityTracker.getXVelocity(this.mActivePointerId), this.mMinVelocity, this.mMaxVelocity);
                        const yvel = this.clampMag(this.mVelocityTracker.getYVelocity(this.mActivePointerId), this.mMinVelocity, this.mMaxVelocity);
                        this.dispatchViewReleased(xvel, yvel);
                    }
                    dragTo(left, top, dx, dy) {
                        let clampedX = left;
                        let clampedY = top;
                        const oldLeft = this.mCapturedView.getLeft();
                        const oldTop = this.mCapturedView.getTop();
                        if (dx != 0) {
                            clampedX = this.mCallback.clampViewPositionHorizontal(this.mCapturedView, left, dx);
                            this.mCapturedView.offsetLeftAndRight(clampedX - oldLeft);
                        }
                        if (dy != 0) {
                            clampedY = this.mCallback.clampViewPositionVertical(this.mCapturedView, top, dy);
                            this.mCapturedView.offsetTopAndBottom(clampedY - oldTop);
                        }
                        if (dx != 0 || dy != 0) {
                            const clampedDx = clampedX - oldLeft;
                            const clampedDy = clampedY - oldTop;
                            this.mCallback.onViewPositionChanged(this.mCapturedView, clampedX, clampedY, clampedDx, clampedDy);
                        }
                    }
                    isCapturedViewUnder(x, y) {
                        return this.isViewUnder(this.mCapturedView, x, y);
                    }
                    isViewUnder(view, x, y) {
                        if (view == null) {
                            return false;
                        }
                        return x >= view.getLeft() && x < view.getRight() && y >= view.getTop() && y < view.getBottom();
                    }
                    findTopChildUnder(x, y) {
                        const childCount = this.mParentView.getChildCount();
                        for (let i = childCount - 1; i >= 0; i--) {
                            const child = this.mParentView.getChildAt(this.mCallback.getOrderedChildIndex(i));
                            if (x >= child.getLeft() && x < child.getRight() && y >= child.getTop() && y < child.getBottom()) {
                                return child;
                            }
                        }
                        return null;
                    }
                    getEdgesTouched(x, y) {
                        let result = 0;
                        if (x < this.mParentView.getLeft() + this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_LEFT;
                        if (y < this.mParentView.getTop() + this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_TOP;
                        if (x > this.mParentView.getRight() - this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_RIGHT;
                        if (y > this.mParentView.getBottom() - this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_BOTTOM;
                        return result;
                    }
                }
                ViewDragHelper.TAG = "ViewDragHelper";
                ViewDragHelper.INVALID_POINTER = -1;
                ViewDragHelper.STATE_IDLE = 0;
                ViewDragHelper.STATE_DRAGGING = 1;
                ViewDragHelper.STATE_SETTLING = 2;
                ViewDragHelper.EDGE_LEFT = 1 << 0;
                ViewDragHelper.EDGE_RIGHT = 1 << 1;
                ViewDragHelper.EDGE_TOP = 1 << 2;
                ViewDragHelper.EDGE_BOTTOM = 1 << 3;
                ViewDragHelper.EDGE_ALL = ViewDragHelper.EDGE_LEFT | ViewDragHelper.EDGE_TOP | ViewDragHelper.EDGE_RIGHT | ViewDragHelper.EDGE_BOTTOM;
                ViewDragHelper.DIRECTION_HORIZONTAL = 1 << 0;
                ViewDragHelper.DIRECTION_VERTICAL = 1 << 1;
                ViewDragHelper.DIRECTION_ALL = ViewDragHelper.DIRECTION_HORIZONTAL | ViewDragHelper.DIRECTION_VERTICAL;
                ViewDragHelper.EDGE_SIZE = 20;
                ViewDragHelper.BASE_SETTLE_DURATION = 256;
                ViewDragHelper.MAX_SETTLE_DURATION = 600;
                ViewDragHelper.sInterpolator = (() => {
                    class _Inner {
                        getInterpolation(t) {
                            t -= 1.0;
                            return t * t * t * t * t + 1.0;
                        }
                    }
                    return new _Inner();
                })();
                widget.ViewDragHelper = ViewDragHelper;
                (function (ViewDragHelper) {
                    class Callback {
                        onViewDragStateChanged(state) {
                        }
                        onViewPositionChanged(changedView, left, top, dx, dy) {
                        }
                        onViewCaptured(capturedChild, activePointerId) {
                        }
                        onViewReleased(releasedChild, xvel, yvel) {
                        }
                        onEdgeTouched(edgeFlags, pointerId) {
                        }
                        onEdgeLock(edgeFlags) {
                            return false;
                        }
                        onEdgeDragStarted(edgeFlags, pointerId) {
                        }
                        getOrderedChildIndex(index) {
                            return index;
                        }
                        getViewHorizontalDragRange(child) {
                            return 0;
                        }
                        getViewVerticalDragRange(child) {
                            return 0;
                        }
                        clampViewPositionHorizontal(child, left, dx) {
                            return 0;
                        }
                        clampViewPositionVertical(child, top, dy) {
                            return 0;
                        }
                    }
                    ViewDragHelper.Callback = Callback;
                })(ViewDragHelper = widget.ViewDragHelper || (widget.ViewDragHelper = {}));
            })(widget = v4.widget || (v4.widget = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../../android/graphics/Canvas.ts"/>
///<reference path="../../../../android/graphics/Paint.ts"/>
///<reference path="../../../../android/graphics/PixelFormat.ts"/>
///<reference path="../../../../android/graphics/Rect.ts"/>
///<reference path="../../../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../../../android/os/SystemClock.ts"/>
///<reference path="../../../../android/view/Gravity.ts"/>
///<reference path="../../../../android/view/KeyEvent.ts"/>
///<reference path="../../../../android/view/MotionEvent.ts"/>
///<reference path="../../../../android/view/View.ts"/>
///<reference path="../../../../android/view/ViewGroup.ts"/>
///<reference path="../../../../android/view/ViewParent.ts"/>
///<reference path="../../../../java/lang/Integer.ts"/>
///<reference path="../../../../java/lang/Runnable.ts"/>
///<reference path="../../../../android/support/v4/widget/ViewDragHelper.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var widget;
            (function (widget) {
                var Paint = android.graphics.Paint;
                var PixelFormat = android.graphics.PixelFormat;
                var SystemClock = android.os.SystemClock;
                var Gravity = android.view.Gravity;
                var KeyEvent = android.view.KeyEvent;
                var MotionEvent = android.view.MotionEvent;
                var View = android.view.View;
                var ViewGroup = android.view.ViewGroup;
                var ViewDragHelper = android.support.v4.widget.ViewDragHelper;
                class DrawerLayout extends ViewGroup {
                    constructor(context, bindElement, defStyle) {
                        super(context, bindElement, defStyle);
                        this.mMinDrawerMargin = 0;
                        this.mScrimColor = DrawerLayout.DEFAULT_SCRIM_COLOR;
                        this.mScrimOpacity = 0;
                        this.mScrimPaint = new Paint();
                        this.mDrawerState = 0;
                        this.mFirstLayout = true;
                        this.mLockModeLeft = 0;
                        this.mLockModeRight = 0;
                        this.mInitialMotionX = 0;
                        this.mInitialMotionY = 0;
                        const density = this.getResources().getDisplayMetrics().density;
                        this.mMinDrawerMargin = Math.floor((DrawerLayout.MIN_DRAWER_MARGIN * density + 0.5));
                        const minVel = DrawerLayout.MIN_FLING_VELOCITY * density;
                        this.mLeftCallback = new DrawerLayout.ViewDragCallback(this, Gravity.LEFT);
                        this.mRightCallback = new DrawerLayout.ViewDragCallback(this, Gravity.RIGHT);
                        this.mLeftDragger = ViewDragHelper.create(this, DrawerLayout.TOUCH_SLOP_SENSITIVITY, this.mLeftCallback);
                        this.mLeftDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);
                        this.mLeftDragger.setMinVelocity(minVel);
                        this.mLeftCallback.setDragger(this.mLeftDragger);
                        this.mRightDragger = ViewDragHelper.create(this, DrawerLayout.TOUCH_SLOP_SENSITIVITY, this.mRightCallback);
                        this.mRightDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_RIGHT);
                        this.mRightDragger.setMinVelocity(minVel);
                        this.mRightCallback.setDragger(this.mRightDragger);
                        this.setFocusableInTouchMode(true);
                        this.setMotionEventSplittingEnabled(false);
                    }
                    setDrawerShadow(shadowDrawable, gravity) {
                        const absGravity = Gravity.getAbsoluteGravity(gravity, this.getLayoutDirection());
                        if ((absGravity & Gravity.LEFT) == Gravity.LEFT) {
                            this.mShadowLeft = shadowDrawable;
                            this.invalidate();
                        }
                        if ((absGravity & Gravity.RIGHT) == Gravity.RIGHT) {
                            this.mShadowRight = shadowDrawable;
                            this.invalidate();
                        }
                    }
                    setScrimColor(color) {
                        this.mScrimColor = color;
                        this.invalidate();
                    }
                    setDrawerListener(listener) {
                        this.mListener = listener;
                    }
                    setDrawerLockMode(lockMode, edgeGravityOrView) {
                        if (edgeGravityOrView == null) {
                            this.setDrawerLockMode(lockMode, Gravity.LEFT);
                            this.setDrawerLockMode(lockMode, Gravity.RIGHT);
                            return;
                        }
                        if (edgeGravityOrView instanceof View) {
                            if (!this.isDrawerView(edgeGravityOrView)) {
                                throw Error(`new IllegalArgumentException("View " + drawerView + " is not a " + "drawer with appropriate layout_gravity")`);
                            }
                            const gravity = edgeGravityOrView.getLayoutParams().gravity;
                            this.setDrawerLockMode(lockMode, gravity);
                            return;
                        }
                        let edgeGravity = edgeGravityOrView;
                        const absGravity = Gravity.getAbsoluteGravity(edgeGravity, this.getLayoutDirection());
                        if (absGravity == Gravity.LEFT) {
                            this.mLockModeLeft = lockMode;
                        }
                        else if (absGravity == Gravity.RIGHT) {
                            this.mLockModeRight = lockMode;
                        }
                        if (lockMode != DrawerLayout.LOCK_MODE_UNLOCKED) {
                            const helper = absGravity == Gravity.LEFT ? this.mLeftDragger : this.mRightDragger;
                            helper.cancel();
                        }
                        switch (lockMode) {
                            case DrawerLayout.LOCK_MODE_LOCKED_OPEN:
                                const toOpen = this.findDrawerWithGravity(absGravity);
                                if (toOpen != null) {
                                    this.openDrawer(toOpen);
                                }
                                break;
                            case DrawerLayout.LOCK_MODE_LOCKED_CLOSED:
                                const toClose = this.findDrawerWithGravity(absGravity);
                                if (toClose != null) {
                                    this.closeDrawer(toClose);
                                }
                                break;
                        }
                    }
                    getDrawerLockMode(edgeGravityOrView) {
                        if (edgeGravityOrView instanceof View) {
                            let drawerView = edgeGravityOrView;
                            const absGravity = this.getDrawerViewAbsoluteGravity(drawerView);
                            if (absGravity == Gravity.LEFT) {
                                return this.mLockModeLeft;
                            }
                            else if (absGravity == Gravity.RIGHT) {
                                return this.mLockModeRight;
                            }
                            return DrawerLayout.LOCK_MODE_UNLOCKED;
                        }
                        else {
                            let edgeGravity = edgeGravityOrView;
                            const absGravity = Gravity.getAbsoluteGravity(edgeGravity, this.getLayoutDirection());
                            if (absGravity == Gravity.LEFT) {
                                return this.mLockModeLeft;
                            }
                            else if (absGravity == Gravity.RIGHT) {
                                return this.mLockModeRight;
                            }
                            return DrawerLayout.LOCK_MODE_UNLOCKED;
                        }
                    }
                    updateDrawerState(forGravity, activeState, activeDrawer) {
                        const leftState = this.mLeftDragger.getViewDragState();
                        const rightState = this.mRightDragger.getViewDragState();
                        let state;
                        if (leftState == DrawerLayout.STATE_DRAGGING || rightState == DrawerLayout.STATE_DRAGGING) {
                            state = DrawerLayout.STATE_DRAGGING;
                        }
                        else if (leftState == DrawerLayout.STATE_SETTLING || rightState == DrawerLayout.STATE_SETTLING) {
                            state = DrawerLayout.STATE_SETTLING;
                        }
                        else {
                            state = DrawerLayout.STATE_IDLE;
                        }
                        if (activeDrawer != null && activeState == DrawerLayout.STATE_IDLE) {
                            const lp = activeDrawer.getLayoutParams();
                            if (lp.onScreen == 0) {
                                this.dispatchOnDrawerClosed(activeDrawer);
                            }
                            else if (lp.onScreen == 1) {
                                this.dispatchOnDrawerOpened(activeDrawer);
                            }
                        }
                        if (state != this.mDrawerState) {
                            this.mDrawerState = state;
                            if (this.mListener != null) {
                                this.mListener.onDrawerStateChanged(state);
                            }
                        }
                    }
                    dispatchOnDrawerClosed(drawerView) {
                        const lp = drawerView.getLayoutParams();
                        if (lp.knownOpen) {
                            lp.knownOpen = false;
                            if (this.mListener != null) {
                                this.mListener.onDrawerClosed(drawerView);
                            }
                        }
                    }
                    dispatchOnDrawerOpened(drawerView) {
                        const lp = drawerView.getLayoutParams();
                        if (!lp.knownOpen) {
                            lp.knownOpen = true;
                            if (this.mListener != null) {
                                this.mListener.onDrawerOpened(drawerView);
                            }
                        }
                    }
                    dispatchOnDrawerSlide(drawerView, slideOffset) {
                        if (this.mListener != null) {
                            this.mListener.onDrawerSlide(drawerView, slideOffset);
                        }
                    }
                    setDrawerViewOffset(drawerView, slideOffset) {
                        const lp = drawerView.getLayoutParams();
                        if (slideOffset == lp.onScreen) {
                            return;
                        }
                        lp.onScreen = slideOffset;
                        this.dispatchOnDrawerSlide(drawerView, slideOffset);
                    }
                    getDrawerViewOffset(drawerView) {
                        return drawerView.getLayoutParams().onScreen;
                    }
                    getDrawerViewAbsoluteGravity(drawerView) {
                        const gravity = drawerView.getLayoutParams().gravity;
                        return Gravity.getAbsoluteGravity(gravity, this.getLayoutDirection());
                    }
                    checkDrawerViewAbsoluteGravity(drawerView, checkFor) {
                        const absGravity = this.getDrawerViewAbsoluteGravity(drawerView);
                        return (absGravity & checkFor) == checkFor;
                    }
                    findOpenDrawer() {
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const child = this.getChildAt(i);
                            if (child.getLayoutParams().knownOpen) {
                                return child;
                            }
                        }
                        return null;
                    }
                    moveDrawerToOffset(drawerView, slideOffset) {
                        const oldOffset = this.getDrawerViewOffset(drawerView);
                        const width = drawerView.getWidth();
                        const oldPos = Math.floor((width * oldOffset));
                        const newPos = Math.floor((width * slideOffset));
                        const dx = newPos - oldPos;
                        drawerView.offsetLeftAndRight(this.checkDrawerViewAbsoluteGravity(drawerView, Gravity.LEFT) ? dx : -dx);
                        this.setDrawerViewOffset(drawerView, slideOffset);
                    }
                    findDrawerWithGravity(gravity) {
                        const absHorizGravity = Gravity.getAbsoluteGravity(gravity, this.getLayoutDirection()) & Gravity.HORIZONTAL_GRAVITY_MASK;
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const child = this.getChildAt(i);
                            const childAbsGravity = this.getDrawerViewAbsoluteGravity(child);
                            if ((childAbsGravity & Gravity.HORIZONTAL_GRAVITY_MASK) == absHorizGravity) {
                                return child;
                            }
                        }
                        return null;
                    }
                    static gravityToString(gravity) {
                        if ((gravity & Gravity.LEFT) == Gravity.LEFT) {
                            return "LEFT";
                        }
                        if ((gravity & Gravity.RIGHT) == Gravity.RIGHT) {
                            return "RIGHT";
                        }
                        return '' + gravity;
                    }
                    onDetachedFromWindow() {
                        super.onDetachedFromWindow();
                        this.mFirstLayout = true;
                    }
                    onAttachedToWindow() {
                        super.onAttachedToWindow();
                        this.mFirstLayout = true;
                    }
                    onMeasure(widthMeasureSpec, heightMeasureSpec) {
                        let widthMode = DrawerLayout.MeasureSpec.getMode(widthMeasureSpec);
                        let heightMode = DrawerLayout.MeasureSpec.getMode(heightMeasureSpec);
                        let widthSize = DrawerLayout.MeasureSpec.getSize(widthMeasureSpec);
                        let heightSize = DrawerLayout.MeasureSpec.getSize(heightMeasureSpec);
                        if (widthMode != DrawerLayout.MeasureSpec.EXACTLY || heightMode != DrawerLayout.MeasureSpec.EXACTLY) {
                            if (this.isInEditMode()) {
                                if (widthMode == DrawerLayout.MeasureSpec.AT_MOST) {
                                    widthMode = DrawerLayout.MeasureSpec.EXACTLY;
                                }
                                else if (widthMode == DrawerLayout.MeasureSpec.UNSPECIFIED) {
                                    widthMode = DrawerLayout.MeasureSpec.EXACTLY;
                                    widthSize = 300;
                                }
                                if (heightMode == DrawerLayout.MeasureSpec.AT_MOST) {
                                    heightMode = DrawerLayout.MeasureSpec.EXACTLY;
                                }
                                else if (heightMode == DrawerLayout.MeasureSpec.UNSPECIFIED) {
                                    heightMode = DrawerLayout.MeasureSpec.EXACTLY;
                                    heightSize = 300;
                                }
                            }
                            else {
                                throw Error(`new IllegalArgumentException("DrawerLayout must be measured with MeasureSpec.EXACTLY.")`);
                            }
                        }
                        this.setMeasuredDimension(widthSize, heightSize);
                        let foundDrawers = 0;
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() == DrawerLayout.GONE) {
                                continue;
                            }
                            const lp = child.getLayoutParams();
                            if (this.isContentView(child)) {
                                const contentWidthSpec = DrawerLayout.MeasureSpec.makeMeasureSpec(widthSize - lp.leftMargin - lp.rightMargin, DrawerLayout.MeasureSpec.EXACTLY);
                                const contentHeightSpec = DrawerLayout.MeasureSpec.makeMeasureSpec(heightSize - lp.topMargin - lp.bottomMargin, DrawerLayout.MeasureSpec.EXACTLY);
                                child.measure(contentWidthSpec, contentHeightSpec);
                            }
                            else if (this.isDrawerView(child)) {
                                const childGravity = this.getDrawerViewAbsoluteGravity(child) & Gravity.HORIZONTAL_GRAVITY_MASK;
                                if ((foundDrawers & childGravity) != 0) {
                                    throw Error(`new IllegalStateException("Child drawer has absolute gravity " + DrawerLayout.gravityToString(childGravity) + " but this " + DrawerLayout.TAG + " already has a " + "drawer view along that edge")`);
                                }
                                const drawerWidthSpec = DrawerLayout.getChildMeasureSpec(widthMeasureSpec, this.mMinDrawerMargin + lp.leftMargin + lp.rightMargin, lp.width);
                                const drawerHeightSpec = DrawerLayout.getChildMeasureSpec(heightMeasureSpec, lp.topMargin + lp.bottomMargin, lp.height);
                                child.measure(drawerWidthSpec, drawerHeightSpec);
                            }
                            else {
                                throw Error(`new IllegalStateException("Child " + child + " at index " + i + " does not have a valid layout_gravity - must be Gravity.LEFT, " + "Gravity.RIGHT or Gravity.NO_GRAVITY")`);
                            }
                        }
                    }
                    onLayout(changed, l, t, r, b) {
                        this.mInLayout = true;
                        const width = r - l;
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() == DrawerLayout.GONE) {
                                continue;
                            }
                            const lp = child.getLayoutParams();
                            if (this.isContentView(child)) {
                                child.layout(lp.leftMargin, lp.topMargin, lp.leftMargin + child.getMeasuredWidth(), lp.topMargin + child.getMeasuredHeight());
                            }
                            else {
                                const childWidth = child.getMeasuredWidth();
                                const childHeight = child.getMeasuredHeight();
                                let childLeft;
                                let newOffset;
                                if (this.checkDrawerViewAbsoluteGravity(child, Gravity.LEFT)) {
                                    childLeft = -childWidth + Math.floor((childWidth * lp.onScreen));
                                    newOffset = (childWidth + childLeft) / childWidth;
                                }
                                else {
                                    childLeft = width - Math.floor((childWidth * lp.onScreen));
                                    newOffset = (width - childLeft) / childWidth;
                                }
                                const changeOffset = newOffset != lp.onScreen;
                                const vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
                                switch (vgrav) {
                                    default:
                                    case Gravity.TOP:
                                        {
                                            child.layout(childLeft, lp.topMargin, childLeft + childWidth, lp.topMargin + childHeight);
                                            break;
                                        }
                                    case Gravity.BOTTOM:
                                        {
                                            const height = b - t;
                                            child.layout(childLeft, height - lp.bottomMargin - child.getMeasuredHeight(), childLeft + childWidth, height - lp.bottomMargin);
                                            break;
                                        }
                                    case Gravity.CENTER_VERTICAL:
                                        {
                                            const height = b - t;
                                            let childTop = (height - childHeight) / 2;
                                            if (childTop < lp.topMargin) {
                                                childTop = lp.topMargin;
                                            }
                                            else if (childTop + childHeight > height - lp.bottomMargin) {
                                                childTop = height - lp.bottomMargin - childHeight;
                                            }
                                            child.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);
                                            break;
                                        }
                                }
                                if (changeOffset) {
                                    this.setDrawerViewOffset(child, newOffset);
                                }
                                const newVisibility = lp.onScreen > 0 ? DrawerLayout.VISIBLE : DrawerLayout.INVISIBLE;
                                if (child.getVisibility() != newVisibility) {
                                    child.setVisibility(newVisibility);
                                }
                            }
                        }
                        this.mInLayout = false;
                        this.mFirstLayout = false;
                    }
                    requestLayout() {
                        if (!this.mInLayout) {
                            super.requestLayout();
                        }
                    }
                    computeScroll() {
                        const childCount = this.getChildCount();
                        let scrimOpacity = 0;
                        for (let i = 0; i < childCount; i++) {
                            const onscreen = this.getChildAt(i).getLayoutParams().onScreen;
                            scrimOpacity = Math.max(scrimOpacity, onscreen);
                        }
                        this.mScrimOpacity = scrimOpacity;
                        let leftContinue = this.mLeftDragger.continueSettling(true);
                        let rightContinue = this.mRightDragger.continueSettling(true);
                        if (leftContinue || rightContinue) {
                            this.postInvalidateOnAnimation();
                        }
                    }
                    static hasOpaqueBackground(v) {
                        const bg = v.getBackground();
                        if (bg != null) {
                            return bg.getOpacity() == PixelFormat.OPAQUE;
                        }
                        return false;
                    }
                    drawChild(canvas, child, drawingTime) {
                        const height = this.getHeight();
                        const drawingContent = this.isContentView(child);
                        let clipLeft = 0, clipRight = this.getWidth();
                        const restoreCount = canvas.save();
                        if (drawingContent) {
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const v = this.getChildAt(i);
                                if (v == child || v.getVisibility() != DrawerLayout.VISIBLE || !DrawerLayout.hasOpaqueBackground(v) || !this.isDrawerView(v) || v.getHeight() < height) {
                                    continue;
                                }
                                if (this.checkDrawerViewAbsoluteGravity(v, Gravity.LEFT)) {
                                    const vright = v.getRight();
                                    if (vright > clipLeft)
                                        clipLeft = vright;
                                }
                                else {
                                    const vleft = v.getLeft();
                                    if (vleft < clipRight)
                                        clipRight = vleft;
                                }
                            }
                            canvas.clipRect(clipLeft, 0, clipRight, this.getHeight());
                        }
                        const result = super.drawChild(canvas, child, drawingTime);
                        canvas.restoreToCount(restoreCount);
                        if (this.mScrimOpacity > 0 && drawingContent) {
                            const baseAlpha = (this.mScrimColor & 0xff000000) >>> 24;
                            const imag = Math.floor((baseAlpha * this.mScrimOpacity));
                            const color = imag << 24 | (this.mScrimColor & 0xffffff);
                            this.mScrimPaint.setColor(color);
                            canvas.drawRect(clipLeft, 0, clipRight, this.getHeight(), this.mScrimPaint);
                        }
                        else if (this.mShadowLeft != null && this.checkDrawerViewAbsoluteGravity(child, Gravity.LEFT)) {
                            const shadowWidth = this.mShadowLeft.getIntrinsicWidth();
                            const childRight = child.getRight();
                            const drawerPeekDistance = this.mLeftDragger.getEdgeSize();
                            const alpha = Math.max(0, Math.min(childRight / drawerPeekDistance, 1.));
                            this.mShadowLeft.setBounds(childRight, child.getTop(), childRight + shadowWidth, child.getBottom());
                            this.mShadowLeft.setAlpha(Math.floor((0xff * alpha)));
                            this.mShadowLeft.draw(canvas);
                        }
                        else if (this.mShadowRight != null && this.checkDrawerViewAbsoluteGravity(child, Gravity.RIGHT)) {
                            const shadowWidth = this.mShadowRight.getIntrinsicWidth();
                            const childLeft = child.getLeft();
                            const showing = this.getWidth() - childLeft;
                            const drawerPeekDistance = this.mRightDragger.getEdgeSize();
                            const alpha = Math.max(0, Math.min(showing / drawerPeekDistance, 1.));
                            this.mShadowRight.setBounds(childLeft - shadowWidth, child.getTop(), childLeft, child.getBottom());
                            this.mShadowRight.setAlpha(Math.floor((0xff * alpha)));
                            this.mShadowRight.draw(canvas);
                        }
                        return result;
                    }
                    isContentView(child) {
                        return child.getLayoutParams().gravity == Gravity.NO_GRAVITY;
                    }
                    isDrawerView(child) {
                        const gravity = child.getLayoutParams().gravity;
                        const absGravity = Gravity.getAbsoluteGravity(gravity, child.getLayoutDirection());
                        return (absGravity & (Gravity.LEFT | Gravity.RIGHT)) != 0;
                    }
                    onInterceptTouchEvent(ev) {
                        const action = ev.getActionMasked();
                        const leftIntercept = this.mLeftDragger.shouldInterceptTouchEvent(ev);
                        const rightIntercept = this.mRightDragger.shouldInterceptTouchEvent(ev);
                        const interceptForDrag = leftIntercept || rightIntercept;
                        let interceptForTap = false;
                        switch (action) {
                            case MotionEvent.ACTION_DOWN:
                                {
                                    const x = ev.getX();
                                    const y = ev.getY();
                                    this.mInitialMotionX = x;
                                    this.mInitialMotionY = y;
                                    if (this.mScrimOpacity > 0 && this.isContentView(this.mLeftDragger.findTopChildUnder(Math.floor(x), Math.floor(y)))) {
                                        interceptForTap = true;
                                    }
                                    this.mDisallowInterceptRequested = false;
                                    this.mChildrenCanceledTouch = false;
                                    break;
                                }
                            case MotionEvent.ACTION_MOVE:
                                {
                                    if (this.mLeftDragger.checkTouchSlop(ViewDragHelper.DIRECTION_ALL)) {
                                        this.mLeftCallback.removeCallbacks();
                                        this.mRightCallback.removeCallbacks();
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_CANCEL:
                            case MotionEvent.ACTION_UP:
                                {
                                    this.closeDrawers(true);
                                    this.mDisallowInterceptRequested = false;
                                    this.mChildrenCanceledTouch = false;
                                }
                        }
                        return interceptForDrag || interceptForTap || this.hasPeekingDrawer() || this.mChildrenCanceledTouch;
                    }
                    onTouchEvent(ev) {
                        this.mLeftDragger.processTouchEvent(ev);
                        this.mRightDragger.processTouchEvent(ev);
                        const action = ev.getAction();
                        let wantTouchEvents = true;
                        switch (action & MotionEvent.ACTION_MASK) {
                            case MotionEvent.ACTION_DOWN:
                                {
                                    const x = ev.getX();
                                    const y = ev.getY();
                                    this.mInitialMotionX = x;
                                    this.mInitialMotionY = y;
                                    this.mDisallowInterceptRequested = false;
                                    this.mChildrenCanceledTouch = false;
                                    break;
                                }
                            case MotionEvent.ACTION_UP:
                                {
                                    const x = ev.getX();
                                    const y = ev.getY();
                                    let peekingOnly = true;
                                    const touchedView = this.mLeftDragger.findTopChildUnder(Math.floor(x), Math.floor(y));
                                    if (touchedView != null && this.isContentView(touchedView)) {
                                        const dx = x - this.mInitialMotionX;
                                        const dy = y - this.mInitialMotionY;
                                        const slop = this.mLeftDragger.getTouchSlop();
                                        if (dx * dx + dy * dy < slop * slop) {
                                            const openDrawer = this.findOpenDrawer();
                                            if (openDrawer != null) {
                                                peekingOnly = this.getDrawerLockMode(openDrawer) == DrawerLayout.LOCK_MODE_LOCKED_OPEN;
                                            }
                                        }
                                    }
                                    this.closeDrawers(peekingOnly);
                                    this.mDisallowInterceptRequested = false;
                                    break;
                                }
                            case MotionEvent.ACTION_CANCEL:
                                {
                                    this.closeDrawers(true);
                                    this.mDisallowInterceptRequested = false;
                                    this.mChildrenCanceledTouch = false;
                                    break;
                                }
                        }
                        return wantTouchEvents;
                    }
                    requestDisallowInterceptTouchEvent(disallowIntercept) {
                        if (DrawerLayout.CHILDREN_DISALLOW_INTERCEPT || (!this.mLeftDragger.isEdgeTouched(ViewDragHelper.EDGE_LEFT) && !this.mRightDragger.isEdgeTouched(ViewDragHelper.EDGE_RIGHT))) {
                            super.requestDisallowInterceptTouchEvent(disallowIntercept);
                        }
                        this.mDisallowInterceptRequested = disallowIntercept;
                        if (disallowIntercept) {
                            this.closeDrawers(true);
                        }
                    }
                    closeDrawers(peekingOnly = false) {
                        let needsInvalidate = false;
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const child = this.getChildAt(i);
                            const lp = child.getLayoutParams();
                            if (!this.isDrawerView(child) || (peekingOnly && !lp.isPeeking)) {
                                continue;
                            }
                            const childWidth = child.getWidth();
                            if (this.checkDrawerViewAbsoluteGravity(child, Gravity.LEFT)) {
                                needsInvalidate = this.mLeftDragger.smoothSlideViewTo(child, -childWidth, child.getTop()) || needsInvalidate;
                            }
                            else {
                                needsInvalidate = this.mRightDragger.smoothSlideViewTo(child, this.getWidth(), child.getTop()) || needsInvalidate;
                            }
                            lp.isPeeking = false;
                        }
                        this.mLeftCallback.removeCallbacks();
                        this.mRightCallback.removeCallbacks();
                        if (needsInvalidate) {
                            this.invalidate();
                        }
                    }
                    openDrawer(arg) {
                        if (arg instanceof View) {
                            this._openDrawer_view(arg);
                        }
                        else {
                            this._openDrawer_gravity(arg);
                        }
                    }
                    _openDrawer_view(drawerView) {
                        if (!this.isDrawerView(drawerView)) {
                            throw Error(`new IllegalArgumentException("View " + drawerView + " is not a sliding drawer")`);
                        }
                        if (this.mFirstLayout) {
                            const lp = drawerView.getLayoutParams();
                            lp.onScreen = 1.;
                            lp.knownOpen = true;
                        }
                        else {
                            if (this.checkDrawerViewAbsoluteGravity(drawerView, Gravity.LEFT)) {
                                this.mLeftDragger.smoothSlideViewTo(drawerView, 0, drawerView.getTop());
                            }
                            else {
                                this.mRightDragger.smoothSlideViewTo(drawerView, this.getWidth() - drawerView.getWidth(), drawerView.getTop());
                            }
                        }
                        this.invalidate();
                    }
                    _openDrawer_gravity(gravity) {
                        const drawerView = this.findDrawerWithGravity(gravity);
                        if (drawerView == null) {
                            throw Error(`new IllegalArgumentException("No drawer view found with gravity " + DrawerLayout.gravityToString(gravity))`);
                        }
                        this.openDrawer(drawerView);
                    }
                    closeDrawer(arg) {
                        if (arg instanceof View) {
                            this._closeDrawer_view(arg);
                        }
                        else {
                            this._closeDrawer_gravity(arg);
                        }
                    }
                    _closeDrawer_view(drawerView) {
                        if (!this.isDrawerView(drawerView)) {
                            throw Error(`new IllegalArgumentException("View " + drawerView + " is not a sliding drawer")`);
                        }
                        if (this.mFirstLayout) {
                            const lp = drawerView.getLayoutParams();
                            lp.onScreen = 0.;
                            lp.knownOpen = false;
                        }
                        else {
                            if (this.checkDrawerViewAbsoluteGravity(drawerView, Gravity.LEFT)) {
                                this.mLeftDragger.smoothSlideViewTo(drawerView, -drawerView.getWidth(), drawerView.getTop());
                            }
                            else {
                                this.mRightDragger.smoothSlideViewTo(drawerView, this.getWidth(), drawerView.getTop());
                            }
                        }
                        this.invalidate();
                    }
                    _closeDrawer_gravity(gravity) {
                        const drawerView = this.findDrawerWithGravity(gravity);
                        if (drawerView == null) {
                            throw Error(`new IllegalArgumentException("No drawer view found with gravity " + DrawerLayout.gravityToString(gravity))`);
                        }
                        this.closeDrawer(drawerView);
                    }
                    isDrawerOpen(arg) {
                        if (arg instanceof View) {
                            return this._isDrawerOpen_view(arg);
                        }
                        else {
                            return this._isDrawerOpen_gravity(arg);
                        }
                    }
                    _isDrawerOpen_view(drawer) {
                        if (!this.isDrawerView(drawer)) {
                            throw Error(`new IllegalArgumentException("View " + drawer + " is not a drawer")`);
                        }
                        return drawer.getLayoutParams().knownOpen;
                    }
                    _isDrawerOpen_gravity(drawerGravity) {
                        const drawerView = this.findDrawerWithGravity(drawerGravity);
                        if (drawerView != null) {
                            return this.isDrawerOpen(drawerView);
                        }
                        return false;
                    }
                    isDrawerVisible(arg) {
                        if (arg instanceof View) {
                            return this._isDrawerVisible_view(arg);
                        }
                        else {
                            return this._isDrawerVisible_gravity(arg);
                        }
                    }
                    _isDrawerVisible_view(drawer) {
                        if (!this.isDrawerView(drawer)) {
                            throw Error(`new IllegalArgumentException("View " + drawer + " is not a drawer")`);
                        }
                        return drawer.getLayoutParams().onScreen > 0;
                    }
                    _isDrawerVisible_gravity(drawerGravity) {
                        const drawerView = this.findDrawerWithGravity(drawerGravity);
                        if (drawerView != null) {
                            return this.isDrawerVisible(drawerView);
                        }
                        return false;
                    }
                    hasPeekingDrawer() {
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const lp = this.getChildAt(i).getLayoutParams();
                            if (lp.isPeeking) {
                                return true;
                            }
                        }
                        return false;
                    }
                    generateDefaultLayoutParams() {
                        return new DrawerLayout.LayoutParams(DrawerLayout.LayoutParams.FILL_PARENT, DrawerLayout.LayoutParams.FILL_PARENT);
                    }
                    generateLayoutParams(p) {
                        return p instanceof DrawerLayout.LayoutParams ? new DrawerLayout.LayoutParams(p)
                            : p instanceof ViewGroup.MarginLayoutParams ? new DrawerLayout.LayoutParams(p)
                                : new DrawerLayout.LayoutParams(p);
                    }
                    checkLayoutParams(p) {
                        return p instanceof DrawerLayout.LayoutParams && super.checkLayoutParams(p);
                    }
                    hasVisibleDrawer() {
                        return this.findVisibleDrawer() != null;
                    }
                    findVisibleDrawer() {
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const child = this.getChildAt(i);
                            if (this.isDrawerView(child) && this.isDrawerVisible(child)) {
                                return child;
                            }
                        }
                        return null;
                    }
                    cancelChildViewTouch() {
                        if (!this.mChildrenCanceledTouch) {
                            const now = SystemClock.uptimeMillis();
                            const cancelEvent = MotionEvent.obtainWithAction(now, now, MotionEvent.ACTION_CANCEL, 0.0, 0.0, 0);
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                this.getChildAt(i).dispatchTouchEvent(cancelEvent);
                            }
                            cancelEvent.recycle();
                            this.mChildrenCanceledTouch = true;
                        }
                    }
                    onKeyDown(keyCode, event) {
                        if (keyCode == KeyEvent.KEYCODE_BACK && this.hasVisibleDrawer()) {
                            event.startTracking();
                            return true;
                        }
                        return super.onKeyDown(keyCode, event);
                    }
                    onKeyUp(keyCode, event) {
                        if (keyCode == KeyEvent.KEYCODE_BACK) {
                            const visibleDrawer = this.findVisibleDrawer();
                            if (visibleDrawer != null && this.getDrawerLockMode(visibleDrawer) == DrawerLayout.LOCK_MODE_UNLOCKED) {
                                this.closeDrawers();
                            }
                            return visibleDrawer != null;
                        }
                        return super.onKeyUp(keyCode, event);
                    }
                }
                DrawerLayout.TAG = "DrawerLayout";
                DrawerLayout.STATE_IDLE = ViewDragHelper.STATE_IDLE;
                DrawerLayout.STATE_DRAGGING = ViewDragHelper.STATE_DRAGGING;
                DrawerLayout.STATE_SETTLING = ViewDragHelper.STATE_SETTLING;
                DrawerLayout.LOCK_MODE_UNLOCKED = 0;
                DrawerLayout.LOCK_MODE_LOCKED_CLOSED = 1;
                DrawerLayout.LOCK_MODE_LOCKED_OPEN = 2;
                DrawerLayout.MIN_DRAWER_MARGIN = 64;
                DrawerLayout.DEFAULT_SCRIM_COLOR = 0x99000000;
                DrawerLayout.PEEK_DELAY = 160;
                DrawerLayout.MIN_FLING_VELOCITY = 400;
                DrawerLayout.ALLOW_EDGE_LOCK = false;
                DrawerLayout.CHILDREN_DISALLOW_INTERCEPT = true;
                DrawerLayout.TOUCH_SLOP_SENSITIVITY = 1.;
                widget.DrawerLayout = DrawerLayout;
                (function (DrawerLayout) {
                    class SimpleDrawerListener {
                        onDrawerSlide(drawerView, slideOffset) {
                        }
                        onDrawerOpened(drawerView) {
                        }
                        onDrawerClosed(drawerView) {
                        }
                        onDrawerStateChanged(newState) {
                        }
                    }
                    DrawerLayout.SimpleDrawerListener = SimpleDrawerListener;
                    class ViewDragCallback extends ViewDragHelper.Callback {
                        constructor(arg, gravity) {
                            super();
                            this.mAbsGravity = 0;
                            this.mPeekRunnable = (() => {
                                const _this = this;
                                class _Inner {
                                    run() {
                                        _this.peekDrawer();
                                    }
                                }
                                return new _Inner();
                            })();
                            this._DrawerLayout_this = arg;
                            this.mAbsGravity = gravity;
                        }
                        setDragger(dragger) {
                            this.mDragger = dragger;
                        }
                        removeCallbacks() {
                            this._DrawerLayout_this.removeCallbacks(this.mPeekRunnable);
                        }
                        tryCaptureView(child, pointerId) {
                            return this._DrawerLayout_this.isDrawerView(child) && this._DrawerLayout_this.checkDrawerViewAbsoluteGravity(child, this.mAbsGravity) && this._DrawerLayout_this.getDrawerLockMode(child) == DrawerLayout.LOCK_MODE_UNLOCKED;
                        }
                        onViewDragStateChanged(state) {
                            this._DrawerLayout_this.updateDrawerState(this.mAbsGravity, state, this.mDragger.getCapturedView());
                        }
                        onViewPositionChanged(changedView, left, top, dx, dy) {
                            let offset;
                            const childWidth = changedView.getWidth();
                            if (this._DrawerLayout_this.checkDrawerViewAbsoluteGravity(changedView, Gravity.LEFT)) {
                                offset = (childWidth + left) / childWidth;
                            }
                            else {
                                const width = this._DrawerLayout_this.getWidth();
                                offset = (width - left) / childWidth;
                            }
                            this._DrawerLayout_this.setDrawerViewOffset(changedView, offset);
                            changedView.setVisibility(offset == 0 ? DrawerLayout.INVISIBLE : DrawerLayout.VISIBLE);
                            this._DrawerLayout_this.invalidate();
                        }
                        onViewCaptured(capturedChild, activePointerId) {
                            const lp = capturedChild.getLayoutParams();
                            lp.isPeeking = false;
                            this.closeOtherDrawer();
                        }
                        closeOtherDrawer() {
                            const otherGrav = this.mAbsGravity == Gravity.LEFT ? Gravity.RIGHT : Gravity.LEFT;
                            const toClose = this._DrawerLayout_this.findDrawerWithGravity(otherGrav);
                            if (toClose != null) {
                                this._DrawerLayout_this.closeDrawer(toClose);
                            }
                        }
                        onViewReleased(releasedChild, xvel, yvel) {
                            const offset = this._DrawerLayout_this.getDrawerViewOffset(releasedChild);
                            const childWidth = releasedChild.getWidth();
                            let left;
                            if (this._DrawerLayout_this.checkDrawerViewAbsoluteGravity(releasedChild, Gravity.LEFT)) {
                                left = xvel > 0 || xvel == 0 && offset > 0.5 ? 0 : -childWidth;
                            }
                            else {
                                const width = this._DrawerLayout_this.getWidth();
                                left = xvel < 0 || xvel == 0 && offset > 0.5 ? width - childWidth : width;
                            }
                            this.mDragger.settleCapturedViewAt(left, releasedChild.getTop());
                            this._DrawerLayout_this.invalidate();
                        }
                        onEdgeTouched(edgeFlags, pointerId) {
                            this._DrawerLayout_this.postDelayed(this.mPeekRunnable, DrawerLayout.PEEK_DELAY);
                        }
                        peekDrawer() {
                            let toCapture;
                            let childLeft;
                            const peekDistance = this.mDragger.getEdgeSize();
                            const leftEdge = this.mAbsGravity == Gravity.LEFT;
                            if (leftEdge) {
                                toCapture = this._DrawerLayout_this.findDrawerWithGravity(Gravity.LEFT);
                                childLeft = (toCapture != null ? -toCapture.getWidth() : 0) + peekDistance;
                            }
                            else {
                                toCapture = this._DrawerLayout_this.findDrawerWithGravity(Gravity.RIGHT);
                                childLeft = this._DrawerLayout_this.getWidth() - peekDistance;
                            }
                            if (toCapture != null && ((leftEdge && toCapture.getLeft() < childLeft) || (!leftEdge && toCapture.getLeft() > childLeft)) && this._DrawerLayout_this.getDrawerLockMode(toCapture) == DrawerLayout.LOCK_MODE_UNLOCKED) {
                                const lp = toCapture.getLayoutParams();
                                this.mDragger.smoothSlideViewTo(toCapture, childLeft, toCapture.getTop());
                                lp.isPeeking = true;
                                this._DrawerLayout_this.invalidate();
                                this.closeOtherDrawer();
                                this._DrawerLayout_this.cancelChildViewTouch();
                            }
                        }
                        onEdgeLock(edgeFlags) {
                            if (DrawerLayout.ALLOW_EDGE_LOCK) {
                                const drawer = this._DrawerLayout_this.findDrawerWithGravity(this.mAbsGravity);
                                if (drawer != null && !this._DrawerLayout_this.isDrawerOpen(drawer)) {
                                    this._DrawerLayout_this.closeDrawer(drawer);
                                }
                                return true;
                            }
                            return false;
                        }
                        onEdgeDragStarted(edgeFlags, pointerId) {
                            let toCapture;
                            if ((edgeFlags & ViewDragHelper.EDGE_LEFT) == ViewDragHelper.EDGE_LEFT) {
                                toCapture = this._DrawerLayout_this.findDrawerWithGravity(Gravity.LEFT);
                            }
                            else {
                                toCapture = this._DrawerLayout_this.findDrawerWithGravity(Gravity.RIGHT);
                            }
                            if (toCapture != null && this._DrawerLayout_this.getDrawerLockMode(toCapture) == DrawerLayout.LOCK_MODE_UNLOCKED) {
                                this.mDragger.captureChildView(toCapture, pointerId);
                            }
                        }
                        getViewHorizontalDragRange(child) {
                            return child.getWidth();
                        }
                        clampViewPositionHorizontal(child, left, dx) {
                            if (this._DrawerLayout_this.checkDrawerViewAbsoluteGravity(child, Gravity.LEFT)) {
                                return Math.max(-child.getWidth(), Math.min(left, 0));
                            }
                            else {
                                const width = this._DrawerLayout_this.getWidth();
                                return Math.max(width - child.getWidth(), Math.min(left, width));
                            }
                        }
                        clampViewPositionVertical(child, top, dy) {
                            return child.getTop();
                        }
                    }
                    DrawerLayout.ViewDragCallback = ViewDragCallback;
                    class LayoutParams extends ViewGroup.MarginLayoutParams {
                        constructor(...args) {
                            super(...(args.length == 3 ? [args[0], args[1]] : args));
                            this.gravity = Gravity.NO_GRAVITY;
                            this.onScreen = 0;
                            this._attrBinder.addAttr('gravity', (value) => {
                                this.gravity = this._attrBinder.parseGravity(value, this.gravity);
                            });
                        }
                    }
                    DrawerLayout.LayoutParams = LayoutParams;
                })(DrawerLayout = widget.DrawerLayout || (widget.DrawerLayout = {}));
            })(widget = v4.widget || (v4.widget = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/6.
 */
///<reference path="../../../../android/view/View.ts"/>
///<reference path="../../../../android/view/ViewGroup.ts"/>
///<reference path="../../../../android/support/v4/view/ViewPager.ts"/>
///<reference path="../../../../android/support/v4/view/PagerAdapter.ts"/>
var com;
(function (com) {
    var jakewharton;
    (function (jakewharton) {
        var salvage;
        (function (salvage) {
            var SparseArray = android.util.SparseArray;
            var PagerAdapter = android.support.v4.view.PagerAdapter;
            class RecyclingPagerAdapter extends PagerAdapter {
                constructor() {
                    super();
                    this.recycleBin = new RecycleBin();
                    this.recycleBin.setViewTypeCount(this.getViewTypeCount());
                }
                notifyDataSetChanged() {
                    this.recycleBin.scrapActiveViews();
                    super.notifyDataSetChanged();
                }
                instantiateItem(container, position) {
                    let viewType = this.getItemViewType(position);
                    let view = null;
                    if (viewType != RecyclingPagerAdapter.IGNORE_ITEM_VIEW_TYPE) {
                        view = this.recycleBin.getScrapView(position, viewType);
                    }
                    view = this.getView(position, view, container);
                    container.addView(view);
                    return view;
                }
                destroyItem(container, position, object) {
                    let view = object;
                    container.removeView(view);
                    let viewType = this.getItemViewType(position);
                    if (viewType != RecyclingPagerAdapter.IGNORE_ITEM_VIEW_TYPE) {
                        this.recycleBin.addScrapView(view, position, viewType);
                    }
                }
                isViewFromObject(view, object) {
                    return view === object;
                }
                getViewTypeCount() {
                    return 1;
                }
                getItemViewType(position) {
                    return 0;
                }
            }
            RecyclingPagerAdapter.IGNORE_ITEM_VIEW_TYPE = -1;
            salvage.RecyclingPagerAdapter = RecyclingPagerAdapter;
            class RecycleBin {
                constructor() {
                    this.activeViews = [];
                    this.activeViewTypes = [];
                    this.viewTypeCount = 0;
                }
                setViewTypeCount(viewTypeCount) {
                    if (viewTypeCount < 1) {
                        throw new Error("Can't have a viewTypeCount < 1");
                    }
                    let scrapViews = new Array(viewTypeCount);
                    for (let i = 0; i < viewTypeCount; i++) {
                        scrapViews[i] = new SparseArray();
                    }
                    this.viewTypeCount = viewTypeCount;
                    this.currentScrapViews = scrapViews[0];
                    this.scrapViews = scrapViews;
                }
                shouldRecycleViewType(viewType) {
                    return viewType >= 0;
                }
                getScrapView(position, viewType) {
                    if (this.viewTypeCount == 1) {
                        return this.retrieveFromScrap(this.currentScrapViews, position);
                    }
                    else if (viewType >= 0 && viewType < this.scrapViews.length) {
                        return this.retrieveFromScrap(this.scrapViews[viewType], position);
                    }
                    return null;
                }
                addScrapView(scrap, position, viewType) {
                    if (this.viewTypeCount == 1) {
                        this.currentScrapViews.put(position, scrap);
                    }
                    else {
                        this.scrapViews[viewType].put(position, scrap);
                    }
                }
                scrapActiveViews() {
                    const activeViews = this.activeViews;
                    const activeViewTypes = this.activeViewTypes;
                    const multipleScraps = this.viewTypeCount > 1;
                    let scrapViews = this.currentScrapViews;
                    const count = activeViews.length;
                    for (let i = count - 1; i >= 0; i--) {
                        const victim = activeViews[i];
                        if (victim != null) {
                            let whichScrap = activeViewTypes[i];
                            activeViews[i] = null;
                            activeViewTypes[i] = -1;
                            if (!this.shouldRecycleViewType(whichScrap)) {
                                continue;
                            }
                            if (multipleScraps) {
                                scrapViews = this.scrapViews[whichScrap];
                            }
                            scrapViews.put(i, victim);
                        }
                    }
                    this.pruneScrapViews();
                }
                pruneScrapViews() {
                    const maxViews = this.activeViews.length;
                    const viewTypeCount = this.viewTypeCount;
                    const scrapViews = this.scrapViews;
                    for (let i = 0; i < viewTypeCount; ++i) {
                        const scrapPile = scrapViews[i];
                        let size = scrapPile.size();
                        const extras = size - maxViews;
                        size--;
                        for (let j = 0; j < extras; j++) {
                            scrapPile.remove(scrapPile.keyAt(size--));
                        }
                    }
                }
                retrieveFromScrap(scrapViews, position) {
                    let size = scrapViews.size();
                    if (size > 0) {
                        for (let i = 0; i < size; i++) {
                            let fromPosition = scrapViews.keyAt(i);
                            let view = scrapViews.get(fromPosition);
                            if (fromPosition == position) {
                                scrapViews.remove(fromPosition);
                                return view;
                            }
                        }
                        let index = size - 1;
                        let r = scrapViews.valueAt(index);
                        scrapViews.remove(scrapViews.keyAt(index));
                        return r;
                    }
                    else {
                        return null;
                    }
                }
            }
        })(salvage = jakewharton.salvage || (jakewharton.salvage = {}));
    })(jakewharton = com.jakewharton || (com.jakewharton = {}));
})(com || (com = {}));
/*******************************************************************************
 * Copyright 2011, 2012 Chris Banes.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
///<reference path="../../../../../android/util/Log.ts"/>
///<reference path="../../../../../android/view/MotionEvent.ts"/>
///<reference path="../../../../../android/view/ScaleGestureDetector.ts"/>
///<reference path="../../../../../android/view/VelocityTracker.ts"/>
///<reference path="../../../../../android/view/ViewConfiguration.ts"/>
///<reference path="../../../../../java/lang/Float.ts"/>
var uk;
(function (uk) {
    var co;
    (function (co) {
        var senab;
        (function (senab) {
            var photoview;
            (function (photoview) {
                var Log = android.util.Log;
                var MotionEvent = android.view.MotionEvent;
                var ScaleGestureDetector = android.view.ScaleGestureDetector;
                var VelocityTracker = android.view.VelocityTracker;
                var ViewConfiguration = android.view.ViewConfiguration;
                class GestureDetector {
                    constructor() {
                        this.mActivePointerId = GestureDetector.INVALID_POINTER_ID;
                        this.mActivePointerIndex = 0;
                        this.mLastTouchX = 0;
                        this.mLastTouchY = 0;
                        this.mTouchSlop = 0;
                        this.mMinimumVelocity = 0;
                        const configuration = ViewConfiguration.get();
                        this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                        this.mTouchSlop = configuration.getScaledTouchSlop();
                        const _this = this;
                        let scaleListener = {
                            onScale(detector) {
                                let scaleFactor = detector.getScaleFactor();
                                if (Number.isNaN(scaleFactor) || !Number.isFinite(scaleFactor))
                                    return false;
                                _this.mListener.onScale(scaleFactor, detector.getFocusX(), detector.getFocusY());
                                return true;
                            },
                            onScaleBegin(detector) {
                                return true;
                            },
                            onScaleEnd(detector) {
                            }
                        };
                        this.mScaleDetector = new ScaleGestureDetector(scaleListener);
                    }
                    setOnGestureListener(listener) {
                        this.mListener = listener;
                    }
                    getActiveX(ev) {
                        return ev.getX(this.mActivePointerIndex < 0 ? 0 : this.mActivePointerIndex);
                    }
                    getActiveY(ev) {
                        return ev.getY(this.mActivePointerIndex < 0 ? 0 : this.mActivePointerIndex);
                    }
                    isScaling() {
                        return this.mScaleDetector.isInProgress();
                    }
                    isDragging() {
                        return this.mIsDragging;
                    }
                    onTouchEvent(ev) {
                        this.mScaleDetector.onTouchEvent(ev);
                        const action = ev.getAction();
                        switch (action & MotionEvent.ACTION_MASK) {
                            case MotionEvent.ACTION_DOWN:
                                this.mActivePointerId = ev.getPointerId(0);
                                break;
                            case MotionEvent.ACTION_CANCEL:
                            case MotionEvent.ACTION_UP:
                                this.mActivePointerId = GestureDetector.INVALID_POINTER_ID;
                                break;
                            case MotionEvent.ACTION_POINTER_UP:
                                const pointerIndex = ev.getActionIndex();
                                const pointerId = ev.getPointerId(pointerIndex);
                                if (pointerId == this.mActivePointerId) {
                                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                                    this.mLastTouchX = ev.getX(newPointerIndex);
                                    this.mLastTouchY = ev.getY(newPointerIndex);
                                }
                                break;
                        }
                        this.mActivePointerIndex = ev.findPointerIndex(this.mActivePointerId != GestureDetector.INVALID_POINTER_ID ? this.mActivePointerId : 0);
                        switch (ev.getAction()) {
                            case MotionEvent.ACTION_DOWN:
                                {
                                    this.mVelocityTracker = VelocityTracker.obtain();
                                    if (null != this.mVelocityTracker) {
                                        this.mVelocityTracker.addMovement(ev);
                                    }
                                    else {
                                        Log.i(GestureDetector.LOG_TAG, "Velocity tracker is null");
                                    }
                                    this.mLastTouchX = this.getActiveX(ev);
                                    this.mLastTouchY = this.getActiveY(ev);
                                    this.mIsDragging = false;
                                    break;
                                }
                            case MotionEvent.ACTION_MOVE:
                                {
                                    const x = this.getActiveX(ev);
                                    const y = this.getActiveY(ev);
                                    const dx = x - this.mLastTouchX, dy = y - this.mLastTouchY;
                                    if (!this.mIsDragging) {
                                        this.mIsDragging = Math.sqrt((dx * dx) + (dy * dy)) >= this.mTouchSlop;
                                    }
                                    if (this.mIsDragging) {
                                        this.mListener.onDrag(dx, dy);
                                        this.mLastTouchX = x;
                                        this.mLastTouchY = y;
                                        if (null != this.mVelocityTracker) {
                                            this.mVelocityTracker.addMovement(ev);
                                        }
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_CANCEL:
                                {
                                    if (null != this.mVelocityTracker) {
                                        this.mVelocityTracker.recycle();
                                        this.mVelocityTracker = null;
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_UP:
                                {
                                    if (this.mIsDragging) {
                                        if (null != this.mVelocityTracker) {
                                            this.mLastTouchX = this.getActiveX(ev);
                                            this.mLastTouchY = this.getActiveY(ev);
                                            this.mVelocityTracker.addMovement(ev);
                                            this.mVelocityTracker.computeCurrentVelocity(1000);
                                            const vX = this.mVelocityTracker.getXVelocity(), vY = this.mVelocityTracker.getYVelocity();
                                            if (Math.max(Math.abs(vX), Math.abs(vY)) >= this.mMinimumVelocity) {
                                                this.mListener.onFling(this.mLastTouchX, this.mLastTouchY, -vX, -vY);
                                            }
                                        }
                                    }
                                    if (null != this.mVelocityTracker) {
                                        this.mVelocityTracker.recycle();
                                        this.mVelocityTracker = null;
                                    }
                                    break;
                                }
                        }
                        return true;
                    }
                }
                GestureDetector.LOG_TAG = "CupcakeGestureDetector";
                GestureDetector.INVALID_POINTER_ID = -1;
                photoview.GestureDetector = GestureDetector;
            })(photoview = senab.photoview || (senab.photoview = {}));
        })(senab = co.senab || (co.senab = {}));
    })(co = uk.co || (uk.co = {}));
})(uk || (uk = {}));
/*******************************************************************************
 * Copyright 2011, 2012 Chris Banes.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
///<reference path="../../../../../android/graphics/Matrix.ts"/>
///<reference path="../../../../../android/graphics/Canvas.ts"/>
///<reference path="../../../../../android/graphics/RectF.ts"/>
///<reference path="../../../../../android/view/GestureDetector.ts"/>
///<reference path="../../../../../android/view/View.ts"/>
///<reference path="../../../../../android/widget/ImageView.ts"/>
///<reference path="../../../../uk/co/senab/photoview/GestureDetector.ts"/>
///<reference path="../../../../uk/co/senab/photoview/PhotoView.ts"/>
///<reference path="../../../../uk/co/senab/photoview/PhotoViewAttacher.ts"/>
var uk;
(function (uk) {
    var co;
    (function (co) {
        var senab;
        (function (senab) {
            var photoview;
            (function (photoview) {
                var IPhotoView;
                (function (IPhotoView) {
                    IPhotoView.DEFAULT_MAX_SCALE = 3.0;
                    IPhotoView.DEFAULT_MID_SCALE = 1.75;
                    IPhotoView.DEFAULT_MIN_SCALE = 1.0;
                    IPhotoView.DEFAULT_ZOOM_DURATION = 200;
                    function isImpl(obj) {
                        if (!obj)
                            return false;
                        return obj['canZoom'] &&
                            obj['getDisplayRect'] &&
                            obj['setDisplayMatrix'] &&
                            obj['getDisplayMatrix'] &&
                            obj['getMinScale'] &&
                            obj['getMinimumScale'] &&
                            obj['getMidScale'] &&
                            obj['getMediumScale'] &&
                            obj['getMaxScale'] &&
                            obj['getMaximumScale'] &&
                            obj['getScale'] &&
                            obj['getScaleType'] &&
                            obj['setAllowParentInterceptOnEdge'] &&
                            obj['setMinScale'] &&
                            obj['setMinimumScale'] &&
                            obj['setMidScale'] &&
                            obj['setMediumScale'] &&
                            obj['setMaxScale'] &&
                            obj['setMaximumScale'] &&
                            obj['setScaleLevels'] &&
                            obj['setOnLongClickListener'] &&
                            obj['setOnMatrixChangeListener'] &&
                            obj['setOnPhotoTapListener'] &&
                            obj['getOnPhotoTapListener'] &&
                            obj['setOnViewTapListener'] &&
                            obj['setRotationTo'] &&
                            obj['setRotationBy'] &&
                            obj['getOnViewTapListener'] &&
                            obj['setScale'] &&
                            obj['setScale'] &&
                            obj['setScale'] &&
                            obj['setScaleType'] &&
                            obj['setZoomable'] &&
                            obj['setPhotoViewRotation'] &&
                            obj['getVisibleRectangleBitmap'] &&
                            obj['setZoomTransitionDuration'] &&
                            obj['getIPhotoViewImplementation'] &&
                            obj['setOnDoubleTapListener'] &&
                            obj['setOnScaleChangeListener'];
                    }
                    IPhotoView.isImpl = isImpl;
                })(IPhotoView = photoview.IPhotoView || (photoview.IPhotoView = {}));
            })(photoview = senab.photoview || (senab.photoview = {}));
        })(senab = co.senab || (co.senab = {}));
    })(co = uk.co || (uk.co = {}));
})(uk || (uk = {}));
/*******************************************************************************
 * Copyright 2011, 2012 Chris Banes.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
///<reference path="../../../../../android/graphics/Canvas.ts"/>
///<reference path="../../../../../android/graphics/Matrix.ts"/>
///<reference path="../../../../../android/graphics/RectF.ts"/>
///<reference path="../../../../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../../../../android/util/Log.ts"/>
///<reference path="../../../../../android/view/MotionEvent.ts"/>
///<reference path="../../../../../android/view/View.ts"/>
///<reference path="../../../../../android/view/ViewParent.ts"/>
///<reference path="../../../../../android/view/ViewTreeObserver.ts"/>
///<reference path="../../../../../android/view/animation/AccelerateDecelerateInterpolator.ts"/>
///<reference path="../../../../../android/view/animation/Interpolator.ts"/>
///<reference path="../../../../../android/widget/ImageView.ts"/>
///<reference path="../../../../../android/widget/OverScroller.ts"/>
///<reference path="../../../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../../../../java/lang/Runnable.ts"/>
///<reference path="../../../../../java/lang/System.ts"/>
///<reference path="../../../../uk/co/senab/photoview/GestureDetector.ts"/>
///<reference path="../../../../uk/co/senab/photoview/IPhotoView.ts"/>
///<reference path="../../../../uk/co/senab/photoview/PhotoView.ts"/>
var uk;
(function (uk) {
    var co;
    (function (co) {
        var senab;
        (function (senab) {
            var photoview;
            (function (photoview) {
                var Matrix = android.graphics.Matrix;
                var ScaleToFit = android.graphics.Matrix.ScaleToFit;
                var RectF = android.graphics.RectF;
                var Log = android.util.Log;
                var AccelerateDecelerateInterpolator = android.view.animation.AccelerateDecelerateInterpolator;
                var ScaleType = android.widget.ImageView.ScaleType;
                var OverScroller = android.widget.OverScroller;
                var WeakReference = java.lang.ref.WeakReference;
                var MotionEvent = android.view.MotionEvent;
                const ACTION_CANCEL = MotionEvent.ACTION_CANCEL;
                const ACTION_DOWN = MotionEvent.ACTION_DOWN;
                const ACTION_UP = MotionEvent.ACTION_UP;
                var System = java.lang.System;
                var GestureDetector = uk.co.senab.photoview.GestureDetector;
                var IPhotoView = uk.co.senab.photoview.IPhotoView;
                class PhotoViewAttacher {
                    constructor(imageView, zoomable = true) {
                        this.ZOOM_DURATION = IPhotoView.DEFAULT_ZOOM_DURATION;
                        this.mMinScale = IPhotoView.DEFAULT_MIN_SCALE;
                        this.mMidScale = IPhotoView.DEFAULT_MID_SCALE;
                        this.mMaxScale = IPhotoView.DEFAULT_MAX_SCALE;
                        this.mAllowParentInterceptOnEdge = true;
                        this.mBlockParentIntercept = false;
                        this.mBaseMatrix = new Matrix();
                        this.mDrawMatrix = new Matrix();
                        this.mSuppMatrix = new Matrix();
                        this.mDisplayRect = new RectF();
                        this.mMatrixValues = new Array(9);
                        this.mIvTop = 0;
                        this.mIvRight = 0;
                        this.mIvBottom = 0;
                        this.mIvLeft = 0;
                        this.mScrollEdge = PhotoViewAttacher.EDGE_BOTH;
                        this.mScaleType = ScaleType.FIT_CENTER;
                        this.mImageView = new WeakReference(imageView);
                        imageView.setOnTouchListener(this);
                        let observer = imageView.getViewTreeObserver();
                        if (null != observer)
                            observer.addOnGlobalLayoutListener(this);
                        PhotoViewAttacher.setImageViewScaleTypeMatrix(imageView);
                        this.mScaleDragDetector = new GestureDetector();
                        this.mScaleDragDetector.setOnGestureListener(this);
                        this.mGestureDetector = new android.view.GestureDetector((() => {
                            const _this = this;
                            class _Inner extends android.view.GestureDetector.SimpleOnGestureListener {
                                onLongPress(e) {
                                    if (null != _this.mLongClickListener) {
                                        _this.mLongClickListener.onLongClick(_this.getImageView());
                                    }
                                }
                            }
                            return new _Inner();
                        })());
                        this.mGestureDetector.setOnDoubleTapListener(new PhotoViewAttacher.DefaultOnDoubleTapListener(this));
                        this.setZoomable(zoomable);
                    }
                    static checkZoomLevels(minZoom, midZoom, maxZoom) {
                        if (minZoom >= midZoom) {
                            throw Error(`new IllegalArgumentException("MinZoom has to be less than MidZoom")`);
                        }
                        else if (midZoom >= maxZoom) {
                            throw Error(`new IllegalArgumentException("MidZoom has to be less than MaxZoom")`);
                        }
                    }
                    static hasDrawable(imageView) {
                        return null != imageView && null != imageView.getDrawable();
                    }
                    static isSupportedScaleType(scaleType) {
                        if (null == scaleType) {
                            return false;
                        }
                        switch (scaleType) {
                            case ScaleType.MATRIX:
                                throw Error(`new IllegalArgumentException(ScaleType.MATRIX is not supported in PhotoView)`);
                            default:
                                return true;
                        }
                    }
                    static setImageViewScaleTypeMatrix(imageView) {
                        if (null != imageView && !(IPhotoView.isImpl(imageView))) {
                            if (ScaleType.MATRIX != (imageView.getScaleType())) {
                                imageView.setScaleType(ScaleType.MATRIX);
                            }
                        }
                    }
                    setOnDoubleTapListener(newOnDoubleTapListener) {
                        if (newOnDoubleTapListener != null) {
                            this.mGestureDetector.setOnDoubleTapListener(newOnDoubleTapListener);
                        }
                        else {
                            this.mGestureDetector.setOnDoubleTapListener(new PhotoViewAttacher.DefaultOnDoubleTapListener(this));
                        }
                    }
                    setOnScaleChangeListener(onScaleChangeListener) {
                        this.mScaleChangeListener = onScaleChangeListener;
                    }
                    canZoom() {
                        return this.mZoomEnabled;
                    }
                    cleanup() {
                        if (null == this.mImageView) {
                            return;
                        }
                        const imageView = this.mImageView.get();
                        if (null != imageView) {
                            let observer = imageView.getViewTreeObserver();
                            if (null != observer && observer.isAlive()) {
                                observer.removeGlobalOnLayoutListener(this);
                            }
                            imageView.setOnTouchListener(null);
                            this.cancelFling();
                        }
                        if (null != this.mGestureDetector) {
                            this.mGestureDetector.setOnDoubleTapListener(null);
                        }
                        this.mMatrixChangeListener = null;
                        this.mPhotoTapListener = null;
                        this.mViewTapListener = null;
                        this.mImageView = null;
                    }
                    getDisplayRect() {
                        this.checkMatrixBounds();
                        return this._getDisplayRect(this.getDrawMatrix());
                    }
                    setDisplayMatrix(finalMatrix) {
                        if (finalMatrix == null)
                            throw Error(`new IllegalArgumentException("Matrix cannot be null")`);
                        let imageView = this.getImageView();
                        if (null == imageView)
                            return false;
                        if (null == imageView.getDrawable())
                            return false;
                        this.mSuppMatrix.set(finalMatrix);
                        this.setImageViewMatrix(this.getDrawMatrix());
                        this.checkMatrixBounds();
                        return true;
                    }
                    setPhotoViewRotation(degrees) {
                        this.mSuppMatrix.setRotate(degrees % 360);
                        this.checkAndDisplayMatrix();
                    }
                    setRotationTo(degrees) {
                        this.mSuppMatrix.setRotate(degrees % 360);
                        this.checkAndDisplayMatrix();
                    }
                    setRotationBy(degrees) {
                        this.mSuppMatrix.postRotate(degrees % 360);
                        this.checkAndDisplayMatrix();
                    }
                    getImageView() {
                        let imageView = null;
                        if (null != this.mImageView) {
                            imageView = this.mImageView.get();
                        }
                        if (null == imageView) {
                            this.cleanup();
                            if (PhotoViewAttacher.DEBUG)
                                Log.i(PhotoViewAttacher.LOG_TAG, "ImageView no longer exists. You should not use this PhotoViewAttacher any more.");
                        }
                        return imageView;
                    }
                    getMinScale() {
                        return this.getMinimumScale();
                    }
                    getMinimumScale() {
                        return this.mMinScale;
                    }
                    getMidScale() {
                        return this.getMediumScale();
                    }
                    getMediumScale() {
                        return this.mMidScale;
                    }
                    getMaxScale() {
                        return this.getMaximumScale();
                    }
                    getMaximumScale() {
                        return this.mMaxScale;
                    }
                    getScale() {
                        return Math.sqrt(Math.pow(this.getValue(this.mSuppMatrix, Matrix.MSCALE_X), 2) + Math.pow(this.getValue(this.mSuppMatrix, Matrix.MSKEW_Y), 2));
                    }
                    getScaleType() {
                        return this.mScaleType;
                    }
                    onDrag(dx, dy) {
                        if (this.mScaleDragDetector.isScaling()) {
                            return;
                        }
                        if (PhotoViewAttacher.DEBUG) {
                            Log.d(PhotoViewAttacher.LOG_TAG, `onDrag: dx: ${dx.toFixed(2)}. dy: ${dy.toFixed(2)}`);
                        }
                        let imageView = this.getImageView();
                        this.mSuppMatrix.postTranslate(dx, dy);
                        this.checkAndDisplayMatrix();
                        let parent = imageView.getParent();
                        if (this.mAllowParentInterceptOnEdge && !this.mScaleDragDetector.isScaling() && !this.mBlockParentIntercept) {
                            if (this.mScrollEdge == PhotoViewAttacher.EDGE_BOTH || (this.mScrollEdge == PhotoViewAttacher.EDGE_LEFT && dx >= 1) || (this.mScrollEdge == PhotoViewAttacher.EDGE_RIGHT && dx <= -1)) {
                                if (null != parent)
                                    parent.requestDisallowInterceptTouchEvent(false);
                            }
                        }
                        else {
                            if (null != parent) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                        }
                    }
                    onFling(startX, startY, velocityX, velocityY) {
                        if (PhotoViewAttacher.DEBUG) {
                            Log.d(PhotoViewAttacher.LOG_TAG, "onFling. sX: " + startX + " sY: " + startY + " Vx: " + velocityX + " Vy: " + velocityY);
                        }
                        let imageView = this.getImageView();
                        this.mCurrentFlingRunnable = new PhotoViewAttacher.FlingRunnable(this);
                        this.mCurrentFlingRunnable.fling(this.getImageViewWidth(imageView), this.getImageViewHeight(imageView), Math.floor(velocityX), Math.floor(velocityY));
                        imageView.post(this.mCurrentFlingRunnable);
                    }
                    onGlobalLayout() {
                        let imageView = this.getImageView();
                        if (null != imageView) {
                            if (this.mZoomEnabled) {
                                const top = imageView.getTop();
                                const right = imageView.getRight();
                                const bottom = imageView.getBottom();
                                const left = imageView.getLeft();
                                if (top != this.mIvTop || bottom != this.mIvBottom || left != this.mIvLeft || right != this.mIvRight) {
                                    this.updateBaseMatrix(imageView.getDrawable());
                                    this.mIvTop = top;
                                    this.mIvRight = right;
                                    this.mIvBottom = bottom;
                                    this.mIvLeft = left;
                                }
                            }
                            else {
                                this.updateBaseMatrix(imageView.getDrawable());
                            }
                        }
                    }
                    onScale(scaleFactor, focusX, focusY) {
                        if (PhotoViewAttacher.DEBUG) {
                            Log.d(PhotoViewAttacher.LOG_TAG, `onScale: scale: ${scaleFactor.toFixed(2)}. fX: ${focusX.toFixed(2)}. fY: ${focusY.toFixed(2)}f`);
                        }
                        if (this.getScale() < this.mMaxScale || scaleFactor < 1) {
                            if (null != this.mScaleChangeListener) {
                                this.mScaleChangeListener.onScaleChange(scaleFactor, focusX, focusY);
                            }
                            this.mSuppMatrix.postScale(scaleFactor, scaleFactor, focusX, focusY);
                            this.checkAndDisplayMatrix();
                        }
                    }
                    onTouch(v, ev) {
                        let handled = false;
                        if (this.mZoomEnabled && PhotoViewAttacher.hasDrawable(v)) {
                            let parent = v.getParent();
                            switch (ev.getAction()) {
                                case ACTION_DOWN:
                                    if (null != parent) {
                                        parent.requestDisallowInterceptTouchEvent(true);
                                    }
                                    else {
                                        Log.i(PhotoViewAttacher.LOG_TAG, "onTouch getParent() returned null");
                                    }
                                    this.cancelFling();
                                    break;
                                case ACTION_CANCEL:
                                case ACTION_UP:
                                    if (this.getScale() < this.mMinScale) {
                                        let rect = this.getDisplayRect();
                                        if (null != rect) {
                                            v.post(new PhotoViewAttacher.AnimatedZoomRunnable(this, this.getScale(), this.mMinScale, rect.centerX(), rect.centerY()));
                                            handled = true;
                                        }
                                    }
                                    break;
                            }
                            if (null != this.mScaleDragDetector) {
                                let wasScaling = this.mScaleDragDetector.isScaling();
                                let wasDragging = this.mScaleDragDetector.isDragging();
                                handled = this.mScaleDragDetector.onTouchEvent(ev);
                                let didntScale = !wasScaling && !this.mScaleDragDetector.isScaling();
                                let didntDrag = !wasDragging && !this.mScaleDragDetector.isDragging();
                                this.mBlockParentIntercept = didntScale && didntDrag;
                            }
                            if (null != this.mGestureDetector && this.mGestureDetector.onTouchEvent(ev)) {
                                handled = true;
                            }
                        }
                        return handled;
                    }
                    setAllowParentInterceptOnEdge(allow) {
                        this.mAllowParentInterceptOnEdge = allow;
                    }
                    setMinScale(minScale) {
                        this.setMinimumScale(minScale);
                    }
                    setMinimumScale(minimumScale) {
                        PhotoViewAttacher.checkZoomLevels(minimumScale, this.mMidScale, this.mMaxScale);
                        this.mMinScale = minimumScale;
                    }
                    setMidScale(midScale) {
                        this.setMediumScale(midScale);
                    }
                    setMediumScale(mediumScale) {
                        PhotoViewAttacher.checkZoomLevels(this.mMinScale, mediumScale, this.mMaxScale);
                        this.mMidScale = mediumScale;
                    }
                    setMaxScale(maxScale) {
                        this.setMaximumScale(maxScale);
                    }
                    setMaximumScale(maximumScale) {
                        PhotoViewAttacher.checkZoomLevels(this.mMinScale, this.mMidScale, maximumScale);
                        this.mMaxScale = maximumScale;
                    }
                    setScaleLevels(minimumScale, mediumScale, maximumScale) {
                        PhotoViewAttacher.checkZoomLevels(minimumScale, mediumScale, maximumScale);
                        this.mMinScale = minimumScale;
                        this.mMidScale = mediumScale;
                        this.mMaxScale = maximumScale;
                    }
                    setOnLongClickListener(listener) {
                        this.mLongClickListener = listener;
                    }
                    setOnMatrixChangeListener(listener) {
                        this.mMatrixChangeListener = listener;
                    }
                    setOnPhotoTapListener(listener) {
                        this.mPhotoTapListener = listener;
                    }
                    getOnPhotoTapListener() {
                        return this.mPhotoTapListener;
                    }
                    setOnViewTapListener(listener) {
                        this.mViewTapListener = listener;
                    }
                    getOnViewTapListener() {
                        return this.mViewTapListener;
                    }
                    setScale(...args) {
                        if (args.length >= 3) {
                            this.setScale_4(...args);
                        }
                        else {
                            this.setScale_2(...args);
                        }
                    }
                    setScale_2(scale, animate = false) {
                        let imageView = this.getImageView();
                        if (null != imageView) {
                            this.setScale(scale, (imageView.getRight()) / 2, (imageView.getBottom()) / 2, animate);
                        }
                    }
                    setScale_4(scale, focalX, focalY, animate = false) {
                        let imageView = this.getImageView();
                        if (null != imageView) {
                            if (scale < this.mMinScale || scale > this.mMaxScale) {
                                Log.i(PhotoViewAttacher.LOG_TAG, "Scale must be within the range of minScale and maxScale");
                                return;
                            }
                            if (animate) {
                                imageView.post(new PhotoViewAttacher.AnimatedZoomRunnable(this, this.getScale(), scale, focalX, focalY));
                            }
                            else {
                                this.mSuppMatrix.setScale(scale, scale, focalX, focalY);
                                this.checkAndDisplayMatrix();
                            }
                        }
                    }
                    setScaleType(scaleType) {
                        if (PhotoViewAttacher.isSupportedScaleType(scaleType) && scaleType != this.mScaleType) {
                            this.mScaleType = scaleType;
                            this.update();
                        }
                    }
                    setZoomable(zoomable) {
                        this.mZoomEnabled = zoomable;
                        this.update();
                    }
                    update() {
                        let imageView = this.getImageView();
                        if (null != imageView) {
                            if (this.mZoomEnabled) {
                                PhotoViewAttacher.setImageViewScaleTypeMatrix(imageView);
                                this.updateBaseMatrix(imageView.getDrawable());
                            }
                            else {
                                this.resetMatrix();
                            }
                        }
                    }
                    getDisplayMatrix() {
                        return new Matrix(this.getDrawMatrix());
                    }
                    getDrawMatrix() {
                        this.mDrawMatrix.set(this.mBaseMatrix);
                        this.mDrawMatrix.postConcat(this.mSuppMatrix);
                        return this.mDrawMatrix;
                    }
                    cancelFling() {
                        if (null != this.mCurrentFlingRunnable) {
                            this.mCurrentFlingRunnable.cancelFling();
                            this.mCurrentFlingRunnable = null;
                        }
                    }
                    checkAndDisplayMatrix() {
                        if (this.checkMatrixBounds()) {
                            this.setImageViewMatrix(this.getDrawMatrix());
                        }
                    }
                    checkImageViewScaleType() {
                        let imageView = this.getImageView();
                        if (null != imageView && !(IPhotoView.isImpl(imageView))) {
                            if (ScaleType.MATRIX != (imageView.getScaleType())) {
                                throw Error(`new IllegalStateException("The ImageView's ScaleType has been changed since attaching a PhotoViewAttacher")`);
                            }
                        }
                    }
                    checkMatrixBounds() {
                        const imageView = this.getImageView();
                        if (null == imageView) {
                            return false;
                        }
                        const rect = this._getDisplayRect(this.getDrawMatrix());
                        if (null == rect) {
                            return false;
                        }
                        const height = rect.height(), width = rect.width();
                        let deltaX = 0, deltaY = 0;
                        const viewHeight = this.getImageViewHeight(imageView);
                        if (height <= viewHeight) {
                            switch (this.mScaleType) {
                                case ScaleType.FIT_START:
                                    deltaY = -rect.top;
                                    break;
                                case ScaleType.FIT_END:
                                    deltaY = viewHeight - height - rect.top;
                                    break;
                                default:
                                    deltaY = (viewHeight - height) / 2 - rect.top;
                                    break;
                            }
                        }
                        else if (rect.top > 0) {
                            deltaY = -rect.top;
                        }
                        else if (rect.bottom < viewHeight) {
                            deltaY = viewHeight - rect.bottom;
                        }
                        const viewWidth = this.getImageViewWidth(imageView);
                        if (width <= viewWidth) {
                            switch (this.mScaleType) {
                                case ScaleType.FIT_START:
                                    deltaX = -rect.left;
                                    break;
                                case ScaleType.FIT_END:
                                    deltaX = viewWidth - width - rect.left;
                                    break;
                                default:
                                    deltaX = (viewWidth - width) / 2 - rect.left;
                                    break;
                            }
                            this.mScrollEdge = PhotoViewAttacher.EDGE_BOTH;
                        }
                        else if (rect.left > 0) {
                            this.mScrollEdge = PhotoViewAttacher.EDGE_LEFT;
                            deltaX = -rect.left;
                        }
                        else if (rect.right < viewWidth) {
                            deltaX = viewWidth - rect.right;
                            this.mScrollEdge = PhotoViewAttacher.EDGE_RIGHT;
                        }
                        else {
                            this.mScrollEdge = PhotoViewAttacher.EDGE_NONE;
                        }
                        this.mSuppMatrix.postTranslate(deltaX, deltaY);
                        return true;
                    }
                    _getDisplayRect(matrix) {
                        let imageView = this.getImageView();
                        if (null != imageView) {
                            let d = imageView.getDrawable();
                            if (null != d) {
                                this.mDisplayRect.set(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());
                                matrix.mapRect(this.mDisplayRect);
                                return this.mDisplayRect;
                            }
                        }
                        return null;
                    }
                    getVisibleRectangleBitmap() {
                        let imageView = this.getImageView();
                        return imageView == null ? null : imageView.getDrawingCache();
                    }
                    setZoomTransitionDuration(milliseconds) {
                        if (milliseconds < 0)
                            milliseconds = IPhotoView.DEFAULT_ZOOM_DURATION;
                        this.ZOOM_DURATION = milliseconds;
                    }
                    getIPhotoViewImplementation() {
                        return this;
                    }
                    getValue(matrix, whichValue) {
                        matrix.getValues(this.mMatrixValues);
                        return this.mMatrixValues[whichValue];
                    }
                    resetMatrix() {
                        this.mSuppMatrix.reset();
                        this.setImageViewMatrix(this.getDrawMatrix());
                        this.checkMatrixBounds();
                    }
                    setImageViewMatrix(matrix) {
                        let imageView = this.getImageView();
                        if (null != imageView) {
                            this.checkImageViewScaleType();
                            imageView.setImageMatrix(matrix);
                            if (null != this.mMatrixChangeListener) {
                                let displayRect = this._getDisplayRect(matrix);
                                if (null != displayRect) {
                                    this.mMatrixChangeListener.onMatrixChanged(displayRect);
                                }
                            }
                        }
                    }
                    updateBaseMatrix(d) {
                        let imageView = this.getImageView();
                        if (null == imageView || null == d) {
                            return;
                        }
                        const viewWidth = this.getImageViewWidth(imageView);
                        const viewHeight = this.getImageViewHeight(imageView);
                        const drawableWidth = d.getIntrinsicWidth();
                        const drawableHeight = d.getIntrinsicHeight();
                        this.mBaseMatrix.reset();
                        const widthScale = viewWidth / drawableWidth;
                        const heightScale = viewHeight / drawableHeight;
                        if (this.mScaleType == ScaleType.CENTER) {
                            this.mBaseMatrix.postTranslate((viewWidth - drawableWidth) / 2, (viewHeight - drawableHeight) / 2);
                        }
                        else if (this.mScaleType == ScaleType.CENTER_CROP) {
                            let scale = Math.max(widthScale, heightScale);
                            this.mBaseMatrix.postScale(scale, scale);
                            this.mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2, (viewHeight - drawableHeight * scale) / 2);
                        }
                        else if (this.mScaleType == ScaleType.CENTER_INSIDE) {
                            let scale = Math.min(1.0, Math.min(widthScale, heightScale));
                            this.mBaseMatrix.postScale(scale, scale);
                            this.mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2, (viewHeight - drawableHeight * scale) / 2);
                        }
                        else {
                            let mTempSrc = new RectF(0, 0, drawableWidth, drawableHeight);
                            let mTempDst = new RectF(0, 0, viewWidth, viewHeight);
                            switch (this.mScaleType) {
                                case ScaleType.FIT_CENTER:
                                    this.mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.CENTER);
                                    break;
                                case ScaleType.FIT_START:
                                    this.mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.START);
                                    break;
                                case ScaleType.FIT_END:
                                    this.mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.END);
                                    break;
                                case ScaleType.FIT_XY:
                                    this.mBaseMatrix.setRectToRect(mTempSrc, mTempDst, ScaleToFit.FILL);
                                    break;
                                default:
                                    break;
                            }
                        }
                        this.resetMatrix();
                    }
                    getImageViewWidth(imageView) {
                        if (null == imageView)
                            return 0;
                        return imageView.getWidth() - imageView.getPaddingLeft() - imageView.getPaddingRight();
                    }
                    getImageViewHeight(imageView) {
                        if (null == imageView)
                            return 0;
                        return imageView.getHeight() - imageView.getPaddingTop() - imageView.getPaddingBottom();
                    }
                }
                PhotoViewAttacher.LOG_TAG = "PhotoViewAttacher";
                PhotoViewAttacher.DEBUG = Log.View_DBG;
                PhotoViewAttacher.sInterpolator = new AccelerateDecelerateInterpolator();
                PhotoViewAttacher.EDGE_NONE = -1;
                PhotoViewAttacher.EDGE_LEFT = 0;
                PhotoViewAttacher.EDGE_RIGHT = 1;
                PhotoViewAttacher.EDGE_BOTH = 2;
                photoview.PhotoViewAttacher = PhotoViewAttacher;
                (function (PhotoViewAttacher) {
                    class AnimatedZoomRunnable {
                        constructor(arg, currentZoom, targetZoom, focalX, focalY) {
                            this.mFocalX = 0;
                            this.mFocalY = 0;
                            this.mStartTime = 0;
                            this.mZoomStart = 0;
                            this.mZoomEnd = 0;
                            this._PhotoViewAttacher_this = arg;
                            this.mFocalX = focalX;
                            this.mFocalY = focalY;
                            this.mStartTime = System.currentTimeMillis();
                            this.mZoomStart = currentZoom;
                            this.mZoomEnd = targetZoom;
                        }
                        run() {
                            let imageView = this._PhotoViewAttacher_this.getImageView();
                            if (imageView == null) {
                                return;
                            }
                            let t = this.interpolate();
                            let scale = this.mZoomStart + t * (this.mZoomEnd - this.mZoomStart);
                            let deltaScale = scale / this._PhotoViewAttacher_this.getScale();
                            this._PhotoViewAttacher_this.onScale(deltaScale, this.mFocalX, this.mFocalY);
                            if (t < 1) {
                                imageView.postOnAnimation(this);
                            }
                        }
                        interpolate() {
                            let t = 1 * (System.currentTimeMillis() - this.mStartTime) / this._PhotoViewAttacher_this.ZOOM_DURATION;
                            t = Math.min(1, t);
                            t = PhotoViewAttacher.sInterpolator.getInterpolation(t);
                            return t;
                        }
                    }
                    PhotoViewAttacher.AnimatedZoomRunnable = AnimatedZoomRunnable;
                    class FlingRunnable {
                        constructor(arg) {
                            this.mCurrentX = 0;
                            this.mCurrentY = 0;
                            this._PhotoViewAttacher_this = arg;
                            this.mScroller = new OverScroller();
                        }
                        cancelFling() {
                            if (PhotoViewAttacher.DEBUG) {
                                Log.d(PhotoViewAttacher.LOG_TAG, "Cancel Fling");
                            }
                            this.mScroller.forceFinished(true);
                        }
                        fling(viewWidth, viewHeight, velocityX, velocityY) {
                            const rect = this._PhotoViewAttacher_this.getDisplayRect();
                            if (null == rect) {
                                return;
                            }
                            const startX = Math.round(-rect.left);
                            let minX, maxX, minY, maxY;
                            if (viewWidth < rect.width()) {
                                minX = 0;
                                maxX = Math.round(rect.width() - viewWidth);
                            }
                            else {
                                minX = maxX = startX;
                            }
                            const startY = Math.round(-rect.top);
                            if (viewHeight < rect.height()) {
                                minY = 0;
                                maxY = Math.round(rect.height() - viewHeight);
                            }
                            else {
                                minY = maxY = startY;
                            }
                            this.mCurrentX = startX;
                            this.mCurrentY = startY;
                            if (PhotoViewAttacher.DEBUG) {
                                Log.d(PhotoViewAttacher.LOG_TAG, "fling. StartX:" + startX + " StartY:" + startY + " MaxX:" + maxX + " MaxY:" + maxY);
                            }
                            if (startX != maxX || startY != maxY) {
                                this.mScroller.fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, 0, 0);
                            }
                        }
                        run() {
                            if (this.mScroller.isFinished()) {
                                return;
                            }
                            let imageView = this._PhotoViewAttacher_this.getImageView();
                            if (null != imageView && this.mScroller.computeScrollOffset()) {
                                const newX = this.mScroller.getCurrX();
                                const newY = this.mScroller.getCurrY();
                                if (PhotoViewAttacher.DEBUG) {
                                    Log.d(PhotoViewAttacher.LOG_TAG, "fling run(). CurrentX:" + this.mCurrentX + " CurrentY:" + this.mCurrentY + " NewX:" + newX + " NewY:" + newY);
                                }
                                this._PhotoViewAttacher_this.mSuppMatrix.postTranslate(this.mCurrentX - newX, this.mCurrentY - newY);
                                this._PhotoViewAttacher_this.setImageViewMatrix(this._PhotoViewAttacher_this.getDrawMatrix());
                                this.mCurrentX = newX;
                                this.mCurrentY = newY;
                                imageView.postOnAnimation(this);
                            }
                        }
                    }
                    PhotoViewAttacher.FlingRunnable = FlingRunnable;
                    class DefaultOnDoubleTapListener {
                        constructor(photoViewAttacher) {
                            this.setPhotoViewAttacher(photoViewAttacher);
                        }
                        setPhotoViewAttacher(newPhotoViewAttacher) {
                            this.photoViewAttacher = newPhotoViewAttacher;
                        }
                        onSingleTapConfirmed(e) {
                            if (this.photoViewAttacher == null)
                                return false;
                            let imageView = this.photoViewAttacher.getImageView();
                            if (null != this.photoViewAttacher.getOnPhotoTapListener()) {
                                const displayRect = this.photoViewAttacher.getDisplayRect();
                                if (null != displayRect) {
                                    const x = e.getX(), y = e.getY();
                                    if (displayRect.contains(x, y)) {
                                        let xResult = (x - displayRect.left) / displayRect.width();
                                        let yResult = (y - displayRect.top) / displayRect.height();
                                        this.photoViewAttacher.getOnPhotoTapListener().onPhotoTap(imageView, xResult, yResult);
                                        return true;
                                    }
                                }
                            }
                            if (null != this.photoViewAttacher.getOnViewTapListener()) {
                                this.photoViewAttacher.getOnViewTapListener().onViewTap(imageView, e.getX(), e.getY());
                            }
                            return false;
                        }
                        onDoubleTap(ev) {
                            if (this.photoViewAttacher == null)
                                return false;
                            try {
                                let scale = this.photoViewAttacher.getScale();
                                let x = ev.getX();
                                let y = ev.getY();
                                if (scale < this.photoViewAttacher.getMediumScale()) {
                                    this.photoViewAttacher.setScale(this.photoViewAttacher.getMediumScale(), x, y, true);
                                }
                                else if (scale >= this.photoViewAttacher.getMediumScale() && scale < this.photoViewAttacher.getMaximumScale()) {
                                    this.photoViewAttacher.setScale(this.photoViewAttacher.getMaximumScale(), x, y, true);
                                }
                                else {
                                    this.photoViewAttacher.setScale(this.photoViewAttacher.getMinimumScale(), x, y, true);
                                }
                            }
                            catch (e) {
                            }
                            return true;
                        }
                        onDoubleTapEvent(e) {
                            return false;
                        }
                    }
                    PhotoViewAttacher.DefaultOnDoubleTapListener = DefaultOnDoubleTapListener;
                })(PhotoViewAttacher = photoview.PhotoViewAttacher || (photoview.PhotoViewAttacher = {}));
            })(photoview = senab.photoview || (senab.photoview = {}));
        })(senab = co.senab || (co.senab = {}));
    })(co = uk.co || (uk.co = {}));
})(uk || (uk = {}));
/*******************************************************************************
 * Copyright 2011, 2012 Chris Banes.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
///<reference path="../../../../../android/graphics/Canvas.ts"/>
///<reference path="../../../../../android/graphics/Matrix.ts"/>
///<reference path="../../../../../android/graphics/RectF.ts"/>
///<reference path="../../../../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../../../../android/view/GestureDetector.ts"/>
///<reference path="../../../../../android/view/View.ts"/>
///<reference path="../../../../../android/widget/ImageView.ts"/>
///<reference path="../../../../uk/co/senab/photoview/PhotoViewAttacher.ts"/>
///<reference path="../../../../uk/co/senab/photoview/IPhotoView.ts"/>
var uk;
(function (uk) {
    var co;
    (function (co) {
        var senab;
        (function (senab) {
            var photoview;
            (function (photoview) {
                var ImageView = android.widget.ImageView;
                var PhotoViewAttacher = uk.co.senab.photoview.PhotoViewAttacher;
                var ScaleType = ImageView.ScaleType;
                class PhotoView extends ImageView {
                    constructor(context, bindElement, defStyle) {
                        super(context, bindElement, defStyle);
                        super.setScaleType(ScaleType.MATRIX);
                        this.init();
                    }
                    init() {
                        if (null == this.mAttacher || null == this.mAttacher.getImageView()) {
                            this.mAttacher = new PhotoViewAttacher(this);
                        }
                        if (null != this.mPendingScaleType) {
                            this.setScaleType(this.mPendingScaleType);
                            this.mPendingScaleType = null;
                        }
                    }
                    setPhotoViewRotation(rotationDegree) {
                        this.mAttacher.setRotationTo(rotationDegree);
                    }
                    setRotationTo(rotationDegree) {
                        this.mAttacher.setRotationTo(rotationDegree);
                    }
                    setRotationBy(rotationDegree) {
                        this.mAttacher.setRotationBy(rotationDegree);
                    }
                    canZoom() {
                        return this.mAttacher.canZoom();
                    }
                    getDisplayRect() {
                        return this.mAttacher.getDisplayRect();
                    }
                    getDisplayMatrix() {
                        return this.mAttacher.getDisplayMatrix();
                    }
                    setDisplayMatrix(finalRectangle) {
                        return this.mAttacher.setDisplayMatrix(finalRectangle);
                    }
                    getMinScale() {
                        return this.getMinimumScale();
                    }
                    getMinimumScale() {
                        return this.mAttacher.getMinimumScale();
                    }
                    getMidScale() {
                        return this.getMediumScale();
                    }
                    getMediumScale() {
                        return this.mAttacher.getMediumScale();
                    }
                    getMaxScale() {
                        return this.getMaximumScale();
                    }
                    getMaximumScale() {
                        return this.mAttacher.getMaximumScale();
                    }
                    getScale() {
                        return this.mAttacher.getScale();
                    }
                    getScaleType() {
                        return this.mAttacher.getScaleType();
                    }
                    setAllowParentInterceptOnEdge(allow) {
                        this.mAttacher.setAllowParentInterceptOnEdge(allow);
                    }
                    setMinScale(minScale) {
                        this.setMinimumScale(minScale);
                    }
                    setMinimumScale(minimumScale) {
                        this.mAttacher.setMinimumScale(minimumScale);
                    }
                    setMidScale(midScale) {
                        this.setMediumScale(midScale);
                    }
                    setMediumScale(mediumScale) {
                        this.mAttacher.setMediumScale(mediumScale);
                    }
                    setMaxScale(maxScale) {
                        this.setMaximumScale(maxScale);
                    }
                    setMaximumScale(maximumScale) {
                        this.mAttacher.setMaximumScale(maximumScale);
                    }
                    setScaleLevels(minimumScale, mediumScale, maximumScale) {
                        this.mAttacher.setScaleLevels(minimumScale, mediumScale, maximumScale);
                    }
                    setImageDrawable(drawable) {
                        super.setImageDrawable(drawable);
                        if (null != this.mAttacher) {
                            this.mAttacher.update();
                        }
                    }
                    setImageURI(uri) {
                        super.setImageURI(uri);
                    }
                    resizeFromDrawable() {
                        let change = super.resizeFromDrawable();
                        if (change && null != this.mAttacher) {
                            this.mAttacher.update();
                        }
                        return change;
                    }
                    setOnMatrixChangeListener(listener) {
                        this.mAttacher.setOnMatrixChangeListener(listener);
                    }
                    setOnLongClickListener(l) {
                        this.mAttacher.setOnLongClickListener(l);
                    }
                    setOnPhotoTapListener(listener) {
                        this.mAttacher.setOnPhotoTapListener(listener);
                    }
                    getOnPhotoTapListener() {
                        return this.mAttacher.getOnPhotoTapListener();
                    }
                    setOnViewTapListener(listener) {
                        this.mAttacher.setOnViewTapListener(listener);
                    }
                    getOnViewTapListener() {
                        return this.mAttacher.getOnViewTapListener();
                    }
                    setScale(...args) {
                        this.mAttacher.setScale(...args);
                    }
                    setScaleType(scaleType) {
                        if (null != this.mAttacher) {
                            this.mAttacher.setScaleType(scaleType);
                        }
                        else {
                            this.mPendingScaleType = scaleType;
                        }
                    }
                    setZoomable(zoomable) {
                        this.mAttacher.setZoomable(zoomable);
                    }
                    getVisibleRectangleBitmap() {
                        return this.mAttacher.getVisibleRectangleBitmap();
                    }
                    setZoomTransitionDuration(milliseconds) {
                        this.mAttacher.setZoomTransitionDuration(milliseconds);
                    }
                    getIPhotoViewImplementation() {
                        return this.mAttacher;
                    }
                    setOnDoubleTapListener(newOnDoubleTapListener) {
                        this.mAttacher.setOnDoubleTapListener(newOnDoubleTapListener);
                    }
                    setOnScaleChangeListener(onScaleChangeListener) {
                        this.mAttacher.setOnScaleChangeListener(onScaleChangeListener);
                    }
                    onDetachedFromWindow() {
                        this.mAttacher.cleanup();
                        super.onDetachedFromWindow();
                    }
                    onAttachedToWindow() {
                        this.init();
                        super.onAttachedToWindow();
                    }
                }
                photoview.PhotoView = PhotoView;
            })(photoview = senab.photoview || (senab.photoview = {}));
        })(senab = co.senab || (co.senab = {}));
    })(co = uk.co || (uk.co = {}));
})(uk || (uk = {}));
/**
 * Created by linfaxin on 15/10/26.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/R/attr.ts"/>
///<reference path="../../androidui/AndroidUI.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        class HtmlBaseView extends View {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
            }
            onTouchEvent(event) {
                event[android.view.ViewRootImpl.ContinueEventToDom] = true;
                return super.onTouchEvent(event) || true;
            }
            requestSyncBoundToElement(immediately = true) {
                super.requestSyncBoundToElement(immediately);
            }
            onAttachedToWindow() {
                this.getContext().androidUI.showDebugLayout();
                return super.onAttachedToWindow();
            }
        }
        widget.HtmlBaseView = HtmlBaseView;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/10/26.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/graphics/Color.ts"/>
///<reference path="../../android/content/res/ColorStateList.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
///<reference path="../../android/R/attr.ts"/>
///<reference path="../../androidui/AndroidUI.ts"/>
///<reference path="HtmlBaseView.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var MeasureSpec = View.MeasureSpec;
        class HtmlView extends widget.HtmlBaseView {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let widthMode = MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = MeasureSpec.getSize(heightMeasureSpec);
                let width, height;
                const density = this.getResources().getDisplayMetrics().density;
                if (widthMode == MeasureSpec.EXACTLY) {
                    width = widthSize;
                }
                else {
                    let sWidth = this.bindElement.style.width, sLeft = this.bindElement.style.left;
                    this.bindElement.style.width = '';
                    this.bindElement.style.left = '';
                    width = this.bindElement.offsetWidth * density + 2;
                    this.bindElement.style.width = sWidth;
                    this.bindElement.style.left = sLeft;
                    width = Math.max(width, this.getSuggestedMinimumWidth());
                    if (widthMode == MeasureSpec.AT_MOST) {
                        width = Math.min(widthSize, width);
                    }
                }
                if (heightMode == MeasureSpec.EXACTLY) {
                    height = heightSize;
                }
                else {
                    let sWidth = this.bindElement.style.width;
                    this.bindElement.style.width = width / density + "px";
                    height = this.bindElement.offsetHeight * density;
                    this.bindElement.style.width = sWidth;
                    height = Math.max(height, this.getSuggestedMinimumHeight());
                    if (heightMode == MeasureSpec.AT_MOST) {
                        height = Math.min(height, heightSize);
                    }
                }
                this.setMeasuredDimension(width, height);
            }
            setHtml(html) {
                this.bindElement.innerHTML = html;
                this.requestLayout();
            }
            getHtml() {
                return this.bindElement.innerHTML;
            }
        }
        widget.HtmlView = HtmlView;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/7.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/widget/ImageView.ts"/>
///<reference path="HtmlBaseView.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var MeasureSpec = View.MeasureSpec;
        var ImageView = android.widget.ImageView;
        window.addEventListener('AndroidUILoadFinish', () => {
            eval('ImageView = android.widget.ImageView;');
        });
        class HtmlImageView extends widget.HtmlBaseView {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.mHaveFrame = false;
                this.mAdjustViewBounds = false;
                this.mMaxWidth = Number.MAX_SAFE_INTEGER;
                this.mMaxHeight = Number.MAX_SAFE_INTEGER;
                this.mAlpha = 255;
                this.mDrawableWidth = 0;
                this.mDrawableHeight = 0;
                this.mAdjustViewBoundsCompat = false;
                this.initImageView();
                this._attrBinder.addAttr('src', (value) => {
                    this.setImageURI(value);
                }, () => {
                    return this.mImgElement.src;
                });
                this._attrBinder.addAttr('adjustViewBounds', (value) => {
                    this.setAdjustViewBounds(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('maxWidth', (value) => {
                    let baseValue = this.getParent() instanceof View ? this.getParent().getWidth() : 0;
                    this.setMaxWidth(this._attrBinder.parseNumber(value, this.mMaxWidth, baseValue));
                }, () => {
                    return this.mMaxWidth;
                });
                this._attrBinder.addAttr('maxHeight', (value) => {
                    let baseValue = this.getParent() instanceof View ? this.getParent().getHeight() : 0;
                    this.setMaxHeight(this._attrBinder.parseNumber(value, this.mMaxHeight, baseValue));
                }, () => {
                    return this.mMaxHeight;
                });
                this._attrBinder.addAttr('scaleType', (value) => {
                    this.setScaleType(ImageView.parseScaleType(value, this.mScaleType));
                }, () => {
                    return this.mScaleType.toString();
                });
            }
            initImageView() {
                this.mScaleType = ImageView.ScaleType.FIT_CENTER;
                this.mImgElement = document.createElement('img');
                this.mImgElement.style.position = "absolute";
                this.mImgElement.onload = (() => {
                    this.mImgElement.style.left = 0 + 'px';
                    this.mImgElement.style.top = 0 + 'px';
                    this.mImgElement.style.width = '';
                    this.mImgElement.style.height = '';
                    this.mDrawableWidth = this.mImgElement.width;
                    this.mDrawableHeight = this.mImgElement.height;
                    this.mImgElement.style.display = 'none';
                    this.mImgElement.style.opacity = '';
                    this.requestLayout();
                });
                this.bindElement.appendChild(this.mImgElement);
            }
            getAdjustViewBounds() {
                return this.mAdjustViewBounds;
            }
            setAdjustViewBounds(adjustViewBounds) {
                this.mAdjustViewBounds = adjustViewBounds;
                if (adjustViewBounds) {
                    this.setScaleType(ImageView.ScaleType.FIT_CENTER);
                }
            }
            getMaxWidth() {
                return this.mMaxWidth;
            }
            setMaxWidth(maxWidth) {
                this.mMaxWidth = maxWidth;
            }
            getMaxHeight() {
                return this.mMaxHeight;
            }
            setMaxHeight(maxHeight) {
                this.mMaxHeight = maxHeight;
            }
            setImageURI(uri) {
                this.mDrawableWidth = -1;
                this.mDrawableHeight = -1;
                this.mImgElement.style.opacity = '0';
                this.mImgElement.src = uri;
            }
            setScaleType(scaleType) {
                if (scaleType == null) {
                    throw new Error('NullPointerException');
                }
                if (this.mScaleType != scaleType) {
                    this.mScaleType = scaleType;
                    this.setWillNotCacheDrawing(scaleType == ImageView.ScaleType.CENTER);
                    this.requestLayout();
                    this.invalidate();
                }
            }
            getScaleType() {
                return this.mScaleType;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let w;
                let h;
                let desiredAspect = 0.0;
                let resizeWidth = false;
                let resizeHeight = false;
                const widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
                const heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
                if (!this.mImgElement.src || !this.mImgElement.complete) {
                    this.mDrawableWidth = -1;
                    this.mDrawableHeight = -1;
                    w = h = 0;
                }
                else {
                    w = this.mDrawableWidth;
                    h = this.mDrawableHeight;
                    if (w <= 0)
                        w = 1;
                    if (h <= 0)
                        h = 1;
                    if (this.mAdjustViewBounds) {
                        resizeWidth = widthSpecMode != MeasureSpec.EXACTLY;
                        resizeHeight = heightSpecMode != MeasureSpec.EXACTLY;
                        desiredAspect = w / h;
                    }
                }
                let pleft = this.mPaddingLeft;
                let pright = this.mPaddingRight;
                let ptop = this.mPaddingTop;
                let pbottom = this.mPaddingBottom;
                let widthSize;
                let heightSize;
                if (resizeWidth || resizeHeight) {
                    widthSize = this.resolveAdjustedSize(w + pleft + pright, this.mMaxWidth, widthMeasureSpec);
                    heightSize = this.resolveAdjustedSize(h + ptop + pbottom, this.mMaxHeight, heightMeasureSpec);
                    if (desiredAspect != 0) {
                        let actualAspect = (widthSize - pleft - pright) / (heightSize - ptop - pbottom);
                        if (Math.abs(actualAspect - desiredAspect) > 0.0000001) {
                            let done = false;
                            if (resizeWidth) {
                                let newWidth = Math.floor(desiredAspect * (heightSize - ptop - pbottom)) +
                                    pleft + pright;
                                if (!resizeHeight && !this.mAdjustViewBoundsCompat) {
                                    widthSize = this.resolveAdjustedSize(newWidth, this.mMaxWidth, widthMeasureSpec);
                                }
                                if (newWidth <= widthSize) {
                                    widthSize = newWidth;
                                    done = true;
                                }
                            }
                            if (!done && resizeHeight) {
                                let newHeight = Math.floor((widthSize - pleft - pright) / desiredAspect) +
                                    ptop + pbottom;
                                if (!resizeWidth && !this.mAdjustViewBoundsCompat) {
                                    heightSize = this.resolveAdjustedSize(newHeight, this.mMaxHeight, heightMeasureSpec);
                                }
                                if (newHeight <= heightSize) {
                                    heightSize = newHeight;
                                }
                            }
                        }
                    }
                }
                else {
                    w += pleft + pright;
                    h += ptop + pbottom;
                    w = Math.max(w, this.getSuggestedMinimumWidth());
                    h = Math.max(h, this.getSuggestedMinimumHeight());
                    widthSize = HtmlImageView.resolveSizeAndState(w, widthMeasureSpec, 0);
                    heightSize = HtmlImageView.resolveSizeAndState(h, heightMeasureSpec, 0);
                }
                this.setMeasuredDimension(widthSize, heightSize);
            }
            resolveAdjustedSize(desiredSize, maxSize, measureSpec) {
                let result = desiredSize;
                let specMode = MeasureSpec.getMode(measureSpec);
                let specSize = MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case MeasureSpec.UNSPECIFIED:
                        result = Math.min(desiredSize, maxSize);
                        break;
                    case MeasureSpec.AT_MOST:
                        result = Math.min(Math.min(desiredSize, specSize), maxSize);
                        break;
                    case MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result;
            }
            setFrame(left, top, right, bottom) {
                let changed = super.setFrame(left, top, right, bottom);
                this.mHaveFrame = true;
                this.configureBounds();
                this.mImgElement.style.display = '';
                return changed;
            }
            configureBounds() {
                let dwidth = this.mDrawableWidth;
                let dheight = this.mDrawableHeight;
                let vwidth = this.getWidth() - this.mPaddingLeft - this.mPaddingRight;
                let vheight = this.getHeight() - this.mPaddingTop - this.mPaddingBottom;
                let fits = (dwidth < 0 || vwidth == dwidth) && (dheight < 0 || vheight == dheight);
                this.mImgElement.style.left = 0 + 'px';
                this.mImgElement.style.top = 0 + 'px';
                this.mImgElement.style.width = '';
                this.mImgElement.style.height = '';
                if (dwidth <= 0 || dheight <= 0) {
                    return;
                }
                if (this.mScaleType === ImageView.ScaleType.FIT_XY) {
                    this.mImgElement.style.width = vwidth + 'px';
                    this.mImgElement.style.height = vheight + 'px';
                    return;
                }
                this.mImgElement.style.width = dwidth + 'px';
                this.mImgElement.style.height = dheight + 'px';
                if (ImageView.ScaleType.MATRIX === this.mScaleType) {
                }
                else if (fits) {
                }
                else if (ImageView.ScaleType.CENTER === this.mScaleType) {
                    let left = Math.round((vwidth - dwidth) * 0.5);
                    let top = Math.round((vheight - dheight) * 0.5);
                    this.mImgElement.style.left = left + 'px';
                    this.mImgElement.style.top = top + 'px';
                }
                else if (ImageView.ScaleType.CENTER_CROP === this.mScaleType) {
                    let scale;
                    let dx = 0, dy = 0;
                    if (dwidth * vheight > vwidth * dheight) {
                        scale = vheight / dheight;
                        dx = (vwidth - dwidth * scale) * 0.5;
                        this.mImgElement.style.width = 'auto';
                        this.mImgElement.style.height = vheight + 'px';
                        this.mImgElement.style.left = Math.round(dx) + 'px';
                        this.mImgElement.style.top = '0px';
                    }
                    else {
                        scale = vwidth / dwidth;
                        dy = (vheight - dheight * scale) * 0.5;
                        this.mImgElement.style.width = vwidth + 'px';
                        this.mImgElement.style.height = 'auto';
                        this.mImgElement.style.left = '0px';
                        this.mImgElement.style.top = Math.round(dy) + 'px';
                    }
                }
                else if (ImageView.ScaleType.CENTER_INSIDE === this.mScaleType) {
                    let scale = 1;
                    if (dwidth <= vwidth && dheight <= vheight) {
                    }
                    else {
                        let wScale = vwidth / dwidth;
                        let hScale = vheight / dheight;
                        if (wScale < hScale) {
                            this.mImgElement.style.width = vwidth + 'px';
                            this.mImgElement.style.height = 'auto';
                        }
                        else {
                            this.mImgElement.style.width = 'auto';
                            this.mImgElement.style.height = vheight + 'px';
                        }
                        scale = Math.min(wScale, hScale);
                    }
                    let dx = Math.round((vwidth - dwidth * scale) * 0.5);
                    let dy = Math.round((vheight - dheight * scale) * 0.5);
                    this.mImgElement.style.left = dx + 'px';
                    this.mImgElement.style.top = dy + 'px';
                }
                else {
                    let wScale = vwidth / dwidth;
                    let hScale = vheight / dheight;
                    if (wScale < hScale) {
                        this.mImgElement.style.width = vwidth + 'px';
                        this.mImgElement.style.height = 'auto';
                    }
                    else {
                        this.mImgElement.style.width = 'auto';
                        this.mImgElement.style.height = vheight + 'px';
                    }
                    let scale = Math.min(wScale, hScale);
                    if (ImageView.ScaleType.FIT_CENTER === this.mScaleType) {
                        let dx = Math.round((vwidth - dwidth * scale) * 0.5);
                        let dy = Math.round((vheight - dheight * scale) * 0.5);
                        this.mImgElement.style.left = dx + 'px';
                        this.mImgElement.style.top = dy + 'px';
                    }
                    else if (ImageView.ScaleType.FIT_END === this.mScaleType) {
                        let dx = Math.round((vwidth - dwidth * scale));
                        let dy = Math.round((vheight - dheight * scale));
                        this.mImgElement.style.left = dx + 'px';
                        this.mImgElement.style.top = dy + 'px';
                    }
                    else if (ImageView.ScaleType.FIT_START === this.mScaleType) {
                    }
                }
            }
            getImageAlpha() {
                return this.mAlpha;
            }
            setImageAlpha(alpha) {
                this.setAlpha(alpha);
            }
        }
        widget.HtmlImageView = HtmlImageView;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/BaseAdapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/SpinnerAdapter.ts"/>
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/content/Context.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var AbsListView = android.widget.AbsListView;
        var BaseAdapter = android.widget.BaseAdapter;
        var AdapterView = android.widget.AdapterView;
        class HtmlDataListAdapter extends BaseAdapter {
            onInflateAdapter(bindElement, context, parent) {
                this.bindElementData = bindElement;
                this.mContext = context;
                if (parent instanceof AbsListView) {
                    parent.setAdapter(this);
                }
                bindElement[HtmlDataListAdapter.BindAdapterProperty] = this;
                this.registerHtmlDataObserver();
            }
            registerHtmlDataObserver() {
                const adapter = this;
                function callBack(arr, observer) {
                    adapter.notifyDataSetChanged();
                }
                let observer = new MutationObserver(callBack);
                observer.observe(this.bindElementData, { childList: true });
            }
            getItemViewType(position) {
                return AdapterView.ITEM_VIEW_TYPE_IGNORE;
            }
            getView(position, convertView, parent) {
                let element = this.getItem(position);
                let view = element[View.AndroidViewProperty];
                this.checkReplaceWithRef(element);
                if (!view) {
                    view = View.inflate(this.mContext, element);
                    element[View.AndroidViewProperty] = view;
                }
                return view;
            }
            getCount() {
                return this.bindElementData.children.length;
            }
            getItem(position) {
                let element = this.bindElementData.children[position];
                if (element.tagName === HtmlDataListAdapter.RefElementTag) {
                    element = element[HtmlDataListAdapter.RefElementProperty];
                    if (!element)
                        throw Error('Reference element is ' + element);
                }
                return element;
            }
            checkReplaceWithRef(element) {
                let refElement = element[HtmlDataListAdapter.RefElementProperty] || document.createElement(HtmlDataListAdapter.RefElementTag);
                refElement[HtmlDataListAdapter.RefElementProperty] = element;
                element[HtmlDataListAdapter.RefElementProperty] = refElement;
                if (element.parentNode === this.bindElementData) {
                    this.bindElementData.insertBefore(refElement, element);
                    this.bindElementData.removeChild(element);
                }
                return refElement;
            }
            removeElementRefAndRestoreToAdapter(childElement) {
                if (childElement.tagName === HtmlDataListAdapter.RefElementTag) {
                    let element = childElement[HtmlDataListAdapter.RefElementProperty];
                    this.bindElementData.insertBefore(element, childElement);
                    this.bindElementData.removeChild(childElement);
                }
            }
            notifyDataSizeWillChange() {
                for (let i = 0, count = this.bindElementData.children.length; i < count; i++) {
                    this.removeElementRefAndRestoreToAdapter(this.bindElementData.children[i]);
                }
                this.notifyDataSetChanged();
            }
            getItemId(position) {
                let id = this.getItem(position).id;
                let idNumber = Number.parseInt(id);
                if (Number.isInteger(idNumber))
                    return idNumber;
                return -1;
            }
        }
        HtmlDataListAdapter.RefElementTag = "ref-element".toUpperCase();
        HtmlDataListAdapter.RefElementProperty = "RefElement";
        HtmlDataListAdapter.BindAdapterProperty = "BindAdapter";
        widget.HtmlDataListAdapter = HtmlDataListAdapter;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/Observable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/support/v4/view/ViewPager.ts"/>
///<reference path="../../android/support/v4/view/PagerAdapter.ts"/>
///<reference path="../../android/content/Context.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var ViewPager = android.support.v4.view.ViewPager;
        var PagerAdapter = android.support.v4.view.PagerAdapter;
        class HtmlDataPagerAdapter extends PagerAdapter {
            onInflateAdapter(bindElement, context, parent) {
                this.bindElementData = bindElement;
                this.mContext = context;
                if (parent instanceof ViewPager) {
                    parent.setAdapter(this);
                }
                bindElement[HtmlDataPagerAdapter.BindAdapterProperty] = this;
                this.registerHtmlDataObserver();
            }
            registerHtmlDataObserver() {
                const adapter = this;
                function callBack(arr, observer) {
                    adapter.notifyDataSetChanged();
                }
                let observer = new MutationObserver(callBack);
                observer.observe(this.bindElementData, { childList: true });
            }
            getCount() {
                return this.bindElementData.children.length;
            }
            instantiateItem(container, position) {
                let element = this.getItem(position);
                let view = element[View.AndroidViewProperty];
                this.checkReplaceWithRef(element);
                if (!view) {
                    view = View.inflate(this.mContext, element);
                    element[View.AndroidViewProperty] = view;
                }
                container.addView(view);
                return view;
            }
            getItem(position) {
                let element = this.bindElementData.children[position];
                if (element.tagName === HtmlDataPagerAdapter.RefElementTag) {
                    element = element[HtmlDataPagerAdapter.RefElementProperty];
                    if (!element)
                        throw Error('Reference element is ' + element);
                }
                return element;
            }
            checkReplaceWithRef(element) {
                let refElement = element[HtmlDataPagerAdapter.RefElementProperty] || document.createElement(HtmlDataPagerAdapter.RefElementTag);
                refElement[HtmlDataPagerAdapter.RefElementProperty] = element;
                element[HtmlDataPagerAdapter.RefElementProperty] = refElement;
                if (element.parentNode === this.bindElementData) {
                    this.bindElementData.insertBefore(refElement, element);
                    this.bindElementData.removeChild(element);
                }
                return refElement;
            }
            removeElementRefAndRestoreToAdapter(childElement) {
                if (childElement.tagName === HtmlDataPagerAdapter.RefElementTag) {
                    let element = childElement[HtmlDataPagerAdapter.RefElementProperty];
                    this.bindElementData.insertBefore(element, childElement);
                    this.bindElementData.removeChild(childElement);
                }
            }
            notifyDataSizeWillChange() {
                for (let i = 0, count = this.bindElementData.children.length; i < count; i++) {
                    this.removeElementRefAndRestoreToAdapter(this.bindElementData.children[i]);
                }
                this.notifyDataSetChanged();
            }
            destroyItem(container, position, object) {
                let view = object;
                container.removeView(view);
            }
            isViewFromObject(view, object) {
                return view === object;
            }
            getItemPosition(object) {
                let position = PagerAdapter.POSITION_NONE;
                if (object == null)
                    return position;
                for (let i = 0, count = this.getCount(); i < count; i++) {
                    if (object === this.getItem(i)[View.AndroidViewProperty]) {
                        position = i;
                        break;
                    }
                }
                return position;
            }
        }
        HtmlDataPagerAdapter.RefElementTag = "ref-element".toUpperCase();
        HtmlDataPagerAdapter.RefElementProperty = "RefElement";
        HtmlDataPagerAdapter.BindAdapterProperty = "BindAdapter";
        widget.HtmlDataPagerAdapter = HtmlDataPagerAdapter;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/NumberPicker.ts"/>
///<reference path="../../android/content/Context.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var NumberPicker = android.widget.NumberPicker;
        class HtmlDataPickerAdapter {
            onInflateAdapter(bindElement, context, parent) {
                this.bindElementData = bindElement;
                if (parent instanceof NumberPicker) {
                    const callBack = (arr, observer) => {
                        const values = [];
                        for (let child of Array.from(this.bindElementData.children)) {
                            values.push(child.innerText);
                        }
                        parent.setDisplayedValues(values);
                    };
                    callBack.call(this);
                    let observer = new MutationObserver(callBack);
                    observer.observe(this.bindElementData, { childList: true });
                }
            }
        }
        widget.HtmlDataPickerAdapter = HtmlDataPickerAdapter;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var MotionEvent = android.view.MotionEvent;
        var AbsListView = android.widget.AbsListView;
        var ScrollView = android.widget.ScrollView;
        var Integer = java.lang.Integer;
        var OverScrollLocker;
        (function (OverScrollLocker) {
            const InstanceMap = new WeakMap();
            function getFrom(view) {
                let scrollLocker = InstanceMap.get(view);
                if (!scrollLocker) {
                    if (view instanceof AbsListView) {
                        scrollLocker = new ListViewOverScrollLocker(view);
                    }
                    else if (view instanceof ScrollView) {
                        scrollLocker = new ScrollViewScrollLocker(view);
                    }
                    if (scrollLocker)
                        InstanceMap.set(view, scrollLocker);
                }
                return scrollLocker;
            }
            OverScrollLocker.getFrom = getFrom;
            class BaseOverScrollLocker {
                constructor(view) {
                    this.view = view;
                    const onTouchEventFunc = view.onTouchEvent;
                    view.onTouchEvent = (event) => {
                        let result = onTouchEventFunc.call(view, event);
                        switch (event.getAction()) {
                            case MotionEvent.ACTION_DOWN:
                            case MotionEvent.ACTION_MOVE:
                                this.isInTouch = true;
                                break;
                            case MotionEvent.ACTION_UP:
                            case MotionEvent.ACTION_CANCEL:
                                this.isInTouch = false;
                                break;
                        }
                        return result;
                    };
                }
                lockOverScrollTop(lockTop) {
                    this.lockTop = lockTop;
                    if (!this.isInTouch && this.getOverScrollY() < -lockTop) {
                        this.springBackToLockTop();
                    }
                }
                lockOverScrollBottom(lockBottom) {
                    this.lockBottom = lockBottom;
                    if (!this.isInTouch && this.getOverScrollY() > lockBottom) {
                        this.springBackToLockBottom();
                    }
                }
            }
            class ListViewOverScrollLocker extends BaseOverScrollLocker {
                constructor(listView) {
                    super(listView);
                    this.listView = listView;
                    this.configListView();
                }
                configListView() {
                    let listView = this.listView;
                    if (!listView.mFlingRunnable)
                        listView.mFlingRunnable = new AbsListView.FlingRunnable(listView);
                    const scroller = listView.mFlingRunnable.mScroller;
                    listView.mFlingRunnable.startOverfling = (initialVelocity) => {
                        scroller.setInterpolator(null);
                        let minY = Integer.MIN_VALUE, maxY = Integer.MAX_VALUE;
                        if (listView.mScrollY < 0)
                            minY = -this.lockTop;
                        else if (listView.mScrollY > 0)
                            maxY = this.lockBottom;
                        scroller.fling(0, listView.mScrollY, 0, initialVelocity, 0, 0, minY, maxY, 0, listView._mOverflingDistance);
                        listView.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                        listView.invalidate();
                        listView.postOnAnimation(listView.mFlingRunnable);
                    };
                    const layoutChildrenFunc = listView.layoutChildren;
                    listView.layoutChildren = () => {
                        const overScrollY = this.getOverScrollY();
                        layoutChildrenFunc.call(listView);
                        if (overScrollY !== 0) {
                            listView.overScrollBy(0, -overScrollY, 0, listView.mScrollY, 0, 0, 0, listView.mOverscrollDistance, false);
                            const atEdge = listView.trackMotionScroll(-overScrollY, -overScrollY);
                            if (atEdge) {
                                listView.overScrollBy(0, overScrollY, 0, listView.mScrollY, 0, 0, 0, listView.mOverscrollDistance, false);
                            }
                            else {
                                listView.mFlingRunnable.mScroller.abortAnimation();
                            }
                        }
                    };
                    listView.checkOverScrollStartScrollIfNeeded = () => {
                        return listView.mScrollY > this.lockBottom || listView.mScrollY < this.lockTop;
                    };
                    listView.mFlingRunnable.edgeReached = (delta) => {
                        let initialVelocity = listView.mFlingRunnable.mScroller.getCurrVelocity();
                        if (delta > 0)
                            initialVelocity = -initialVelocity;
                        listView.mFlingRunnable.startOverfling(initialVelocity);
                    };
                    const oldSpringBack = scroller.springBack;
                    scroller.springBack = (startX, startY, minX, maxX, minY, maxY) => {
                        minY = -this.lockTop;
                        maxY = this.lockBottom;
                        return oldSpringBack.call(scroller, startX, startY, minX, maxX, minY, maxY);
                    };
                    const oldFling = scroller.fling;
                    scroller.fling = (startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX = 0, overY = 0) => {
                        if (velocityY > 0)
                            overY += this.lockBottom;
                        else
                            overY += this.lockTop;
                        oldFling.call(scroller, startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX, overY);
                    };
                }
                getScrollContentBottom() {
                    let childCount = this.listView.getChildCount();
                    let maxBottom = 0;
                    let minTop = 0;
                    for (let i = 0; i < childCount; i++) {
                        let child = this.listView.getChildAt(i);
                        let childBottom = child.getBottom();
                        let childTop = child.getTop();
                        if (childBottom > maxBottom) {
                            maxBottom = childBottom;
                        }
                        if (childTop < minTop) {
                            minTop = childTop;
                        }
                    }
                    if (minTop > 0)
                        minTop = 0;
                    if (this.listView.getAdapter() && childCount > 0) {
                        return (maxBottom - minTop) * this.listView.getAdapter().getCount() / childCount;
                    }
                    return 0;
                }
                getOverScrollY() {
                    return this.listView.mScrollY;
                }
                startSpringBack() {
                    this.listView.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                    this.listView.mFlingRunnable.mScroller.springBack(0, this.listView.mScrollY, 0, 0, 0, 0);
                    this.listView.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                    this.listView.postOnAnimation(this.listView.mFlingRunnable);
                }
                springBackToLockTop() {
                    this.startSpringBack();
                }
                springBackToLockBottom() {
                    this.startSpringBack();
                }
            }
            class ScrollViewScrollLocker extends BaseOverScrollLocker {
                constructor(scrollView) {
                    super(scrollView);
                    this.scrollView = scrollView;
                    const scroller = scrollView.mScroller;
                    const oldSpringBack = scroller.springBack;
                    scroller.springBack = (startX, startY, minX, maxX, minY, maxY) => {
                        minY = -this.lockTop;
                        maxY = this.scrollView.getScrollRange() + this.lockBottom;
                        return oldSpringBack.call(scroller, startX, startY, minX, maxX, minY, maxY);
                    };
                    const oldFling = scroller.fling;
                    scroller.fling = (startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX = 0, overY = 0) => {
                        if (velocityY > 0)
                            overY += this.lockBottom;
                        else
                            overY += this.lockTop;
                        minY -= this.lockTop;
                        maxY += this.lockBottom;
                        oldFling.call(scroller, startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX, overY);
                    };
                    this.listenScrollContentHeightChange();
                }
                listenScrollContentHeightChange() {
                    const listenHeightChange = (v) => {
                        const onSizeChangedFunc = v.onSizeChanged;
                        v.onSizeChanged = (w, h, oldw, oldh) => {
                            onSizeChangedFunc.call(v, w, h, oldw, oldh);
                            this.scrollView.overScrollBy(0, 0, 0, this.scrollView.mScrollY, 0, this.scrollView.getScrollRange(), 0, this.scrollView.mOverscrollDistance, false);
                        };
                    };
                    if (this.scrollView.getChildCount() > 0) {
                        listenHeightChange(this.scrollView.getChildAt(0));
                    }
                    else {
                        const onViewAddedFunc = this.scrollView.onViewAdded;
                        this.scrollView.onViewAdded = (v) => {
                            onViewAddedFunc.call(this.scrollView, v);
                            listenHeightChange(v);
                        };
                    }
                }
                getScrollContentBottom() {
                    if (this.scrollView.getChildCount() > 0) {
                        return this.scrollView.getChildAt(0).getBottom();
                    }
                    return this.scrollView.getPaddingTop();
                }
                getOverScrollY() {
                    let scrollY = this.scrollView.getScrollY();
                    if (scrollY < 0)
                        return scrollY;
                    let scrollRange = this.scrollView.getScrollRange();
                    if (scrollY > scrollRange) {
                        return scrollY - scrollRange;
                    }
                    return 0;
                }
                startSpringBack() {
                    if (this.scrollView.mScroller.springBack(this.scrollView.mScrollX, this.scrollView.mScrollY, 0, 0, 0, this.scrollView.getScrollRange())) {
                        this.scrollView.postInvalidateOnAnimation();
                    }
                }
                springBackToLockTop() {
                    this.startSpringBack();
                }
                springBackToLockBottom() {
                    this.startSpringBack();
                }
            }
        })(OverScrollLocker = widget.OverScrollLocker || (widget.OverScrollLocker = {}));
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/19.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/ProgressBar.ts"/>
///<reference path="../../android/R/string.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="OverScrollLocker.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var Gravity = android.view.Gravity;
        var ViewGroup = android.view.ViewGroup;
        var FrameLayout = android.widget.FrameLayout;
        var TextView = android.widget.TextView;
        var LinearLayout = android.widget.LinearLayout;
        var ProgressBar = android.widget.ProgressBar;
        var R = android.R;
        class PullRefreshLoadLayout extends FrameLayout {
            constructor(context, bindElement, defStyle) {
                super(context, bindElement, defStyle);
                this.autoLoadScrollAtBottom = true;
                this.footerViewReadyDistance = 36 * android.content.res.Resources.getDisplayMetrics().density;
                this.contentOverY = 0;
                this.setHeaderView(new PullRefreshLoadLayout.DefaultHeaderView(context));
                this.setFooterView(new PullRefreshLoadLayout.DefaultFooterView(context));
                this._attrBinder.addAttr('refreshEnable', (value) => {
                    this.setRefreshEnable(this._attrBinder.parseBoolean(value, true));
                });
                this._attrBinder.addAttr('loadEnable', (value) => {
                    this.setLoadEnable(this._attrBinder.parseBoolean(value, true));
                });
            }
            onViewAdded(child) {
                super.onViewAdded(child);
                if (child instanceof PullRefreshLoadLayout.HeaderView) {
                    if (child != this.headerView)
                        this.setHeaderView(child);
                }
                else if (child instanceof PullRefreshLoadLayout.FooterView) {
                    if (child != this.footerView)
                        this.setFooterView(child);
                }
                else {
                    if (child != this.contentView)
                        this.setContentView(child);
                }
                if (this.footerView != null) {
                    this.bringChildToFront(this.footerView);
                }
            }
            configHeaderView() {
                let headerView = this.headerView;
                let params = headerView.getLayoutParams();
                params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL;
                params.height = ViewGroup.LayoutParams.WRAP_CONTENT;
                params.width = ViewGroup.LayoutParams.MATCH_PARENT;
                headerView.setLayoutParams(params);
            }
            configFooterView() {
                let footerView = this.footerView;
                let params = footerView.getLayoutParams();
                params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;
                params.height = ViewGroup.LayoutParams.WRAP_CONTENT;
                params.width = ViewGroup.LayoutParams.WRAP_CONTENT;
                footerView.setLayoutParams(params);
            }
            configContentView() {
                let contentView = this.contentView;
                let params = contentView.getLayoutParams();
                params.height = ViewGroup.LayoutParams.MATCH_PARENT;
                params.width = ViewGroup.LayoutParams.MATCH_PARENT;
                contentView.setLayoutParams(params);
                this.overScrollLocker = widget.OverScrollLocker.getFrom(contentView);
                const overScrollByFunc = contentView.overScrollBy;
                contentView.overScrollBy = (deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent) => {
                    let result = overScrollByFunc.call(contentView, deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
                    if (contentView === this.contentView) {
                        this.onContentOverScroll(scrollRangeY, maxOverScrollY, isTouchEvent);
                    }
                    return result;
                };
            }
            onContentOverScroll(scrollRangeY, maxOverScrollY, isTouchEvent) {
                let newScrollY = this.contentView.mScrollY;
                const top = 0;
                const bottom = scrollRangeY;
                if (newScrollY > bottom) {
                    this.contentOverY = newScrollY - bottom;
                }
                else if (newScrollY < top) {
                    this.contentOverY = newScrollY - top;
                }
                else {
                    this.contentOverY = 0;
                }
                this.checkHeaderFooterPosition();
                if (this.headerView) {
                    if (this.contentOverY < -this.headerView.getHeight()) {
                        if (isTouchEvent) {
                            this.setHeaderState(PullRefreshLoadLayout.State_Header_ReadyToRefresh);
                        }
                        else if (this.headerView.state === PullRefreshLoadLayout.State_Header_ReadyToRefresh) {
                            this.setHeaderState(PullRefreshLoadLayout.State_Header_Refreshing);
                        }
                    }
                    else if (this.headerView.state === PullRefreshLoadLayout.State_Header_ReadyToRefresh) {
                        this.setHeaderState(this.headerView.stateBeforeReady);
                    }
                }
                if (this.footerView) {
                    const footerState = this.footerView.state;
                    if (this.contentOverY > this.footerView.getHeight() + this.footerViewReadyDistance) {
                        if (isTouchEvent) {
                            this.setFooterState(PullRefreshLoadLayout.State_Footer_ReadyToLoad);
                        }
                        else if (footerState === PullRefreshLoadLayout.State_Footer_ReadyToLoad) {
                            this.setFooterState(PullRefreshLoadLayout.State_Footer_Loading);
                        }
                    }
                    else if (footerState === PullRefreshLoadLayout.State_Footer_ReadyToLoad) {
                        this.setFooterState(this.footerView.stateBeforeReady);
                    }
                    if (this.contentOverY > 0 && this.autoLoadScrollAtBottom
                        && footerState === PullRefreshLoadLayout.State_Footer_Normal) {
                        this.setFooterState(PullRefreshLoadLayout.State_Footer_Loading);
                    }
                }
            }
            setHeaderView(headerView) {
                if (this.headerView) {
                    this.removeView(this.headerView);
                }
                this.headerView = headerView;
                if (headerView.getParent() == null)
                    this.addView(headerView);
                this.configHeaderView();
            }
            setFooterView(footerView) {
                if (this.footerView) {
                    this.removeView(this.footerView);
                }
                this.footerView = footerView;
                if (footerView.getParent() == null)
                    this.addView(footerView);
                this.configFooterView();
            }
            setContentView(contentView) {
                if (this.contentView) {
                    this.removeView(this.contentView);
                }
                this.contentView = contentView;
                if (contentView.getParent() == null)
                    this.addView(contentView);
                this.configContentView();
            }
            setHeaderState(newState) {
                if (!this.headerView)
                    return;
                if (this.headerView.state === newState)
                    return;
                const changeLimit = PullRefreshLoadLayout.StateChangeLimit[this.headerView.state];
                if (changeLimit && changeLimit.indexOf(newState) !== -1)
                    return;
                this.headerView.setStateInner(this, newState);
                this.checkLockOverScroll();
                if (newState === PullRefreshLoadLayout.State_Header_Refreshing && this.refreshLoadListener) {
                    this.refreshLoadListener.onRefresh(this);
                }
            }
            getHeaderState() {
                if (!this.headerView)
                    return PullRefreshLoadLayout.State_Disable;
                return this.headerView.state;
            }
            setFooterState(newState) {
                if (!this.footerView)
                    return;
                if (this.footerView.state === newState)
                    return;
                const changeLimit = PullRefreshLoadLayout.StateChangeLimit[this.footerView.state];
                if (changeLimit && changeLimit.indexOf(newState) !== -1)
                    return;
                this.footerView.setStateInner(this, newState);
                this.checkLockOverScroll();
                if (newState === PullRefreshLoadLayout.State_Footer_Loading && this.refreshLoadListener) {
                    this.refreshLoadListener.onLoadMore(this);
                }
            }
            getFooterState() {
                if (!this.footerView)
                    return PullRefreshLoadLayout.State_Disable;
                return this.footerView.state;
            }
            checkLockOverScroll() {
                if (!this.overScrollLocker)
                    return;
                if (this.headerView) {
                    switch (this.headerView.state) {
                        case PullRefreshLoadLayout.State_Header_Normal:
                            this.overScrollLocker.lockOverScrollTop(0);
                            break;
                        case PullRefreshLoadLayout.State_Header_Refreshing:
                            this.overScrollLocker.lockOverScrollTop(this.headerView.getHeight());
                            break;
                        case PullRefreshLoadLayout.State_Header_ReadyToRefresh:
                            this.overScrollLocker.lockOverScrollTop(this.headerView.getHeight());
                            break;
                        case PullRefreshLoadLayout.State_Header_RefreshFail:
                            this.overScrollLocker.lockOverScrollTop(this.headerView.getHeight());
                            break;
                    }
                }
                else {
                    this.overScrollLocker.lockOverScrollTop(0);
                }
                this.overScrollLocker.lockOverScrollBottom(this.footerView ? this.footerView.getHeight() : 0);
            }
            checkHeaderFooterPosition() {
                if (this.contentOverY > 0) {
                    this.setHeaderViewAppearDistance(0);
                    this.setFooterViewAppearDistance(this.contentOverY);
                }
                else if (this.contentOverY < 0) {
                    this.setHeaderViewAppearDistance(-this.contentOverY);
                    this.setFooterViewAppearDistance(0);
                }
                else {
                    this.setHeaderViewAppearDistance(0);
                    this.setFooterViewAppearDistance(0);
                }
            }
            setHeaderViewAppearDistance(distance) {
                if (!this.headerView)
                    return;
                let offset = -this.headerView.getHeight() - this.headerView.getTop() + distance;
                this.headerView.offsetTopAndBottom(offset);
            }
            setFooterViewAppearDistance(distance) {
                if (!this.contentView || !this.footerView)
                    return;
                let bottomToParentBottom = Math.min(this.overScrollLocker.getScrollContentBottom(), this.contentView.getHeight()) - this.footerView.getBottom();
                if (this.contentOverY < 0)
                    bottomToParentBottom -= this.contentOverY;
                let offset = this.footerView.getHeight() + bottomToParentBottom - distance;
                this.footerView.offsetTopAndBottom(offset);
            }
            onLayout(changed, left, top, right, bottom) {
                super.onLayout(changed, left, top, right, bottom);
                this.checkHeaderFooterPosition();
                this.checkLockOverScroll();
                if (!this.isLaidOut()) {
                    if (this.autoLoadScrollAtBottom && this.footerView != null
                        && this.footerView.getGlobalVisibleRect(new android.graphics.Rect())) {
                        this.setFooterState(PullRefreshLoadLayout.State_Footer_Loading);
                    }
                }
            }
            setAutoLoadMoreWhenScrollBottom(autoLoad) {
                this.autoLoadScrollAtBottom = autoLoad;
            }
            setRefreshEnable(enable) {
                const oldEnable = this.headerView != null;
                if (enable === oldEnable)
                    return;
                if (!enable) {
                    this.removeView(this.headerView);
                    this.headerView = null;
                    if (this.overScrollLocker)
                        this.overScrollLocker.lockOverScrollTop(0);
                }
                else {
                    this.setHeaderView(new PullRefreshLoadLayout.DefaultHeaderView());
                }
            }
            setLoadEnable(enable) {
                const oldEnable = this.footerView != null;
                if (enable === oldEnable)
                    return;
                if (!enable) {
                    this.removeView(this.footerView);
                    this.footerView = null;
                    if (this.overScrollLocker)
                        this.overScrollLocker.lockOverScrollBottom(0);
                }
                else {
                    this.setFooterView(new PullRefreshLoadLayout.DefaultFooterView());
                }
            }
            setRefreshLoadListener(refreshLoadListener) {
                this.refreshLoadListener = refreshLoadListener;
            }
            startRefresh() {
                this.setHeaderState(PullRefreshLoadLayout.State_Header_Refreshing);
            }
            startLoadMore() {
                this.setFooterState(PullRefreshLoadLayout.State_Footer_Loading);
            }
        }
        PullRefreshLoadLayout.State_Disable = -1;
        PullRefreshLoadLayout.State_Header_Normal = 0;
        PullRefreshLoadLayout.State_Header_Refreshing = 1;
        PullRefreshLoadLayout.State_Header_ReadyToRefresh = 2;
        PullRefreshLoadLayout.State_Header_RefreshFail = 3;
        PullRefreshLoadLayout.State_Footer_Normal = 4;
        PullRefreshLoadLayout.State_Footer_Loading = 5;
        PullRefreshLoadLayout.State_Footer_ReadyToLoad = 6;
        PullRefreshLoadLayout.State_Footer_LoadFail = 7;
        PullRefreshLoadLayout.State_Footer_NoMoreToLoad = 8;
        PullRefreshLoadLayout.StateChangeLimit = {
            [PullRefreshLoadLayout.State_Header_Refreshing]: [PullRefreshLoadLayout.State_Header_ReadyToRefresh, PullRefreshLoadLayout.State_Footer_Loading,
                PullRefreshLoadLayout.State_Footer_ReadyToLoad, PullRefreshLoadLayout.State_Footer_LoadFail,
                PullRefreshLoadLayout.State_Footer_NoMoreToLoad,],
            [PullRefreshLoadLayout.State_Header_RefreshFail]: [PullRefreshLoadLayout.State_Header_ReadyToRefresh, PullRefreshLoadLayout.State_Footer_Loading,
                PullRefreshLoadLayout.State_Footer_ReadyToLoad, PullRefreshLoadLayout.State_Footer_LoadFail,
                PullRefreshLoadLayout.State_Footer_NoMoreToLoad,],
            [PullRefreshLoadLayout.State_Footer_Loading]: [PullRefreshLoadLayout.State_Header_ReadyToRefresh, PullRefreshLoadLayout.State_Header_Refreshing,
                PullRefreshLoadLayout.State_Footer_ReadyToLoad, PullRefreshLoadLayout.State_Header_RefreshFail],
            [PullRefreshLoadLayout.State_Footer_NoMoreToLoad]: [PullRefreshLoadLayout.State_Footer_ReadyToLoad]
        };
        widget.PullRefreshLoadLayout = PullRefreshLoadLayout;
        (function (PullRefreshLoadLayout) {
            class HeaderView extends FrameLayout {
                constructor(...args) {
                    super(...args);
                    this.state = PullRefreshLoadLayout.State_Header_Normal;
                    this.stateBeforeReady = PullRefreshLoadLayout.State_Header_Normal;
                }
                setStateInner(prll, state) {
                    const oldState = this.state;
                    this.state = state;
                    this.onStateChange(state, oldState);
                    const _this = this;
                    switch (state) {
                        case PullRefreshLoadLayout.State_Header_RefreshFail:
                            this.postDelayed({
                                run() {
                                    if (state === _this.state) {
                                        prll.setHeaderState(PullRefreshLoadLayout.State_Header_Normal);
                                    }
                                }
                            }, 1000);
                            break;
                        case PullRefreshLoadLayout.State_Header_ReadyToRefresh:
                            this.stateBeforeReady = oldState;
                            break;
                    }
                }
            }
            PullRefreshLoadLayout.HeaderView = HeaderView;
            class FooterView extends FrameLayout {
                constructor(...args) {
                    super(...args);
                    this.state = PullRefreshLoadLayout.State_Footer_Normal;
                    this.stateBeforeReady = PullRefreshLoadLayout.State_Footer_Normal;
                }
                setStateInner(prll, state) {
                    const oldState = this.state;
                    this.state = state;
                    this.onStateChange(state, oldState);
                    switch (state) {
                        case PullRefreshLoadLayout.State_Footer_ReadyToLoad:
                            this.stateBeforeReady = oldState;
                            break;
                    }
                }
            }
            PullRefreshLoadLayout.FooterView = FooterView;
            class DefaultHeaderView extends HeaderView {
                constructor(context, bindElement, defStyle) {
                    super(context, bindElement, defStyle);
                    this.progressBar = new ProgressBar();
                    this.progressBar.setVisibility(View.GONE);
                    this.textView = new TextView();
                    let density = android.content.res.Resources.getDisplayMetrics().density;
                    const pad = 16 * density;
                    this.textView.setPadding(pad / 2, pad, pad / 2, pad);
                    this.textView.setGravity(Gravity.CENTER);
                    let linear = new LinearLayout();
                    linear.addView(this.progressBar, 32 * density, 32 * density);
                    linear.addView(this.textView);
                    linear.setGravity(Gravity.CENTER);
                    this.addView(linear, -1, -2);
                    this.onStateChange(PullRefreshLoadLayout.State_Header_Normal, PullRefreshLoadLayout.State_Disable);
                }
                onStateChange(newState, oldState) {
                    switch (newState) {
                        case PullRefreshLoadLayout.State_Header_Refreshing:
                            this.textView.setText(R.string_.prll_header_state_loading);
                            this.progressBar.setVisibility(View.VISIBLE);
                            break;
                        case PullRefreshLoadLayout.State_Header_ReadyToRefresh:
                            this.textView.setText(R.string_.prll_header_state_ready);
                            this.progressBar.setVisibility(View.GONE);
                            break;
                        case PullRefreshLoadLayout.State_Header_RefreshFail:
                            this.textView.setText(R.string_.prll_header_state_fail);
                            this.progressBar.setVisibility(View.GONE);
                            break;
                        default:
                            this.textView.setText(R.string_.prll_header_state_normal);
                            this.progressBar.setVisibility(View.GONE);
                    }
                }
            }
            PullRefreshLoadLayout.DefaultHeaderView = DefaultHeaderView;
            class DefaultFooterView extends FooterView {
                constructor(context, bindElement, defStyle) {
                    super(context, bindElement, defStyle);
                    this.progressBar = new ProgressBar();
                    this.progressBar.setVisibility(View.GONE);
                    this.textView = new TextView();
                    let density = android.content.res.Resources.getDisplayMetrics().density;
                    const pad = 16 * density;
                    this.textView.setPadding(pad / 2, pad, pad / 2, pad);
                    this.textView.setGravity(Gravity.CENTER);
                    let linear = new LinearLayout();
                    linear.addView(this.progressBar);
                    linear.addView(this.textView);
                    linear.setGravity(Gravity.CENTER);
                    this.addView(linear, -1, -2);
                    this.onStateChange(PullRefreshLoadLayout.State_Footer_Normal, PullRefreshLoadLayout.State_Disable);
                    this.setOnClickListener({
                        onClick(v) {
                            let parent = v.getParent();
                            if (parent instanceof PullRefreshLoadLayout) {
                                parent.setFooterState(PullRefreshLoadLayout.State_Footer_Loading);
                            }
                        }
                    });
                }
                onStateChange(newState, oldState) {
                    switch (newState) {
                        case PullRefreshLoadLayout.State_Footer_Loading:
                            this.textView.setText(R.string_.prll_footer_state_loading);
                            this.progressBar.setVisibility(View.VISIBLE);
                            break;
                        case PullRefreshLoadLayout.State_Footer_ReadyToLoad:
                            this.textView.setText(R.string_.prll_footer_state_ready);
                            this.progressBar.setVisibility(View.GONE);
                            break;
                        case PullRefreshLoadLayout.State_Footer_LoadFail:
                            this.textView.setText(R.string_.prll_footer_state_fail);
                            this.progressBar.setVisibility(View.GONE);
                            break;
                        case PullRefreshLoadLayout.State_Footer_NoMoreToLoad:
                            this.textView.setText(R.string_.prll_footer_state_no_more);
                            this.progressBar.setVisibility(View.GONE);
                            break;
                        default:
                            this.textView.setText(R.string_.prll_footer_state_normal);
                            this.progressBar.setVisibility(View.GONE);
                    }
                }
            }
            PullRefreshLoadLayout.DefaultFooterView = DefaultFooterView;
        })(PullRefreshLoadLayout = widget.PullRefreshLoadLayout || (widget.PullRefreshLoadLayout = {}));
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/12/14.
 */
///<reference path="../../android/view/Surface.ts"/>
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="NativeApi.ts"/>
var androidui;
(function (androidui) {
    var native;
    (function (native) {
        var Canvas = android.graphics.Canvas;
        let sNextID = 0;
        class NativeCanvas extends Canvas {
            initImpl() {
                this.canvasId = ++sNextID;
                this.createCanvasImpl();
            }
            createCanvasImpl() {
                native.NativeApi.canvas.createCanvas(this.canvasId, this.mWidth, this.mHeight);
            }
            recycleImpl() {
                native.NativeApi.canvas.recycleCanvas(this.canvasId);
            }
            translateImpl(dx, dy) {
                native.NativeApi.canvas.translate(this.canvasId, dx, dy);
            }
            scaleImpl(sx, sy) {
                native.NativeApi.canvas.scale(this.canvasId, sx, sy);
            }
            rotateImpl(degrees) {
                native.NativeApi.canvas.rotate(this.canvasId, degrees);
            }
            concatImpl(MSCALE_X, MSKEW_X, MTRANS_X, MSKEW_Y, MSCALE_Y, MTRANS_Y, MPERSP_0, MPERSP_1, MPERSP_2) {
                native.NativeApi.canvas.concat(this.canvasId, MSCALE_X, MSKEW_X, MTRANS_X, MSKEW_Y, MSCALE_Y, MTRANS_Y);
            }
            drawARGBImpl(a, r, g, b) {
                native.NativeApi.canvas.drawColor(this.canvasId, android.graphics.Color.argb(a, r, g, b));
            }
            clearRectImpl(left, top, width, height) {
                native.NativeApi.canvas.clearRect(this.canvasId, left, top, width, height);
            }
            saveImpl() {
                native.NativeApi.canvas.save(this.canvasId);
            }
            restoreImpl() {
                native.NativeApi.canvas.restore(this.canvasId);
            }
            clipRectImpl(left, top, width, height) {
                native.NativeApi.canvas.clipRect(this.canvasId, left, top, width, height);
            }
            drawCanvasImpl(canvas, offsetX, offsetY) {
                if (canvas instanceof NativeCanvas) {
                    native.NativeApi.canvas.drawCanvas(this.canvasId, canvas.canvasId, offsetX, offsetY);
                }
                else {
                    throw Error('canvas should be NativeCanvas');
                }
            }
            drawImageImpl(image, dstRect) {
                if (image instanceof native.NativeImage) {
                    native.NativeApi.canvas.drawImage(this.canvasId, image.imageId, dstRect.left, dstRect.top, dstRect.width(), dstRect.height());
                }
                else {
                    throw Error('image should be NativeImage');
                }
            }
            drawRectImpl(left, top, width, height, paint) {
                native.NativeApi.canvas.drawRect(this.canvasId, left, top, width, height);
            }
            drawOvalImpl(oval, paint) {
            }
            drawCircleImpl(cx, cy, radius, paint) {
            }
            drawArcImpl(oval, startAngle, sweepAngle, useCenter, paint) {
            }
            drawRoundRectImpl(rect, radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft, paint) {
            }
            drawTextImpl(text, x, y, style) {
                native.NativeApi.canvas.drawText(this.canvasId, text, x, y, style);
            }
            setColorImpl(color, style) {
                native.NativeApi.canvas.setFillColor(this.canvasId, color);
            }
            multiplyAlphaImpl(alpha) {
                native.NativeApi.canvas.multiplyAlpha(this.canvasId, alpha);
            }
            setAlphaImpl(alpha) {
                native.NativeApi.canvas.setAlpha(this.canvasId, alpha);
            }
            setTextAlignImpl(align) {
                native.NativeApi.canvas.setTextAlign(this.canvasId, align);
            }
            setLineWidthImpl(width) {
                native.NativeApi.canvas.setLineWidth(this.canvasId, width);
            }
            setLineCapImpl(lineCap) {
                native.NativeApi.canvas.setLineCap(this.canvasId, lineCap);
            }
            setLineJoinImpl(lineJoin) {
                native.NativeApi.canvas.setLineJoin(this.canvasId, lineJoin);
            }
            setShadowImpl(radius, dx, dy, color) {
                native.NativeApi.canvas.setShadow(this.canvasId, radius, dx, dy, color);
            }
            setFontSizeImpl(size) {
                native.NativeApi.canvas.setFontSize(this.canvasId, size);
            }
            setFontImpl(fontName) {
                native.NativeApi.canvas.setFont(this.canvasId, fontName);
            }
            static applyTextMeasure(cacheMeasureTextSize, defaultWidth, widths) {
                android.graphics.Canvas.measureTextImpl = function (text, textSize) {
                    let width = 0;
                    for (let i = 0, length = text.length; i < length; i++) {
                        let c = text.charCodeAt(i);
                        let cWidth = widths[c] || defaultWidth;
                        width += cWidth * textSize / cacheMeasureTextSize;
                    }
                    return width;
                };
            }
        }
        native.NativeCanvas = NativeCanvas;
    })(native = androidui.native || (androidui.native = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/12/14.
 */
///<reference path="../../android/view/Surface.ts"/>
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="NativeCanvas.ts"/>
///<reference path="NativeApi.ts"/>
var androidui;
(function (androidui) {
    var native;
    (function (native) {
        var Surface = android.view.Surface;
        let sNextSurfaceID = 0;
        const SurfaceInstances = new Map();
        class NativeSurface extends Surface {
            initImpl() {
                this.initCanvasBound();
                this.surfaceId = ++sNextSurfaceID;
                SurfaceInstances.set(this.surfaceId, this);
                let bound = this.mCanvasBound;
                let density = android.content.res.Resources.getDisplayMetrics().density;
                native.NativeApi.surface.createSurface(this.surfaceId, bound.left * density, bound.top * density, bound.right * density, bound.bottom * density);
            }
            notifyBoundChange() {
                this.initCanvasBound();
                let bound = this.mCanvasBound;
                native.NativeApi.surface.onSurfaceBoundChange(this.surfaceId, bound.left, bound.top, bound.right, bound.bottom);
            }
            lockCanvasImpl(left, top, width, height) {
                let canvas = new SurfaceLockCanvas(width, height);
                native.NativeApi.surface.lockCanvas(this.surfaceId, canvas.canvasId, left, top, left + width, top + height);
                return canvas;
            }
            unlockCanvasAndPost(canvas) {
                if (canvas instanceof native.NativeCanvas) {
                    native.NativeApi.surface.unlockCanvasAndPost(this.surfaceId, canvas.canvasId);
                    native.NativeApi.canvas.recycleCanvas(canvas.canvasId);
                }
                else {
                    throw Error('canvas is not NativeCanvas');
                }
            }
            static notifySurfaceReady(surfaceId) {
                let surface = SurfaceInstances.get(surfaceId);
                surface.viewRoot.scheduleTraversals();
            }
            static notifySurfaceSupportDirtyDraw(surfaceId, dirtyDrawSupport) {
                let surface = SurfaceInstances.get(surfaceId);
                surface.mSupportDirtyDraw = dirtyDrawSupport;
                surface.viewRoot.scheduleTraversals();
            }
        }
        native.NativeSurface = NativeSurface;
        class SurfaceLockCanvas extends native.NativeCanvas {
            createCanvasImpl() {
            }
        }
    })(native = androidui.native || (androidui.native = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/12/14.
 */
///<reference path="../image/NetImage"/>
///<reference path="NativeApi.ts"/>
var androidui;
(function (androidui) {
    var native;
    (function (native) {
        var NetImage = androidui.image.NetImage;
        let sNextId = 0;
        const NativeImageInstances = new Map();
        class NativeImage extends NetImage {
            createImage() {
                this.imageId = sNextId++;
                NativeImageInstances.set(this.imageId, this);
                native.NativeApi.image.createImage(this.imageId);
            }
            loadImage() {
                native.NativeApi.image.loadImage(this.imageId, this.src);
            }
            recycle() {
                native.NativeApi.image.recycleImage(this.imageId);
                NativeImageInstances.delete(this.imageId);
            }
            static notifyLoadFinish(imageId, width, height) {
                let image = NativeImageInstances.get(imageId);
                image.mImageWidth = width;
                image.mImageHeight = height;
                image.fireOnLoad();
            }
            static notifyLoadError(imageId) {
                let image = NativeImageInstances.get(imageId);
                image.mImageWidth = image.mImageHeight = 0;
                image.fireOnError();
            }
        }
        native.NativeImage = NativeImage;
    })(native = androidui.native || (androidui.native = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/12/14.
 */
///<reference path="../../android/view/Surface.ts"/>
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="NativeSurface.ts"/>
///<reference path="NativeCanvas.ts"/>
///<reference path="NativeImage.ts"/>
var androidui;
(function (androidui) {
    var native;
    (function (native) {
        const AndroidJsBridgeProperty = 'AndroidUIRuntime';
        const JSBridge = window[AndroidJsBridgeProperty];
        class NativeApi {
        }
        native.NativeApi = NativeApi;
        (function (NativeApi) {
            class CallQueues {
                constructor() {
                    this.calls = [];
                }
                pushCall(method, methodArgs) {
                    this.calls.push(new NativeCall(method, methodArgs));
                }
                clear() {
                    this.calls = [];
                }
                toString() {
                    return this.calls.join('\n');
                }
            }
            class NativeCall {
                constructor(methodName, methodArgs) {
                    this.method = methodName;
                    this.args = methodArgs;
                }
                toString() {
                    return this.method + JSON.stringify(this.args);
                }
            }
            let callQueues = new CallQueues();
            class SurfaceApi {
                createSurface(surfaceId, left, top, right, bottom) {
                    JSBridge.createSurface(surfaceId, left, top, right, bottom);
                }
                onSurfaceBoundChange(surfaceId, left, top, right, bottom) {
                    JSBridge.onSurfaceBoundChange(surfaceId, left, top, right, bottom);
                }
                lockCanvas(surfaceId, canvasId, left, top, right, bottom) {
                    callQueues.pushCall('lockCanvas', [surfaceId, canvasId, left, top, right, bottom]);
                }
                unlockCanvasAndPost(surfaceId, canvasId) {
                    callQueues.pushCall('unlockCanvasAndPost', [surfaceId, canvasId]);
                    JSBridge.batchCall(callQueues.toString());
                    callQueues.clear();
                }
            }
            NativeApi.SurfaceApi = SurfaceApi;
            class CanvasApi {
                createCanvas(canvasId, width, height) {
                    callQueues.pushCall('createCanvas', [canvasId, width, height]);
                }
                recycleCanvas(canvasId) {
                    callQueues.pushCall('recycleCanvas', [canvasId]);
                }
                translate(canvasId, dx, dy) {
                    callQueues.pushCall('translate', [canvasId, dx, dy]);
                }
                scale(canvasId, sx, sy) {
                    callQueues.pushCall('scale', [canvasId, sx, sy]);
                }
                rotate(canvasId, degrees) {
                    callQueues.pushCall('rotate', [canvasId, degrees]);
                }
                concat(canvasId, MSCALE_X, MSKEW_X, MTRANS_X, MSKEW_Y, MSCALE_Y, MTRANS_Y) {
                    callQueues.pushCall('concat', [canvasId, MSCALE_X, MSKEW_X, MTRANS_X, MSKEW_Y, MSCALE_Y, MTRANS_Y]);
                }
                drawColor(canvasId, color) {
                    callQueues.pushCall('drawColor', [canvasId, color]);
                }
                clearRect(canvasId, left, top, width, height) {
                    callQueues.pushCall('clearRect', [canvasId, left, top, width, height]);
                }
                drawRect(canvasId, left, top, width, height) {
                    callQueues.pushCall('drawRect', [canvasId, left, top, width, height]);
                }
                clipRect(canvasId, left, top, width, height) {
                    callQueues.pushCall('clipRect', [canvasId, left, top, width, height]);
                }
                save(canvasId) {
                    callQueues.pushCall('save', [canvasId]);
                }
                restore(canvasId) {
                    callQueues.pushCall('restore', [canvasId]);
                }
                drawCanvas(canvasId, drawCanvasId, offsetX, offsetY) {
                    callQueues.pushCall('drawCanvas', [canvasId, drawCanvasId, offsetX, offsetY]);
                }
                drawImage(canvasId, drawImageId, dstLeft, dstTop, dstWidth, dstHeight) {
                    callQueues.pushCall('drawImage', [canvasId, drawImageId, dstLeft, dstTop, dstWidth, dstHeight]);
                }
                drawText(canvasId, text, x, y, fillStyle) {
                    callQueues.pushCall('drawText', [canvasId, encodeURIComponent(text), x, y, fillStyle]);
                }
                setFillColor(canvasId, color) {
                    callQueues.pushCall('setFillColor', [canvasId, color]);
                }
                multiplyAlpha(canvasId, alpha) {
                    callQueues.pushCall('multiplyAlpha', [canvasId, alpha]);
                }
                setAlpha(canvasId, alpha) {
                    callQueues.pushCall('setAlpha', [canvasId, alpha]);
                }
                setTextAlign(canvasId, align) {
                    callQueues.pushCall('setTextAlign', [canvasId, align]);
                }
                setLineWidth(canvasId, width) {
                    callQueues.pushCall('setLineWidth', [canvasId, width]);
                }
                setLineCap(canvasId, lineCap) {
                    callQueues.pushCall('setLineCap', [canvasId, lineCap]);
                }
                setLineJoin(canvasId, lineJoin) {
                    callQueues.pushCall('setLineJoin', [canvasId, lineJoin]);
                }
                setShadow(canvasId, radius, dx, dy, color) {
                    callQueues.pushCall('setShadow', [canvasId, radius, dx, dy, color]);
                }
                setFontSize(canvasId, size) {
                    callQueues.pushCall('setFontSize', [canvasId, size]);
                }
                setFont(canvasId, fontName) {
                    callQueues.pushCall('setFont', [canvasId, fontName]);
                }
            }
            NativeApi.CanvasApi = CanvasApi;
        })(NativeApi = native.NativeApi || (native.NativeApi = {}));
        if (JSBridge) {
            android.view.Surface.prototype = native.NativeSurface.prototype;
            android.graphics.Canvas.prototype = native.NativeCanvas.prototype;
            androidui.image.NetImage.prototype = native.NativeImage.prototype;
            NativeApi.surface = new NativeApi.SurfaceApi();
            NativeApi.canvas = new NativeApi.CanvasApi();
            NativeApi.image = JSBridge;
        }
    })(native = androidui.native || (androidui.native = {}));
})(androidui || (androidui = {}));
//use the deepest sub class as enter
///<reference path="android/app/Application.ts"/>
///<reference path="android/view/GestureDetector.ts"/>
///<reference path="android/widget/FrameLayout.ts"/>
///<reference path="android/widget/ScrollView.ts"/>
///<reference path="android/widget/LinearLayout.ts"/>
///<reference path="android/widget/RelativeLayout.ts"/>
///<reference path="android/widget/TextView.ts"/>
///<reference path="android/widget/Button.ts"/>
///<reference path="android/widget/ImageView.ts"/>
///<reference path="android/widget/ImageButton.ts"/>
///<reference path="android/widget/ListView.ts"/>
///<reference path="android/widget/GridView.ts"/>
///<reference path="android/widget/HorizontalScrollView.ts"/>
///<reference path="android/widget/NumberPicker.ts"/>
///<reference path="android/widget/ProgressBar.ts"/>
///<reference path="android/widget/CheckBox.ts"/>
///<reference path="android/widget/RadioButton.ts"/>
///<reference path="android/widget/RadioGroup.ts"/>
///<reference path="android/widget/CheckedTextView.ts"/>
///<reference path="android/widget/SeekBar.ts"/>
///<reference path="android/widget/RatingBar.ts"/>
///<reference path="android/widget/ExpandableListView.ts"/>
///<reference path="android/widget/BaseExpandableListAdapter.ts"/>
///<reference path="android/widget/Toast.ts"/>
///<reference path="android/widget/Spinner.ts"/>
///<reference path="android/widget/ListPopupWindow.ts"/>
///<reference path="android/app/AlertDialog.ts"/>
///<reference path="android/view/animation/AlphaAnimation.ts"/>
///<reference path="android/view/animation/ScaleAnimation.ts"/>
///<reference path="android/view/animation/RotateAnimation.ts"/>
///<reference path="android/view/animation/TranslateAnimation.ts"/>
///<reference path="android/view/animation/AnimationSet.ts"/>
///<reference path="android/support/v4/view/ViewPager.ts"/>
///<reference path="android/support/v4/widget/ViewDragHelper.ts"/>
///<reference path="android/support/v4/widget/DrawerLayout.ts"/>
///<reference path="lib/com/jakewharton/salvage/RecyclingPagerAdapter.ts"/>
///<reference path="lib/uk/co/senab/photoview/PhotoView.ts"/>
///<reference path="android/app/Activity.ts"/>
///<reference path="androidui/AndroidUI.ts"/>
///<reference path="androidui/image/NetDrawable.ts"/>
///<reference path="androidui/widget/HtmlView.ts"/>
///<reference path="androidui/widget/HtmlImageView.ts"/>
///<reference path="androidui/widget/HtmlDataListAdapter.ts"/>
///<reference path="androidui/widget/HtmlDataPagerAdapter.ts"/>
///<reference path="androidui/widget/HtmlDataPickerAdapter.ts"/>
///<reference path="androidui/widget/PullRefreshLoadLayout.ts"/>
///<reference path="androidui/util/PerformanceAdjuster.ts"/>
///<reference path="androidui/native/NativeApi.ts"/>
window[`android`] = android;
window[`java`] = java;
window[`AndroidUI`] = androidui.AndroidUI;
window.dispatchEvent(new CustomEvent("AndroidUILoadFinish"));
